{"version":3,"file":"main.153345f4780549166727.hot-update.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;ACPA,gGAAuC;;;;;;;;;;;ACAvC;AACA;AACA;AACA;;AAEA,qBAAqB,mBAAO,CAAC,gGAA8B;AAC3D,qBAAqB,mBAAO,CAAC,gGAA8B;AAC3D,qBAAqB,mBAAO,CAAC,gGAA8B;AAC3D,gBAAgB,mBAAO,CAAC,kFAAuB;;AAE/C,wBAAwB,mBAAO,CAAC,sFAAyB;AACzD,gBAAgB,mBAAO,CAAC,sEAAiB;AACzC,iBAAiB,0GAAsC;AACvD,iBAAiB,mBAAO,CAAC,wEAAkB;AAC3C,wBAAwB,mBAAO,CAAC,wFAA0B;AAC1D,wBAAwB,mBAAO,CAAC,wFAA0B;AAC1D,wBAAwB,yIAAyD;AACjF,4BAA4B,6IAA6D;AACzF,kBAAkB,mBAAO,CAAC,0EAAmB;AAC7C,iBAAiB,mBAAO,CAAC,wEAAkB;AAC3C,mBAAmB,mBAAO,CAAC,8EAAqB;;AAEhD,4BAA4B,mBAAO,CAAC,0GAAmC;AACvE,kBAAkB,mBAAO,CAAC,kFAAuB;;AAEjD,sBAAsB,mBAAO,CAAC,sEAAiB;AAC/C,kCAAkC,mBAAO,CAAC,gFAAsB;;AAEhE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,uCAAuC;;AAEjF;AACA;AACA,eAAe;AACf,KAAK;AACL;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACrPA,iBAAiB,0HAAuC;;AAExD,YAAY,mBAAO,CAAC,2EAAoB;;AAExC;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AChCA;;AAEA,cAAc,mBAAO,CAAC,kGAA0B;AAChD,kBAAkB,mBAAO,CAAC,0GAA8B;AACxD,cAAc,mBAAO,CAAC,gGAAyB;;AAE/C,yBAAyB,mBAAO,CAAC,4GAA+B;AAChE,sBAAsB,mBAAO,CAAC,sGAA4B;;AAE1D,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,sCAAsC;AACxD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC3mDA,2BAA2B,mBAAO,CAAC,mGAA2B;;AAE9D,iBAAiB,2HAAwC;;AAEzD,YAAY,mBAAO,CAAC,8EAAuB;AAC3C,aAAa,mBAAO,CAAC,gFAAwB;;AAE7C,qBAAqB,mBAAO,CAAC,0FAA6B;;AAE1D;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;;AAEA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnoBA,qBAAqB,mBAAO,CAAC,sHAA6B;;AAE1D;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnSA,yBAAyB,oHAAqC;;AAE9D;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACdA,mBAAmB,gGAA2B;;AAE9C,YAAY,mBAAO,CAAC,8EAAuB;AAC3C,aAAa,mBAAO,CAAC,gFAAwB;;AAE7C;AACA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;;AAEA,gBAAgB,oBAAoB;AACpC;;AAEA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;;AAEA;AACA;AACA,uGAAuG,OAAO;AAC9G;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9SA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACTA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACLA,oBAAoB,mBAAO,CAAC,0FAAkB;AAC9C,gBAAgB,mBAAO,CAAC,kFAAc;AACtC,gBAAgB,mBAAO,CAAC,kFAAc;AACtC,iBAAiB,mBAAO,CAAC,sFAAgB;;AAEzC,WAAW,mBAAO,CAAC,+DAAS;AAC5B,mBAAmB,mBAAO,CAAC,iFAAkB;AAC7C,4BAA4B,mBAAO,CAAC,qGAA4B;AAChE,wBAAwB,wHAAqC;;AAE7D,oBAAoB,mBAAO,CAAC,iFAAkB;AAC9C,iBAAiB,mBAAO,CAAC,8FAAoB;;AAE7C,wBAAwB,6IAA6D;;AAErF,YAAY,mBAAO,CAAC,8EAAuB;AAC3C,aAAa,mBAAO,CAAC,gFAAwB;;AAE7C,qBAAqB,mBAAO,CAAC,0FAA6B;;AAE1D,qBAAqB,2GAAsC;;AAE3D;AACA;;AAEA,iCAAiC,mIAAmD;;AAEpF,uEAAuE,GAAG;AAC1E;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,OAAO;AAC7C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,OAAO;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;;AAEA,oDAAoD,OAAO;AAC3D;AACA;;AAEA;AACA;;AAEA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,mBAAmB;AACjC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC7SA;AACA,cAAc,iKAA2D;AACzE,aAAa,iKAA2D;AACxE,gBAAgB,uKAA8D;AAC9E,UAAU,yJAAuD;AACjE,cAAc,mKAA4D;AAC1E,UAAU,yJAAuD;AACjE,WAAW,2JAAwD;AACnE,WAAW,2JAAwD;AACnE;;;;;;;;;;;ACTA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpBA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA,qBAAqB,mBAAO,CAAC,0FAA6B;;AAE1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACRA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACjCA,aAAa,0GAAsC;AACnD,aAAa,mBAAO,CAAC,gFAAwB;AAC7C,qBAAqB,mBAAO,CAAC,0FAA6B;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AChPA;AACA,SAAS,8IAAgD;AACzD,WAAW,kJAAkD;AAC7D,YAAY,oJAAmD;AAC/D,aAAa,sJAAoD;AACjE,cAAc,0JAAsD;AACpE,QAAQ,4IAA+C;AACvD,QAAQ,4IAA+C;AACvD,aAAa,wJAAqD;AAClE,aAAa,wJAAqD;AAClE,iBAAiB,gKAAyD;AAC1E,cAAc,wJAAqD;AACnE,QAAQ,4IAA+C;AACvD;;;;;;;;;;;ACbA,iBAAiB,mBAAO,CAAC,iHAAqB;AAC9C,iBAAiB,mBAAO,CAAC,iHAAqB;AAC9C,iBAAiB,mBAAO,CAAC,iHAAqB;;AAE9C,YAAY,mBAAO,CAAC,yEAAsB;;AAE1C;AACA;AACA,6CAA6C,EAAE;AAC/C,8CAA8C,EAAE;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5LA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5DA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACTA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClBA,kBAAkB,mBAAO,CAAC,yGAAiB;;AAE3C,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA,wBAAwB,gJAAgE;;AAExF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxBA,wBAAwB,gJAAgE;;AAExF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;;;;;;;;;;ACvCA,kBAAkB,mBAAO,CAAC,yGAAiB;;AAE3C,wBAAwB,gJAAgE;;AAExF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACtBA;AACA;AACA;AACA,0CAA0C,GAAG;;AAE7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACnBA,kBAAkB,mBAAO,CAAC,yGAAiB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACrBA,wBAAwB,gJAAgE;;AAExF,aAAa,mBAAO,CAAC,mFAA2B;;AAEhD;AACA;AACA;AACA;AACA,sDAAsD;AACtD,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/CA,YAAY,mBAAO,CAAC,yEAAsB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,2CAA2C;;AAEvE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChDA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,8EAAuB;AAC3C,qBAAqB,2GAAsC;AAC3D,qBAAqB,2GAAsC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACrEA,aAAa,mBAAO,CAAC,gFAAwB;AAC7C,YAAY,mBAAO,CAAC,sEAAmB;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,0CAA0C,OAAO;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,aAAa;AACtD;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACzQA,kBAAkB,mBAAO,CAAC,sFAAgB;;AAE1C,yBAAyB,mBAAO,CAAC,oGAAuB;;AAExD,oBAAoB,mBAAO,CAAC,mGAA2B;AACvD,gBAAgB,mBAAO,CAAC,2FAAuB;;AAE/C,wBAAwB,6IAA6D;;AAErF,oBAAoB,0GAAqC;AACzD,qBAAqB,2GAAsC;;AAE3D,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjDA,iBAAiB,sHAAmC;AACpD,uBAAuB,4HAAyC;AAChE,wBAAwB,mBAAO,CAAC,kGAAsB;AACtD,mBAAmB,mBAAO,CAAC,wFAAiB;;AAE5C,qBAAqB,2GAAsC;AAC3D,wBAAwB,6IAA6D;AACrF,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,OAAO;AACjD;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACtGA,kBAAkB,mBAAO,CAAC,sFAAgB;;AAE1C,oBAAoB,mBAAO,CAAC,mGAA2B;AACvD,gBAAgB,mBAAO,CAAC,2FAAuB;;AAE/C,wBAAwB,6IAA6D;;AAErF,oBAAoB,0GAAqC;AACzD,qBAAqB,2GAAsC;;AAE3D,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC/EA,iBAAiB,sHAAmC;AACpD,wBAAwB,mBAAO,CAAC,kGAAsB;;AAEtD,yBAAyB,mBAAO,CAAC,oGAAuB;;AAExD,qBAAqB,2GAAsC;;AAE3D,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA;AACA;AACA;AACA;;AAEA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7EA,oBAAoB,mBAAO,CAAC,0FAAkB;AAC9C,wBAAwB,mBAAO,CAAC,oGAAuB;AACvD,6BAA6B,mBAAO,CAAC,kHAA8B;AACnE,iCAAiC,mBAAO,CAAC,0HAAkC;AAC3E,wBAAwB,mBAAO,CAAC,oGAAuB;AACvD,iCAAiC,mBAAO,CAAC,0HAAkC;AAC3E,kCAAkC,mBAAO,CAAC,0HAAkC;AAC5E,uBAAuB,mBAAO,CAAC,gGAAqB;AACpD,0BAA0B,mBAAO,CAAC,0GAA0B;AAC5D,kBAAkB,mBAAO,CAAC,oFAAe;;AAEzC,yBAAyB,mBAAO,CAAC,oGAAuB;;AAExD,wBAAwB,6IAA6D;;AAErF,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA,qCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;;AAEA,cAAc,0BAA0B;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC1IA,aAAa,mBAAO,CAAC,mFAA2B;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC3BA,oBAAoB,mBAAO,CAAC,oFAAqB;;AAEjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+CAA+C,OAAO;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACvCA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACbA;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACTA,oBAAoB,mBAAO,CAAC,oFAAqB;;AAEjD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;;;;;;;;;;ACrBA,aAAa,mBAAO,CAAC,mFAA2B;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACVA,sBAAsB,mBAAO,CAAC,2GAAqB;AACnD,iBAAiB,mBAAO,CAAC,+FAAe;AACxC,oBAAoB,mBAAO,CAAC,uGAAmB;AAC/C,yBAAyB,mBAAO,CAAC,+GAAuB;;AAExD,oBAAoB,mBAAO,CAAC,oFAAqB;AACjD,gBAAgB,gGAA2B;AAC3C,4BAA4B,mBAAO,CAAC,6GAA4B;;AAEhE,4BAA4B,mBAAO,CAAC,wGAA+B;AACnE,iBAAiB,8HAA2C;;AAE5D,oBAAoB,6GAAwC;AAC5D,YAAY,mBAAO,CAAC,iFAA0B;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qDAAqD,OAAO;AAC5D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD,OAAO;AACvD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD,OAAO;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAgD,OAAO;AACvD;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD,OAAO;AAC3D;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AClfA,0BAA0B,mBAAO,CAAC,mHAAyB;AAC3D,yBAAyB,mBAAO,CAAC,+GAAuB;AACxD,yBAAyB,mBAAO,CAAC,+GAAuB;;AAExD,4BAA4B,mBAAO,CAAC,6GAA4B;;AAEhE,wBAAwB,2HAAwC;AAChE,mBAAmB,mBAAO,CAAC,oFAAqB;AAChD,4BAA4B,mBAAO,CAAC,wGAA+B;;AAEnE,wBAAwB,gJAAgE;;AAExF;AACA;AACA;AACA;AACA;;AAEA;;AAEA,sCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACvCA,iBAAiB,mBAAO,CAAC,+FAAe;AACxC,eAAe,mBAAO,CAAC,2FAAa;AACpC,sBAAsB,mBAAO,CAAC,2GAAqB;AACnD,sBAAsB,mBAAO,CAAC,2GAAqB;AACnD,oBAAoB,mBAAO,CAAC,uGAAmB;AAC/C,2BAA2B,mBAAO,CAAC,qHAA0B;AAC7D,qCAAqC,mBAAO,CAAC,2IAAqC;AAClF,2BAA2B,sHAAuC;;AAElE,oBAAoB,mBAAO,CAAC,oFAAqB;AACjD,gBAAgB,gGAA2B;AAC3C,4BAA4B,mBAAO,CAAC,6GAA4B;AAChE,mBAAmB,mGAA8B;;AAEjD,4BAA4B,mBAAO,CAAC,wGAA+B;;AAEnE,YAAY,mBAAO,CAAC,iFAA0B;AAC9C,aAAa,mBAAO,CAAC,mFAA2B;;AAEhD,wBAAwB,iHAA4C;;AAEpE;AACA;AACA;;AAEA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kDAAkD,OAAO;AACzD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA,8CAA8C,OAAO;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,UAAU;AACnB;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,OAAO;AACrD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD,QAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,6CAA6C,QAAQ;AACrD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,gDAAgD,uBAAuB;AACvE;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9eA,oBAAoB,mBAAO,CAAC,oFAAqB;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACRA,oBAAoB,mBAAO,CAAC,oFAAqB;AACjD,2BAA2B,mBAAO,CAAC,sGAA8B;;AAEjE;AACA;AACA;;AAEA,sCAAsC,QAAQ;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,oCAAoC;AACpC;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+EAA+E,wCAAwC;AACvH;;AAEA;;;;;;;;;;;ACtDA,kBAAkB,mBAAO,CAAC,sFAAgB;;AAE1C,yBAAyB,mBAAO,CAAC,oGAAuB;;AAExD,iBAAiB,mBAAO,CAAC,kFAAyB;;AAElD,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C,oBAAoB,0GAAqC;AACzD,qBAAqB,2GAAsC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,OAAO;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,0CAA0C,OAAO;AACjD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACnLA,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C,mBAAmB,yGAAoC;;AAEvD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C,mBAAmB,yGAAoC;AACvD,qBAAqB,2GAAsC;;AAE3D;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC7BA,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C,oBAAoB,0GAAqC;AACzD,qBAAqB,2GAAsC;;AAE3D;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uCAAuC,OAAO;AAC9C;AACA;;AAEA,yCAAyC,QAAQ;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1CA,yBAAyB,mBAAO,CAAC,0HAAkC;;AAEnE,wBAAwB,2HAAwC;AAChE,4BAA4B,mBAAO,CAAC,qGAA4B;;AAEhE,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,OAAO;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;;AAEA,oCAAoC,OAAO;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACxPA;;AAEA,mBAAmB,mBAAO,CAAC,wFAAiB;AAC5C,2BAA2B,mBAAO,CAAC,wGAAyB;;AAE5D;AACA;;AAEA;AACA,iCAAiC,QAAQ;AACzC,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC5FA,oBAAoB,mBAAO,CAAC,iFAAkB;;AAE9C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,uBAAuB,4HAAyC;AAChE,wBAAwB,mBAAO,CAAC,kGAAsB;AACtD,kBAAkB,mBAAO,CAAC,sFAAgB;AAC1C,yBAAyB,mBAAO,CAAC,sGAAwB;;AAEzD,YAAY,mBAAO,CAAC,8EAAuB;;AAE3C,iBAAiB,mBAAO,CAAC,kFAAyB;;AAElD,oBAAoB,0GAAqC;AACzD,qBAAqB,2GAAsC;;AAE3D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,QAAQ;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,QAAQ;AACjD;;AAEA,6CAA6C,QAAQ;AACrD;;AAEA,2CAA2C,OAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2CAA2C,QAAQ;AACnD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C,2CAA2C,QAAQ;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yDAAyD,QAAQ;AACjE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,oCAAoC,QAAQ;AAC5C,sBAAsB,QAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,QAAQ;AAC5C;AACA;;AAEA,kBAAkB,gBAAgB;AAClC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;;AAEA;AACA,SAAS,8BAA8B;AACvC;AACA;AACA;AACA;AACA;;AAEA,cAAc,4BAA4B;AAC1C;AACA;AACA;;AAEA;;;;;;;;;;;ACpYA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;;AAEA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC/BA,kBAAkB,mBAAO,CAAC,oFAAe;;AAEzC;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;;AAEA,sCAAsC,OAAO;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACjCA,aAAa,mBAAO,CAAC,gFAAwB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC5EA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAoC,OAAO;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACpBA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACVA,WAAW,mBAAO,CAAC,8DAAQ;;AAE3B,aAAa,mBAAO,CAAC,6EAAqB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;AC7EA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,EAAE,UAAU,EAAE;AACtD,8BAA8B,KAAK,aAAa,KAAK,IAAI,KAAK,aAAa,KAAK,IAAI,KAAK,aAAa,KAAK,YAAY,KAAK,aAAa,KAAK,IAAI,KAAK,aAAa,KAAK,IAAI,KAAK,aAAa,KAAK,IAAI,KAAK,SAAS,KAAK;AAC3N;AACA;AACA;AACA;AACA,8BAA8B,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,YAAY,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,UAAU,KAAK;AACtN;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,EAAE;AACzC,sCAAsC,EAAE;AACxC,qCAAqC,EAAE;AACvC,uCAAuC,EAAE;;AAEzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACviBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACtBA,WAAW,mBAAO,CAAC,8DAAQ;;AAE3B,aAAa,mBAAO,CAAC,6EAAqB;AAC1C,YAAY,mBAAO,CAAC,2EAAoB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,QAAQ;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;AC5LA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD;AACpD,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACpMA,yBAAyB,mBAAO,CAAC,mGAAgC;;AAEjE;AACA;AACA;;AAEA;;;;;;;;;;;ACNA,sBAAsB,iIAAiB;;AAEvC,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,2CAA2C;AAC3E;;AAEA;AACA,gCAAgC,qCAAqC;AACrE;;AAEA;AACA,gCAAgC,8CAA8C;AAC9E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK,IAAI;AACT;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxOA,UAAU,mBAAO,CAAC,sCAAK;;AAEvB,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;;;;;;;;;;;ACrBA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACdA,4BAA4B,qIAAqD;;AAEjF,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC;AACA;;AAEA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACxNA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B,8CAA8C;AAC3E,gCAAgC,wBAAwB;;AAExD;AACA,6BAA6B,iDAAiD;AAC9E,gCAAgC,wBAAwB;;AAExD;AACA,6BAA6B,8CAA8C;AAC3E,gCAAgC,wBAAwB;;AAExD;AACA;;AAEA;;;;;;;;;;;ACxBA,WAAW,mBAAO,CAAC,mIAAM;;AAEzB;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;ACVA,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;;AAEA;AACA,+BAA+B;AAC/B,gCAAgC;AAChC,qCAAqC;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACvFA,SAAS,mBAAO,CAAC,iIAAI;AACrB,WAAW,mBAAO,CAAC,mIAAM;;AAEzB,wBAAwB,mBAAO,CAAC,yFAAuB;AACvD,mBAAmB,mBAAO,CAAC,+EAAkB;AAC7C,qBAAqB,mBAAO,CAAC,mFAAoB;AACjD,sBAAsB,mBAAO,CAAC,qFAAqB;;AAEnD,YAAY,mBAAO,CAAC,2EAAoB;AACxC,kBAAkB,mBAAO,CAAC,iFAAuB;AACjD,wBAAwB,mBAAO,CAAC,iGAA+B;AAC/D,uBAAuB,mBAAO,CAAC,6FAA6B;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,wBAAwB;AACrE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,4DAA4D;AAC5D,2DAA2D;AAC3D,kCAAkC,qBAAM;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACpPA,YAAY,mBAAO,CAAC,mEAAgB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AClCA,wBAAwB,oGAAuC;;AAE/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACzDA,WAAW,mBAAO,CAAC,mIAAM;AACzB,UAAU,mBAAO,CAAC,sCAAK;;AAEvB,uBAAuB,mBAAO,CAAC,6FAA6B;AAC5D,kBAAkB,mBAAO,CAAC,iFAAuB;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,kBAAkB;AAChC;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC5EA,SAAS,mBAAO,CAAC,iIAAI;AACrB,WAAW,mBAAO,CAAC,mIAAM;;AAEzB,wBAAwB,mBAAO,CAAC,yFAAuB;;AAEvD,kBAAkB,mBAAO,CAAC,iFAAuB;AACjD,uBAAuB,mBAAO,CAAC,6FAA6B;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,OAAO;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,2BAA2B;AACvD;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC7HA,WAAW,mBAAO,CAAC,mIAAM;AACzB,YAAY,mBAAO,CAAC,oIAAO;AAC3B,UAAU,mBAAO,CAAC,sCAAK;;AAEvB,qBAAqB,mBAAO,CAAC,yFAA2B;AACxD,sBAAsB,mBAAO,CAAC,2FAA4B;AAC1D,eAAe,mBAAO,CAAC,yEAAmB;;AAE1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;;;;ACzEA,uCAAuC,eAAe,YAAY,OAAO;;AAEzE;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACPA,SAAS,mBAAO,CAAC,iIAAI;AACrB,WAAW,mBAAO,CAAC,mIAAM;;AAEzB,sBAAsB,mBAAO,CAAC,qFAAqB;AACnD,+BAA+B,mBAAO,CAAC,2GAAgC;AACvE,wBAAwB,mBAAO,CAAC,yFAAuB;AACvD,0BAA0B,mBAAO,CAAC,6FAAyB;AAC3D,oBAAoB,mBAAO,CAAC,+EAAkB;AAC9C,aAAa,mBAAO,CAAC,+DAAU;AAC/B,qBAAqB,mBAAO,CAAC,mFAAoB;AACjD,sBAAsB,mBAAO,CAAC,qFAAqB;AACnD,oBAAoB,mBAAO,CAAC,+EAAkB;;AAE9C,eAAe,mBAAO,CAAC,iFAAuB;AAC9C,YAAY,mBAAO,CAAC,2EAAoB;AACxC,aAAa,mBAAO,CAAC,6EAAqB;AAC1C,kBAAkB,mBAAO,CAAC,iFAAuB;AACjD,eAAe,mBAAO,CAAC,2EAAoB;AAC3C,uBAAuB,mBAAO,CAAC,6FAA6B;;AAE5D;;AAEA;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sCAAsC,gCAAgC;AACtE;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA,GAAG;;AAEH,wDAAwD,iBAAiB;AACzE;;AAEA;AACA;AACA,wDAAwD,iBAAiB;AACzE;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,sDAAsD,OAAO;AAC7D;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;;;;;;;;;;ACpVA,WAAW,mBAAO,CAAC,mIAAM;;AAEzB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACdA,WAAW,mBAAO,CAAC,mIAAM;AACzB,UAAU,mBAAO,CAAC,sCAAK;;AAEvB;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACbA,+BAA+B,mBAAO,CAAC,2GAAgC;AACvE,oBAAoB,mBAAO,CAAC,+EAAkB;AAC9C,iBAAiB,mBAAO,CAAC,yEAAe;;AAExC,YAAY,mBAAO,CAAC,2EAAoB;AACxC,eAAe,mBAAO,CAAC,2EAAoB;;AAE3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA,0EAA0E,OAAO;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACpGA;AACA;AACA;;AAEA;;;;;;;;;;;ACJA,WAAW,mBAAO,CAAC,mIAAM;AACzB,UAAU,mBAAO,CAAC,sCAAK;;AAEvB,wBAAwB,mBAAO,CAAC,iGAA+B;;AAE/D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACzBA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA,uDAAuD,IAAI,0BAA0B,IAAI;AACzF;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;;AAEA;;;;;;;;;;;AChBA,aAAa,mBAAO,CAAC,kEAAU;AAC/B,YAAY,mBAAO,CAAC,gEAAS;;AAE7B,qBAAqB,mBAAO,CAAC,uFAA0B;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,KAAK,MAAM,KAAK;AAC5C;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,gCAAgC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,MAAM;AACN,kEAAkE;AAClE;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,gEAAgE;AAChE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,gEAAgE;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,sEAAsE,YAAY;AAClF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,qCAAqC;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,qDAAqD,SAAS,sBAAsB;AACpF;AACA;;AAEA;AACA;AACA,MAAM;AACN,yCAAyC,UAAU;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,oEAAoE,UAAU;AAC9E;AACA;AACA;AACA;AACA,MAAM;AACN,+DAA+D,eAAe;AAC9E;AACA;AACA,MAAM;AACN,qDAAqD,mBAAmB;AACxE;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,kEAAkE,UAAU,YAAY;AACxF;AACA;AACA;AACA,MAAM;AACN,gDAAgD;AAChD;AACA,MAAM;AACN,2CAA2C,SAAS,UAAU;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,uDAAuD,SAAS,sBAAsB;AACtF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,uDAAuD,SAAS,WAAW;AAC3E;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,yDAAyD,mBAAmB;AAC5E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN,kEAAkE,UAAU,WAAW;AACvF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,+EAA+E,UAAU;AACzF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,0CAA0C,WAAW;AACrD;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,kDAAkD,UAAU,WAAW;AACvE,mDAAmD;AACnD;AACA;AACA,MAAM;AACN,yDAAyD,IAAI;AAC7D;AACA,MAAM;AACN,oCAAoC;AACpC;AACA;AACA;AACA,MAAM;AACN,qCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN,2DAA2D;AAC3D;AACA;AACA;AACA,MAAM;AACN,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,6DAA6D;AAC7D;;AAEA;AACA;AACA,MAAM;AACN,yCAAyC;AACzC;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,qDAAqD;AACrD;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA,MAAM;AACN,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC3oBA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACXA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACVA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA,uCAAuC,eAAe,YAAY,OAAO;;AAEzE;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACNA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,OAAO;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN,sCAAsC;AACtC,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;ACjCA,aAAa,mBAAO,CAAC,6EAAqB;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC7DA;;AAEA,aAAa,uGAAmC;AAChD,aAAa,uGAAmC;;AAEhD,aAAa,mBAAO,CAAC,6EAAqB;AAC1C,YAAY,mBAAO,CAAC,2EAAoB;;AAExC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,YAAY;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,OAAO;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvPA,cAAc,mBAAO,CAAC,iEAAW;;AAEjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnDA,UAAU,4FAAwB;;AAElC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjDA,yBAAyB,qGAAwC;AACjE,UAAU,4FAAwB;;AAElC,uBAAuB,mBAAO,CAAC,6FAA6B;;AAE5D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpGa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,uBAAuB,mBAAO,CAAC,kFAAkB;AACjD,eAAe,mBAAO,CAAC,kEAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,8CAA8C,uBAAuB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,kDAAkD,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,wCAAwC,oBAAoB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,yBAAyB;;;;;;;;;;;;ACnHZ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gEAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;;;;;;;;;;;ACxUX;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,cAAc,mBAAO,CAAC,gEAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;;;;;;;;;;;ACjFP;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1Ha;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,iBAAiB,mBAAO,CAAC,kDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA,eAAe;;;;;;;;;;;;ACtDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,aAAa;AAC/B,cAAc,mBAAO,CAAC,sDAAS;AAC/B,yCAAwC,EAAE,qCAAqC,yBAAyB,EAAC;AACzG,gBAAgB,mBAAO,CAAC,0DAAW;AACnC,2CAA0C,EAAE,qCAAqC,6BAA6B,EAAC;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAe;;;;;;;;;;;;ACjCF;AACb;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;;;;;;;;;;AC3Eb,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;;;;;;;;;;;ACxHhB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,yDAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;;;;;;;;;;AC3IA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd,qBAAqB;AACrB,qBAAqB;;AAErB,qBAAqB;AACrB,qBAAqB;;AAErB,qBAAqB;AACrB,qBAAqB;;AAErB,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;AClEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;AC9GA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;;;;;;;;;;;AC9EnB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,UAAU;AACrB;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,UAAU;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;;;;;;;;;;;ACjHA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,WAAW,mBAAO,CAAC,qDAAQ;AAC3B,mBAAmB,mBAAO,CAAC,uEAAiB;AAC5C,eAAe,+FAA+B;AAC9C,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,gBAAgB,kGAAiC;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wCAAwC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,MAAM;AACnC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C,sBAAsB,+CAA+C;AACrE;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,sBAAsB,4BAA4B;AAClD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gCAAgC;;;;;;;;;;;ACxnChC,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,mBAAO,CAAC,iEAAc;AACtC,WAAW,mBAAO,CAAC,qDAAQ;AAC3B,eAAe,+FAA+B;AAC9C,kBAAkB,wGAAqC;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;;;;;;;;;;ACxa1B,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,+HAAoD;AAC7E,WAAW,mBAAO,CAAC,qDAAQ;;AAE3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,6CAA6C,cAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH,WAAW;AACX;;AAEA,kBAAkB;;;;;;;;;;;AC5ZlB,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;;;;;;;;;;;ACvexB;AACA;AACA;AACA;AACA;AACA,8JAAqF;AACrF,0JAAkF;AAClF,4HAA4D;;;;;;;;;;;;ACP5D;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,sBAAsB;AACtB,mBAAmB;AACnB;AACA;AACA,oDAAoD;AACpD,KAAK;AACL,gBAAgB;AAChB;AACA,6EAA6E;AAC7E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ,IAA8B;AACtC;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;AACA,+DAA+D,MAAM,OAAO,KAAK,EAAE,KAAK,EAAE,IAAI;AAC9F;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA,iEAAiE;AACjE;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,yCAAyC;AACzC,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA,gBAAgB;AAChB;AACA,eAAe;AACf;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,4EAA4E;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA,qCAAqC;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA,uCAAuC;AACvC,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA,kCAAkC,KAAK;AACvC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA,wDAAwD,MAAM,SAAS,MAAM;AAC7E;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,uBAAuB;AACvB,CAAC;;AAED;AACA;AACA,uBAAuB;AACvB,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA,UAAU,gCAAgC,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,uCAAuC,yBAAyB;AAChE;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7jEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iCAAiC,KAAK,eAAe,UAAU,UAAU,MAAM;AAC/E;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,4EAA4E,mBAAmB;;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,mFAAmF,kBAAkB;AACrG;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU;AAC5E,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,cAAc;AACtF,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,SAAS;AAC7E;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iCAAiC,IAAI,yBAAyB,aAAa,IAAI;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E,iBAAiB,kCAAkC,YAAY;AAC/D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE;AACA;AACA,qDAAqD,YAAY;AACjE;AACA,6EAA6E,KAAK;AAClF;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA,wBAAwB;AACxB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,+CAA+C,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACzE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,qCAAqC,KAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,2BAA2B;AACzF;AACA;AACA;AACA;AACA,6CAA6C,iCAAiC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,iCAAiC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sBAAsB;AACtB;AACA,sBAAsB,qBAAqB,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kEAAkE,6BAA6B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C,QAAQ,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,GAAG;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,YAAY;AACrF;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,uBAAuB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,KAAK,EAAE,KAAK,EAAE,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gEAAgE,KAAK,EAAE,KAAK,EAAE,IAAI;;AAElF;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,wCAAwC,MAAM,YAAY,KAAK,EAAE,KAAK,EAAE,IAAI;AAC5E;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,oCAAoC,6BAA6B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,2EAA2E,KAAK,EAAE,KAAK,EAAE,IAAI;AAC7F,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,mDAAmD;AACnD;AACA;AACA;AACA,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,qDAAqD,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAC/E;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD,qDAAqD;AACrD;AACA;AACA;AACA,gDAAgD;AAChD,gDAAgD;AAChD,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,uFAAuF,cAAc;AACrG,8BAA8B;AAC9B,wFAAwF,gBAAgB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,UAAU;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA,+EAA+E,eAAe;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iFAAiF,KAAK;AACtF;AACA,8BAA8B;AAC9B,4FAA4F,KAAK;AACjG;AACA;AACA,8BAA8B;AAC9B,uFAAuF,KAAK;AAC5F,yEAAyE,UAAU;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,yEAAyE,KAAK;AAC9E;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,iFAAiF,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAC3G;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM,cAAc,KAAK,EAAE,KAAK,EAAE,IAAI;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,wFAAwF,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAClH;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,8FAA8F,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACxH;AACA,0BAA0B;AAC1B,qEAAqE,KAAK;AAC1E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,8BAA8B;AAC9B;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,uFAAuF,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,KAAK;AAC9D;AACA;AACA;AACA;AACA,2EAA2E,KAAK,EAAE,KAAK,EAAE,IAAI;AAC7F;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA,0FAA0F,KAAK,EAAE,KAAK,EAAE,IAAI;AAC5G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,KAAK;AACvF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,oEAAoE,UAAU;AAC9E,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,UAAU;AACjG,6CAA6C;AAC7C;AACA,sCAAsC;AACtC;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8DAA8D,UAAU;AACxE,sBAAsB;AACtB;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qEAAqE,gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA,kBAAkB;AAClB;AACA;AACA;AACA,4DAA4D,UAAU;AACtE,6DAA6D,UAAU;AACvE;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,SAAS;AACT;AACA;AACA,wBAAwB;AACxB;AACA,SAAS,GAAG;AACZ;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,UAAU;AAC5G;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gBAAgB;AACrE;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qGAAqG,UAAU;AAC/G;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,UAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,aAAa;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,EAAE,KAAK,EAAE,IAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK,EAAE,KAAK,EAAE,IAAI;AACvF;AACA;AACA;AACA,8DAA8D,YAAY;AAC1E;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,8EAA8E,iBAAiB;AAC/F;AACA,+EAA+E,sBAAsB;AACrG;AACA,iEAAiE,YAAY;AAC7E;AACA,cAAc;AACd;AACA;AACA,yEAAyE,sBAAsB;AAC/F;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,wDAAwD,KAAK,EAAE,KAAK,EAAE,IAAI;AAC1E,8EAA8E,sBAAsB;AACpG;AACA;AACA,6DAA6D,YAAY;AACzE,cAAc;AACd,uDAAuD,KAAK,EAAE,KAAK,EAAE,IAAI;AACzE;AACA,qEAAqE,sBAAsB;AAC3F;AACA;AACA;AACA,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,uBAAuB;AACjG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,kBAAkB;AAC/F;AACA;AACA;AACA;AACA;AACA,0DAA0D,yDAAyD;AACnH,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yDAAyD;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,wEAAwE,uBAAuB;AAC/F;AACA;AACA,aAAa;AACb,yDAAyD,YAAY;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,mCAAmC;AACtF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD,4DAA4D,oBAAoB;AAChF,sBAAsB;AACtB,8DAA8D,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAC1F;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,oDAAoD,qBAAqB;AACzE;AACA;AACA,gFAAgF,gBAAgB;AAChG;AACA;AACA;AACA,gFAAgF,WAAW;AAC3F;AACA;AACA;AACA,wDAAwD,WAAW;AACnE;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gFAAgF,UAAU;AAC1F;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB,qDAAqD,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAC/E;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE,gFAAgF,WAAW;AAC3F;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA,oCAAoC,oCAAoC;AACxE;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU;AAC9E;AACA,6BAA6B,kCAAkC,UAAU;AACzE,yBAAyB;AACzB,6DAA6D,WAAW;AACxE,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc,8CAA8C;AACjF;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA,0DAA0D,GAAG;AAC7D,yBAAyB;AACzB;AACA;AACA,kBAAkB;AAClB;AACA,mFAAmF,KAAK,EAAE,KAAK,EAAE,IAAI;AACrG;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA,yDAAyD,cAAc;AACvE;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA,kFAAkF,gBAAgB;AAClG;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,wEAAwE,oBAAoB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,8BAA8B;AAC9B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB,yEAAyE,wBAAwB;AACjG;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,cAAc;AACd;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA,kEAAkE,UAAU;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,aAAa;AACb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,oDAAoD,6BAA6B;AACjF,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,KAAK,EAAE,KAAK,EAAE,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,4BAA4B;AACzF,iBAAiB;AACjB;AACA,qDAAqD,qCAAqC;AAC1F;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK,EAAE,KAAK,EAAE,IAAI;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK,EAAE,KAAK,EAAE,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK,EAAE,KAAK,EAAE,IAAI;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sCAAsC;AACtC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,KAAK,EAAE,KAAK,EAAE,IAAI;AACzF;AACA,kBAAkB;AAClB,sEAAsE,KAAK,EAAE,KAAK,EAAE,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK,EAAE,KAAK,EAAE,IAAI;AACnF;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA,sEAAsE,KAAK,EAAE,KAAK,EAAE,IAAI;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,QAAQ,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,kBAAkB;AAClB,sDAAsD,UAAU,QAAQ,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACnG;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,kEAAkE,UAAU,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AAChG;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,kBAAkB;AAClB;AACA,gEAAgE,KAAK,EAAE,KAAK,EAAE,IAAI;AAClF;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,IAAI,IAAI,UAAU,IAAI,SAAS,IAAI;AACpE;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAyB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,4DAA4D,WAAW;AACvE;AACA,qBAAqB;AACrB,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qCAAqC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,KAAK,EAAE,KAAK,EAAE,IAAI;AACtE;AACA,UAAU;AACV,mDAAmD,KAAK,EAAE,KAAK,EAAE,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iEAAiE,WAAW,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,IAAI;AACvG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,6DAA6D,kBAAkB;AAC/E,4DAA4D,cAAc;AAC1E,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E,4DAA4D,UAAU;AACtE,iBAAiB;AACjB;AACA;AACA,KAAK;;AAEL;AACA;AACA,+CAA+C,MAAM,gBAAgB,KAAK,EAAE,KAAK,EAAE,IAAI;AACvF;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oBAAoB;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACl4YY;;AAEb;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,sBAAsB;AACtB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,cAAc;AACnG,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iBAAiB;AACjB,MAAM;AACN;AACA;AACA;AACA;;;;;;;;;;;;AC/QA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU;AACV,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB;AACjB,KAAK;;AAEL;AACA,iBAAiB;AACjB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,0DAA0D;AAC1D,wDAAwD;AACxD;AACA,kBAAkB,EAAE;AACpB,eAAe;AACf;AACA;AACA,wDAAwD;AACxD,yBAAyB;AACzB;AACA,mBAAmB;AACnB,eAAe;AACf;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6BAA6B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oCAAoC;AAC5D,oCAAoC,uCAAuC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACzvCD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU,OAAO;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,mFAAmF;AAC3G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,gBAAgB,gCAAgC;AACvF;AACA,gCAAgC;AAChC;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,gCAAgC;AACvF,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA,MAAM,mBAAmB;;AAEzB;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,gBAAgB;AAChB,MAAM;AACN;AACA;;AAEA;AACA,0CAA0C;AAC1C,gBAAgB;AAChB;;AAEA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,uCAAuC,8BAA8B;AACrE;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA,2CAA2C,uCAAuC;AAClF;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA,2CAA2C,kBAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,4CAA4C;AAC5C,4CAA4C;AAC5C,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B,iBAAiB,aAAa;AAC9B;AACA,oBAAoB,MAAM,cAAc,MAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA,SAAS;AACT,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,+BAA+B;AAC/B;AACA,cAAc;AACd,+BAA+B;AAC/B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,cAAc;AACd,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,4BAA4B;AAC5B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACr5DD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB,yBAAyB;AACzB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,cAAc;AACd;AACA;AACA,cAAc,eAAe;AAC7B,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA,oBAAoB,aAAa;AACjC;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA,yBAAyB;AACzB,gEAAgE;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6EAA6E,YAAY;AACzF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C,0BAA0B;AACpE;;AAEA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,UAAU;AACV;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wBAAwB,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB,gCAAgC;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kCAAkC;AAClC;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,2CAA2C,YAAY;AACvD;AACA,2CAA2C,qBAAqB;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oGAAoG;AACpG;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,iCAAiC,6BAA6B;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc;AACrD,cAAc;AACd;AACA,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,sCAAsC,8BAA8B;AACpE,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB;AACjB;AACA,6BAA6B;AAC7B,sCAAsC;AACtC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yBAAyB;AACzB;AACA;AACA,iCAAiC;AACjC,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,0CAA0C,oCAAoC;AAC9E;AACA;AACA,KAAK;AACL;;;;;;;;;;;;ACtgFA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,MAAM;AACN;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClQA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,oDAAoD;AACpD,oDAAoD;AACpD,oDAAoD;AACpD,oDAAoD,+DAA+D;AACnH,oDAAoD;AACpD;;AAEA;AACA;AACA,oDAAoD;AACpD,oDAAoD;AACpD;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA,6BAA6B,GAAG;AAChC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV,KAAK;AACL;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY;AACrD;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;ACp0BD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,cAAc;AACd,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClMA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;ACzPD;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,aAAa;AACb;AACA;AACA;AACA;;AAEA;;AAEa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,2BAA2B,KAAK,KAAK;AACrC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT,KAAK;AACL;;;;;;;;;;;ACpSA,kBAAqB;AACrB,oBAAuB;AACvB,YAAe;AACf,cAAiB;AACjB,aAAgB;AAChB,iBAAoB;AACpB,uBAA0B;AAC1B,kBAAqB;;;;;;;;;;;ACPrB,SAAS,mBAAO,CAAC,iIAAI;;AAErB,aAAa;AACb,IAAI,mBAAe,CAAC,8DAAiB;AACrC,IAAI,mBAAe,CAAC,0DAAe;AACnC,IAAI,mBAAe,CAAC,sEAAqB;AACzC,IAAI,mBAAe,CAAC,8DAAiB;AACrC,IAAI,mBAAe,CAAC,8DAAiB;AACrC,IAAI,mBAAe,CAAC,oEAAoB;AACxC,IAAI,mBAAe,CAAC,gEAAkB;AACtC,IAAI,mBAAe,CAAC,sEAAqB;AACzC,IAAI,mBAAe,CAAC,0EAAuB;AAC3C,IAAI,mBAAe,CAAC,wEAAsB;AAC1C,IAAI,mBAAe,CAAC,gEAAkB;AACtC,IAAI,mBAAe,CAAC,+DAAc;AAClC;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uCAAuC,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA,mBAAmB;AACnB,0CAA0C,kDAAkD;AAC5F;AACA;;AAEA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,+BAA+B,MAAM;AACrC;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;AC7GkC;AACK;AACuB;;AAER;AACvB;AAC/B,iBAAiB,mBAAO,CAAC,sEAAkB;;AAE3C;AACA;AACA,IAAI,gDAAO;AACX,WAAW,oDAAW;AACtB;AACA;AACA,OAAO;;AAEP,WAAW,4DAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM,mDAAG;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,CAAC;;AAED;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB,aAAa,cAAc;AAC3B;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,aAAa;AACb;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,aAAa;AACb;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA,eAAe,UAAU;AACzB,eAAe,cAAc;AAC7B,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,MAAM;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,aAAa;AACb;AACO;AACP,aAAa,OAAO;AACpB;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,aAAa;AACb;AACO;AACP,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,cAAc;AACzB,aAAa;AACb;AACO;AACP,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACzNA;AACA,aAAa,8BAA8B;AAC3C;AACA;AACA,cAAc,OAAO;AACrB,cAAc,QAAQ;AACtB;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B;;AAEA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChpGA;AACA,aAAa,0BAA0B;AACvC,aAAa,yBAAyB;AACtC,aAAa,4BAA4B;AACzC;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEuC;AACI;AACP;AACF;AACJ;AACI;;AAElC,cAAc;;AAEd;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,iBAAiB;AAC5B,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,SAAS,0BAA0B;AACnC,aAAa,kBAAkB;AAC/B;;AAEA;AACA;AACA;AACA,aAAa,8CAAM,CAAC,iDAAS,EAAE,yBAAyB;AACxD;AACA;AACA;AACA,IAAI,4BAA4B,8CAAM,CAAC,iDAAS,EAAE,iBAAiB;AACnE;AACA,IAAI,4BAA4B,8CAAM,CAAC,iDAAS,EAAE,iBAAiB;AACnE;AACA,IAAI,8BAA8B,8CAAM;AACxC;AACA;;AAEA;AACA;AACA,kBAAkB,6CAAK;AACvB;;AAEA,SAAS,iDAAS;AAClB;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA,SAAS,0BAA0B;;AAEnC;;AAEA,oBAAoB,iDAAS,EAAE,yBAAyB;;AAExD,qCAAqC,6CAAK;AAC1C;AACA;AACA,IAAI;AACJ;AACA,mCAAmC,6CAAK;AACxC;AACA;AACA,IAAI;AACJ;AACA,mCAAmC,6CAAK;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,WAAW,SAAS;AACpB;AACA,aAAa;AACb;AACA;AACO;AACP;AACA;AACA,iBAAiB,6CAAK;AACtB,gBAAgB,iDAAS;;AAEzB;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,uDAAc;AACjC,eAAe,gDAAO;;AAEtB;AACA;AACA;;AAEA,QAAQ,4DAAc;AACtB,4BAA4B,gDAAO;AACnC;AACA;;AAEA;AACA;;AAEA,mBAAmB,qDAAa;AAChC,uBAAuB,8CAAM,oBAAoB,8CAAM;AACvD,kBAAkB,8CAAM,kBAAkB,8CAAM;AAChD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;;AAEA,gBAAgB,0CAAI;AACpB,mBAAmB,0CAAI;AACvB,oBAAoB,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS,iDAAS;AAClB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,eAAe,6CAAK;AACpB,gBAAgB,6CAAK;AACrB,aAAa,eAAe;AAC5B;AACA,aAAa,uBAAuB;AACpC;AACA,aAAa,cAAc;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,uCAAuC;AAClD,aAAa;AACb;AACA;AACA;AACA,aAAa,sDAAsD;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,uCAAuC;AAClD,aAAa;AACb;AACA;AACA,aAAa,sDAAsD;AACnE;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1TA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC90DA;AACA,aAAa,8BAA8B;AAC3C;;AAEA;AACA,WAAW;AACX;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9FA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClzDA,WAAW,6BAA6B;AACjC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B;AACA;AACA,cAAc,uBAAuB;AACrC,cAAc,eAAe;AAC7B,cAAc,uBAAuB;AACrC,cAAc,uBAAuB;AACrC,cAAc,eAAe;AAC7B,cAAc,kBAAkB;AAChC,cAAc,eAAe;AAC7B,cAAc,uBAAuB;AACrC,cAAc,uBAAuB;AACrC;;AAEkD;AACJ;AACV;AACA;AACF;;AAElC,cAAc;;AAEd;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa;AACb;AACO,gCAAgC;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,8CAAM;AACrB,wBAAwB,8CAAM;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,yDAAgB;;AAE3B;AACA;;AAEA;AACA,SAAS,+DAAc;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ,+DAAc;AACtB,QAAQ,+DAAc;AACtB,QAAQ,+DAAc;AACtB,SAAS,+DAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM,+DAAc;AACpB,MAAM,+DAAc;AACpB,MAAM,+DAAc;AACpB,MAAM,+DAAc;AACpB,OAAO,+DAAc;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,+DAAc;AACtB,QAAQ,+DAAc;AACtB,SAAS,+DAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,qDAAS;AACjB,QAAQ,qDAAS;AACjB,QAAQ,qDAAS;AACjB,SAAS,qDAAS;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAa,mEAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU,qDAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS,mEAAgB;AACzB;AACA,SAAS,mEAAgB;AACzB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ,mEAAgB;AACxB,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;;AAEA,eAAe,mEAAgB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,mEAAgB;AACtB;AACA;AACA;;AAEA,aAAa,mEAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrTA,WAAW,eAAe;AACnB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACXA;AACA,aAAa,sCAAsC;AACnD,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO,8BAA8B;AACrC,aAAa,eAAe;AAC5B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,YAAY;AACzB;AACA;AACA,UAAU;AACV;AACA,wBAAwB;AACxB,wBAAwB,+BAA+B;AACvD;AACA,UAAU;AACV;AACA,wBAAwB;AACxB,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB,WAAW,OAAO;AAClB,WAAW,uBAAuB;AAClC,aAAa;AACb;AACO;AACP;;AAEA;AACA;;AAEA;AACA,0BAA0B,oBAAoB;AAC9C;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACjEA,YAAY;;AAEZ;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,WAAW;AACxB;AACA,0BAA0B,8BAA8B;AACxD,0BAA0B,sCAAsC;AAChE,0BAA0B,sCAAsC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,YAAY;AACzB;AACA;AACA,4BAA4B,mBAAmB;AAC/C,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,cAAc;AAC3B;AACA;AACA,+BAA+B,wBAAwB;AACvD,+BAA+B,uBAAuB;AACtD,+BAA+B,uBAAuB;AACtD,+BAA+B,sBAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;AACJ;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP,OAAO,+DAAS;AAChB;AACA;;AAEA;;AAEA,MAAM,mEAAW;AACjB;AACA;;AAEA,UAAU,mEAAW;AACrB;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;;AAE1B;AACA;;;;;;;;;;;;;;;;;;;;ACvFA;AACA,aAAa,kCAAkC;AAC/C,aAAa,mCAAmC;AAChD,aAAa,gCAAgC;AAC7C;;AAEgC;AACI;;AAEpC;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP;AACA,IAAI,gDAAG,CAAC,oDAAK,mBAAmB,gCAAgC;AAChE;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,SAAS,gDAAG,CAAC,oDAAK,mBAAmB,iBAAiB;AACtD;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,aAAa;AACb;AACO;AACP,SAAS,gDAAG,CAAC,oDAAK,mBAAmB,MAAM;AAC3C;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA,aAAa,wBAAwB;AACrC,aAAa,gCAAgC;AAC7C,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C,aAAa,+BAA+B;AAC5C,aAAa,qCAAqC;AAClD,aAAa,kCAAkC;AAC/C;;AAE8C;AACjB;AACc;AACb;AACI;AACJ;;AAE9B,aAAa,8CAAM;AACnB;AACA;AACA;AACA;AACA,aAAa;AACb,CAAC;;AAED;AACA,WAAW,wBAAwB;AACnC,WAAW,oBAAoB;AAC/B,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAE,8CAAI;AACN;AACA;AACA;AACA;AACA;AACA,sCAAsC,qDAAG,GAAG,sDAAI;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,aAAa,gBAAgB;AAC7B;AACA,iBAAiB,2DAAU;;AAE3B,QAAQ,8CAAI;AACZ;AACA,QAAQ,8CAAI;AACZ,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B,aAAa,MAAM;AACnB,aAAa,GAAG;AAChB,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA,UAAU,kEAA0B;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA,eAAe,iBAAiB;AAChC;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC9LA;AACA,aAAa,2BAA2B;AACxC,aAAa,+BAA+B;AAC5C,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C,aAAa,2BAA2B;AACxC,aAAa,oCAAoC;AACjD;;AAE0D;AACR;AACT;AACiB;AAC7B;;AAE7B,eAAe,8CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA,uCAAuC,0DAAI;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,SAAS,mEAAW;AACpB;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA,IAAI,mEAAW;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mEAAW;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI,mEAAW;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA,IAAI,mEAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA,IAAI,mEAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA,IAAI,mEAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,6DAAM,GAAG,6DAAM;AACjD;;AAEA;AACA;;;;;;;;;;;;;;;;ACzNA;AACA,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP,aAAa,gBAAgB;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA,aAAa,kCAAkC;AAC/C,aAAa,+BAA+B;AAC5C,aAAa,mCAAmC;AAChD,aAAa,gCAAgC;AAC7C,aAAa,kDAAkD;AAC/D;;AAEmC;AACW;AACF;AACJ;AACU;AACjB;;AAEjC;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACO;AACP;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,mBAAmB;AAChC;;AAEA,MAAM,iDAAO;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,UAAU,+DAAS;AACnB,uBAAuB,qDAAG;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,2BAA2B,+DAAS;AACpC;AACA,2BAA2B,+DAAS;AACpC;AACA;AACA;AACA,QAAQ,2BAA2B,+DAAS;AAC5C,YAAY,+DAAS;AACrB;AACA,gCAAgC,6DAAQ;AACxC,UAAU;AACV,UAAU,+DAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU,uDAAK;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA,2BAA2B,kDAAI;AAC/B;;AAEA;AACA;AACA,OAAO,+DAAS;AAChB;AACA;AACA,aAAa,kDAAI;AACjB;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA,iBAAiB,oDAAS;AAC1B;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA,IAAI,iDAAO;AACX;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACvJA;AACA,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;ACZA;AACA,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;ACZA;AACA,aAAa,2BAA2B;AACxC,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C,aAAa,kCAAkC;AAC/C,aAAa,qCAAqC;AAClD,aAAa,8BAA8B;AAC3C;;AAE6B;AACc;AACF;;AAEzC,cAAc;;AAEd,eAAe,8CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,WAAW,SAAS;AACb;AACP;AACA;;AAEA;AACA;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA,OAAO,gDAAM;AACb;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA,aAAa,kBAAkB;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,iDAAO;AACjB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,QAAQ,iDAAO;AACf;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA,iBAAiB,2DAAU;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9NA;AACA,aAAa,+BAA+B;AAC5C,aAAa,gCAAgC;AAC7C,aAAa,8BAA8B;AAC3C,aAAa,2BAA2B;AACxC,aAAa,iCAAiC;AAC9C,aAAa,oCAAoC;AACjD;;AAEqD;AACd;AACV;;AAE7B,WAAW,6BAA6B;AACxC;AACA,iBAAiB,iDAAuB;;AAExC;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,kEAAiB;;AAEpC;AACA,gBAAgB,8CAAM,UAAU,WAAW,0BAA0B;;AAErE;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC1FA;AACA,aAAa,2BAA2B;AACxC,aAAa,iCAAiC;AAC9C,aAAa,oCAAoC;AACjD,aAAa,yCAAyC;AACtD,aAAa,6BAA6B;AAC1C,aAAa,+BAA+B;AAC5C,aAAa,gCAAgC;AAC7C,aAAa,kCAAkC;AAC/C,aAAa,8BAA8B;AAC3C,aAAa,mCAAmC;AAChD;;AAE2C;AACW;AACJ;AACJ;AACC;AAClB;AACD;;AAE5B,eAAe,8CAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,4CAAG;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,IAAI,+DAAS,oCAAoC,mEAAW;AAC5D;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA,MAAM,+DAAS;AACf;AACA;AACA;AACA;AACA,QAAQ,mEAAW;AACnB;AACA;;AAEA,MAAM,+DAAS;AACf,WAAW,mEAAW;AACtB;;AAEA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mEAAW;AACrB;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA,IAAI,+DAAS;AACb,IAAI,mEAAW;AACf;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA,SAAS,+DAAS;AAClB,OAAO,mEAAW,0BAA0B,mEAAW;AACvD;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+DAAS;AACf;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA,IAAI,+DAAS;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;;AAEA;AACA,aAAa,cAAc;AAC3B,eAAe;AACf;AACA;AACA;AACA,6DAA6D,gEAAU;AACvE;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4DAAc,iBAAiB,6DAAM;AACzC;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,kCAAkC;AAC7C,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,4CAAG;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,aAAa;AACb;AACA;AACA,aAAa,WAAW;AACxB;AACA,gCAAgC,uCAAuC;AACvE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B,cAAc;AAC5D;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5lBA;AACA,aAAa,2BAA2B;AACxC,aAAa,+BAA+B;AAC5C,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C,aAAa,kCAAkC;AAC/C,aAAa,yDAAyD;AACtE;;AAEwC;AACC;AACf;AACI;AACI;AACD;;AAEjC;AACA,WAAW,MAAM;AACjB,WAAW,UAAU;AACrB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,aAAa;AACb;AACO;AACP;AACA,IAAI,iDAAO;AACX;AACA,yBAAyB,8CAAI;AAC7B,4BAA4B,yDAAS;AACrC,oBAAoB,0CAAE;AACtB,uBAAuB,wDAAS;AAChC,yBAAyB,kDAAM;AAC/B;AACA;;;;;;;;;;;;;;;;;;AClCA;AACA,aAAa,2BAA2B;AACxC,aAAa,8BAA8B;AAC3C,aAAa,6BAA6B;AAC1C,aAAa,yDAAyD;AACtE;;AAEmD;;AAEnD;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;;AAEA,WAAW,WAAW;AACtB;AACO,gBAAgB,oEAAc;;;;;;;;;;;;;;;;ACpBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC,aAAa,+BAA+B;AAC5C;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,cAAc;AACzB,aAAa;AACb;AACA;AACA;AACA,aAAa,UAAU;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,QAAQ;AACtB,cAAc,aAAa;AAC3B,cAAc,aAAa;AAC3B,cAAc,8BAA8B;AAC5C,cAAc,MAAM;AACpB,cAAc,MAAM;AACpB;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,SAAS;AACtB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACf8C;AACV;;AAEpC;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,SAAS;AACtB;AACO;AACP,SAAS,+DAAc,eAAe,qDAAS;AAC/C;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,aAAa,SAAS;AACtB;AACO;AACP;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEsC;AACY;AACJ;AACW;AACvB;;AAElC,cAAc;;AAEd;AACA,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA,UAAU,mEAAW;AACrB,WAAW,0EAAc;AACzB,sBAAsB,8CAAM,WAAW,+DAAS,OAAO,8CAAM;AAC7D;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,2DAA2D;AACtE;AACA;AACA;AACA;;AAEA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA,aAAa,sBAAsB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,sCAAsC;AACjD;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5EA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEgC;AACM;AACU;AACJ;AACK;;AAEjD,kBAAkB,sCAAQ;;AAE1B;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT,UAAU,kEAAU;AACpB;AACA,wBAAwB,6DAAQ;AAChC,UAAU,kEAAU;AACpB;AACA;AACA,UAAU;AACV;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;AACS;AACP;AACU;AACF;AACe;;AAE/D;AACA,aAAa,qBAAqB;AAClC,aAAa,iDAAiD;AAC9D;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA,qCAAqC,mEAAW;AAChD,4BAA4B,0DAAI,CAAC,sDAAI;;AAErC,uBAAuB,4EAAoB;AAC3C;;AAEA;AACA;AACA;AACA,sBAAsB,iEAAS;AAC/B;;AAEA;AACA,iCAAiC,4EAAoB;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yDAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,YAAY;AACvB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA,aAAa,sBAAsB;AACnC;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AACQ;AACY;AACO;;AAEzD,6BAA6B;AAC7B,iBAAiB,IAAI;;AAErB;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA,YAAY,mEAAW,gBAAgB,0EAAc;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,4DAA4D;AACvE,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,6CAAa;AAChC;AACA,IAAI;;AAEJ;AACA;;;;;;;;;;;;;;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AACQ;AACU;AACJ;AACQ;AACF;;AAElD;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,uDAAK;AACT,UAAU,qEAAY,WAAW,mEAAW;AAC5C;AACA,sBAAsB,6CAAa,CAAC,6DAAQ;;AAE5C,mDAAmD;AACnD;AACA;;AAEA,UAAU,iEAAU;AACpB;AACA;AACA,UAAU;AACV;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;;AAE8B;AACQ;AACY;AACJ;AACG;;AAEjD;AACA,aAAa,qBAAqB;AAClC;;AAEA,cAAc;;AAEd;AACA;AACA;;AAEA,6BAA6B;AAC7B,iBAAiB,IAAI;;AAErB;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA,UAAU,mEAAW;AACrB,mBAAmB,8DAAa;AAChC,UAAU,+DAAS,OAAO,8DAAa;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,6CAAa;AAC1C;AACA,cAAc;;AAEd;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;AACU;AACJ;AACE;;AAE9C;AACA,aAAa,qBAAqB;AAClC;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,uDAAK;AACT;AACA,QAAQ,+DAAS;AACjB;AACA;AACA;AACA;AACA,UAAU,iEAAU,iCAAiC,6DAAQ;AAC7D,UAAU;AACV;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAE+C;AACT;AACY;;AAElD;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU,mEAAW;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAc;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEgC;AACM;AACQ;;AAE9C,kBAAkB,sCAAQ;;AAE1B;AACA,iBAAiB,EAAE,WAAW;;AAE9B;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;;AAEA,mBAAmB,+DAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEgC;AACM;AACQ;AACI;;AAElD,kBAAkB,sCAAQ;;AAE1B,kBAAkB;AAClB,iBAAiB;;AAEjB;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA;;AAEA;AACA,QAAQ,+DAAS;AACjB;AACA,QAAQ,mEAAW;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEuD;AACjB;AACQ;AACI;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA;AACA;;AAEA;AACA,QAAQ,+DAAS;AACjB,QAAQ,mEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iEAAS,CAAC,6DAAK,UAAU,eAAe;AAC1D;;AAEA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEgC;AACM;AACY;;AAElD,kBAAkB,sCAAQ;;AAE1B,kBAAkB;AAClB,iBAAiB;;AAEjB;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT,6BAA6B,mEAAW;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACY;AACJ;AACZ;;AAElC,cAAc;;AAEd;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA,UAAU,mEAAW;AACrB,mBAAmB,8CAAM;AACzB,UAAU,+DAAS,OAAO,8CAAM;AAChC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,WAAW,4DAA4D;AACvE,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC,aAAa;AACb;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,sCAAsC;AACjD,aAAa;AACb;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7EA;AACA,UAAU;AACV;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCgF;AACtB;AACW;AACW;AACd;AACQ;AACN;AACN;AACL;AACa;AACV;AACI;AACM;AACT;AACwB;AAC5B;AACkC;AACrB;AACe;AACF;AAChB;AACC;AACX;;AAEzD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE,0EAA+B;AACjC,EAAE,+DAAoB;AACtB;AACA;AACA,EAAE,qEAAyB;AAC3B,EAAE,0EAA+B;AACjC,EAAE,mEAAwB;AAC1B,EAAE,uEAA4B;AAC9B,EAAE,oEAAyB;AAC3B,EAAE,iEAAsB;AACxB,EAAE,8DAAoB;AACtB,EAAE,qEAA0B;AAC5B,EAAE,iEAAqB;AACvB,EAAE,mEAAuB;AACzB,EAAE,sEAA0B;AAC5B,EAAE,iEAAsB;AACxB,EAAE,8EAAiC;AACnC,EAAE,+DAAoB;AACtB,EAAE,iFAAoC;AACtC,EAAE,sEAA0B;AAC5B,EAAE,8EAAiC;AACnC,EAAE,6EAAgC;AAClC,EAAE,qEAAwB;AAC1B,EAAE,qEAAyB;AAC3B,EAAE,+DAAoB;AACtB;;AAEA,4BAA4B;;AAE5B,iEAAe,kBAAkB;;;;;;;;;;;;;;;;;;ACxEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,sBAAsB;AACnC,aAAa,+BAA+B;AAC5C;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;;AAEwC;AAC6B;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACe,0CAA0C;AACzD;;AAEA;AACA;AACA;AACA;AACA,IAAI,yDAAM,QAAQ,eAAe;AACjC;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,uBAAuB,UAAU;AACjC,oBAAoB,sFAAoB;AACxC;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa;AACb;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;;;;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACQ;AACZ;;AAElC,cAAc;;AAEd;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,8CAAM;AAC3B,YAAY,+DAAS,OAAO,8CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC5CA,WAAW,sCAAsC;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACQ;AACW;AACvB;;AAElC,cAAc;;AAEd;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,0EAAc;AAC3B,wBAAwB,8CAAM,WAAW,+DAAS,OAAO,8CAAM;AAC/D;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;AC7CA,WAAW,sCAAsC;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACnGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACc;AACF;;AAElD;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,uDAAK;AACT,UAAU,qEAAY,UAAU,mEAAW;AAC3C;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,cAAc;AACpB;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC,aAAa,uBAAuB;AACpC;;AAEsC;AACU;AACE;;AAElD;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,mBAAmB;AAClC;AACA,eAAe,uBAAuB;AACtC;AACA,eAAe,uBAAuB;AACtC;;AAEA,IAAI,wDAAK;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR,YAAY,mEAAW;AACvB;AACA,UAAU;AACV,UAAU,mEAAW;AACrB;AACA;AACA,wBAAwB,iEAAS;;AAEjC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACc;;AAEpD;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,uDAAK;AACT,UAAU,qEAAY;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACS;AACE;;AAEjD;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,IAAI,uDAAK;AACT;AACA;AACA;AACA,SAAS,gEAAS,UAAU,kEAAU;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC;;AAEsC;AACQ;AACZ;;AAElC,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,eAAe,gBAAgB,gDAAgD,GAAG;AAClF;AACA,eAAe,yCAAyC;AACxD;;AAEA,IAAI,wDAAK;AACT;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,8CAAM;AAC3B,YAAY,+DAAS,OAAO,8CAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA,eAAe,QAAQ;AACvB,eAAe,uBAAuB;AACtC;AACA;AACA,qDAAqD,sBAAsB;AAC3E;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,uCAAuC;AACxD;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/HA,WAAW,sCAAsC;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,qBAAqB;AAClC,aAAa,wBAAwB;AACrC;;AAEsC;;AAEtC,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACe;AACf;AACA,eAAe,gBAAgB,gDAAgD,GAAG;AAClF;;AAEA,IAAI,wDAAK;AACT;AACA,qDAAqD,sBAAsB;AAC3E;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,IAAI,wDAAK;AACT;AACA;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,iCAAiC;AAClD;AACA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,iBAAiB,gCAAgC;AACjD;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC3HA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC,aAAa,8BAA8B;AAC3C;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;;AAEqC;;AAErC,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,eAAe;AAC9B,eAAe,MAAM;AACrB,iBAAiB;AACjB;AACA;AACA,iBAAiB,sDAAO;AACxB;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,MAAM;AACvB,iBAAiB,kBAAkB;AACnC,iBAAiB,kBAAkB;AACnC,mBAAmB;AACnB;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,mBAAmB,QAAQ;AAC3B;AACA,mBAAmB,MAAM;AACzB;AACA,mBAAmB,QAAQ;AAC3B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtGA;AACA,WAAW,QAAQ;AACnB,aAAa;AACb;AACO;AACP;AACA;;;;;;;;;;;;;;;;;;;;;ACNA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC,aAAa,8BAA8B;AAC3C,aAAa,kCAAkC;AAC/C,aAAa,iCAAiC;AAC9C,aAAa,uCAAuC;AACpD,aAAa,yCAAyC;AACtD,aAAa,mCAAmC;AAChD;;AAEqC;AACL;;AAEhC;AACA;AACA;AACO;AACP;AACA;AACA;AACO;AACP;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,yCAAyC;AACxD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sDAAO;AACxB;;AAEA;;AAEA;AACA,iBAAiB,MAAM;AACvB,iBAAiB,SAAS;AAC1B,iBAAiB,gBAAgB;AACjC;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA,mBAAmB,kBAAkB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,gDAAK;AACnB;AACA,WAAW;AACX;;AAEA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA,qBAAqB,aAAa;AAClC;AACA,qBAAqB,QAAQ;AAC7B;AACA,qBAAqB,gBAAgB;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,eAAe;AAC1B,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;ACvJA;AACA,aAAa,sBAAsB;AACnC,aAAa,wBAAwB;AACrC,aAAa,8BAA8B;AAC3C,aAAa,kDAAkD;AAC/D,aAAa,mCAAmC;AAChD;;AAE2E;;AAE9C;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,MAAM;AACrB,eAAe,mCAAmC;AAClD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM,sEAAY;;AAElB;AACA,iBAAiB,MAAM;AACvB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxDA,YAAY;;AAEZ;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA,aAAa,yBAAyB;AACtC;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,UAAU;AACxB;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB,YAAY;AACZ,eAAe;AACf,gBAAgB,SAAS;AACzB,gBAAgB,SAAS;AACzB,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;UC5DA","sources":["webpack://svelte-app/./node_modules/boolbase/index.js","webpack://svelte-app/./node_modules/clean-css/index.js","webpack://svelte-app/./node_modules/clean-css/lib/clean.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/clone.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/configuration.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/configuration/break-up.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/configuration/can-override.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/configuration/properties/understandable.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/configuration/restore.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/hack.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/invalid-property-error.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-0/optimize.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/optimize.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/background.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/border-radius.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/box-shadow.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/filter.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/font-weight.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/margin.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/outline.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/property-optimizers/padding.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/sort-selectors.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/tidy-at-rule.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/tidy-block.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/tidy-rules.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hex.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-hsl.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/color/shorten-rgb.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/degrees.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/fraction.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/precision.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/starts-as-url.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/text-quotes.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/time.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/unit.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-prefix.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-quotes.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/url-whitespace.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/whitespace.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-1/value-optimizers/zero.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/extract-properties.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/is-mergeable.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/merge-adjacent.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/merge-media-queries.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-body.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/merge-non-adjacent-by-selector.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/optimize.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/every-values-pair.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/find-component-in.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/has-inherit.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/has-same-values.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/has-unset.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/is-component-of.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/is-mergeable-shorthand.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/merge-into-shorthands.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/optimize.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/override-properties.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/overrides-non-component-shorthand.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/properties/populate-components.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/reduce-non-adjacent.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-font-at-rules.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/remove-duplicate-media-queries.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/remove-duplicates.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/remove-unused-at-rules.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/reorderable.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/restore-with-components.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/restructure.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/rules-overlap.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/specificities-overlap.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/specificity.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/level-2/tidy-rule-duplicates.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/remove-unused.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/restore-from-optimizing.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/validator.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/vendor-prefixes.js","webpack://svelte-app/./node_modules/clean-css/lib/optimizer/wrap-for-optimizing.js","webpack://svelte-app/./node_modules/clean-css/lib/options/compatibility.js","webpack://svelte-app/./node_modules/clean-css/lib/options/fetch.js","webpack://svelte-app/./node_modules/clean-css/lib/options/format.js","webpack://svelte-app/./node_modules/clean-css/lib/options/inline-request.js","webpack://svelte-app/./node_modules/clean-css/lib/options/inline-timeout.js","webpack://svelte-app/./node_modules/clean-css/lib/options/inline.js","webpack://svelte-app/./node_modules/clean-css/lib/options/optimization-level.js","webpack://svelte-app/./node_modules/clean-css/lib/options/plugins.js","webpack://svelte-app/./node_modules/clean-css/lib/options/rebase-to.js","webpack://svelte-app/./node_modules/clean-css/lib/options/rebase.js","webpack://svelte-app/./node_modules/clean-css/lib/options/rounding-precision.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/apply-source-maps.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/extract-import-url-and-media.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/input-source-map-tracker.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/is-allowed-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/load-original-sources.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/load-remote-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/match-data-uri.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/normalize-path.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/read-sources.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/rebase-local-map.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/rebase-remote-map.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/rebase.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/restore-import.js","webpack://svelte-app/./node_modules/clean-css/lib/reader/rewrite-url.js","webpack://svelte-app/./node_modules/clean-css/lib/tokenizer/marker.js","webpack://svelte-app/./node_modules/clean-css/lib/tokenizer/token.js","webpack://svelte-app/./node_modules/clean-css/lib/tokenizer/tokenize.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/clone-array.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/format-position.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/has-protocol.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/is-data-uri-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/is-http-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/is-https-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/is-import.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/is-remote-resource.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/natural-compare.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/override.js","webpack://svelte-app/./node_modules/clean-css/lib/utils/split.js","webpack://svelte-app/./node_modules/clean-css/lib/writer/helpers.js","webpack://svelte-app/./node_modules/clean-css/lib/writer/one-time.js","webpack://svelte-app/./node_modules/clean-css/lib/writer/simple.js","webpack://svelte-app/./node_modules/clean-css/lib/writer/source-maps.js","webpack://svelte-app/./node_modules/css-selector-parser/lib/index.js","webpack://svelte-app/./node_modules/css-selector-parser/lib/parser-context.js","webpack://svelte-app/./node_modules/css-selector-parser/lib/render.js","webpack://svelte-app/./node_modules/css-selector-parser/lib/utils.js","webpack://svelte-app/./node_modules/nth-check/lib/compile.js","webpack://svelte-app/./node_modules/nth-check/lib/index.js","webpack://svelte-app/./node_modules/nth-check/lib/parse.js","webpack://svelte-app/./node_modules/source-map/lib/array-set.js","webpack://svelte-app/./node_modules/source-map/lib/base64-vlq.js","webpack://svelte-app/./node_modules/source-map/lib/base64.js","webpack://svelte-app/./node_modules/source-map/lib/binary-search.js","webpack://svelte-app/./node_modules/source-map/lib/mapping-list.js","webpack://svelte-app/./node_modules/source-map/lib/quick-sort.js","webpack://svelte-app/./node_modules/source-map/lib/source-map-consumer.js","webpack://svelte-app/./node_modules/source-map/lib/source-map-generator.js","webpack://svelte-app/./node_modules/source-map/lib/source-node.js","webpack://svelte-app/./node_modules/source-map/lib/util.js","webpack://svelte-app/./node_modules/source-map/source-map.js","webpack://svelte-app/./node_modules/uglify-js/lib/ast.js","webpack://svelte-app/./node_modules/uglify-js/lib/compress.js","webpack://svelte-app/./node_modules/uglify-js/lib/minify.js","webpack://svelte-app/./node_modules/uglify-js/lib/mozilla-ast.js","webpack://svelte-app/./node_modules/uglify-js/lib/output.js","webpack://svelte-app/./node_modules/uglify-js/lib/parse.js","webpack://svelte-app/./node_modules/uglify-js/lib/propmangle.js","webpack://svelte-app/./node_modules/uglify-js/lib/scope.js","webpack://svelte-app/./node_modules/uglify-js/lib/sourcemap.js","webpack://svelte-app/./node_modules/uglify-js/lib/transform.js","webpack://svelte-app/./node_modules/uglify-js/lib/utils.js","webpack://svelte-app/./node_modules/uglify-js/tools/exports.js","webpack://svelte-app/./node_modules/uglify-js/tools/node.js","webpack://svelte-app/./src/main.js","webpack://svelte-app/./node_modules/bcp-47-match/index.js","webpack://svelte-app/./node_modules/bcp-47-normalize/lib/fields.js","webpack://svelte-app/./node_modules/bcp-47-normalize/lib/index.js","webpack://svelte-app/./node_modules/bcp-47-normalize/lib/likely.js","webpack://svelte-app/./node_modules/bcp-47-normalize/lib/many.js","webpack://svelte-app/./node_modules/bcp-47-normalize/lib/matches.js","webpack://svelte-app/./node_modules/bcp-47/lib/normal.js","webpack://svelte-app/./node_modules/bcp-47/lib/parse.js","webpack://svelte-app/./node_modules/bcp-47/lib/regular.js","webpack://svelte-app/./node_modules/bcp-47/lib/stringify.js","webpack://svelte-app/./node_modules/direction/index.js","webpack://svelte-app/./node_modules/hast-util-from-string/index.js","webpack://svelte-app/./node_modules/hast-util-has-property/index.js","webpack://svelte-app/./node_modules/hast-util-is-conditional-comment/index.js","webpack://svelte-app/./node_modules/hast-util-is-css-link/index.js","webpack://svelte-app/./node_modules/hast-util-is-css-style/index.js","webpack://svelte-app/./node_modules/hast-util-is-event-handler/index.js","webpack://svelte-app/./node_modules/hast-util-is-javascript/index.js","webpack://svelte-app/./node_modules/hast-util-select/index.js","webpack://svelte-app/./node_modules/hast-util-select/lib/any.js","webpack://svelte-app/./node_modules/hast-util-select/lib/attribute.js","webpack://svelte-app/./node_modules/hast-util-select/lib/class-name.js","webpack://svelte-app/./node_modules/hast-util-select/lib/enter-state.js","webpack://svelte-app/./node_modules/hast-util-select/lib/id.js","webpack://svelte-app/./node_modules/hast-util-select/lib/name.js","webpack://svelte-app/./node_modules/hast-util-select/lib/nest.js","webpack://svelte-app/./node_modules/hast-util-select/lib/parse.js","webpack://svelte-app/./node_modules/hast-util-select/lib/pseudo.js","webpack://svelte-app/./node_modules/hast-util-select/lib/test.js","webpack://svelte-app/./node_modules/hast-util-select/lib/util.js","webpack://svelte-app/./node_modules/hast-util-to-string/index.js","webpack://svelte-app/./node_modules/html-enumerated-attributes/index.js","webpack://svelte-app/./node_modules/html-url-attributes/index.js","webpack://svelte-app/./node_modules/is-alphabetical/index.js","webpack://svelte-app/./node_modules/is-alphanumerical/index.js","webpack://svelte-app/./node_modules/is-decimal/index.js","webpack://svelte-app/./node_modules/rehype-minify-attribute-whitespace/index.js","webpack://svelte-app/./node_modules/rehype-minify-attribute-whitespace/schema.js","webpack://svelte-app/./node_modules/rehype-minify-css-style/index.js","webpack://svelte-app/./node_modules/rehype-minify-enumerated-attribute/index.js","webpack://svelte-app/./node_modules/rehype-minify-event-handler/index.js","webpack://svelte-app/./node_modules/rehype-minify-javascript-script/index.js","webpack://svelte-app/./node_modules/rehype-minify-javascript-url/index.js","webpack://svelte-app/./node_modules/rehype-minify-json-script/index.js","webpack://svelte-app/./node_modules/rehype-minify-language/index.js","webpack://svelte-app/./node_modules/rehype-minify-media-attribute/index.js","webpack://svelte-app/./node_modules/rehype-minify-meta-color/index.js","webpack://svelte-app/./node_modules/rehype-minify-meta-content/index.js","webpack://svelte-app/./node_modules/rehype-minify-style-attribute/index.js","webpack://svelte-app/./node_modules/rehype-normalize-attribute-value-case/index.js","webpack://svelte-app/./node_modules/rehype-normalize-attribute-value-case/schema.js","webpack://svelte-app/./node_modules/rehype-preset-minify/index.js","webpack://svelte-app/./node_modules/rehype-remove-comments/index.js","webpack://svelte-app/./node_modules/rehype-remove-duplicate-attribute-values/index.js","webpack://svelte-app/./node_modules/rehype-remove-duplicate-attribute-values/schema.js","webpack://svelte-app/./node_modules/rehype-remove-empty-attribute/index.js","webpack://svelte-app/./node_modules/rehype-remove-empty-attribute/schema.js","webpack://svelte-app/./node_modules/rehype-remove-external-script-content/index.js","webpack://svelte-app/./node_modules/rehype-remove-meta-http-equiv/index.js","webpack://svelte-app/./node_modules/rehype-remove-script-type-javascript/index.js","webpack://svelte-app/./node_modules/rehype-remove-style-type-css/index.js","webpack://svelte-app/./node_modules/rehype-sort-attribute-values/index.js","webpack://svelte-app/./node_modules/rehype-sort-attribute-values/schema.js","webpack://svelte-app/./node_modules/rehype-sort-attributes/index.js","webpack://svelte-app/./node_modules/unist-util-filter/index.js","webpack://svelte-app/./node_modules/unist-util-visit-parents/color.browser.js","webpack://svelte-app/./node_modules/unist-util-visit-parents/index.js","webpack://svelte-app/./node_modules/unist-util-visit/index.js","webpack://svelte-app/./node_modules/zwitch/index.js","webpack://svelte-app/webpack/runtime/getFullHash"],"sourcesContent":["module.exports = {\n\ttrueFunc: function trueFunc(){\n\t\treturn true;\n\t},\n\tfalseFunc: function falseFunc(){\n\t\treturn false;\n\t}\n};","module.exports = require('./lib/clean');\n","/**\n * Clean-css - https://github.com/clean-css/clean-css\n * Released under the terms of MIT license\n */\n\nvar level0Optimize = require('./optimizer/level-0/optimize');\nvar level1Optimize = require('./optimizer/level-1/optimize');\nvar level2Optimize = require('./optimizer/level-2/optimize');\nvar validator = require('./optimizer/validator');\n\nvar compatibilityFrom = require('./options/compatibility');\nvar fetchFrom = require('./options/fetch');\nvar formatFrom = require('./options/format').formatFrom;\nvar inlineFrom = require('./options/inline');\nvar inlineRequestFrom = require('./options/inline-request');\nvar inlineTimeoutFrom = require('./options/inline-timeout');\nvar OptimizationLevel = require('./options/optimization-level').OptimizationLevel;\nvar optimizationLevelFrom = require('./options/optimization-level').optimizationLevelFrom;\nvar pluginsFrom = require('./options/plugins');\nvar rebaseFrom = require('./options/rebase');\nvar rebaseToFrom = require('./options/rebase-to');\n\nvar inputSourceMapTracker = require('./reader/input-source-map-tracker');\nvar readSources = require('./reader/read-sources');\n\nvar serializeStyles = require('./writer/simple');\nvar serializeStylesAndSourceMap = require('./writer/source-maps');\n\nvar CleanCSS = module.exports = function CleanCSS(options) {\n  options = options || {};\n\n  this.options = {\n    batch: !!options.batch,\n    compatibility: compatibilityFrom(options.compatibility),\n    explicitRebaseTo: 'rebaseTo' in options,\n    fetch: fetchFrom(options.fetch),\n    format: formatFrom(options.format),\n    inline: inlineFrom(options.inline),\n    inlineRequest: inlineRequestFrom(options.inlineRequest),\n    inlineTimeout: inlineTimeoutFrom(options.inlineTimeout),\n    level: optimizationLevelFrom(options.level),\n    plugins: pluginsFrom(options.plugins),\n    rebase: rebaseFrom(options.rebase, options.rebaseTo),\n    rebaseTo: rebaseToFrom(options.rebaseTo),\n    returnPromise: !!options.returnPromise,\n    sourceMap: !!options.sourceMap,\n    sourceMapInlineSources: !!options.sourceMapInlineSources\n  };\n};\n\n\n// for compatibility with optimize-css-assets-webpack-plugin\nCleanCSS.process = function (input, opts) {\n  var cleanCss;\n  var optsTo = opts.to;\n\n  delete opts.to;\n  cleanCss = new CleanCSS(Object.assign({ returnPromise: true, rebaseTo: optsTo }, opts));\n\n  return cleanCss.minify(input)\n    .then(function(output) {\n      return { css: output.styles };\n    });\n};\n\n\nCleanCSS.prototype.minify = function (input, maybeSourceMap, maybeCallback) {\n  var options = this.options;\n\n  if (options.returnPromise) {\n    return new Promise(function (resolve, reject) {\n      minifyAll(input, options, maybeSourceMap, function (errors, output) {\n        return errors ?\n          reject(errors) :\n          resolve(output);\n      });\n    });\n  } else {\n    return minifyAll(input, options, maybeSourceMap, maybeCallback);\n  }\n};\n\nfunction minifyAll(input, options, maybeSourceMap, maybeCallback) {\n  if (options.batch && Array.isArray(input)) {\n    return minifyInBatchesFromArray(input, options, maybeSourceMap, maybeCallback);\n  } else if (options.batch && (typeof input == 'object')) {\n    return minifyInBatchesFromHash(input, options, maybeSourceMap, maybeCallback);\n  } else {\n    return minify(input, options, maybeSourceMap, maybeCallback);\n  }\n}\n\nfunction minifyInBatchesFromArray(input, options, maybeSourceMap, maybeCallback) {\n  var callback = typeof maybeCallback == 'function' ?\n    maybeCallback :\n    (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);\n  var errors = [];\n  var outputAsHash = {};\n  var inputValue;\n  var i, l;\n\n  function whenHashBatchDone(innerErrors, output) {\n    outputAsHash = Object.assign(outputAsHash, output);\n\n    if (innerErrors !== null) {\n      errors = errors.concat(innerErrors);\n    }\n  }\n\n  for (i = 0, l = input.length; i < l; i++) {\n    if (typeof input[i] == 'object') {\n      minifyInBatchesFromHash(input[i], options, whenHashBatchDone);\n    } else {\n      inputValue = input[i];\n\n      outputAsHash[inputValue] = minify([inputValue], options);\n      errors = errors.concat(outputAsHash[inputValue].errors);\n    }\n  }\n\n  return callback ?\n    callback(errors.length > 0 ? errors : null, outputAsHash) :\n    outputAsHash;\n}\n\nfunction minifyInBatchesFromHash(input, options, maybeSourceMap, maybeCallback) {\n  var callback = typeof maybeCallback == 'function' ?\n    maybeCallback :\n    (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);\n  var errors = [];\n  var outputAsHash = {};\n  var inputKey;\n  var inputValue;\n\n  for (inputKey in input) {\n    inputValue = input[inputKey];\n\n    outputAsHash[inputKey] = minify(inputValue.styles, options, inputValue.sourceMap);\n    errors = errors.concat(outputAsHash[inputKey].errors);\n  }\n\n  return callback ?\n    callback(errors.length > 0 ? errors : null, outputAsHash) :\n    outputAsHash;\n}\n\nfunction minify(input, options, maybeSourceMap, maybeCallback) {\n  var sourceMap = typeof maybeSourceMap != 'function' ?\n    maybeSourceMap :\n    null;\n  var callback = typeof maybeCallback == 'function' ?\n    maybeCallback :\n    (typeof maybeSourceMap == 'function' ? maybeSourceMap : null);\n  var context = {\n    stats: {\n      efficiency: 0,\n      minifiedSize: 0,\n      originalSize: 0,\n      startedAt: Date.now(),\n      timeSpent: 0\n    },\n    cache: {\n      specificity: {}\n    },\n    errors: [],\n    inlinedStylesheets: [],\n    inputSourceMapTracker: inputSourceMapTracker(),\n    localOnly: !callback,\n    options: options,\n    source: null,\n    sourcesContent: {},\n    validator: validator(options.compatibility),\n    warnings: []\n  };\n  var implicitRebaseToWarning;\n\n  if (sourceMap) {\n    context.inputSourceMapTracker.track(undefined, sourceMap);\n  }\n\n  if (options.rebase && !options.explicitRebaseTo) {\n    implicitRebaseToWarning =\n      'You have set `rebase: true` without giving `rebaseTo` option, which, in this case, defaults to the current working directory. ' +\n      'You are then warned this can lead to unexpected URL rebasing (aka here be dragons)! ' +\n      'If you are OK with the clean-css output, then you can get rid of this warning by giving clean-css a `rebaseTo: process.cwd()` option.';\n    context.warnings.push(implicitRebaseToWarning);\n  }\n\n  return runner(context.localOnly)(function () {\n    return readSources(input, context, function (tokens) {\n      var serialize = context.options.sourceMap ?\n        serializeStylesAndSourceMap :\n        serializeStyles;\n\n      var optimizedTokens = optimize(tokens, context);\n      var optimizedStyles = serialize(optimizedTokens, context);\n      var output = withMetadata(optimizedStyles, context);\n\n      return callback ?\n        callback(context.errors.length > 0 ? context.errors : null, output) :\n        output;\n    });\n  });\n}\n\nfunction runner(localOnly) {\n  // to always execute code asynchronously when a callback is given\n  // more at blog.izs.me/post/59142742143/designing-apis-for-asynchrony\n  return localOnly ?\n    function (callback) { return callback(); } :\n    process.nextTick;\n}\n\nfunction optimize(tokens, context) {\n  var optimized = level0Optimize(tokens, context);\n\n  optimized = OptimizationLevel.One in context.options.level ?\n    level1Optimize(tokens, context) :\n    tokens;\n  optimized = OptimizationLevel.Two in context.options.level ?\n    level2Optimize(tokens, context, true) :\n    optimized;\n\n  return optimized;\n}\n\nfunction withMetadata(output, context) {\n  output.stats = calculateStatsFrom(output.styles, context);\n  output.errors = context.errors;\n  output.inlinedStylesheets = context.inlinedStylesheets;\n  output.warnings = context.warnings;\n\n  return output;\n}\n\nfunction calculateStatsFrom(styles, context) {\n  var finishedAt = Date.now();\n  var timeSpent = finishedAt - context.stats.startedAt;\n\n  delete context.stats.startedAt;\n  context.stats.timeSpent = timeSpent;\n  context.stats.efficiency = 1 - styles.length / context.stats.originalSize;\n  context.stats.minifiedSize = styles.length;\n\n  return context.stats;\n}\n","var wrapSingle = require('./wrap-for-optimizing').single;\n\nvar Token = require('../tokenizer/token');\n\nfunction deep(property) {\n  var cloned = shallow(property);\n  for (var i = property.components.length - 1; i >= 0; i--) {\n    var component = shallow(property.components[i]);\n    component.value = property.components[i].value.slice(0);\n    cloned.components.unshift(component);\n  }\n\n  cloned.dirty = true;\n  cloned.value = property.value.slice(0);\n\n  return cloned;\n}\n\nfunction shallow(property) {\n  var cloned = wrapSingle([\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, property.name]\n  ]);\n  cloned.important = property.important;\n  cloned.hack = property.hack;\n  cloned.unused = false;\n  return cloned;\n}\n\nmodule.exports = {\n  deep: deep,\n  shallow: shallow\n};\n","// Contains the interpretation of CSS properties, as used by the property optimizer\n\nvar breakUp = require('./configuration/break-up');\nvar canOverride = require('./configuration/can-override');\nvar restore = require('./configuration/restore');\n\nvar propertyOptimizers = require('./level-1/property-optimizers');\nvar valueOptimizers = require('./level-1/value-optimizers');\n\nvar override = require('../utils/override');\n\n// Properties to process\n// Extend this object in order to add support for more properties in the optimizer.\n//\n// Each key in this object represents a CSS property and should be an object.\n// Such an object contains properties that describe how the represented CSS property should be handled.\n// Possible options:\n//\n// * components: array (Only specify for shorthand properties.)\n//   Contains the names of the granular properties this shorthand compacts.\n//\n// * canOverride: function\n//   Returns whether two tokens of this property can be merged with each other.\n//   This property has no meaning for shorthands.\n//\n// * defaultValue: string\n//   Specifies the default value of the property according to the CSS standard.\n//   For shorthand, this is used when every component is set to its default value, therefore it should be the shortest possible default value of all the components.\n//\n// * shortestValue: string\n//   Specifies the shortest possible value the property can possibly have.\n//   (Falls back to defaultValue if unspecified.)\n//\n// * breakUp: function (Only specify for shorthand properties.)\n//   Breaks the shorthand up to its components.\n//\n// * restore: function (Only specify for shorthand properties.)\n//   Puts the shorthand together from its components.\n//\nvar configuration = {\n  'animation': {\n    canOverride: canOverride.generic.components([\n      canOverride.generic.time,\n      canOverride.generic.timingFunction,\n      canOverride.generic.time,\n      canOverride.property.animationIterationCount,\n      canOverride.property.animationDirection,\n      canOverride.property.animationFillMode,\n      canOverride.property.animationPlayState,\n      canOverride.property.animationName\n    ]),\n    components: [\n      'animation-duration',\n      'animation-timing-function',\n      'animation-delay',\n      'animation-iteration-count',\n      'animation-direction',\n      'animation-fill-mode',\n      'animation-play-state',\n      'animation-name'\n    ],\n    breakUp: breakUp.multiplex(breakUp.animation),\n    defaultValue: 'none',\n    restore: restore.multiplex(restore.withoutDefaults),\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.textQuotes,\n      valueOptimizers.time,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-delay': {\n    canOverride: canOverride.generic.time,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: '0s',\n    intoMultiplexMode: 'real',\n    valueOptimizers: [\n      valueOptimizers.time,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-direction': {\n    canOverride: canOverride.property.animationDirection,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: 'normal',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-duration': {\n    canOverride: canOverride.generic.time,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: '0s',\n    intoMultiplexMode: 'real',\n    keepUnlessDefault: 'animation-delay',\n    valueOptimizers: [\n      valueOptimizers.time,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-fill-mode': {\n    canOverride: canOverride.property.animationFillMode,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: 'none',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-iteration-count': {\n    canOverride: canOverride.property.animationIterationCount,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: '1',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-name': {\n    canOverride: canOverride.property.animationName,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: 'none',\n    intoMultiplexMode: 'real',\n    valueOptimizers: [\n      valueOptimizers.textQuotes\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-play-state': {\n    canOverride: canOverride.property.animationPlayState,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: 'running',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'animation-timing-function': {\n    canOverride: canOverride.generic.timingFunction,\n    componentOf: [\n      'animation'\n    ],\n    defaultValue: 'ease',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'background': {\n    canOverride: canOverride.generic.components([\n      canOverride.generic.image,\n      canOverride.property.backgroundPosition,\n      canOverride.property.backgroundSize,\n      canOverride.property.backgroundRepeat,\n      canOverride.property.backgroundAttachment,\n      canOverride.property.backgroundOrigin,\n      canOverride.property.backgroundClip,\n      canOverride.generic.color\n    ]),\n    components: [\n      'background-image',\n      'background-position',\n      'background-size',\n      'background-repeat',\n      'background-attachment',\n      'background-origin',\n      'background-clip',\n      'background-color'\n    ],\n    breakUp: breakUp.multiplex(breakUp.background),\n    defaultValue: '0 0',\n    propertyOptimizer: propertyOptimizers.background,\n    restore: restore.multiplex(restore.background),\n    shortestValue: '0',\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.urlWhiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.zero,\n      valueOptimizers.color,\n      valueOptimizers.urlPrefix,\n      valueOptimizers.urlQuotes\n    ]\n  },\n  'background-attachment': {\n    canOverride: canOverride.property.backgroundAttachment,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: 'scroll',\n    intoMultiplexMode: 'real'\n  },\n  'background-clip': {\n    canOverride: canOverride.property.backgroundClip,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: 'border-box',\n    intoMultiplexMode: 'real',\n    shortestValue: 'border-box'\n  },\n  'background-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: 'transparent',\n    intoMultiplexMode: 'real', // otherwise real color will turn into default since color appears in last multiplex only\n    multiplexLastOnly: true,\n    nonMergeableValue: 'none',\n    shortestValue: 'red',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'background-image': {\n    canOverride: canOverride.generic.image,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: 'none',\n    intoMultiplexMode: 'default',\n    valueOptimizers: [\n      valueOptimizers.urlWhiteSpace,\n      valueOptimizers.urlPrefix,\n      valueOptimizers.urlQuotes,\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ]\n  },\n  'background-origin': {\n    canOverride: canOverride.property.backgroundOrigin,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: 'padding-box',\n    intoMultiplexMode: 'real',\n    shortestValue: 'border-box'\n  },\n  'background-position': {\n    canOverride: canOverride.property.backgroundPosition,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: ['0', '0'],\n    doubleValues: true,\n    intoMultiplexMode: 'real',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'background-repeat': {\n    canOverride: canOverride.property.backgroundRepeat,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: ['repeat'],\n    doubleValues: true,\n    intoMultiplexMode: 'real'\n  },\n  'background-size': {\n    canOverride: canOverride.property.backgroundSize,\n    componentOf: [\n      'background'\n    ],\n    defaultValue: ['auto'],\n    doubleValues: true,\n    intoMultiplexMode: 'real',\n    shortestValue: '0 0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'bottom': {\n    canOverride: canOverride.property.bottom,\n    defaultValue: 'auto',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'border': {\n    breakUp: breakUp.border,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.property.borderStyle,\n      canOverride.generic.color\n    ]),\n    components: [\n      'border-width',\n      'border-style',\n      'border-color'\n    ],\n    defaultValue: 'none',\n    overridesShorthands: [\n      'border-bottom',\n      'border-left',\n      'border-right',\n      'border-top'\n    ],\n    restore: restore.withoutDefaults,\n    shorthand: true,\n    shorthandComponents: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ]\n  },\n  'border-bottom': {\n    breakUp: breakUp.border,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.property.borderStyle,\n      canOverride.generic.color\n    ]),\n    components: [\n      'border-bottom-width',\n      'border-bottom-style',\n      'border-bottom-color'\n    ],\n    defaultValue: 'none',\n    restore: restore.withoutDefaults,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ]\n  },\n  'border-bottom-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'border-bottom',\n      'border-color'\n    ],\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-bottom-left-radius': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-radius'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.borderRadius,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-'\n    ]\n  },\n  'border-bottom-right-radius': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-radius'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.borderRadius,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-'\n    ]\n  },\n  'border-bottom-style': {\n    canOverride: canOverride.property.borderStyle,\n    componentOf: [\n      'border-bottom',\n      'border-style'\n    ],\n    defaultValue: 'none'\n  },\n  'border-bottom-width': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-bottom',\n      'border-width'\n    ],\n    defaultValue: 'medium',\n    oppositeTo: 'border-top-width',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'border-collapse': {\n    canOverride: canOverride.property.borderCollapse,\n    defaultValue: 'separate'\n  },\n  'border-color': {\n    breakUp: breakUp.fourValues,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.color,\n      canOverride.generic.color,\n      canOverride.generic.color,\n      canOverride.generic.color\n    ]),\n    componentOf: [\n      'border'\n    ],\n    components: [\n      'border-top-color',\n      'border-right-color',\n      'border-bottom-color',\n      'border-left-color'\n    ],\n    defaultValue: 'none',\n    restore: restore.fourValues,\n    shortestValue: 'red',\n    shorthand: true,\n    singleTypeComponents: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-left': {\n    breakUp: breakUp.border,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.property.borderStyle,\n      canOverride.generic.color\n    ]),\n    components: [\n      'border-left-width',\n      'border-left-style',\n      'border-left-color'\n    ],\n    defaultValue: 'none',\n    restore: restore.withoutDefaults,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ]\n  },\n  'border-left-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'border-color',\n      'border-left'\n    ],\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-left-style': {\n    canOverride: canOverride.property.borderStyle,\n    componentOf: [\n      'border-left',\n      'border-style'\n    ],\n    defaultValue: 'none'\n  },\n  'border-left-width': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-left',\n      'border-width'\n    ],\n    defaultValue: 'medium',\n    oppositeTo: 'border-right-width',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'border-radius': {\n    breakUp: breakUp.borderRadius,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit\n    ]),\n    components: [\n      'border-top-left-radius',\n      'border-top-right-radius',\n      'border-bottom-right-radius',\n      'border-bottom-left-radius'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.borderRadius,\n    restore: restore.borderRadius,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-'\n    ]\n  },\n  'border-right': {\n    breakUp: breakUp.border,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.property.borderStyle,\n      canOverride.generic.color\n    ]),\n    components: [\n      'border-right-width',\n      'border-right-style',\n      'border-right-color'\n    ],\n    defaultValue: 'none',\n    restore: restore.withoutDefaults,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-right-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'border-color',\n      'border-right'\n    ],\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-right-style': {\n    canOverride: canOverride.property.borderStyle,\n    componentOf: [\n      'border-right',\n      'border-style'\n    ],\n    defaultValue: 'none'\n  },\n  'border-right-width': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-right',\n      'border-width'\n    ],\n    defaultValue: 'medium',\n    oppositeTo: 'border-left-width',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'border-style': {\n    breakUp: breakUp.fourValues,\n    canOverride: canOverride.generic.components([\n      canOverride.property.borderStyle,\n      canOverride.property.borderStyle,\n      canOverride.property.borderStyle,\n      canOverride.property.borderStyle\n    ]),\n    componentOf: [\n      'border'\n    ],\n    components: [\n      'border-top-style',\n      'border-right-style',\n      'border-bottom-style',\n      'border-left-style'\n    ],\n    defaultValue: 'none',\n    restore: restore.fourValues,\n    shorthand: true,\n    singleTypeComponents: true\n  },\n  'border-top': {\n    breakUp: breakUp.border,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.property.borderStyle,\n      canOverride.generic.color\n    ]),\n    components: [\n      'border-top-width',\n      'border-top-style',\n      'border-top-color'\n    ],\n    defaultValue: 'none',\n    restore: restore.withoutDefaults,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.zero,\n      valueOptimizers.color,\n      valueOptimizers.unit\n    ]\n  },\n  'border-top-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'border-color',\n      'border-top'\n    ],\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'border-top-left-radius': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-radius'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.borderRadius,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-'\n    ]\n  },\n  'border-top-right-radius': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-radius'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.borderRadius,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-o-'\n    ]\n  },\n  'border-top-style': {\n    canOverride: canOverride.property.borderStyle,\n    componentOf: [\n      'border-style',\n      'border-top'\n    ],\n    defaultValue: 'none'\n  },\n  'border-top-width': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'border-top',\n      'border-width'\n    ],\n    defaultValue: 'medium',\n    oppositeTo: 'border-bottom-width',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'border-width': {\n    breakUp: breakUp.fourValues,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit\n    ]),\n    componentOf: [\n      'border'\n    ],\n    components: [\n      'border-top-width',\n      'border-right-width',\n      'border-bottom-width',\n      'border-left-width'\n    ],\n    defaultValue: 'medium',\n    restore: restore.fourValues,\n    shortestValue: '0',\n    shorthand: true,\n    singleTypeComponents: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'box-shadow': {\n    propertyOptimizer: propertyOptimizers.boxShadow,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'clear': {\n    canOverride: canOverride.property.clear,\n    defaultValue: 'none'\n  },\n  'clip': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'color': {\n    canOverride: canOverride.generic.color,\n    defaultValue: 'transparent',\n    shortestValue: 'red',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'column-gap': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'cursor': {\n    canOverride: canOverride.property.cursor,\n    defaultValue: 'auto'\n  },\n  'display': {\n    canOverride: canOverride.property.display,\n  },\n  'filter': {\n    propertyOptimizer: propertyOptimizers.filter,\n    valueOptimizers: [\n      valueOptimizers.fraction\n    ]\n  },\n  'float': {\n    canOverride: canOverride.property.float,\n    defaultValue: 'none'\n  },\n  'font': {\n    breakUp: breakUp.font,\n    canOverride: canOverride.generic.components([\n      canOverride.property.fontStyle,\n      canOverride.property.fontVariant,\n      canOverride.property.fontWeight,\n      canOverride.property.fontStretch,\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.property.fontFamily\n    ]),\n    components: [\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'font-stretch',\n      'font-size',\n      'line-height',\n      'font-family'\n    ],\n    restore: restore.font,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.textQuotes\n    ]\n  },\n  'font-family': {\n    canOverride: canOverride.property.fontFamily,\n    defaultValue: 'user|agent|specific',\n    valueOptimizers: [\n      valueOptimizers.textQuotes\n    ]\n  },\n  'font-size': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: 'medium',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.fraction\n    ]\n  },\n  'font-stretch': {\n    canOverride: canOverride.property.fontStretch,\n    defaultValue: 'normal'\n  },\n  'font-style': {\n    canOverride: canOverride.property.fontStyle,\n    defaultValue: 'normal'\n  },\n  'font-variant': {\n    canOverride: canOverride.property.fontVariant,\n    defaultValue: 'normal'\n  },\n  'font-weight': {\n    canOverride: canOverride.property.fontWeight,\n    defaultValue: 'normal',\n    propertyOptimizer: propertyOptimizers.fontWeight,\n    shortestValue: '400'\n  },\n  'gap': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'height': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: 'auto',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'left': {\n    canOverride: canOverride.property.left,\n    defaultValue: 'auto',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'letter-spacing': {\n    valueOptimizers: [\n      valueOptimizers.fraction,\n      valueOptimizers.zero\n    ]\n  },\n  'line-height': {\n    canOverride: canOverride.generic.unitOrNumber,\n    defaultValue: 'normal',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.fraction,\n      valueOptimizers.zero\n    ]\n  },\n  'list-style': {\n    canOverride: canOverride.generic.components([\n      canOverride.property.listStyleType,\n      canOverride.property.listStylePosition,\n      canOverride.property.listStyleImage\n    ]),\n    components: [\n      'list-style-type',\n      'list-style-position',\n      'list-style-image'\n    ],\n    breakUp: breakUp.listStyle,\n    restore: restore.withoutDefaults,\n    defaultValue: 'outside', // can't use 'disc' because that'd override default 'decimal' for <ol>\n    shortestValue: 'none',\n    shorthand: true\n  },\n  'list-style-image' : {\n    canOverride: canOverride.generic.image,\n    componentOf: [\n      'list-style'\n    ],\n    defaultValue: 'none'\n  },\n  'list-style-position' : {\n    canOverride: canOverride.property.listStylePosition,\n    componentOf: [\n      'list-style'\n    ],\n    defaultValue: 'outside',\n    shortestValue: 'inside'\n  },\n  'list-style-type' : {\n    canOverride: canOverride.property.listStyleType,\n    componentOf: [\n      'list-style'\n    ],\n    // NOTE: we can't tell the real default value here, it's 'disc' for <ul> and 'decimal' for <ol>\n    // this is a hack, but it doesn't matter because this value will be either overridden or\n    // it will disappear at the final step anyway\n    defaultValue: 'decimal|disc',\n    shortestValue: 'none'\n  },\n  'margin': {\n    breakUp: breakUp.fourValues,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit\n    ]),\n    components: [\n      'margin-top',\n      'margin-right',\n      'margin-bottom',\n      'margin-left'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.margin,\n    restore: restore.fourValues,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-bottom': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'margin'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'margin-top',\n    propertyOptimizer: propertyOptimizers.margin,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-inline-end': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-inline-start': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-left': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'margin'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'margin-right',\n    propertyOptimizer: propertyOptimizers.margin,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-right': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'margin'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'margin-left',\n    propertyOptimizer: propertyOptimizers.margin,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'margin-top': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'margin'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'margin-bottom',\n    propertyOptimizer: propertyOptimizers.margin,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'max-height': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: 'none',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'max-width': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: 'none',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'min-height': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: '0',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'min-width': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: '0',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'opacity': {\n    valueOptimizers: [\n      valueOptimizers.fraction,\n      valueOptimizers.precision\n    ]\n  },\n  'outline': {\n    canOverride: canOverride.generic.components([\n      canOverride.generic.color,\n      canOverride.property.outlineStyle,\n      canOverride.generic.unit\n    ]),\n    components: [\n      'outline-color',\n      'outline-style',\n      'outline-width'\n    ],\n    breakUp: breakUp.outline,\n    restore: restore.withoutDefaults,\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.outline,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'outline-color': {\n    canOverride: canOverride.generic.color,\n    componentOf: [\n      'outline'\n    ],\n    defaultValue: 'invert',\n    shortestValue: 'red',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.color\n    ]\n  },\n  'outline-style': {\n    canOverride: canOverride.property.outlineStyle,\n    componentOf: [\n      'outline'\n    ],\n    defaultValue: 'none'\n  },\n  'outline-width': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'outline'\n    ],\n    defaultValue: 'medium',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'overflow': {\n    canOverride: canOverride.property.overflow,\n    defaultValue: 'visible'\n  },\n  'overflow-x': {\n    canOverride: canOverride.property.overflow,\n    defaultValue: 'visible'\n  },\n  'overflow-y': {\n    canOverride: canOverride.property.overflow,\n    defaultValue: 'visible'\n  },\n  'padding': {\n    breakUp: breakUp.fourValues,\n    canOverride: canOverride.generic.components([\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit,\n      canOverride.generic.unit\n    ]),\n    components: [\n      'padding-top',\n      'padding-right',\n      'padding-bottom',\n      'padding-left'\n    ],\n    defaultValue: '0',\n    propertyOptimizer: propertyOptimizers.padding,\n    restore: restore.fourValues,\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'padding-bottom': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'padding'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'padding-top',\n    propertyOptimizer: propertyOptimizers.padding,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'padding-left': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'padding'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'padding-right',\n    propertyOptimizer: propertyOptimizers.padding,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'padding-right': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'padding'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'padding-left',\n    propertyOptimizer: propertyOptimizers.padding,\n        valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'padding-top': {\n    canOverride: canOverride.generic.unit,\n    componentOf: [\n      'padding'\n    ],\n    defaultValue: '0',\n    oppositeTo: 'padding-bottom',\n    propertyOptimizer: propertyOptimizers.padding,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'position': {\n    canOverride: canOverride.property.position,\n    defaultValue: 'static'\n  },\n  'right': {\n    canOverride: canOverride.property.right,\n    defaultValue: 'auto',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'row-gap': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'src': {\n    valueOptimizers: [\n      valueOptimizers.urlWhiteSpace,\n      valueOptimizers.urlPrefix,\n      valueOptimizers.urlQuotes\n    ]\n  },\n  'stroke-width': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'text-align': {\n    canOverride: canOverride.property.textAlign,\n    // NOTE: we can't tell the real default value here, as it depends on default text direction\n    // this is a hack, but it doesn't matter because this value will be either overridden or\n    // it will disappear anyway\n    defaultValue: 'left|right'\n  },\n  'text-decoration': {\n    canOverride: canOverride.property.textDecoration,\n    defaultValue: 'none'\n  },\n  'text-indent': {\n    canOverride: canOverride.property.textOverflow,\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.fraction,\n      valueOptimizers.zero\n    ]\n  },\n  'text-overflow': {\n    canOverride: canOverride.property.textOverflow,\n    defaultValue: 'none'\n  },\n  'text-shadow': {\n    canOverride: canOverride.property.textShadow,\n    defaultValue: 'none',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.zero,\n      valueOptimizers.color\n    ]\n  },\n  'top': {\n    canOverride: canOverride.property.top,\n    defaultValue: 'auto',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'transform': {\n    canOverride: canOverride.property.transform,\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.degrees,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'transition': {\n    breakUp: breakUp.multiplex(breakUp.transition),\n    canOverride: canOverride.generic.components([\n      canOverride.property.transitionProperty,\n      canOverride.generic.time,\n      canOverride.generic.timingFunction,\n      canOverride.generic.time\n    ]),\n    components: [\n      'transition-property',\n      'transition-duration',\n      'transition-timing-function',\n      'transition-delay'\n    ],\n    defaultValue: 'none',\n    restore: restore.multiplex(restore.withoutDefaults),\n    shorthand: true,\n    valueOptimizers: [\n      valueOptimizers.time,\n      valueOptimizers.fraction\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'transition-delay': {\n    canOverride: canOverride.generic.time,\n    componentOf: [\n      'transition'\n    ],\n    defaultValue: '0s',\n    intoMultiplexMode: 'real',\n    valueOptimizers: [\n      valueOptimizers.time\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'transition-duration': {\n    canOverride: canOverride.generic.time,\n    componentOf: [\n      'transition'\n    ],\n    defaultValue: '0s',\n    intoMultiplexMode: 'real',\n    keepUnlessDefault: 'transition-delay',\n    valueOptimizers: [\n      valueOptimizers.time,\n      valueOptimizers.fraction\n    ],\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'transition-property': {\n    canOverride: canOverride.generic.propertyName,\n    componentOf: [\n      'transition'\n    ],\n    defaultValue: 'all',\n    intoMultiplexMode: 'placeholder',\n    placeholderValue: '_', // it's a short value that won't match any property and still be a valid `transition-property`\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'transition-timing-function': {\n    canOverride: canOverride.generic.timingFunction,\n    componentOf: [\n      'transition'\n    ],\n    defaultValue: 'ease',\n    intoMultiplexMode: 'real',\n    vendorPrefixes: [\n      '-moz-',\n      '-ms-',\n      '-o-',\n      '-webkit-'\n    ]\n  },\n  'vertical-align': {\n    canOverride: canOverride.property.verticalAlign,\n    defaultValue: 'baseline',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'visibility': {\n    canOverride: canOverride.property.visibility,\n    defaultValue: 'visible'\n  },\n  '-webkit-tap-highlight-color': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.color\n    ]\n  },\n  '-webkit-margin-end': {\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'white-space': {\n    canOverride: canOverride.property.whiteSpace,\n    defaultValue: 'normal'\n  },\n  'width': {\n    canOverride: canOverride.generic.unit,\n    defaultValue: 'auto',\n    shortestValue: '0',\n    valueOptimizers: [\n      valueOptimizers.whiteSpace,\n      valueOptimizers.fraction,\n      valueOptimizers.precision,\n      valueOptimizers.unit,\n      valueOptimizers.zero\n    ]\n  },\n  'z-index': {\n    canOverride: canOverride.property.zIndex,\n    defaultValue: 'auto'\n  }\n};\n\n// generate vendor-prefixed configuration\nvar vendorPrefixedConfiguration = {};\n\nfunction cloneDescriptor(propertyName, prefix) {\n  var clonedDescriptor = override(configuration[propertyName], {});\n\n  if ('componentOf' in clonedDescriptor) {\n    clonedDescriptor.componentOf = clonedDescriptor.componentOf.map(function (shorthandName) {\n      return prefix + shorthandName;\n    });\n  }\n\n  if ('components' in clonedDescriptor) {\n    clonedDescriptor.components = clonedDescriptor.components.map(function (longhandName) {\n      return prefix + longhandName;\n    });\n  }\n\n  if ('keepUnlessDefault' in clonedDescriptor) {\n    clonedDescriptor.keepUnlessDefault = prefix + clonedDescriptor.keepUnlessDefault;\n  }\n\n  return clonedDescriptor;\n}\n\nvar vendorPrefixedConfiguration = {};\n\nfor (var propertyName in configuration) {\n  var descriptor = configuration[propertyName];\n\n  if (!('vendorPrefixes' in descriptor)) {\n    continue;\n  }\n\n  for (var i = 0; i < descriptor.vendorPrefixes.length; i++) {\n    var prefix = descriptor.vendorPrefixes[i];\n    var clonedDescriptor = cloneDescriptor(propertyName, prefix);\n    delete clonedDescriptor.vendorPrefixes;\n\n    vendorPrefixedConfiguration[prefix + propertyName] = clonedDescriptor;\n  }\n\n  delete descriptor.vendorPrefixes;\n}\n\nmodule.exports = override(configuration, vendorPrefixedConfiguration);\n","var InvalidPropertyError = require('../invalid-property-error');\n\nvar wrapSingle = require('../wrap-for-optimizing').single;\n\nvar Token = require('../../tokenizer/token');\nvar Marker = require('../../tokenizer/marker');\n\nvar formatPosition = require('../../utils/format-position');\n\nfunction _anyIsInherit(values) {\n  var i, l;\n\n  for (i = 0, l = values.length; i < l; i++) {\n    if (values[i][1] == 'inherit') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _colorFilter(validator) {\n  return function (value) {\n    return value[1] == 'invert' || validator.isColor(value[1]) || validator.isPrefixed(value[1]);\n  };\n}\n\nfunction _styleFilter(validator) {\n  return function (value) {\n    return value[1] != 'inherit' && validator.isStyleKeyword(value[1]) && !validator.isColorFunction(value[1]);\n  };\n}\n\nfunction _wrapDefault(name, property, configuration) {\n  var descriptor = configuration[name];\n  if (descriptor.doubleValues && descriptor.defaultValue.length == 2) {\n    return wrapSingle([\n      Token.PROPERTY,\n      [Token.PROPERTY_NAME, name],\n      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]],\n      [Token.PROPERTY_VALUE, descriptor.defaultValue[1]]\n    ]);\n  } else if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {\n    return wrapSingle([\n      Token.PROPERTY,\n      [Token.PROPERTY_NAME, name],\n      [Token.PROPERTY_VALUE, descriptor.defaultValue[0]]\n    ]);\n  } else {\n    return wrapSingle([\n      Token.PROPERTY,\n      [Token.PROPERTY_NAME, name],\n      [Token.PROPERTY_VALUE, descriptor.defaultValue]\n    ]);\n  }\n}\n\nfunction _widthFilter(validator) {\n  return function (value) {\n    return value[1] != 'inherit' &&\n      (validator.isWidth(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) &&\n      !validator.isStyleKeyword(value[1]) &&\n      !validator.isColorFunction(value[1]);\n  };\n}\n\nfunction animation(property, configuration, validator) {\n  var duration = _wrapDefault(property.name + '-duration', property, configuration);\n  var timing = _wrapDefault(property.name + '-timing-function', property, configuration);\n  var delay = _wrapDefault(property.name + '-delay', property, configuration);\n  var iteration = _wrapDefault(property.name + '-iteration-count', property, configuration);\n  var direction = _wrapDefault(property.name + '-direction', property, configuration);\n  var fill = _wrapDefault(property.name + '-fill-mode', property, configuration);\n  var play = _wrapDefault(property.name + '-play-state', property, configuration);\n  var name = _wrapDefault(property.name + '-name', property, configuration);\n  var components = [duration, timing, delay, iteration, direction, fill, play, name];\n  var values = property.value;\n  var value;\n  var durationSet = false;\n  var timingSet = false;\n  var delaySet = false;\n  var iterationSet = false;\n  var directionSet = false;\n  var fillSet = false;\n  var playSet = false;\n  var nameSet = false;\n  var i;\n  var l;\n\n  if (property.value.length == 1 && property.value[0][1] == 'inherit') {\n    duration.value = timing.value = delay.value = iteration.value = direction.value = fill.value = play.value = name.value = property.value;\n    return components;\n  }\n\n  if (values.length > 1 && _anyIsInherit(values)) {\n    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  for (i = 0, l = values.length; i < l; i++) {\n    value = values[i];\n\n    if (validator.isTime(value[1]) && !durationSet) {\n      duration.value = [value];\n      durationSet = true;\n    } else if (validator.isTime(value[1]) && !delaySet) {\n      delay.value = [value];\n      delaySet = true;\n    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {\n      timing.value = [value];\n      timingSet = true;\n    } else if ((validator.isAnimationIterationCountKeyword(value[1]) || validator.isPositiveNumber(value[1])) && !iterationSet) {\n      iteration.value = [value];\n      iterationSet = true;\n    } else if (validator.isAnimationDirectionKeyword(value[1]) && !directionSet) {\n      direction.value = [value];\n      directionSet = true;\n    } else if (validator.isAnimationFillModeKeyword(value[1]) && !fillSet) {\n      fill.value = [value];\n      fillSet = true;\n    } else if (validator.isAnimationPlayStateKeyword(value[1]) && !playSet) {\n      play.value = [value];\n      playSet = true;\n    } else if ((validator.isAnimationNameKeyword(value[1]) || validator.isIdentifier(value[1])) && !nameSet) {\n      name.value = [value];\n      nameSet = true;\n    } else {\n      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');\n    }\n  }\n\n  return components;\n}\n\nfunction background(property, configuration, validator) {\n  var image = _wrapDefault('background-image', property, configuration);\n  var position = _wrapDefault('background-position', property, configuration);\n  var size = _wrapDefault('background-size', property, configuration);\n  var repeat = _wrapDefault('background-repeat', property, configuration);\n  var attachment = _wrapDefault('background-attachment', property, configuration);\n  var origin = _wrapDefault('background-origin', property, configuration);\n  var clip = _wrapDefault('background-clip', property, configuration);\n  var color = _wrapDefault('background-color', property, configuration);\n  var components = [image, position, size, repeat, attachment, origin, clip, color];\n  var values = property.value;\n\n  var positionSet = false;\n  var clipSet = false;\n  var originSet = false;\n  var repeatSet = false;\n\n  var anyValueSet = false;\n\n  if (property.value.length == 1 && property.value[0][1] == 'inherit') {\n    // NOTE: 'inherit' is not a valid value for background-attachment\n    color.value = image.value =  repeat.value = position.value = size.value = origin.value = clip.value = property.value;\n    return components;\n  }\n\n  if (property.value.length == 1 && property.value[0][1] == '0 0') {\n    return components;\n  }\n\n  for (var i = values.length - 1; i >= 0; i--) {\n    var value = values[i];\n\n    if (validator.isBackgroundAttachmentKeyword(value[1])) {\n      attachment.value = [value];\n      anyValueSet = true;\n    } else if (validator.isBackgroundClipKeyword(value[1]) || validator.isBackgroundOriginKeyword(value[1])) {\n      if (clipSet) {\n        origin.value = [value];\n        originSet = true;\n      } else {\n        clip.value = [value];\n        clipSet = true;\n      }\n      anyValueSet = true;\n    } else if (validator.isBackgroundRepeatKeyword(value[1])) {\n      if (repeatSet) {\n        repeat.value.unshift(value);\n      } else {\n        repeat.value = [value];\n        repeatSet = true;\n      }\n      anyValueSet = true;\n    } else if (validator.isBackgroundPositionKeyword(value[1]) || validator.isBackgroundSizeKeyword(value[1]) || validator.isUnit(value[1]) || validator.isDynamicUnit(value[1])) {\n      if (i > 0) {\n        var previousValue = values[i - 1];\n\n        if (previousValue[1] == Marker.FORWARD_SLASH) {\n          size.value = [value];\n        } else if (i > 1 && values[i - 2][1] == Marker.FORWARD_SLASH) {\n          size.value = [previousValue, value];\n          i -= 2;\n        } else {\n          if (!positionSet)\n            position.value = [];\n\n          position.value.unshift(value);\n          positionSet = true;\n        }\n      } else {\n        if (!positionSet)\n          position.value = [];\n\n        position.value.unshift(value);\n        positionSet = true;\n      }\n      anyValueSet = true;\n    } else if ((color.value[0][1] == configuration[color.name].defaultValue || color.value[0][1] == 'none') && (validator.isColor(value[1]) || validator.isPrefixed(value[1]))) {\n      color.value = [value];\n      anyValueSet = true;\n    } else if (validator.isUrl(value[1]) || validator.isFunction(value[1])) {\n      image.value = [value];\n      anyValueSet = true;\n    }\n  }\n\n  if (clipSet && !originSet)\n    origin.value = clip.value.slice(0);\n\n  if (!anyValueSet) {\n    throw new InvalidPropertyError('Invalid background value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  return components;\n}\n\nfunction borderRadius(property, configuration) {\n  var values = property.value;\n  var splitAt = -1;\n\n  for (var i = 0, l = values.length; i < l; i++) {\n    if (values[i][1] == Marker.FORWARD_SLASH) {\n      splitAt = i;\n      break;\n    }\n  }\n\n  if (splitAt === 0 || splitAt === values.length - 1) {\n    throw new InvalidPropertyError('Invalid border-radius value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  var target = _wrapDefault(property.name, property, configuration);\n  target.value = splitAt > -1 ?\n    values.slice(0, splitAt) :\n    values.slice(0);\n  target.components = fourValues(target, configuration);\n\n  var remainder = _wrapDefault(property.name, property, configuration);\n  remainder.value = splitAt > -1 ?\n    values.slice(splitAt + 1) :\n    values.slice(0);\n  remainder.components = fourValues(remainder, configuration);\n\n  for (var j = 0; j < 4; j++) {\n    target.components[j].multiplex = true;\n    target.components[j].value = target.components[j].value.concat(remainder.components[j].value);\n  }\n\n  return target.components;\n}\n\nfunction font(property, configuration, validator) {\n  var style = _wrapDefault('font-style', property, configuration);\n  var variant = _wrapDefault('font-variant', property, configuration);\n  var weight = _wrapDefault('font-weight', property, configuration);\n  var stretch = _wrapDefault('font-stretch', property, configuration);\n  var size = _wrapDefault('font-size', property, configuration);\n  var height = _wrapDefault('line-height', property, configuration);\n  var family = _wrapDefault('font-family', property, configuration);\n  var components = [style, variant, weight, stretch, size, height, family];\n  var values = property.value;\n  var fuzzyMatched = 4; // style, variant, weight, and stretch\n  var index = 0;\n  var isStretchSet = false;\n  var isStretchValid;\n  var isStyleSet = false;\n  var isStyleValid;\n  var isVariantSet = false;\n  var isVariantValid;\n  var isWeightSet = false;\n  var isWeightValid;\n  var appendableFamilyName = false;\n\n  if (!values[index]) {\n    throw new InvalidPropertyError('Missing font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');\n  }\n\n  if (values.length == 1 && values[0][1] == 'inherit') {\n    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;\n    return components;\n  }\n\n  if (values.length == 1 && (validator.isFontKeyword(values[0][1]) || validator.isGlobal(values[0][1]) || validator.isPrefixed(values[0][1]))) {\n    values[0][1] = Marker.INTERNAL + values[0][1];\n    style.value = variant.value = weight.value = stretch.value = size.value = height.value = family.value = values;\n    return components;\n  }\n\n  if (values.length < 2 || !_anyIsFontSize(values, validator) || !_anyIsFontFamily(values, validator)) {\n    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(property.all[property.position][1][2][0]) + '. Ignoring.');\n  }\n\n  if (values.length > 1 && _anyIsInherit(values)) {\n    throw new InvalidPropertyError('Invalid font values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  // fuzzy match style, variant, weight, and stretch on first elements\n  while (index < fuzzyMatched) {\n    isStretchValid = validator.isFontStretchKeyword(values[index][1]) || validator.isGlobal(values[index][1]);\n    isStyleValid = validator.isFontStyleKeyword(values[index][1]) || validator.isGlobal(values[index][1]);\n    isVariantValid = validator.isFontVariantKeyword(values[index][1]) || validator.isGlobal(values[index][1]);\n    isWeightValid = validator.isFontWeightKeyword(values[index][1]) || validator.isGlobal(values[index][1]);\n\n    if (isStyleValid && !isStyleSet) {\n      style.value = [values[index]];\n      isStyleSet = true;\n    } else if (isVariantValid && !isVariantSet) {\n      variant.value = [values[index]];\n      isVariantSet = true;\n    } else if (isWeightValid && !isWeightSet) {\n      weight.value = [values[index]];\n      isWeightSet = true;\n    } else if (isStretchValid && !isStretchSet) {\n      stretch.value = [values[index]];\n      isStretchSet = true;\n    } else if (isStyleValid && isStyleSet || isVariantValid && isVariantSet || isWeightValid && isWeightSet || isStretchValid && isStretchSet) {\n      throw new InvalidPropertyError('Invalid font style / variant / weight / stretch value at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  // now comes font-size ...\n  if (validator.isFontSizeKeyword(values[index][1]) || validator.isUnit(values[index][1]) && !validator.isDynamicUnit(values[index][1])) {\n    size.value = [values[index]];\n    index++;\n  } else {\n    throw new InvalidPropertyError('Missing font size at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  if (!values[index]) {\n    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  // ... and perhaps line-height\n  if (values[index] && values[index][1] == Marker.FORWARD_SLASH && values[index + 1] && (validator.isLineHeightKeyword(values[index + 1][1]) || validator.isUnit(values[index + 1][1]) || validator.isNumber(values[index + 1][1]))) {\n    height.value = [values[index + 1]];\n    index++;\n    index++;\n  }\n\n  // ... and whatever comes next is font-family\n  family.value = [];\n\n  while (values[index]) {\n    if (values[index][1] == Marker.COMMA) {\n      appendableFamilyName = false;\n    } else {\n      if (appendableFamilyName) {\n        family.value[family.value.length - 1][1] += Marker.SPACE + values[index][1];\n      } else {\n        family.value.push(values[index]);\n      }\n\n      appendableFamilyName = true;\n    }\n\n    index++;\n  }\n\n  if (family.value.length === 0) {\n    throw new InvalidPropertyError('Missing font family at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  return components;\n}\n\nfunction _anyIsFontSize(values, validator) {\n  var value;\n  var i, l;\n\n  for (i = 0, l = values.length; i < l; i++) {\n    value = values[i];\n\n    if (validator.isFontSizeKeyword(value[1]) || validator.isUnit(value[1]) && !validator.isDynamicUnit(value[1]) || validator.isFunction(value[1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _anyIsFontFamily(values, validator) {\n  var value;\n  var i, l;\n\n  for (i = 0, l = values.length; i < l; i++) {\n    value = values[i];\n\n    if (validator.isIdentifier(value[1]) || validator.isQuotedText(value[1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction fourValues(property, configuration) {\n  var componentNames = configuration[property.name].components;\n  var components = [];\n  var value = property.value;\n\n  if (value.length < 1)\n    return [];\n\n  if (value.length < 2)\n    value[1] = value[0].slice(0);\n  if (value.length < 3)\n    value[2] = value[0].slice(0);\n  if (value.length < 4)\n    value[3] = value[1].slice(0);\n\n  for (var i = componentNames.length - 1; i >= 0; i--) {\n    var component = wrapSingle([\n      Token.PROPERTY,\n      [Token.PROPERTY_NAME, componentNames[i]]\n    ]);\n    component.value = [value[i]];\n    components.unshift(component);\n  }\n\n  return components;\n}\n\nfunction multiplex(splitWith) {\n  return function (property, configuration, validator) {\n    var splitsAt = [];\n    var values = property.value;\n    var i, j, l, m;\n\n    // find split commas\n    for (i = 0, l = values.length; i < l; i++) {\n      if (values[i][1] == ',')\n        splitsAt.push(i);\n    }\n\n    if (splitsAt.length === 0)\n      return splitWith(property, configuration, validator);\n\n    var splitComponents = [];\n\n    // split over commas, and into components\n    for (i = 0, l = splitsAt.length; i <= l; i++) {\n      var from = i === 0 ? 0 : splitsAt[i - 1] + 1;\n      var to = i < l ? splitsAt[i] : values.length;\n\n      var _property = _wrapDefault(property.name, property, configuration);\n      _property.value = values.slice(from, to);\n\n      if (_property.value.length > 0) {\n        splitComponents.push(splitWith(_property, configuration, validator));\n      }\n    }\n\n    var components = splitComponents[0];\n\n    // group component values from each split\n    for (i = 0, l = components.length; i < l; i++) {\n      components[i].multiplex = true;\n\n      for (j = 1, m = splitComponents.length; j < m; j++) {\n        components[i].value.push([Token.PROPERTY_VALUE, Marker.COMMA]);\n        Array.prototype.push.apply(components[i].value, splitComponents[j][i].value);\n      }\n    }\n\n    return components;\n  };\n}\n\nfunction listStyle(property, configuration, validator) {\n  var type = _wrapDefault('list-style-type', property, configuration);\n  var position = _wrapDefault('list-style-position', property, configuration);\n  var image = _wrapDefault('list-style-image', property, configuration);\n  var components = [type, position, image];\n\n  if (property.value.length == 1 && property.value[0][1] == 'inherit') {\n    type.value = position.value = image.value = [property.value[0]];\n    return components;\n  }\n\n  var values = property.value.slice(0);\n  var total = values.length;\n  var index = 0;\n\n  // `image` first...\n  for (index = 0, total = values.length; index < total; index++) {\n    if (validator.isUrl(values[index][1]) || values[index][1] == '0') {\n      image.value = [values[index]];\n      values.splice(index, 1);\n      break;\n    }\n  }\n\n  // ... then `position`\n  for (index = 0, total = values.length; index < total; index++) {\n    if (validator.isListStylePositionKeyword(values[index][1])) {\n      position.value = [values[index]];\n      values.splice(index, 1);\n      break;\n    }\n  }\n\n  // ... and what's left is a `type`\n  if (values.length > 0 && (validator.isListStyleTypeKeyword(values[0][1]) || validator.isIdentifier(values[0][1]))) {\n    type.value = [values[0]];\n  }\n\n  return components;\n}\n\nfunction transition(property, configuration, validator) {\n  var prop = _wrapDefault(property.name + '-property', property, configuration);\n  var duration = _wrapDefault(property.name + '-duration', property, configuration);\n  var timing = _wrapDefault(property.name + '-timing-function', property, configuration);\n  var delay = _wrapDefault(property.name + '-delay', property, configuration);\n  var components = [prop, duration, timing, delay];\n  var values = property.value;\n  var value;\n  var durationSet = false;\n  var delaySet = false;\n  var propSet = false;\n  var timingSet = false;\n  var i;\n  var l;\n\n  if (property.value.length == 1 && property.value[0][1] == 'inherit') {\n    prop.value = duration.value = timing.value = delay.value = property.value;\n    return components;\n  }\n\n  if (values.length > 1 && _anyIsInherit(values)) {\n    throw new InvalidPropertyError('Invalid animation values at ' + formatPosition(values[0][2][0]) + '. Ignoring.');\n  }\n\n  for (i = 0, l = values.length; i < l; i++) {\n    value = values[i];\n\n    if (validator.isTime(value[1]) && !durationSet) {\n      duration.value = [value];\n      durationSet = true;\n    } else if (validator.isTime(value[1]) && !delaySet) {\n      delay.value = [value];\n      delaySet = true;\n    } else if ((validator.isGlobal(value[1]) || validator.isTimingFunction(value[1])) && !timingSet) {\n      timing.value = [value];\n      timingSet = true;\n    } else if (validator.isIdentifier(value[1]) && !propSet) {\n      prop.value = [value];\n      propSet = true;\n    } else {\n      throw new InvalidPropertyError('Invalid animation value at ' + formatPosition(value[2][0]) + '. Ignoring.');\n    }\n  }\n\n  return components;\n}\n\nfunction widthStyleColor(property, configuration, validator) {\n  var descriptor = configuration[property.name];\n  var components = [\n    _wrapDefault(descriptor.components[0], property, configuration),\n    _wrapDefault(descriptor.components[1], property, configuration),\n    _wrapDefault(descriptor.components[2], property, configuration)\n  ];\n  var color, style, width;\n\n  for (var i = 0; i < 3; i++) {\n    var component = components[i];\n\n    if (component.name.indexOf('color') > 0)\n      color = component;\n    else if (component.name.indexOf('style') > 0)\n      style = component;\n    else\n      width = component;\n  }\n\n  if ((property.value.length == 1 && property.value[0][1] == 'inherit') ||\n      (property.value.length == 3 && property.value[0][1] == 'inherit' && property.value[1][1] == 'inherit' && property.value[2][1] == 'inherit')) {\n    color.value = style.value = width.value = [property.value[0]];\n    return components;\n  }\n\n  var values = property.value.slice(0);\n  var match, matches;\n\n  // NOTE: usually users don't follow the required order of parts in this shorthand,\n  // so we'll try to parse it caring as little about order as possible\n\n  if (values.length > 0) {\n    matches = values.filter(_widthFilter(validator));\n    match = matches.length > 1 && (matches[0][1] == 'none' || matches[0][1] == 'auto') ? matches[1] : matches[0];\n    if (match) {\n      width.value = [match];\n      values.splice(values.indexOf(match), 1);\n    }\n  }\n\n  if (values.length > 0) {\n    match = values.filter(_styleFilter(validator))[0];\n    if (match) {\n      style.value = [match];\n      values.splice(values.indexOf(match), 1);\n    }\n  }\n\n  if (values.length > 0) {\n    match = values.filter(_colorFilter(validator))[0];\n    if (match) {\n      color.value = [match];\n      values.splice(values.indexOf(match), 1);\n    }\n  }\n\n  return components;\n}\n\nmodule.exports = {\n  animation: animation,\n  background: background,\n  border: widthStyleColor,\n  borderRadius: borderRadius,\n  font: font,\n  fourValues: fourValues,\n  listStyle: listStyle,\n  multiplex: multiplex,\n  outline: widthStyleColor,\n  transition: transition\n};\n","var understandable = require('./properties/understandable');\n\nfunction animationIterationCount(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isAnimationIterationCountKeyword(value2) || validator.isPositiveNumber(value2);\n}\n\nfunction animationName(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isAnimationNameKeyword(value2) || validator.isIdentifier(value2);\n}\n\nfunction areSameFunction(validator, value1, value2) {\n  if (!validator.isFunction(value1) || !validator.isFunction(value2)) {\n    return false;\n  }\n\n  var function1Name = value1.substring(0, value1.indexOf('('));\n  var function2Name = value2.substring(0, value2.indexOf('('));\n\n  var function1Value = value1.substring(function1Name.length + 1, value1.length - 1);\n  var function2Value = value2.substring(function2Name.length + 1, value2.length - 1);\n\n  if (validator.isFunction(function1Value) || validator.isFunction(function2Value)) {\n    return function1Name === function2Name && areSameFunction(validator, function1Value, function2Value);\n  } else {\n    return function1Name === function2Name;\n  }\n}\n\nfunction backgroundPosition(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (validator.isBackgroundPositionKeyword(value2) || validator.isGlobal(value2)) {\n    return true;\n  }\n\n  return unit(validator, value1, value2);\n}\n\nfunction backgroundSize(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (validator.isBackgroundSizeKeyword(value2) || validator.isGlobal(value2)) {\n    return true;\n  }\n\n  return unit(validator, value1, value2);\n}\n\nfunction color(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isColor(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (!validator.colorOpacity && (validator.isRgbColor(value1) || validator.isHslColor(value1))) {\n    return false;\n  } else if (!validator.colorOpacity && (validator.isRgbColor(value2) || validator.isHslColor(value2))) {\n    return false;\n  } else if (!validator.colorHexAlpha && (validator.isHexAlphaColor(value1) || validator.isHexAlphaColor(value2))) {\n    return false;\n  } else if (validator.isColor(value1) && validator.isColor(value2)) {\n    return true;\n  }\n\n  return sameFunctionOrValue(validator, value1, value2);\n}\n\nfunction components(overrideCheckers) {\n  return function (validator, value1, value2, position) {\n    return overrideCheckers[position](validator, value1, value2);\n  };\n}\n\nfunction fontFamily(validator, value1, value2) {\n  return understandable(validator, value1, value2, 0, true);\n}\n\nfunction image(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isImage(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (validator.isImage(value2)) {\n    return true;\n  } else if (validator.isImage(value1)) {\n    return false;\n  }\n\n  return sameFunctionOrValue(validator, value1, value2);\n}\n\nfunction keyword(propertyName) {\n  return function(validator, value1, value2) {\n    if (!understandable(validator, value1, value2, 0, true) && !validator.isKeyword(propertyName)(value2)) {\n      return false;\n    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n      return true;\n    }\n\n    return validator.isKeyword(propertyName)(value2);\n  };\n}\n\nfunction keywordWithGlobal(propertyName) {\n  return function(validator, value1, value2) {\n    if (!understandable(validator, value1, value2, 0, true) && !(validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2))) {\n      return false;\n    } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n      return true;\n    }\n\n    return validator.isKeyword(propertyName)(value2) || validator.isGlobal(value2);\n  };\n}\n\nfunction propertyName(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isIdentifier(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isIdentifier(value2);\n}\n\nfunction sameFunctionOrValue(validator, value1, value2) {\n  return areSameFunction(validator, value1, value2) ?\n    true :\n    value1 === value2;\n}\n\nfunction textShadow(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isUnit(value2) || validator.isColor(value2) || validator.isGlobal(value2);\n}\n\nfunction time(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isTime(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (validator.isTime(value1) && !validator.isTime(value2)) {\n    return false;\n  } else if (validator.isTime(value2)) {\n    return true;\n  } else if (validator.isTime(value1)) {\n    return false;\n  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {\n    return true;\n  }\n\n  return sameFunctionOrValue(validator, value1, value2);\n}\n\nfunction timingFunction(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isTimingFunction(value2) || validator.isGlobal(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isTimingFunction(value2) || validator.isGlobal(value2);\n}\n\nfunction unit(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isUnit(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if (validator.isUnit(value1) && !validator.isUnit(value2)) {\n    return false;\n  } else if (validator.isUnit(value2)) {\n    return true;\n  } else if (validator.isUnit(value1)) {\n    return false;\n  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {\n    return true;\n  }\n\n  return sameFunctionOrValue(validator, value1, value2);\n}\n\nfunction unitOrKeywordWithGlobal(propertyName) {\n  var byKeyword = keywordWithGlobal(propertyName);\n\n  return function(validator, value1, value2) {\n    return unit(validator, value1, value2) || byKeyword(validator, value1, value2);\n  };\n}\n\nfunction unitOrNumber(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !(validator.isUnit(value2) || validator.isNumber(value2))) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  } else if ((validator.isUnit(value1) || validator.isNumber(value1)) && !(validator.isUnit(value2) || validator.isNumber(value2))) {\n    return false;\n  } else if (validator.isUnit(value2) || validator.isNumber(value2)) {\n    return true;\n  } else if (validator.isUnit(value1) || validator.isNumber(value1)) {\n    return false;\n  } else if (validator.isFunction(value1) && !validator.isPrefixed(value1) && validator.isFunction(value2) && !validator.isPrefixed(value2)) {\n    return true;\n  }\n\n  return sameFunctionOrValue(validator, value1, value2);\n}\n\nfunction zIndex(validator, value1, value2) {\n  if (!understandable(validator, value1, value2, 0, true) && !validator.isZIndex(value2)) {\n    return false;\n  } else if (validator.isVariable(value1) && validator.isVariable(value2)) {\n    return true;\n  }\n\n  return validator.isZIndex(value2);\n}\n\nmodule.exports = {\n  generic: {\n    color: color,\n    components: components,\n    image: image,\n    propertyName: propertyName,\n    time: time,\n    timingFunction: timingFunction,\n    unit: unit,\n    unitOrNumber: unitOrNumber\n  },\n  property: {\n    animationDirection: keywordWithGlobal('animation-direction'),\n    animationFillMode: keyword('animation-fill-mode'),\n    animationIterationCount: animationIterationCount,\n    animationName: animationName,\n    animationPlayState: keywordWithGlobal('animation-play-state'),\n    backgroundAttachment: keyword('background-attachment'),\n    backgroundClip: keywordWithGlobal('background-clip'),\n    backgroundOrigin: keyword('background-origin'),\n    backgroundPosition: backgroundPosition,\n    backgroundRepeat: keyword('background-repeat'),\n    backgroundSize: backgroundSize,\n    bottom: unitOrKeywordWithGlobal('bottom'),\n    borderCollapse: keyword('border-collapse'),\n    borderStyle: keywordWithGlobal('*-style'),\n    clear: keywordWithGlobal('clear'),\n    cursor: keywordWithGlobal('cursor'),\n    display: keywordWithGlobal('display'),\n    float: keywordWithGlobal('float'),\n    left: unitOrKeywordWithGlobal('left'),\n    fontFamily: fontFamily,\n    fontStretch: keywordWithGlobal('font-stretch'),\n    fontStyle: keywordWithGlobal('font-style'),\n    fontVariant: keywordWithGlobal('font-variant'),\n    fontWeight: keywordWithGlobal('font-weight'),\n    listStyleType: keywordWithGlobal('list-style-type'),\n    listStylePosition: keywordWithGlobal('list-style-position'),\n    outlineStyle: keywordWithGlobal('*-style'),\n    overflow: keywordWithGlobal('overflow'),\n    position: keywordWithGlobal('position'),\n    right: unitOrKeywordWithGlobal('right'),\n    textAlign: keywordWithGlobal('text-align'),\n    textDecoration: keywordWithGlobal('text-decoration'),\n    textOverflow: keywordWithGlobal('text-overflow'),\n    textShadow: textShadow,\n    top: unitOrKeywordWithGlobal('top'),\n    transform: sameFunctionOrValue,\n    verticalAlign: unitOrKeywordWithGlobal('vertical-align'),\n    visibility: keywordWithGlobal('visibility'),\n    whiteSpace: keywordWithGlobal('white-space'),\n    zIndex: zIndex\n  }\n};\n","var sameVendorPrefixes = require('../../vendor-prefixes').same;\n\nfunction understandable(validator, value1, value2, _position, isPaired) {\n  if (!sameVendorPrefixes(value1, value2)) {\n    return false;\n  }\n\n  if (isPaired && validator.isVariable(value1) !== validator.isVariable(value2)) {\n    return false;\n  }\n\n  return true;\n}\n\nmodule.exports = understandable;\n","var shallowClone = require('../clone').shallow;\n\nvar Token = require('../../tokenizer/token');\nvar Marker = require('../../tokenizer/marker');\n\nfunction isInheritOnly(values) {\n  for (var i = 0, l = values.length; i < l; i++) {\n    var value = values[i][1];\n\n    if (value != 'inherit' && value != Marker.COMMA && value != Marker.FORWARD_SLASH)\n      return false;\n  }\n\n  return true;\n}\n\nfunction background(property, configuration, lastInMultiplex) {\n  var components = property.components;\n  var restored = [];\n  var needsOne, needsBoth;\n\n  function restoreValue(component) {\n    Array.prototype.unshift.apply(restored, component.value);\n  }\n\n  function isDefaultValue(component) {\n    var descriptor = configuration[component.name];\n\n    if (descriptor.doubleValues && descriptor.defaultValue.length == 1) {\n      return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] == descriptor.defaultValue[0] : true);\n    } else if (descriptor.doubleValues && descriptor.defaultValue.length != 1) {\n      return component.value[0][1] == descriptor.defaultValue[0] && (component.value[1] ? component.value[1][1] : component.value[0][1]) == descriptor.defaultValue[1];\n    } else {\n      return component.value[0][1] == descriptor.defaultValue;\n    }\n  }\n\n  for (var i = components.length - 1; i >= 0; i--) {\n    var component = components[i];\n    var isDefault = isDefaultValue(component);\n\n    if (component.name == 'background-clip') {\n      var originComponent = components[i - 1];\n      var isOriginDefault = isDefaultValue(originComponent);\n\n      needsOne = component.value[0][1] == originComponent.value[0][1];\n\n      needsBoth = !needsOne && (\n        (isOriginDefault && !isDefault) ||\n        (!isOriginDefault && !isDefault) ||\n        (!isOriginDefault && isDefault && component.value[0][1] != originComponent.value[0][1]));\n\n      if (needsOne) {\n        restoreValue(originComponent);\n      } else if (needsBoth) {\n        restoreValue(component);\n        restoreValue(originComponent);\n      }\n\n      i--;\n    } else if (component.name == 'background-size') {\n      var positionComponent = components[i - 1];\n      var isPositionDefault = isDefaultValue(positionComponent);\n\n      needsOne = !isPositionDefault && isDefault;\n\n      needsBoth = !needsOne &&\n        (isPositionDefault && !isDefault || !isPositionDefault && !isDefault);\n\n      if (needsOne) {\n        restoreValue(positionComponent);\n      } else if (needsBoth) {\n        restoreValue(component);\n        restored.unshift([Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]);\n        restoreValue(positionComponent);\n      } else if (positionComponent.value.length == 1) {\n        restoreValue(positionComponent);\n      }\n\n      i--;\n    } else {\n      if (isDefault || configuration[component.name].multiplexLastOnly && !lastInMultiplex)\n        continue;\n\n      restoreValue(component);\n    }\n  }\n\n  if (restored.length === 0 && property.value.length == 1 && property.value[0][1] == '0')\n    restored.push(property.value[0]);\n\n  if (restored.length === 0)\n    restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]);\n\n  if (isInheritOnly(restored))\n    return [restored[0]];\n\n  return restored;\n}\n\nfunction borderRadius(property) {\n  if (property.multiplex) {\n    var horizontal = shallowClone(property);\n    var vertical = shallowClone(property);\n\n    for (var i = 0; i < 4; i++) {\n      var component = property.components[i];\n\n      var horizontalComponent = shallowClone(property);\n      horizontalComponent.value = [component.value[0]];\n      horizontal.components.push(horizontalComponent);\n\n      var verticalComponent = shallowClone(property);\n      // FIXME: only shorthand compactor (see breakup#borderRadius) knows that border radius\n      // longhands have two values, whereas tokenizer does not care about populating 2nd value\n      // if it's missing, hence this fallback\n      verticalComponent.value = [component.value[1] || component.value[0]];\n      vertical.components.push(verticalComponent);\n    }\n\n    var horizontalValues = fourValues(horizontal);\n    var verticalValues = fourValues(vertical);\n\n    if (horizontalValues.length == verticalValues.length &&\n        horizontalValues[0][1] == verticalValues[0][1] &&\n        (horizontalValues.length > 1 ? horizontalValues[1][1] == verticalValues[1][1] : true) &&\n        (horizontalValues.length > 2 ? horizontalValues[2][1] == verticalValues[2][1] : true) &&\n        (horizontalValues.length > 3 ? horizontalValues[3][1] == verticalValues[3][1] : true)) {\n      return horizontalValues;\n    } else {\n      return horizontalValues.concat([[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]).concat(verticalValues);\n    }\n  } else {\n    return fourValues(property);\n  }\n}\n\nfunction font(property, configuration) {\n  var components = property.components;\n  var restored = [];\n  var component;\n  var componentIndex = 0;\n  var fontFamilyIndex = 0;\n\n  if (property.value[0][1].indexOf(Marker.INTERNAL) === 0) {\n    property.value[0][1] = property.value[0][1].substring(Marker.INTERNAL.length);\n    return property.value;\n  }\n\n  // first four components are optional\n  while (componentIndex < 4) {\n    component = components[componentIndex];\n\n    if (component.value[0][1] != configuration[component.name].defaultValue) {\n      Array.prototype.push.apply(restored, component.value);\n    }\n\n    componentIndex++;\n  }\n\n  // then comes font-size\n  Array.prototype.push.apply(restored, components[componentIndex].value);\n  componentIndex++;\n\n  // then may come line-height\n  if (components[componentIndex].value[0][1] != configuration[components[componentIndex].name].defaultValue) {\n    Array.prototype.push.apply(restored, [[Token.PROPERTY_VALUE, Marker.FORWARD_SLASH]]);\n    Array.prototype.push.apply(restored, components[componentIndex].value);\n  }\n\n  componentIndex++;\n\n  // then comes font-family\n  while (components[componentIndex].value[fontFamilyIndex]) {\n    restored.push(components[componentIndex].value[fontFamilyIndex]);\n\n    if (components[componentIndex].value[fontFamilyIndex + 1]) {\n      restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);\n    }\n\n    fontFamilyIndex++;\n  }\n\n  if (isInheritOnly(restored)) {\n    return [restored[0]];\n  }\n\n  return restored;\n}\n\nfunction fourValues(property) {\n  var components = property.components;\n  var value1 = components[0].value[0];\n  var value2 = components[1].value[0];\n  var value3 = components[2].value[0];\n  var value4 = components[3].value[0];\n\n  if (value1[1] == value2[1] && value1[1] == value3[1] && value1[1] == value4[1]) {\n    return [value1];\n  } else if (value1[1] == value3[1] && value2[1] == value4[1]) {\n    return [value1, value2];\n  } else if (value2[1] == value4[1]) {\n    return [value1, value2, value3];\n  } else {\n    return [value1, value2, value3, value4];\n  }\n}\n\nfunction multiplex(restoreWith) {\n  return function (property, configuration) {\n    if (!property.multiplex)\n      return restoreWith(property, configuration, true);\n\n    var multiplexSize = 0;\n    var restored = [];\n    var componentMultiplexSoFar = {};\n    var i, l;\n\n    // At this point we don't know what's the multiplex size, e.g. how many background layers are there\n    for (i = 0, l = property.components[0].value.length; i < l; i++) {\n      if (property.components[0].value[i][1] == Marker.COMMA)\n        multiplexSize++;\n    }\n\n    for (i = 0; i <= multiplexSize; i++) {\n      var _property = shallowClone(property);\n\n      // We split multiplex into parts and restore them one by one\n      for (var j = 0, m = property.components.length; j < m; j++) {\n        var componentToClone = property.components[j];\n        var _component = shallowClone(componentToClone);\n        _property.components.push(_component);\n\n        // The trick is some properties has more than one value, so we iterate over values looking for\n        // a multiplex separator - a comma\n        for (var k = componentMultiplexSoFar[_component.name] || 0, n = componentToClone.value.length; k < n; k++) {\n          if (componentToClone.value[k][1] == Marker.COMMA) {\n            componentMultiplexSoFar[_component.name] = k + 1;\n            break;\n          }\n\n          _component.value.push(componentToClone.value[k]);\n        }\n      }\n\n      // No we can restore shorthand value\n      var lastInMultiplex = i == multiplexSize;\n      var _restored = restoreWith(_property, configuration, lastInMultiplex);\n      Array.prototype.push.apply(restored, _restored);\n\n      if (i < multiplexSize)\n        restored.push([Token.PROPERTY_VALUE, Marker.COMMA]);\n    }\n\n    return restored;\n  };\n}\n\nfunction withoutDefaults(property, configuration) {\n  var components = property.components;\n  var restored = [];\n\n  for (var i = components.length - 1; i >= 0; i--) {\n    var component = components[i];\n    var descriptor = configuration[component.name];\n\n    if (component.value[0][1] != descriptor.defaultValue || ('keepUnlessDefault' in descriptor) && !isDefault(components, configuration, descriptor.keepUnlessDefault)) {\n      restored.unshift(component.value[0]);\n    }\n  }\n\n  if (restored.length === 0)\n    restored.push([Token.PROPERTY_VALUE, configuration[property.name].defaultValue]);\n\n  if (isInheritOnly(restored))\n    return [restored[0]];\n\n  return restored;\n}\n\nfunction isDefault(components, configuration, propertyName) {\n  var component;\n  var i, l;\n\n  for (i = 0, l = components.length; i < l; i++) {\n    component = components[i];\n\n    if (component.name == propertyName && component.value[0][1] == configuration[propertyName].defaultValue) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = {\n  background: background,\n  borderRadius: borderRadius,\n  font: font,\n  fourValues: fourValues,\n  multiplex: multiplex,\n  withoutDefaults: withoutDefaults\n};\n","var Hack = {\n  ASTERISK: 'asterisk',\n  BANG: 'bang',\n  BACKSLASH: 'backslash',\n  UNDERSCORE: 'underscore'\n};\n\nmodule.exports = Hack;\n","function InvalidPropertyError(message) {\n  this.name = 'InvalidPropertyError';\n  this.message = message;\n  this.stack = (new Error()).stack;\n}\n\nInvalidPropertyError.prototype = Object.create(Error.prototype);\nInvalidPropertyError.prototype.constructor = InvalidPropertyError;\n\nmodule.exports = InvalidPropertyError;\n","function level0Optimize(tokens) {\n  // noop as level 0 means no optimizations!\n  return tokens;\n}\n\nmodule.exports = level0Optimize;\n","var sortSelectors = require('./sort-selectors');\nvar tidyRules = require('./tidy-rules');\nvar tidyBlock = require('./tidy-block');\nvar tidyAtRule = require('./tidy-at-rule');\n\nvar Hack = require('../hack');\nvar removeUnused = require('../remove-unused');\nvar restoreFromOptimizing = require('../restore-from-optimizing');\nvar wrapForOptimizing = require('../wrap-for-optimizing').all;\n\nvar configuration = require('../configuration');\nvar optimizers = require('./value-optimizers');\n\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\n\nvar Token = require('../../tokenizer/token');\nvar Marker = require('../../tokenizer/marker');\n\nvar formatPosition = require('../../utils/format-position');\n\nvar serializeRules = require('../../writer/one-time').rules;\n\nvar CHARSET_TOKEN = '@charset';\nvar CHARSET_REGEXP = new RegExp('^' + CHARSET_TOKEN, 'i');\n\nvar DEFAULT_ROUNDING_PRECISION = require('../../options/rounding-precision').DEFAULT;\n\nvar PROPERTY_NAME_PATTERN = /^(?:\\-chrome\\-|\\-[\\w\\-]+\\w|\\w[\\w\\-]+\\w|\\w{1,}|\\-\\-\\S+)$/;\nvar IMPORT_PREFIX_PATTERN = /^@import/i;\nvar URL_PREFIX_PATTERN = /^url\\(/i;\n\nfunction startsAsUrl(value) {\n  return URL_PREFIX_PATTERN.test(value);\n}\n\nfunction isImport(token) {\n  return IMPORT_PREFIX_PATTERN.test(token[1]);\n}\n\nfunction isLegacyFilter(property) {\n  var value;\n\n  if (property.name == 'filter' || property.name == '-ms-filter') {\n    value = property.value[0][1];\n\n    return value.indexOf('progid') > -1 ||\n      value.indexOf('alpha') === 0 ||\n      value.indexOf('chroma') === 0;\n  } else {\n    return false;\n  }\n}\n\nfunction noop() {}\n\nfunction optimizeBody(rule, properties, context) {\n  var options = context.options;\n  var valueOptimizers;\n  var property, name, type, value;\n  var propertyToken;\n  var propertyOptimizer;\n  var serializedRule = serializeRules(rule);\n  var _properties = wrapForOptimizing(properties);\n  var pluginValueOptimizers = context.options.plugins.level1Value;\n  var pluginPropertyOptimizers = context.options.plugins.level1Property;\n  var i, l;\n\n  propertyLoop:\n  for (i = 0, l = _properties.length; i < l; i++) {\n    var j, k, m, n;\n\n    property = _properties[i];\n    name = property.name;\n    propertyOptimizer = configuration[name] && configuration[name].propertyOptimizer || noop;\n    valueOptimizers = configuration[name] && configuration[name].valueOptimizers || [optimizers.whiteSpace];\n\n    if (!PROPERTY_NAME_PATTERN.test(name)) {\n      propertyToken = property.all[property.position];\n      context.warnings.push('Invalid property name \\'' + name + '\\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');\n      property.unused = true;\n      continue;\n    }\n\n    if (property.value.length === 0) {\n      propertyToken = property.all[property.position];\n      context.warnings.push('Empty property \\'' + name + '\\' at ' + formatPosition(propertyToken[1][2][0]) + '. Ignoring.');\n      property.unused = true;\n      continue;\n    }\n\n    if (property.hack && (\n        (property.hack[0] == Hack.ASTERISK || property.hack[0] == Hack.UNDERSCORE) && !options.compatibility.properties.iePrefixHack ||\n        property.hack[0] == Hack.BACKSLASH && !options.compatibility.properties.ieSuffixHack ||\n        property.hack[0] == Hack.BANG && !options.compatibility.properties.ieBangHack)) {\n      property.unused = true;\n      continue;\n    }\n\n    if (!options.compatibility.properties.ieFilters && isLegacyFilter(property)) {\n      property.unused = true;\n      continue;\n    }\n\n    if (property.block) {\n      optimizeBody(rule, property.value[0][1], context);\n      continue;\n    }\n\n    valuesLoop:\n    for (j = 0, m = property.value.length; j < m; j++) {\n      type = property.value[j][0];\n      value = property.value[j][1];\n\n      if (type == Token.PROPERTY_BLOCK) {\n        property.unused = true;\n        context.warnings.push('Invalid value token at ' + formatPosition(value[0][1][2][0]) + '. Ignoring.');\n        break;\n      }\n\n      if (startsAsUrl(value) && !context.validator.isUrl(value)) {\n        property.unused = true;\n        context.warnings.push('Broken URL \\'' + value + '\\' at ' + formatPosition(property.value[j][2][0]) + '. Ignoring.');\n        break;\n      }\n\n      for (k = 0, n = valueOptimizers.length; k < n; k++) {\n        value = valueOptimizers[k](name, value, options);\n      }\n\n      for (k = 0, n = pluginValueOptimizers.length; k < n; k++) {\n        value = pluginValueOptimizers[k](name, value, options);\n      }\n\n      property.value[j][1] = value;\n    }\n\n    propertyOptimizer(serializedRule, property, options);\n\n    for (j = 0, m = pluginPropertyOptimizers.length; j < m; j++) {\n      pluginPropertyOptimizers[j](serializedRule, property, options);\n    }\n  }\n\n  restoreFromOptimizing(_properties);\n  removeUnused(_properties);\n  removeComments(properties, options);\n}\n\nfunction removeComments(tokens, options) {\n  var token;\n  var i;\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    if (token[0] != Token.COMMENT) {\n      continue;\n    }\n\n    optimizeComment(token, options);\n\n    if (token[1].length === 0) {\n      tokens.splice(i, 1);\n      i--;\n    }\n  }\n}\n\nfunction optimizeComment(token, options) {\n  if (token[1][2] == Marker.EXCLAMATION && (options.level[OptimizationLevel.One].specialComments == 'all' || options.commentsKept < options.level[OptimizationLevel.One].specialComments)) {\n    options.commentsKept++;\n    return;\n  }\n\n  token[1] = [];\n}\n\nfunction cleanupCharsets(tokens) {\n  var hasCharset = false;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    if (token[0] != Token.AT_RULE)\n      continue;\n\n    if (!CHARSET_REGEXP.test(token[1]))\n      continue;\n\n    if (hasCharset || token[1].indexOf(CHARSET_TOKEN) == -1) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    } else {\n      hasCharset = true;\n      tokens.splice(i, 1);\n      tokens.unshift([Token.AT_RULE, token[1].replace(CHARSET_REGEXP, CHARSET_TOKEN)]);\n    }\n  }\n}\n\nfunction buildUnitRegexp(options) {\n  var units = ['px', 'em', 'ex', 'cm', 'mm', 'in', 'pt', 'pc', '%'];\n  var otherUnits = ['ch', 'rem', 'vh', 'vm', 'vmax', 'vmin', 'vw'];\n\n  otherUnits.forEach(function (unit) {\n    if (options.compatibility.units[unit]) {\n      units.push(unit);\n    }\n  });\n\n  return new RegExp('(^|\\\\s|\\\\(|,)0(?:' + units.join('|') + ')(\\\\W|$)', 'g');\n}\n\nfunction buildPrecisionOptions(roundingPrecision) {\n  var precisionOptions = {\n    matcher: null,\n    units: {},\n  };\n  var optimizable = [];\n  var unit;\n  var value;\n\n  for (unit in roundingPrecision) {\n    value = roundingPrecision[unit];\n\n    if (value != DEFAULT_ROUNDING_PRECISION) {\n      precisionOptions.units[unit] = {};\n      precisionOptions.units[unit].value = value;\n      precisionOptions.units[unit].multiplier = Math.pow(10, value);\n\n      optimizable.push(unit);\n    }\n  }\n\n  if (optimizable.length > 0) {\n    precisionOptions.enabled = true;\n    precisionOptions.decimalPointMatcher = new RegExp('(\\\\d)\\\\.($|' + optimizable.join('|') + ')($|\\\\W)', 'g');\n    precisionOptions.zeroMatcher = new RegExp('(\\\\d*)(\\\\.\\\\d+)(' + optimizable.join('|') + ')', 'g');\n  }\n\n  return precisionOptions;\n}\n\nfunction level1Optimize(tokens, context) {\n  var options = context.options;\n  var levelOptions = options.level[OptimizationLevel.One];\n  var ie7Hack = options.compatibility.selectors.ie7Hack;\n  var adjacentSpace = options.compatibility.selectors.adjacentSpace;\n  var spaceAfterClosingBrace = options.compatibility.properties.spaceAfterClosingBrace;\n  var format = options.format;\n  var mayHaveCharset = false;\n  var afterRules = false;\n\n  options.unitsRegexp = options.unitsRegexp || buildUnitRegexp(options);\n  options.precision = options.precision || buildPrecisionOptions(levelOptions.roundingPrecision);\n  options.commentsKept = options.commentsKept || 0;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        token[1] = isImport(token) && afterRules ? '' : token[1];\n        token[1] = levelOptions.tidyAtRules ? tidyAtRule(token[1]) : token[1];\n        mayHaveCharset = true;\n        break;\n      case Token.AT_RULE_BLOCK:\n        optimizeBody(token[1], token[2], context);\n        afterRules = true;\n        break;\n      case Token.NESTED_BLOCK:\n        token[1] = levelOptions.tidyBlockScopes ? tidyBlock(token[1], spaceAfterClosingBrace) : token[1];\n        level1Optimize(token[2], context);\n        afterRules = true;\n        break;\n      case Token.COMMENT:\n        optimizeComment(token, options);\n        break;\n      case Token.RULE:\n        token[1] = levelOptions.tidySelectors ? tidyRules(token[1], !ie7Hack, adjacentSpace, format, context.warnings) : token[1];\n        token[1] = token[1].length > 1 ? sortSelectors(token[1], levelOptions.selectorsSortingMethod) : token[1];\n        optimizeBody(token[1], token[2], context);\n        afterRules = true;\n        break;\n    }\n\n    if (token[0] == Token.COMMENT && token[1].length === 0 || levelOptions.removeEmpty && (token[1].length === 0 || (token[2] && token[2].length === 0))) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    }\n  }\n\n  if (levelOptions.cleanupCharsets && mayHaveCharset) {\n    cleanupCharsets(tokens);\n  }\n\n  return tokens;\n}\n\nmodule.exports = level1Optimize;\n","module.exports = {\n  background: require('./property-optimizers/background').level1.property,\n  boxShadow: require('./property-optimizers/box-shadow').level1.property,\n  borderRadius: require('./property-optimizers/border-radius').level1.property,\n  filter: require('./property-optimizers/filter').level1.property,\n  fontWeight: require('./property-optimizers/font-weight').level1.property,\n  margin: require('./property-optimizers/margin').level1.property,\n  outline: require('./property-optimizers/outline').level1.property,\n  padding: require('./property-optimizers/padding').level1.property\n};\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar plugin = {\n  level1: {\n    property: function background(_rule, property, options) {\n      var values = property.value;\n\n      if (!options.level[OptimizationLevel.One].optimizeBackground) {\n        return;\n      }\n\n      if (values.length == 1 && values[0][1] == 'none') {\n        values[0][1] = '0 0';\n      }\n\n      if (values.length == 1 && values[0][1] == 'transparent') {\n        values[0][1] = '0 0';\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar plugin = {\n  level1: {\n    property: function borderRadius(_rule, property, options) {\n      var values = property.value;\n\n      if (!options.level[OptimizationLevel.One].optimizeBorderRadius) {\n        return;\n      }\n\n      if (values.length == 3 && values[1][1] == '/' && values[0][1] == values[2][1]) {\n        property.value.splice(1);\n        property.dirty = true;\n      } else if (values.length == 5 && values[2][1] == '/' && values[0][1] == values[3][1] && values[1][1] == values[4][1]) {\n        property.value.splice(2);\n        property.dirty = true;\n      } else if (values.length == 7 && values[3][1] == '/' && values[0][1] == values[4][1] && values[1][1] == values[5][1] && values[2][1] == values[6][1]) {\n        property.value.splice(3);\n        property.dirty = true;\n      } else if (values.length == 9 && values[4][1] == '/' && values[0][1] == values[5][1] && values[1][1] == values[6][1] && values[2][1] == values[7][1] && values[3][1] == values[8][1]) {\n        property.value.splice(4);\n        property.dirty = true;\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var plugin = {\n  level1: {\n    property: function boxShadow(_rule, property) {\n      var values = property.value;\n\n      // remove multiple zeros\n      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {\n        property.value.splice(2);\n        property.dirty = true;\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar ALPHA_OR_CHROMA_FILTER_PATTERN = /progid:DXImageTransform\\.Microsoft\\.(Alpha|Chroma)(\\W)/;\nvar NO_SPACE_AFTER_COMMA_PATTERN = /,(\\S)/g;\nvar WHITESPACE_AROUND_EQUALS_PATTERN = / ?= ?/g;\n\nvar plugin = {\n  level1: {\n    property: function filter(_rule, property, options) {\n      if (!options.compatibility.properties.ieFilters) {\n        return;\n      }\n\n      if (!options.level[OptimizationLevel.One].optimizeFilter) {\n        return;\n      }\n\n      if (property.value.length == 1) {\n        property.value[0][1] = property.value[0][1].replace(ALPHA_OR_CHROMA_FILTER_PATTERN, function (match, filter, suffix) {\n          return filter.toLowerCase() + suffix;\n        });\n      }\n\n      property.value[0][1] = property.value[0][1]\n        .replace(NO_SPACE_AFTER_COMMA_PATTERN, ', $1')\n        .replace(WHITESPACE_AROUND_EQUALS_PATTERN, '=');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar plugin = {\n  level1: {\n    property: function fontWeight(_rule, property, options) {\n      var value = property.value[0][1];\n\n      if (!options.level[OptimizationLevel.One].optimizeFontWeight) {\n        return;\n      }\n\n      if (value == 'normal') {\n        value = '400';\n      } else if (value == 'bold') {\n        value = '700';\n      }\n\n      property.value[0][1] = value;\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar plugin = {\n  level1: {\n    property: function margin(_rule, property, options) {\n      var values = property.value;\n\n      if (!options.level[OptimizationLevel.One].replaceMultipleZeros) {\n        return;\n      }\n\n      // remove multiple zeros\n      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {\n        property.value.splice(1);\n        property.dirty = true;\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar plugin = {\n  level1: {\n    property: function outline(_rule, property, options) {\n      var values = property.value;\n\n      if (!options.level[OptimizationLevel.One].optimizeOutline) {\n        return;\n      }\n\n      if (values.length == 1 && values[0][1] == 'none') {\n        values[0][1] = '0';\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nfunction isNegative(value) {\n  return value && value[1][0] == '-' && parseFloat(value[1]) < 0;\n}\n\nvar plugin = {\n  level1: {\n    property: function padding(_rule, property, options) {\n      var values = property.value;\n\n      // remove multiple zeros\n      if (values.length == 4 && values[0][1] === '0' && values[1][1] === '0' && values[2][1] === '0' && values[3][1] === '0') {\n        property.value.splice(1);\n        property.dirty = true;\n      }\n\n      // remove negative paddings\n      if (options.level[OptimizationLevel.One].removeNegativePaddings && (isNegative(property.value[0]) || isNegative(property.value[1]) || isNegative(property.value[2]) || isNegative(property.value[3]))) {\n        property.unused = true;\n      }\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var naturalCompare = require('../../utils/natural-compare');\n\nfunction naturalSorter(scope1, scope2) {\n  return naturalCompare(scope1[1], scope2[1]);\n}\n\nfunction standardSorter(scope1, scope2) {\n  return scope1[1] > scope2[1] ? 1 : -1;\n}\n\nfunction sortSelectors(selectors, method) {\n  switch (method) {\n    case 'natural':\n      return selectors.sort(naturalSorter);\n    case 'standard':\n      return selectors.sort(standardSorter);\n    case 'none':\n    case false:\n      return selectors;\n  }\n}\n\nmodule.exports = sortSelectors;\n","function tidyAtRule(value) {\n  return value\n    .replace(/\\s+/g, ' ')\n    .replace(/url\\(\\s+/g, 'url(')\n    .replace(/\\s+\\)/g, ')')\n    .trim();\n}\n\nmodule.exports = tidyAtRule;\n","var SUPPORTED_COMPACT_BLOCK_MATCHER = /^@media\\W/;\nvar SUPPORTED_QUOTE_REMOVAL_MATCHER = /^@(?:keyframes|-moz-keyframes|-o-keyframes|-webkit-keyframes)\\W/;\n\nfunction tidyBlock(values, spaceAfterClosingBrace) {\n  var withoutSpaceAfterClosingBrace;\n  var withoutQuotes;\n  var i;\n\n  for (i = values.length - 1; i >= 0; i--) {\n    withoutSpaceAfterClosingBrace = !spaceAfterClosingBrace && SUPPORTED_COMPACT_BLOCK_MATCHER.test(values[i][1]);\n    withoutQuotes = SUPPORTED_QUOTE_REMOVAL_MATCHER.test(values[i][1]);\n\n    values[i][1] = values[i][1]\n      .replace(/\\n|\\r\\n/g, ' ')\n      .replace(/\\s+/g, ' ')\n      .replace(/(,|:|\\() /g, '$1')\n      .replace(/ \\)/g, ')');\n\n    if (withoutQuotes) {\n      values[i][1] = values[i][1]\n        .replace(/'([a-zA-Z][a-zA-Z\\d\\-_]+)'/, '$1')\n        .replace(/\"([a-zA-Z][a-zA-Z\\d\\-_]+)\"/, '$1');\n    }\n\n    if (withoutSpaceAfterClosingBrace) {\n      values[i][1] = values[i][1]\n        .replace(/\\) /g, ')');\n    }\n  }\n\n  return values;\n}\n\nmodule.exports = tidyBlock;\n","var Spaces = require('../../options/format').Spaces;\nvar Marker = require('../../tokenizer/marker');\nvar formatPosition = require('../../utils/format-position');\n\nvar CASE_ATTRIBUTE_PATTERN = /[\\s\"'][iI]\\s*\\]/;\nvar CASE_RESTORE_PATTERN = /([\\d\\w])([iI])\\]/g;\nvar DOUBLE_QUOTE_CASE_PATTERN = /=\"([a-zA-Z][a-zA-Z\\d\\-_]+)\"([iI])/g;\nvar DOUBLE_QUOTE_PATTERN = /=\"([a-zA-Z][a-zA-Z\\d\\-_]+)\"(\\s|\\])/g;\nvar HTML_COMMENT_PATTERN = /^(?:(?:<!--|-->)\\s*)+/;\nvar SINGLE_QUOTE_CASE_PATTERN = /='([a-zA-Z][a-zA-Z\\d\\-_]+)'([iI])/g;\nvar SINGLE_QUOTE_PATTERN = /='([a-zA-Z][a-zA-Z\\d\\-_]+)'(\\s|\\])/g;\nvar RELATION_PATTERN = /[>\\+~]/;\nvar WHITESPACE_PATTERN = /\\s/;\n\nvar ASTERISK_PLUS_HTML_HACK = '*+html ';\nvar ASTERISK_FIRST_CHILD_PLUS_HTML_HACK = '*:first-child+html ';\nvar LESS_THAN = '<';\n\nvar PSEUDO_CLASSES_WITH_SELECTORS = [\n  ':current',\n  ':future',\n  ':has',\n  ':host',\n  ':host-context',\n  ':is',\n  ':not',\n  ':past',\n  ':where'\n];\n\nfunction hasInvalidCharacters(value) {\n  var isEscaped;\n  var isInvalid = false;\n  var character;\n  var isQuote = false;\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    if (isEscaped) {\n      // continue as always\n    } else if (character == Marker.SINGLE_QUOTE || character == Marker.DOUBLE_QUOTE) {\n      isQuote = !isQuote;\n    } else if (!isQuote && (character == Marker.CLOSE_CURLY_BRACKET || character == Marker.EXCLAMATION || character == LESS_THAN || character == Marker.SEMICOLON)) {\n      isInvalid = true;\n      break;\n    } else if (!isQuote && i === 0 && RELATION_PATTERN.test(character)) {\n      isInvalid = true;\n      break;\n    }\n\n    isEscaped = character == Marker.BACK_SLASH;\n  }\n\n  return isInvalid;\n}\n\nfunction removeWhitespace(value, format) {\n  var stripped = [];\n  var character;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isEscaped;\n  var wasEscaped;\n  var isQuoted;\n  var isSingleQuoted;\n  var isDoubleQuoted;\n  var isAttribute;\n  var isRelation;\n  var isWhitespace;\n  var isSpaceAwarePseudoClass;\n  var roundBracketLevel = 0;\n  var wasComma = false;\n  var wasRelation = false;\n  var wasWhitespace = false;\n  var withCaseAttribute = CASE_ATTRIBUTE_PATTERN.test(value);\n  var spaceAroundRelation = format && format.spaces[Spaces.AroundSelectorRelation];\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && value[i - 1] == Marker.CARRIAGE_RETURN;\n    isQuoted = isSingleQuoted || isDoubleQuoted;\n    isRelation = !isAttribute && !isEscaped && roundBracketLevel === 0 && RELATION_PATTERN.test(character);\n    isWhitespace = WHITESPACE_PATTERN.test(character);\n    isSpaceAwarePseudoClass = roundBracketLevel == 1 && character == Marker.CLOSE_ROUND_BRACKET ?\n      false :\n      isSpaceAwarePseudoClass || (roundBracketLevel === 0 && character == Marker.COLON && isPseudoClassWithSelectors(value, i));\n\n    if (wasEscaped && isQuoted && isNewLineWin) {\n      // swallow escaped new windows lines in comments\n      stripped.pop();\n      stripped.pop();\n    } else if (isEscaped && isQuoted && isNewLineNix) {\n      // swallow escaped new *nix lines in comments\n      stripped.pop();\n    } else if (isEscaped) {\n      stripped.push(character);\n    } else if (character == Marker.OPEN_SQUARE_BRACKET && !isQuoted) {\n      stripped.push(character);\n      isAttribute = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && !isQuoted) {\n      stripped.push(character);\n      isAttribute = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted) {\n      stripped.push(character);\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted) {\n      stripped.push(character);\n      roundBracketLevel--;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      stripped.push(character);\n      isSingleQuoted = true;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      stripped.push(character);\n      isDoubleQuoted = true;\n    } else if (character == Marker.SINGLE_QUOTE && isQuoted) {\n      stripped.push(character);\n      isSingleQuoted = false;\n    } else if (character == Marker.DOUBLE_QUOTE && isQuoted) {\n      stripped.push(character);\n      isDoubleQuoted = false;\n    } else if (isWhitespace && wasRelation && !spaceAroundRelation) {\n      continue;\n    } else if (!isWhitespace && wasRelation && spaceAroundRelation) {\n      stripped.push(Marker.SPACE);\n      stripped.push(character);\n    } else if (isWhitespace && !wasWhitespace && wasComma && roundBracketLevel > 0 && isSpaceAwarePseudoClass) {\n      // skip space\n    } else if (isWhitespace && !wasWhitespace && roundBracketLevel > 0 && isSpaceAwarePseudoClass) {\n      stripped.push(character);\n    } else if (isWhitespace && (isAttribute || roundBracketLevel > 0) && !isQuoted) {\n      // skip space\n    } else if (isWhitespace && wasWhitespace && !isQuoted) {\n      // skip extra space\n    } else if ((isNewLineWin || isNewLineNix) && (isAttribute || roundBracketLevel > 0) && isQuoted) {\n      // skip newline\n    } else if (isRelation && wasWhitespace && !spaceAroundRelation) {\n      stripped.pop();\n      stripped.push(character);\n    } else if (isRelation && !wasWhitespace && spaceAroundRelation) {\n      stripped.push(Marker.SPACE);\n      stripped.push(character);\n    } else if (isWhitespace) {\n      stripped.push(Marker.SPACE);\n    } else {\n      stripped.push(character);\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = character == Marker.BACK_SLASH;\n    wasRelation = isRelation;\n    wasWhitespace = isWhitespace;\n    wasComma = character == Marker.COMMA;\n  }\n\n  return withCaseAttribute ?\n    stripped.join('').replace(CASE_RESTORE_PATTERN, '$1 $2]') :\n    stripped.join('');\n}\n\nfunction isPseudoClassWithSelectors(value, colonPosition) {\n  var pseudoClass = value.substring(colonPosition, value.indexOf(Marker.OPEN_ROUND_BRACKET, colonPosition));\n\n  return PSEUDO_CLASSES_WITH_SELECTORS.indexOf(pseudoClass) > -1;\n}\n\nfunction removeQuotes(value) {\n  if (value.indexOf('\\'') == -1 && value.indexOf('\"') == -1) {\n    return value;\n  }\n\n  return value\n    .replace(SINGLE_QUOTE_CASE_PATTERN, '=$1 $2')\n    .replace(SINGLE_QUOTE_PATTERN, '=$1$2')\n    .replace(DOUBLE_QUOTE_CASE_PATTERN, '=$1 $2')\n    .replace(DOUBLE_QUOTE_PATTERN, '=$1$2');\n}\n\nfunction tidyRules(rules, removeUnsupported, adjacentSpace, format, warnings) {\n  var list = [];\n  var repeated = [];\n\n  function removeHTMLComment(rule, match) {\n    warnings.push('HTML comment \\'' + match + '\\' at ' + formatPosition(rule[2][0]) + '. Removing.');\n    return '';\n  }\n\n  for (var i = 0, l = rules.length; i < l; i++) {\n    var rule = rules[i];\n    var reduced = rule[1];\n\n    reduced = reduced.replace(HTML_COMMENT_PATTERN, removeHTMLComment.bind(null, rule));\n\n    if (hasInvalidCharacters(reduced)) {\n      warnings.push('Invalid selector \\'' + rule[1] + '\\' at ' + formatPosition(rule[2][0]) + '. Ignoring.');\n      continue;\n    }\n\n    reduced = removeWhitespace(reduced, format);\n    reduced = removeQuotes(reduced);\n\n    if (adjacentSpace && reduced.indexOf('nav') > 0) {\n      reduced = reduced.replace(/\\+nav(\\S|$)/, '+ nav$1');\n    }\n\n    if (removeUnsupported && reduced.indexOf(ASTERISK_PLUS_HTML_HACK) > -1) {\n      continue;\n    }\n\n    if (removeUnsupported && reduced.indexOf(ASTERISK_FIRST_CHILD_PLUS_HTML_HACK) > -1) {\n      continue;\n    }\n\n    if (reduced.indexOf('*') > -1) {\n      reduced = reduced\n        .replace(/\\*([:#\\.\\[])/g, '$1')\n        .replace(/^(\\:first\\-child)?\\+html/, '*$1+html');\n    }\n\n    if (repeated.indexOf(reduced) > -1) {\n      continue;\n    }\n\n    rule[1] = reduced;\n    repeated.push(reduced);\n    list.push(rule);\n  }\n\n  if (list.length == 1 && list[0][1].length === 0) {\n    warnings.push('Empty selector \\'' + list[0][1] + '\\' at ' + formatPosition(list[0][2][0]) + '. Ignoring.');\n    list = [];\n  }\n\n  return list;\n}\n\nmodule.exports = tidyRules;\n","module.exports = {\n  color: require('./value-optimizers/color').level1.value,\n  degrees: require('./value-optimizers/degrees').level1.value,\n  fraction: require('./value-optimizers/fraction').level1.value,\n  precision: require('./value-optimizers/precision').level1.value,\n  textQuotes: require('./value-optimizers/text-quotes').level1.value,\n  time: require('./value-optimizers/time').level1.value,\n  unit: require('./value-optimizers/unit').level1.value,\n  urlPrefix: require('./value-optimizers/url-prefix').level1.value,\n  urlQuotes: require('./value-optimizers/url-quotes').level1.value,\n  urlWhiteSpace: require('./value-optimizers/url-whitespace').level1.value,\n  whiteSpace: require('./value-optimizers/whitespace').level1.value,\n  zero: require('./value-optimizers/zero').level1.value\n};\n","var shortenHex = require('./color/shorten-hex');\nvar shortenHsl = require('./color/shorten-hsl');\nvar shortenRgb = require('./color/shorten-rgb');\n\nvar split = require('../../../utils/split');\n\nvar ANY_COLOR_FUNCTION_PATTERN = /(rgb|rgba|hsl|hsla)\\(([^\\(\\)]+)\\)/gi;\nvar COLOR_PREFIX_PATTERN = /#|rgb|hsl/gi;\nvar HEX_LONG_PATTERN = /(^|[^='\"])#([0-9a-f]{6})/gi;\nvar HEX_SHORT_PATTERN = /(^|[^='\"])#([0-9a-f]{3})/gi;\nvar HEX_VALUE_PATTERN = /[0-9a-f]/i;\nvar HSL_PATTERN = /hsl\\((-?\\d+),(-?\\d+)%?,(-?\\d+)%?\\)/gi;\nvar RGBA_HSLA_PATTERN = /(rgb|hsl)a?\\((\\-?\\d+),(\\-?\\d+\\%?),(\\-?\\d+\\%?),(0*[1-9]+[0-9]*(\\.?\\d*)?)\\)/gi;\nvar RGB_PATTERN = /rgb\\((\\-?\\d+),(\\-?\\d+),(\\-?\\d+)\\)/gi;\nvar TRANSPARENT_FUNCTION_PATTERN = /(?:rgba|hsla)\\(0,0%?,0%?,0\\)/g;\n\nvar plugin = {\n  level1: {\n    value: function color(name, value, options) {\n      if (!options.compatibility.properties.colors) {\n        return value;\n      }\n\n      if (!value.match(COLOR_PREFIX_PATTERN)) {\n        return shortenHex(value);\n      }\n\n      value = value\n        .replace(RGBA_HSLA_PATTERN, function (match, colorFn, p1, p2, p3, alpha) {\n          return (parseInt(alpha, 10) >= 1 ? colorFn + '(' + [p1,p2,p3].join(',') + ')' : match);\n        })\n        .replace(RGB_PATTERN, function (match, red, green, blue) {\n          return shortenRgb(red, green, blue);\n        })\n        .replace(HSL_PATTERN, function (match, hue, saturation, lightness) {\n          return shortenHsl(hue, saturation, lightness);\n        })\n        .replace(HEX_LONG_PATTERN, function (match, prefix, color, at, inputValue) {\n          var suffix = inputValue[at + match.length];\n\n          if (suffix && HEX_VALUE_PATTERN.test(suffix)) {\n            return match;\n          } else if (color[0] == color[1] && color[2] == color[3] && color[4] == color[5]) {\n            return (prefix + '#' + color[0] + color[2] + color[4]).toLowerCase();\n          } else {\n            return (prefix + '#' + color).toLowerCase();\n          }\n        })\n        .replace(HEX_SHORT_PATTERN, function (match, prefix, color) {\n          return prefix + '#' + color.toLowerCase();\n        })\n        .replace(ANY_COLOR_FUNCTION_PATTERN, function (match, colorFunction, colorDef) {\n          var tokens = colorDef.split(',');\n          var colorFnLowercase = colorFunction && colorFunction.toLowerCase();\n          var applies = (colorFnLowercase == 'hsl' && tokens.length == 3) ||\n            (colorFnLowercase == 'hsla' && tokens.length == 4) ||\n            (colorFnLowercase == 'rgb' && tokens.length === 3 && colorDef.indexOf('%') > 0) ||\n            (colorFnLowercase == 'rgba' && tokens.length == 4 && colorDef.indexOf('%') > 0);\n\n          if (!applies) {\n            return match;\n          }\n\n          if (tokens[1].indexOf('%') == -1) {\n            tokens[1] += '%';\n          }\n\n          if (tokens[2].indexOf('%') == -1) {\n            tokens[2] += '%';\n          }\n\n          return colorFunction + '(' + tokens.join(',') + ')';\n        });\n\n      if (options.compatibility.colors.opacity && name.indexOf('background') == -1) {\n        value = value.replace(TRANSPARENT_FUNCTION_PATTERN, function (match) {\n          if (split(value, ',').pop().indexOf('gradient(') > -1) {\n            return match;\n          }\n\n          return 'transparent';\n        });\n      }\n\n      return shortenHex(value);\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var COLORS = {\n  aliceblue: '#f0f8ff',\n  antiquewhite: '#faebd7',\n  aqua: '#0ff',\n  aquamarine: '#7fffd4',\n  azure: '#f0ffff',\n  beige: '#f5f5dc',\n  bisque: '#ffe4c4',\n  black: '#000',\n  blanchedalmond: '#ffebcd',\n  blue: '#00f',\n  blueviolet: '#8a2be2',\n  brown: '#a52a2a',\n  burlywood: '#deb887',\n  cadetblue: '#5f9ea0',\n  chartreuse: '#7fff00',\n  chocolate: '#d2691e',\n  coral: '#ff7f50',\n  cornflowerblue: '#6495ed',\n  cornsilk: '#fff8dc',\n  crimson: '#dc143c',\n  cyan: '#0ff',\n  darkblue: '#00008b',\n  darkcyan: '#008b8b',\n  darkgoldenrod: '#b8860b',\n  darkgray: '#a9a9a9',\n  darkgreen: '#006400',\n  darkgrey: '#a9a9a9',\n  darkkhaki: '#bdb76b',\n  darkmagenta: '#8b008b',\n  darkolivegreen: '#556b2f',\n  darkorange: '#ff8c00',\n  darkorchid: '#9932cc',\n  darkred: '#8b0000',\n  darksalmon: '#e9967a',\n  darkseagreen: '#8fbc8f',\n  darkslateblue: '#483d8b',\n  darkslategray: '#2f4f4f',\n  darkslategrey: '#2f4f4f',\n  darkturquoise: '#00ced1',\n  darkviolet: '#9400d3',\n  deeppink: '#ff1493',\n  deepskyblue: '#00bfff',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1e90ff',\n  firebrick: '#b22222',\n  floralwhite: '#fffaf0',\n  forestgreen: '#228b22',\n  fuchsia: '#f0f',\n  gainsboro: '#dcdcdc',\n  ghostwhite: '#f8f8ff',\n  gold: '#ffd700',\n  goldenrod: '#daa520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#adff2f',\n  grey: '#808080',\n  honeydew: '#f0fff0',\n  hotpink: '#ff69b4',\n  indianred: '#cd5c5c',\n  indigo: '#4b0082',\n  ivory: '#fffff0',\n  khaki: '#f0e68c',\n  lavender: '#e6e6fa',\n  lavenderblush: '#fff0f5',\n  lawngreen: '#7cfc00',\n  lemonchiffon: '#fffacd',\n  lightblue: '#add8e6',\n  lightcoral: '#f08080',\n  lightcyan: '#e0ffff',\n  lightgoldenrodyellow: '#fafad2',\n  lightgray: '#d3d3d3',\n  lightgreen: '#90ee90',\n  lightgrey: '#d3d3d3',\n  lightpink: '#ffb6c1',\n  lightsalmon: '#ffa07a',\n  lightseagreen: '#20b2aa',\n  lightskyblue: '#87cefa',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#b0c4de',\n  lightyellow: '#ffffe0',\n  lime: '#0f0',\n  limegreen: '#32cd32',\n  linen: '#faf0e6',\n  magenta: '#ff00ff',\n  maroon: '#800000',\n  mediumaquamarine: '#66cdaa',\n  mediumblue: '#0000cd',\n  mediumorchid: '#ba55d3',\n  mediumpurple: '#9370db',\n  mediumseagreen: '#3cb371',\n  mediumslateblue: '#7b68ee',\n  mediumspringgreen: '#00fa9a',\n  mediumturquoise: '#48d1cc',\n  mediumvioletred: '#c71585',\n  midnightblue: '#191970',\n  mintcream: '#f5fffa',\n  mistyrose: '#ffe4e1',\n  moccasin: '#ffe4b5',\n  navajowhite: '#ffdead',\n  navy: '#000080',\n  oldlace: '#fdf5e6',\n  olive: '#808000',\n  olivedrab: '#6b8e23',\n  orange: '#ffa500',\n  orangered: '#ff4500',\n  orchid: '#da70d6',\n  palegoldenrod: '#eee8aa',\n  palegreen: '#98fb98',\n  paleturquoise: '#afeeee',\n  palevioletred: '#db7093',\n  papayawhip: '#ffefd5',\n  peachpuff: '#ffdab9',\n  peru: '#cd853f',\n  pink: '#ffc0cb',\n  plum: '#dda0dd',\n  powderblue: '#b0e0e6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#f00',\n  rosybrown: '#bc8f8f',\n  royalblue: '#4169e1',\n  saddlebrown: '#8b4513',\n  salmon: '#fa8072',\n  sandybrown: '#f4a460',\n  seagreen: '#2e8b57',\n  seashell: '#fff5ee',\n  sienna: '#a0522d',\n  silver: '#c0c0c0',\n  skyblue: '#87ceeb',\n  slateblue: '#6a5acd',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#fffafa',\n  springgreen: '#00ff7f',\n  steelblue: '#4682b4',\n  tan: '#d2b48c',\n  teal: '#008080',\n  thistle: '#d8bfd8',\n  tomato: '#ff6347',\n  turquoise: '#40e0d0',\n  violet: '#ee82ee',\n  wheat: '#f5deb3',\n  white: '#fff',\n  whitesmoke: '#f5f5f5',\n  yellow: '#ff0',\n  yellowgreen: '#9acd32'\n};\n\nvar toHex = {};\nvar toName = {};\n\nfor (var name in COLORS) {\n  var hex = COLORS[name];\n\n  if (name.length < hex.length) {\n    toName[hex] = name;\n  } else {\n    toHex[name] = hex;\n  }\n}\n\nvar toHexPattern = new RegExp('(^| |,|\\\\))(' + Object.keys(toHex).join('|') + ')( |,|\\\\)|$)', 'ig');\nvar toNamePattern = new RegExp('(' + Object.keys(toName).join('|') + ')([^a-f0-9]|$)', 'ig');\n\nfunction hexConverter(match, prefix, colorValue, suffix) {\n  return prefix + toHex[colorValue.toLowerCase()] + suffix;\n}\n\nfunction nameConverter(match, colorValue, suffix) {\n  return toName[colorValue.toLowerCase()] + suffix;\n}\n\nfunction shortenHex(value) {\n  var hasHex = value.indexOf('#') > -1;\n  var shortened = value.replace(toHexPattern, hexConverter);\n\n  if (shortened != value) {\n    shortened = shortened.replace(toHexPattern, hexConverter);\n  }\n\n  return hasHex ?\n    shortened.replace(toNamePattern, nameConverter) :\n    shortened;\n}\n\nmodule.exports = shortenHex;\n","// HSL to RGB converter. Both methods adapted from:\n// http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript\n\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n\n  // normalize hue orientation b/w 0 and 360 degrees\n  h = h % 360;\n  if (h < 0)\n    h += 360;\n  h = ~~h / 360;\n\n  if (s < 0)\n    s = 0;\n  else if (s > 100)\n    s = 100;\n  s = ~~s / 100;\n\n  if (l < 0)\n    l = 0;\n  else if (l > 100)\n    l = 100;\n  l = ~~l / 100;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ?\n      l * (1 + s) :\n      l + s - l * s;\n    var p = 2 * l - q;\n    r = hueToRgb(p, q, h + 1/3);\n    g = hueToRgb(p, q, h);\n    b = hueToRgb(p, q, h - 1/3);\n  }\n\n  return [~~(r * 255), ~~(g * 255), ~~(b * 255)];\n}\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1/6) return p + (q - p) * 6 * t;\n  if (t < 1/2) return q;\n  if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;\n  return p;\n}\n\nfunction shortenHsl(hue, saturation, lightness) {\n  var asRgb = hslToRgb(hue, saturation, lightness);\n  var redAsHex = asRgb[0].toString(16);\n  var greenAsHex = asRgb[1].toString(16);\n  var blueAsHex = asRgb[2].toString(16);\n\n  return '#' +\n    ((redAsHex.length == 1 ? '0' : '') + redAsHex) +\n    ((greenAsHex.length == 1 ? '0' : '') + greenAsHex) +\n    ((blueAsHex.length == 1 ? '0' : '') + blueAsHex);\n}\n\nmodule.exports = shortenHsl;\n","function shortenRgb(red, green, blue) {\n  var normalizedRed = Math.max(0, Math.min(parseInt(red), 255));\n  var normalizedGreen = Math.max(0, Math.min(parseInt(green), 255));\n  var normalizedBlue = Math.max(0, Math.min(parseInt(blue), 255));\n\n  // Credit: Asen  http://jsbin.com/UPUmaGOc/2/edit?js,console\n  return '#' + ('00000' + (normalizedRed << 16 | normalizedGreen << 8 | normalizedBlue).toString(16)).slice(-6);\n}\n\nmodule.exports = shortenRgb;\n","var ZERO_DEG_PATTERN = /\\(0deg\\)/g;\n\nvar plugin = {\n  level1: {\n    value: function degrees(_name, value, options) {\n      if (!options.compatibility.properties.zeroUnits) {\n        return value;\n      }\n\n      if (value.indexOf('0deg') == -1) {\n        return value;\n      }\n\n      return value.replace(ZERO_DEG_PATTERN, '(0)');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var startsAsUrl = require('./starts-as-url');\n\nvar OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar DOT_ZERO_PATTERN = /(^|\\D)\\.0+(\\D|$)/g;\nvar FRACTION_PATTERN = /\\.([1-9]*)0+(\\D|$)/g;\nvar LEADING_ZERO_FRACTION_PATTERN = /(^|\\D)0\\.(\\d)/g;\nvar MINUS_ZERO_FRACTION_PATTERN = /([^\\w\\d\\-]|^)\\-0([^\\.]|$)/g;\nvar ZERO_PREFIXED_UNIT_PATTERN = /(^|\\s)0+([1-9])/g;\n\nvar plugin = {\n  level1: {\n    value: function fraction(name, value, options) {\n      if (!options.level[OptimizationLevel.One].replaceZeroUnits) {\n        return value;\n      }\n\n      if (startsAsUrl(value)) {\n        return value;\n      }\n\n      if (value.indexOf('0') == -1) {\n        return value;\n      }\n\n      if (value.indexOf('-') > -1) {\n        value = value\n          .replace(MINUS_ZERO_FRACTION_PATTERN, '$10$2')\n          .replace(MINUS_ZERO_FRACTION_PATTERN, '$10$2');\n      }\n\n      return value\n        .replace(ZERO_PREFIXED_UNIT_PATTERN, '$1$2')\n        .replace(DOT_ZERO_PATTERN, '$10$2')\n        .replace(FRACTION_PATTERN, function (match, nonZeroPart, suffix) {\n          return (nonZeroPart.length > 0 ? '.' : '') + nonZeroPart + suffix;\n        })\n        .replace(LEADING_ZERO_FRACTION_PATTERN, '$1.$2');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var plugin = {\n  level1: {\n    value: function precision(_name, value, options) {\n      if (!options.precision.enabled || value.indexOf('.') === -1) {\n        return value;\n      }\n\n      return value\n        .replace(options.precision.decimalPointMatcher, '$1$2$3')\n        .replace(options.precision.zeroMatcher, function (match, integerPart, fractionPart, unit) {\n          var multiplier = options.precision.units[unit].multiplier;\n          var parsedInteger = parseInt(integerPart);\n          var integer = isNaN(parsedInteger) ? 0 : parsedInteger;\n          var fraction = parseFloat(fractionPart);\n\n          return Math.round((integer + fraction) * multiplier) / multiplier + unit;\n        });\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var URL_PREFIX_PATTERN = /^url\\(/i;\n\nfunction startsAsUrl(value) {\n  return URL_PREFIX_PATTERN.test(value);\n}\n\nmodule.exports = startsAsUrl;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar LOCAL_PREFIX_PATTERN = /^local\\(/i;\nvar QUOTED_PATTERN = /^('.*'|\".*\")$/;\nvar QUOTED_BUT_SAFE_PATTERN = /^['\"][a-zA-Z][a-zA-Z\\d\\-_]+['\"]$/;\n\nvar plugin = {\n  level1: {\n    value: function textQuotes(_name, value, options) {\n      if (!options.level[OptimizationLevel.One].removeQuotes) {\n        return value;\n      }\n\n      if (!QUOTED_PATTERN.test(value) && !LOCAL_PREFIX_PATTERN.test(value)) {\n        return value;\n      }\n\n      return QUOTED_BUT_SAFE_PATTERN.test(value) ?\n        value.substring(1, value.length - 1) :\n        value;\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar TIME_VALUE = /^(\\-?[\\d\\.]+)(m?s)$/;\n\nvar plugin = {\n  level1: {\n    value: function time(name, value, options) {\n      if (!options.level[OptimizationLevel.One].replaceTimeUnits) {\n        return value;\n      }\n\n      if (!TIME_VALUE.test(value)) {\n        return value;\n      }\n\n      return value.replace(TIME_VALUE, function (match, val, unit) {\n        var newValue;\n\n        if (unit == 'ms') {\n          newValue = parseInt(val) / 1000 + 's';\n        } else if (unit == 's') {\n          newValue = parseFloat(val) * 1000 + 'ms';\n        }\n\n        return newValue.length < match.length ? newValue : match;\n      });\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var WHOLE_PIXEL_VALUE = /(?:^|\\s|\\()(-?\\d+)px/;\n\nvar plugin = {\n  level1: {\n    value: function unit(_name, value, options) {\n      if (!WHOLE_PIXEL_VALUE.test(value)) {\n        return value;\n      }\n\n      return value.replace(WHOLE_PIXEL_VALUE, function (match, val) {\n        var newValue;\n        var intVal = parseInt(val);\n\n        if (intVal === 0) {\n          return match;\n        }\n\n        if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.pt && intVal * 3 % 4 === 0) {\n          newValue = intVal * 3 / 4 + 'pt';\n        }\n\n        if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.pc && intVal % 16 === 0) {\n          newValue = intVal / 16 + 'pc';\n        }\n\n        if (options.compatibility.properties.shorterLengthUnits && options.compatibility.units.in && intVal % 96 === 0) {\n          newValue = intVal / 96 + 'in';\n        }\n\n        if (newValue) {\n          newValue = match.substring(0, match.indexOf(val)) + newValue;\n        }\n\n        return newValue && newValue.length < match.length ? newValue : match;\n      });\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var startsAsUrl = require('./starts-as-url');\n\nvar OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar URL_PREFIX_PATTERN = /^url\\(/i;\n\nvar plugin = {\n  level1: {\n    value: function urlPrefix(_name, value, options) {\n      if (!options.level[OptimizationLevel.One].normalizeUrls) {\n        return value;\n      }\n\n      if (!startsAsUrl(value)) {\n        return value;\n      }\n\n      return value.replace(URL_PREFIX_PATTERN, 'url(');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var QUOTED_URL_PATTERN = /^url\\(['\"].+['\"]\\)$/;\nvar QUOTED_URL_WITH_WHITESPACE_PATTERN = /^url\\(['\"].*[\\*\\s\\(\\)'\"].*['\"]\\)$/;\nvar QUOTES_PATTERN = /[\"']/g;\nvar URL_DATA_PATTERN = /^url\\(['\"]data:[^;]+;charset/;\n\nvar plugin = {\n  level1: {\n    value: function urlQuotes(_name, value, options) {\n      if (options.compatibility.properties.urlQuotes) {\n        return value;\n      }\n\n      return QUOTED_URL_PATTERN.test(value) && !QUOTED_URL_WITH_WHITESPACE_PATTERN.test(value) && !URL_DATA_PATTERN.test(value) ?\n        value.replace(QUOTES_PATTERN, '') :\n        value;\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var startsAsUrl = require('./starts-as-url');\n\nvar WHITESPACE_PATTERN = /\\\\?\\n|\\\\?\\r\\n/g;\nvar WHITESPACE_PREFIX_PATTERN = /(\\()\\s+/g;\nvar WHITESPACE_SUFFIX_PATTERN = /\\s+(\\))/g;\n\nvar plugin = {\n  level1: {\n    value: function urlWhitespace(_name, value) {\n      if (!startsAsUrl(value)) {\n        return value;\n      }\n\n      return value\n        .replace(WHITESPACE_PATTERN, '')\n        .replace(WHITESPACE_PREFIX_PATTERN, '$1')\n        .replace(WHITESPACE_SUFFIX_PATTERN, '$1');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nvar Marker = require('../../../tokenizer/marker');\n\nvar CALC_DIVISION_WHITESPACE_PATTERN = /\\) ?\\/ ?/g;\nvar COMMA_AND_SPACE_PATTERN = /, /g;\nvar LINE_BREAK_PATTERN = /\\r?\\n/g;\nvar MULTI_WHITESPACE_PATTERN = /\\s+/g;\nvar FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN = /\\s+(;?\\))/g;\nvar FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN = /(\\(;?)\\s+/g;\nvar VARIABLE_NAME_PATTERN = /^--\\S+$/;\nvar VARIABLE_VALUE_PATTERN = /^var\\(\\s*--\\S+\\s*\\)$/;\n\nvar plugin = {\n  level1: {\n    value: function whitespace(name, value, options) {\n      if (!options.level[OptimizationLevel.One].removeWhitespace) {\n        return value;\n      }\n\n      if (VARIABLE_NAME_PATTERN.test(name) && !VARIABLE_VALUE_PATTERN.test(value)) {\n        return value;\n      }\n\n      if ((value.indexOf(' ') == -1 && value.indexOf('\\n') == -1) || value.indexOf('expression') === 0) {\n        return value;\n      }\n\n      if (value.indexOf(Marker.SINGLE_QUOTE) > -1 || value.indexOf(Marker.DOUBLE_QUOTE) > -1) {\n        return value;\n      }\n\n      value = value.replace(LINE_BREAK_PATTERN, '');\n      value = value.replace(MULTI_WHITESPACE_PATTERN, ' ');\n\n      if (value.indexOf('calc') > -1) {\n        value = value.replace(CALC_DIVISION_WHITESPACE_PATTERN, ')/ ');\n      }\n\n      return value\n        .replace(FUNCTION_OPENING_BRACE_WHITESPACE_PATTERN, '$1')\n        .replace(FUNCTION_CLOSING_BRACE_WHITESPACE_PATTERN, '$1')\n        .replace(COMMA_AND_SPACE_PATTERN, ',');\n    }\n  }\n};\n\nmodule.exports = plugin;\n","var split = require('../../../utils/split');\n\nvar ANY_FUNCTION_PATTERN = /^(\\-(?:moz|ms|o|webkit)\\-[a-z\\-]+|[a-z\\-]+)\\((.+)\\)$/;\nvar SKIP_FUNCTION_PATTERN = /^(?:\\-moz\\-calc|\\-webkit\\-calc|calc|rgb|hsl|rgba|hsla|min|max|clamp|expression)\\(/;\nvar TOKEN_SEPARATOR_PATTERN = /([\\s,\\/])/;\n\nfunction removeRecursively(value, options) {\n  var functionTokens;\n  var tokens;\n\n  if (SKIP_FUNCTION_PATTERN.test(value)) {\n    return value;\n  }\n\n  functionTokens = ANY_FUNCTION_PATTERN.exec(value);\n\n  if (!functionTokens) {\n    return removeZeros(value, options);\n  }\n\n  tokens = split(functionTokens[2], TOKEN_SEPARATOR_PATTERN)\n    .map(function (token) { return removeRecursively(token, options); });\n\n  return functionTokens[1] + '(' + tokens.join('') + ')';\n}\n\nfunction removeZeros(value, options) {\n  return value\n    .replace(options.unitsRegexp, '$1' + '0' + '$2')\n    .replace(options.unitsRegexp, '$1' + '0' + '$2');\n}\n\nvar plugin = {\n  level1: {\n    value: function zero(name, value, options) {\n      if (!options.compatibility.properties.zeroUnits) {\n        return value;\n      }\n\n      if (value.indexOf('%') > 0 && (name == 'height' || name == 'max-height' || name == 'width' || name == 'max-width')) {\n        return value;\n      }\n\n      return removeRecursively(value, options);\n    }\n  }\n};\n\nmodule.exports = plugin;\n","// This extractor is used in level 2 optimizations\n// IMPORTANT: Mind Token class and this code is not related!\n// Properties will be tokenized in one step, see #429\n\nvar Token = require('../../tokenizer/token');\nvar serializeRules = require('../../writer/one-time').rules;\nvar serializeValue = require('../../writer/one-time').value;\n\nfunction extractProperties(token) {\n  var properties = [];\n  var inSpecificSelector;\n  var property;\n  var name;\n  var value;\n  var i, l;\n\n  if (token[0] == Token.RULE) {\n    inSpecificSelector = !/[\\.\\+>~]/.test(serializeRules(token[1]));\n\n    for (i = 0, l = token[2].length; i < l; i++) {\n      property = token[2][i];\n\n      if (property[0] != Token.PROPERTY)\n        continue;\n\n      name = property[1][1];\n      if (name.length === 0)\n        continue;\n\n      value = serializeValue(property, i);\n\n      properties.push([\n        name,\n        value,\n        findNameRoot(name),\n        token[2][i],\n        name + ':' + value,\n        token[1],\n        inSpecificSelector\n      ]);\n    }\n  } else if (token[0] == Token.NESTED_BLOCK) {\n    for (i = 0, l = token[2].length; i < l; i++) {\n      properties = properties.concat(extractProperties(token[2][i]));\n    }\n  }\n\n  return properties;\n}\n\nfunction findNameRoot(name) {\n  if (name == 'list-style')\n    return name;\n  if (name.indexOf('-radius') > 0)\n    return 'border-radius';\n  if (name == 'border-collapse' || name == 'border-spacing' || name == 'border-image')\n    return name;\n  if (name.indexOf('border-') === 0 && /^border\\-\\w+\\-\\w+$/.test(name))\n    return name.match(/border\\-\\w+/)[0];\n  if (name.indexOf('border-') === 0 && /^border\\-\\w+$/.test(name))\n    return 'border';\n  if (name.indexOf('text-') === 0)\n    return name;\n  if (name == '-chrome-')\n    return name;\n\n  return name.replace(/^\\-\\w+\\-/, '').match(/([a-zA-Z]+)/)[0].toLowerCase();\n}\n\nmodule.exports = extractProperties;\n","var Marker = require('../../tokenizer/marker');\nvar split = require('../../utils/split');\n\nvar DEEP_SELECTOR_PATTERN = /\\/deep\\//;\nvar DOUBLE_COLON_PATTERN = /^::/;\nvar VENDOR_PREFIXED_PATTERN = /:(-moz-|-ms-|-o-|-webkit-)/;\n\nvar NOT_PSEUDO = ':not';\nvar PSEUDO_CLASSES_WITH_ARGUMENTS = [\n  ':dir',\n  ':lang',\n  ':not',\n  ':nth-child',\n  ':nth-last-child',\n  ':nth-last-of-type',\n  ':nth-of-type'\n];\nvar RELATION_PATTERN = /[>\\+~]/;\nvar UNMIXABLE_PSEUDO_CLASSES = [\n  ':after',\n  ':before',\n  ':first-letter',\n  ':first-line',\n  ':lang'\n];\nvar UNMIXABLE_PSEUDO_ELEMENTS = [\n  '::after',\n  '::before',\n  '::first-letter',\n  '::first-line'\n];\n\nvar Level = {\n  DOUBLE_QUOTE: 'double-quote',\n  SINGLE_QUOTE: 'single-quote',\n  ROOT: 'root'\n};\n\nfunction isMergeable(selector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {\n  var singleSelectors = split(selector, Marker.COMMA);\n  var singleSelector;\n  var i, l;\n\n  for (i = 0, l = singleSelectors.length; i < l; i++) {\n    singleSelector = singleSelectors[i];\n\n    if (singleSelector.length === 0 ||\n        isDeepSelector(singleSelector) ||\n        isVendorPrefixed(singleSelector) ||\n        (singleSelector.indexOf(Marker.COLON) > -1 && !areMergeable(singleSelector, extractPseudoFrom(singleSelector), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isDeepSelector(selector) {\n  return DEEP_SELECTOR_PATTERN.test(selector);\n}\n\nfunction isVendorPrefixed(selector) {\n  return VENDOR_PREFIXED_PATTERN.test(selector);\n}\n\nfunction extractPseudoFrom(selector) {\n  var list = [];\n  var character;\n  var buffer = [];\n  var level = Level.ROOT;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isEscaped;\n  var isPseudo = false;\n  var isRelation;\n  var wasColon = false;\n  var index;\n  var len;\n\n  for (index = 0, len = selector.length; index < len; index++) {\n    character = selector[index];\n\n    isRelation = !isEscaped && RELATION_PATTERN.test(character);\n    isQuoted = level == Level.DOUBLE_QUOTE || level == Level.SINGLE_QUOTE;\n\n    if (isEscaped) {\n      buffer.push(character);\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.ROOT) {\n      buffer.push(character);\n      level = Level.DOUBLE_QUOTE;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      buffer.push(character);\n      level = Level.ROOT;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.ROOT) {\n      buffer.push(character);\n      level = Level.SINGLE_QUOTE;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      buffer.push(character);\n      level = Level.ROOT;\n    } else if (isQuoted) {\n      buffer.push(character);\n    } else if (character == Marker.OPEN_ROUND_BRACKET) {\n      buffer.push(character);\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1 && isPseudo) {\n      buffer.push(character);\n      list.push(buffer.join(''));\n      roundBracketLevel--;\n      buffer = [];\n      isPseudo = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET) {\n      buffer.push(character);\n      roundBracketLevel--;\n    } else if (character == Marker.COLON && roundBracketLevel === 0 && isPseudo && !wasColon) {\n      list.push(buffer.join(''));\n      buffer = [];\n      buffer.push(character);\n    } else if (character == Marker.COLON && roundBracketLevel === 0 && !wasColon) {\n      buffer = [];\n      buffer.push(character);\n      isPseudo = true;\n    } else if (character == Marker.SPACE && roundBracketLevel === 0 && isPseudo) {\n      list.push(buffer.join(''));\n      buffer = [];\n      isPseudo = false;\n    } else if (isRelation && roundBracketLevel === 0 && isPseudo) {\n      list.push(buffer.join(''));\n      buffer = [];\n      isPseudo = false;\n    } else {\n      buffer.push(character);\n    }\n\n    isEscaped = character == Marker.BACK_SLASH;\n    wasColon = character == Marker.COLON;\n  }\n\n  if (buffer.length > 0 && isPseudo) {\n    list.push(buffer.join(''));\n  }\n\n  return list;\n}\n\nfunction areMergeable(selector, matches, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) {\n  return areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) &&\n    needArguments(matches) &&\n    (matches.length < 2 || !someIncorrectlyChained(selector, matches)) &&\n    (matches.length < 2 || multiplePseudoMerging && allMixable(matches));\n}\n\nfunction areAllowed(matches, mergeablePseudoClasses, mergeablePseudoElements) {\n  var match;\n  var name;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n    name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?\n      match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) :\n      match;\n\n    if (mergeablePseudoClasses.indexOf(name) === -1 && mergeablePseudoElements.indexOf(name) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction needArguments(matches) {\n  var match;\n  var name;\n  var bracketOpensAt;\n  var hasArguments;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n\n    bracketOpensAt = match.indexOf(Marker.OPEN_ROUND_BRACKET);\n    hasArguments = bracketOpensAt > -1;\n    name = hasArguments ?\n      match.substring(0, bracketOpensAt) :\n      match;\n\n    if (hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) == -1) {\n      return false;\n    }\n\n    if (!hasArguments && PSEUDO_CLASSES_WITH_ARGUMENTS.indexOf(name) > -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction someIncorrectlyChained(selector, matches) {\n  var positionInSelector = 0;\n  var match;\n  var matchAt;\n  var nextMatch;\n  var nextMatchAt;\n  var name;\n  var nextName;\n  var areChained;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n    nextMatch = matches[i + 1];\n\n    if (!nextMatch) {\n      break;\n    }\n\n    matchAt = selector.indexOf(match, positionInSelector);\n    nextMatchAt = selector.indexOf(match, matchAt + 1);\n    positionInSelector = nextMatchAt;\n    areChained = matchAt + match.length == nextMatchAt;\n\n    if (areChained) {\n      name = match.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?\n        match.substring(0, match.indexOf(Marker.OPEN_ROUND_BRACKET)) :\n        match;\n      nextName = nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET) > -1 ?\n        nextMatch.substring(0, nextMatch.indexOf(Marker.OPEN_ROUND_BRACKET)) :\n        nextMatch;\n\n      if (name != NOT_PSEUDO || nextName != NOT_PSEUDO) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction allMixable(matches) {\n  var unmixableMatches = 0;\n  var match;\n  var i, l;\n\n  for (i = 0, l = matches.length; i < l; i++) {\n    match = matches[i];\n\n    if (isPseudoElement(match)) {\n      unmixableMatches += UNMIXABLE_PSEUDO_ELEMENTS.indexOf(match) > -1 ? 1 : 0;\n    } else {\n      unmixableMatches += UNMIXABLE_PSEUDO_CLASSES.indexOf(match) > -1 ? 1 : 0;\n    }\n\n    if (unmixableMatches > 1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isPseudoElement(pseudo) {\n  return DOUBLE_COLON_PATTERN.test(pseudo);\n}\n\nmodule.exports = isMergeable;\n","var isMergeable = require('./is-mergeable');\n\nvar optimizeProperties = require('./properties/optimize');\n\nvar sortSelectors = require('../level-1/sort-selectors');\nvar tidyRules = require('../level-1/tidy-rules');\n\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nvar Token = require('../../tokenizer/token');\n\nfunction mergeAdjacent(tokens, context) {\n  var lastToken = [null, [], []];\n  var options = context.options;\n  var adjacentSpace = options.compatibility.selectors.adjacentSpace;\n  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var mergeLimit = options.compatibility.selectors.mergeLimit;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    if (token[0] != Token.RULE) {\n      lastToken = [null, [], []];\n      continue;\n    }\n\n    if (lastToken[0] == Token.RULE && serializeRules(token[1]) == serializeRules(lastToken[1])) {\n      Array.prototype.push.apply(lastToken[2], token[2]);\n      optimizeProperties(lastToken[2], true, true, context);\n      token[2] = [];\n    } else if (lastToken[0] == Token.RULE && serializeBody(token[2]) == serializeBody(lastToken[2]) &&\n        isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&\n        isMergeable(serializeRules(lastToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&\n        lastToken[1].length < mergeLimit) {\n      lastToken[1] = tidyRules(lastToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);\n      lastToken[1] = lastToken.length > 1 ? sortSelectors(lastToken[1], selectorsSortingMethod) : lastToken[1];\n      token[2] = [];\n    } else {\n      lastToken = token;\n    }\n  }\n}\n\nmodule.exports = mergeAdjacent;\n","var canReorder = require('./reorderable').canReorder;\nvar canReorderSingle = require('./reorderable').canReorderSingle;\nvar extractProperties = require('./extract-properties');\nvar rulesOverlap = require('./rules-overlap');\n\nvar serializeRules = require('../../writer/one-time').rules;\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\nvar Token = require('../../tokenizer/token');\n\nfunction mergeMediaQueries(tokens, context) {\n  var mergeSemantically = context.options.level[OptimizationLevel.Two].mergeSemantically;\n  var specificityCache = context.cache.specificity;\n  var candidates = {};\n  var reduced = [];\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    if (token[0] != Token.NESTED_BLOCK) {\n      continue;\n    }\n\n    var key = serializeRules(token[1]);\n    var candidate = candidates[key];\n    if (!candidate) {\n      candidate = [];\n      candidates[key] = candidate;\n    }\n\n    candidate.push(i);\n  }\n\n  for (var name in candidates) {\n    var positions = candidates[name];\n\n    positionLoop:\n    for (var j = positions.length - 1; j > 0; j--) {\n      var positionOne = positions[j];\n      var tokenOne = tokens[positionOne];\n      var positionTwo = positions[j - 1];\n      var tokenTwo = tokens[positionTwo];\n\n      directionLoop:\n      for (var direction = 1; direction >= -1; direction -= 2) {\n        var topToBottom = direction == 1;\n        var from = topToBottom ? positionOne + 1 : positionTwo - 1;\n        var to = topToBottom ? positionTwo : positionOne;\n        var delta = topToBottom ? 1 : -1;\n        var source = topToBottom ? tokenOne : tokenTwo;\n        var target = topToBottom ? tokenTwo : tokenOne;\n        var movedProperties = extractProperties(source);\n\n        while (from != to) {\n          var traversedProperties = extractProperties(tokens[from]);\n          from += delta;\n\n          if (mergeSemantically && allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache)) {\n            continue;\n          }\n\n          if (!canReorder(movedProperties, traversedProperties, specificityCache))\n            continue directionLoop;\n        }\n\n        target[2] = topToBottom ?\n          source[2].concat(target[2]) :\n          target[2].concat(source[2]);\n        source[2] = [];\n\n        reduced.push(target);\n        continue positionLoop;\n      }\n    }\n  }\n\n  return reduced;\n}\n\nfunction allSameRulePropertiesCanBeReordered(movedProperties, traversedProperties, specificityCache) {\n  var movedProperty;\n  var movedRule;\n  var traversedProperty;\n  var traversedRule;\n  var i, l;\n  var j, m;\n\n  for (i = 0, l = movedProperties.length; i < l; i++) {\n    movedProperty = movedProperties[i];\n    movedRule = movedProperty[5];\n\n    for (j = 0, m = traversedProperties.length; j < m; j++) {\n      traversedProperty = traversedProperties[j];\n      traversedRule = traversedProperty[5];\n\n      if (rulesOverlap(movedRule, traversedRule, true) && !canReorderSingle(movedProperty, traversedProperty, specificityCache)) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = mergeMediaQueries;\n","var isMergeable = require('./is-mergeable');\n\nvar sortSelectors = require('../level-1/sort-selectors');\nvar tidyRules = require('../level-1/tidy-rules');\n\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nvar Token = require('../../tokenizer/token');\n\nfunction unsafeSelector(value) {\n  return /\\.|\\*| :/.test(value);\n}\n\nfunction isBemElement(token) {\n  var asString = serializeRules(token[1]);\n  return asString.indexOf('__') > -1 || asString.indexOf('--') > -1;\n}\n\nfunction withoutModifier(selector) {\n  return selector.replace(/--[^ ,>\\+~:]+/g, '');\n}\n\nfunction removeAnyUnsafeElements(left, candidates) {\n  var leftSelector = withoutModifier(serializeRules(left[1]));\n\n  for (var body in candidates) {\n    var right = candidates[body];\n    var rightSelector = withoutModifier(serializeRules(right[1]));\n\n    if (rightSelector.indexOf(leftSelector) > -1 || leftSelector.indexOf(rightSelector) > -1)\n      delete candidates[body];\n  }\n}\n\nfunction mergeNonAdjacentByBody(tokens, context) {\n  var options = context.options;\n  var mergeSemantically = options.level[OptimizationLevel.Two].mergeSemantically;\n  var adjacentSpace = options.compatibility.selectors.adjacentSpace;\n  var selectorsSortingMethod = options.level[OptimizationLevel.One].selectorsSortingMethod;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var candidates = {};\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    if (token[0] != Token.RULE)\n      continue;\n\n    if (token[2].length > 0 && (!mergeSemantically && unsafeSelector(serializeRules(token[1]))))\n      candidates = {};\n\n    if (token[2].length > 0 && mergeSemantically && isBemElement(token))\n      removeAnyUnsafeElements(token, candidates);\n\n    var candidateBody = serializeBody(token[2]);\n    var oldToken = candidates[candidateBody];\n    if (oldToken &&\n        isMergeable(serializeRules(token[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) &&\n        isMergeable(serializeRules(oldToken[1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {\n\n      if (token[2].length > 0) {\n        token[1] = tidyRules(oldToken[1].concat(token[1]), false, adjacentSpace, false, context.warnings);\n        token[1] = token[1].length > 1 ? sortSelectors(token[1], selectorsSortingMethod) : token[1];\n      } else {\n        token[1] = oldToken[1].concat(token[1]);\n      }\n\n      oldToken[2] = [];\n      candidates[candidateBody] = null;\n    }\n\n    candidates[serializeBody(token[2])] = token;\n  }\n}\n\nmodule.exports = mergeNonAdjacentByBody;\n","var canReorder = require('./reorderable').canReorder;\nvar extractProperties = require('./extract-properties');\n\nvar optimizeProperties = require('./properties/optimize');\n\nvar serializeRules = require('../../writer/one-time').rules;\n\nvar Token = require('../../tokenizer/token');\n\nfunction mergeNonAdjacentBySelector(tokens, context) {\n  var specificityCache = context.cache.specificity;\n  var allSelectors = {};\n  var repeatedSelectors = [];\n  var i;\n\n  for (i = tokens.length - 1; i >= 0; i--) {\n    if (tokens[i][0] != Token.RULE)\n      continue;\n    if (tokens[i][2].length === 0)\n      continue;\n\n    var selector = serializeRules(tokens[i][1]);\n    allSelectors[selector] = [i].concat(allSelectors[selector] || []);\n\n    if (allSelectors[selector].length == 2)\n      repeatedSelectors.push(selector);\n  }\n\n  for (i = repeatedSelectors.length - 1; i >= 0; i--) {\n    var positions = allSelectors[repeatedSelectors[i]];\n\n    selectorIterator:\n    for (var j = positions.length - 1; j > 0; j--) {\n      var positionOne = positions[j - 1];\n      var tokenOne = tokens[positionOne];\n      var positionTwo = positions[j];\n      var tokenTwo = tokens[positionTwo];\n\n      directionIterator:\n      for (var direction = 1; direction >= -1; direction -= 2) {\n        var topToBottom = direction == 1;\n        var from = topToBottom ? positionOne + 1 : positionTwo - 1;\n        var to = topToBottom ? positionTwo : positionOne;\n        var delta = topToBottom ? 1 : -1;\n        var moved = topToBottom ? tokenOne : tokenTwo;\n        var target = topToBottom ? tokenTwo : tokenOne;\n        var movedProperties = extractProperties(moved);\n\n        while (from != to) {\n          var traversedProperties = extractProperties(tokens[from]);\n          from += delta;\n\n          // traversed then moved as we move selectors towards the start\n          var reorderable = topToBottom ?\n            canReorder(movedProperties, traversedProperties, specificityCache) :\n            canReorder(traversedProperties, movedProperties, specificityCache);\n\n          if (!reorderable && !topToBottom)\n            continue selectorIterator;\n          if (!reorderable && topToBottom)\n            continue directionIterator;\n        }\n\n        if (topToBottom) {\n          Array.prototype.push.apply(moved[2], target[2]);\n          target[2] = moved[2];\n        } else {\n          Array.prototype.push.apply(target[2], moved[2]);\n        }\n\n        optimizeProperties(target[2], true, true, context);\n        moved[2] = [];\n      }\n    }\n  }\n}\n\nmodule.exports = mergeNonAdjacentBySelector;\n","var mergeAdjacent = require('./merge-adjacent');\nvar mergeMediaQueries = require('./merge-media-queries');\nvar mergeNonAdjacentByBody = require('./merge-non-adjacent-by-body');\nvar mergeNonAdjacentBySelector = require('./merge-non-adjacent-by-selector');\nvar reduceNonAdjacent = require('./reduce-non-adjacent');\nvar removeDuplicateFontAtRules = require('./remove-duplicate-font-at-rules');\nvar removeDuplicateMediaQueries = require('./remove-duplicate-media-queries');\nvar removeDuplicates = require('./remove-duplicates');\nvar removeUnusedAtRules = require('./remove-unused-at-rules');\nvar restructure = require('./restructure');\n\nvar optimizeProperties = require('./properties/optimize');\n\nvar OptimizationLevel = require('../../options/optimization-level').OptimizationLevel;\n\nvar Token = require('../../tokenizer/token');\n\nfunction removeEmpty(tokens) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n    var isEmpty = false;\n\n    switch (token[0]) {\n      case Token.RULE:\n        isEmpty = token[1].length === 0 || token[2].length === 0;\n        break;\n      case Token.NESTED_BLOCK:\n        removeEmpty(token[2]);\n        isEmpty = token[2].length === 0;\n        break;\n      case Token.AT_RULE:\n        isEmpty = token[1].length === 0;\n        break;\n      case Token.AT_RULE_BLOCK:\n        isEmpty = token[2].length === 0;\n    }\n\n    if (isEmpty) {\n      tokens.splice(i, 1);\n      i--;\n      l--;\n    }\n  }\n}\n\nfunction recursivelyOptimizeBlocks(tokens, context) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    if (token[0] == Token.NESTED_BLOCK) {\n      var isKeyframes = /@(-moz-|-o-|-webkit-)?keyframes/.test(token[1][0][1]);\n      level2Optimize(token[2], context, !isKeyframes);\n    }\n  }\n}\n\nfunction recursivelyOptimizeProperties(tokens, context) {\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    var token = tokens[i];\n\n    switch (token[0]) {\n      case Token.RULE:\n        optimizeProperties(token[2], true, true, context);\n        break;\n      case Token.NESTED_BLOCK:\n        recursivelyOptimizeProperties(token[2], context);\n    }\n  }\n}\n\nfunction level2Optimize(tokens, context, withRestructuring) {\n  var levelOptions = context.options.level[OptimizationLevel.Two];\n  var level2Plugins = context.options.plugins.level2Block;\n  var reduced;\n  var i;\n\n  recursivelyOptimizeBlocks(tokens, context);\n  recursivelyOptimizeProperties(tokens, context);\n\n  if (levelOptions.removeDuplicateRules) {\n    removeDuplicates(tokens, context);\n  }\n\n  if (levelOptions.mergeAdjacentRules) {\n    mergeAdjacent(tokens, context);\n  }\n\n  if (levelOptions.reduceNonAdjacentRules) {\n    reduceNonAdjacent(tokens, context);\n  }\n\n  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'body') {\n    mergeNonAdjacentBySelector(tokens, context);\n  }\n\n  if (levelOptions.mergeNonAdjacentRules && levelOptions.mergeNonAdjacentRules != 'selector') {\n    mergeNonAdjacentByBody(tokens, context);\n  }\n\n  if (levelOptions.restructureRules && levelOptions.mergeAdjacentRules && withRestructuring) {\n    restructure(tokens, context);\n    mergeAdjacent(tokens, context);\n  }\n\n  if (levelOptions.restructureRules && !levelOptions.mergeAdjacentRules && withRestructuring) {\n    restructure(tokens, context);\n  }\n\n  if (levelOptions.removeDuplicateFontRules) {\n    removeDuplicateFontAtRules(tokens, context);\n  }\n\n  if (levelOptions.removeDuplicateMediaBlocks) {\n    removeDuplicateMediaQueries(tokens, context);\n  }\n\n  if (levelOptions.removeUnusedAtRules) {\n    removeUnusedAtRules(tokens, context);\n  }\n\n  if (levelOptions.mergeMedia) {\n    reduced = mergeMediaQueries(tokens, context);\n    for (i = reduced.length - 1; i >= 0; i--) {\n      level2Optimize(reduced[i][2], context, false);\n    }\n  }\n\n  for (i = 0; i < level2Plugins.length; i++) {\n    level2Plugins[i](tokens);\n  }\n\n  if (levelOptions.removeEmpty) {\n    removeEmpty(tokens);\n  }\n\n  return tokens;\n}\n\nmodule.exports = level2Optimize;\n","var Marker = require('../../../tokenizer/marker');\n\nfunction everyValuesPair(fn, left, right) {\n  var leftSize = left.value.length;\n  var rightSize = right.value.length;\n  var total = Math.max(leftSize, rightSize);\n  var lowerBound = Math.min(leftSize, rightSize) - 1;\n  var leftValue;\n  var rightValue;\n  var position;\n\n  for (position = 0; position < total; position++) {\n    leftValue = left.value[position] && left.value[position][1] || leftValue;\n    rightValue = right.value[position] && right.value[position][1] || rightValue;\n\n    if (leftValue == Marker.COMMA || rightValue == Marker.COMMA) {\n      continue;\n    }\n\n    if (!fn(leftValue, rightValue, position, position <= lowerBound)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = everyValuesPair;\n","var configuration = require('../../configuration');\n\nfunction findComponentIn(shorthand, longhand) {\n  var comparator = nameComparator(longhand);\n\n  return findInDirectComponents(shorthand, comparator) || findInSubComponents(shorthand, comparator);\n}\n\nfunction nameComparator(to) {\n  return function (property) {\n    return to.name === property.name;\n  };\n}\n\nfunction findInDirectComponents(shorthand, comparator) {\n  return shorthand.components.filter(comparator)[0];\n}\n\nfunction findInSubComponents(shorthand, comparator) {\n  var shorthandComponent;\n  var longhandMatch;\n  var i, l;\n\n  if (!configuration[shorthand.name].shorthandComponents) {\n    return;\n  }\n\n  for (i = 0, l = shorthand.components.length; i < l; i++) {\n    shorthandComponent = shorthand.components[i];\n    longhandMatch = findInDirectComponents(shorthandComponent, comparator);\n\n    if (longhandMatch) {\n      return longhandMatch;\n    }\n  }\n\n  return;\n}\n\nmodule.exports = findComponentIn;\n","function hasInherit(property) {\n  for (var i = property.value.length - 1; i >= 0; i--) {\n    if (property.value[i][1] == 'inherit')\n      return true;\n  }\n\n  return false;\n}\n\nmodule.exports = hasInherit;\n","function hasSameValues(property) {\n  var firstValue = property.value[0][1];\n  var i, l;\n\n  for (i = 1, l = property.value.length; i < l; i++) {\n    if (property.value[i][1] != firstValue) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = hasSameValues;\n","function hasUnset(property) {\n  for (var i = property.value.length - 1; i >= 0; i--) {\n    if (property.value[i][1] == 'unset')\n      return true;\n  }\n\n  return false;\n}\n\nmodule.exports = hasUnset;\n","var configuration = require('../../configuration');\n\nfunction isComponentOf(property1, property2, shallow) {\n  return isDirectComponentOf(property1, property2) ||\n    !shallow && !!configuration[property1.name].shorthandComponents && isSubComponentOf(property1, property2);\n}\n\nfunction isDirectComponentOf(property1, property2) {\n  var descriptor = configuration[property1.name];\n\n  return 'components' in descriptor && descriptor.components.indexOf(property2.name) > -1;\n}\n\nfunction isSubComponentOf(property1, property2) {\n  return property1\n    .components\n    .some(function (component) {\n      return isDirectComponentOf(component, property2);\n    });\n}\n\nmodule.exports = isComponentOf;\n","var Marker = require('../../../tokenizer/marker');\n\nfunction isMergeableShorthand(shorthand) {\n  if (shorthand.name != 'font') {\n    return true;\n  }\n\n  return shorthand.value[0][1].indexOf(Marker.INTERNAL) == -1;\n}\n\nmodule.exports = isMergeableShorthand;\n","var everyValuesPair = require('./every-values-pair');\nvar hasInherit = require('./has-inherit');\nvar hasSameValues = require('./has-same-values');\nvar populateComponents = require('./populate-components');\n\nvar configuration = require('../../configuration');\nvar deepClone = require('../../clone').deep;\nvar restoreWithComponents = require('../restore-with-components');\n\nvar restoreFromOptimizing = require('../../restore-from-optimizing');\nvar wrapSingle = require('../../wrap-for-optimizing').single;\n\nvar serializeBody = require('../../../writer/one-time').body;\nvar Token = require('../../../tokenizer/token');\n\nfunction mergeIntoShorthands(properties, validator) {\n  var candidates = {};\n  var descriptor;\n  var componentOf;\n  var property;\n  var i, l;\n  var j, m;\n\n  // there is no shorthand property made up of less than 3 longhands\n  if (properties.length < 3) {\n    return;\n  }\n\n  for (i = 0, l = properties.length; i < l; i++) {\n    property = properties[i];\n    descriptor = configuration[property.name];\n\n    if (property.dynamic) {\n      continue;\n    }\n\n    if (property.unused) {\n      continue;\n    }\n\n    if (property.hack) {\n      continue;\n    }\n\n    if (property.block) {\n      continue;\n    }\n\n    if (descriptor && descriptor.singleTypeComponents && !hasSameValues(property)) {\n      continue;\n    }\n\n    invalidateOrCompact(properties, i, candidates, validator);\n\n    if (descriptor && descriptor.componentOf) {\n      for (j = 0, m = descriptor.componentOf.length; j < m; j++) {\n        componentOf = descriptor.componentOf[j];\n\n        candidates[componentOf] = candidates[componentOf] || {};\n        candidates[componentOf][property.name] = property;\n      }\n    }\n  }\n\n  invalidateOrCompact(properties, i, candidates, validator);\n}\n\nfunction invalidateOrCompact(properties, position, candidates, validator) {\n  var invalidatedBy = properties[position];\n  var shorthandName;\n  var shorthandDescriptor;\n  var candidateComponents;\n  var replacedCandidates = [];\n  var i;\n\n  for (shorthandName in candidates) {\n    if (undefined !== invalidatedBy && shorthandName == invalidatedBy.name) {\n      continue;\n    }\n\n    shorthandDescriptor = configuration[shorthandName];\n    candidateComponents = candidates[shorthandName];\n    if (invalidatedBy && invalidates(candidates, shorthandName, invalidatedBy)) {\n      delete candidates[shorthandName];\n      continue;\n    }\n\n    if (shorthandDescriptor.components.length > Object.keys(candidateComponents).length) {\n      continue;\n    }\n\n    if (mixedImportance(candidateComponents)) {\n      continue;\n    }\n\n    if (!overridable(candidateComponents, shorthandName, validator)) {\n      continue;\n    }\n\n    if (!mergeable(candidateComponents)) {\n      continue;\n    }\n\n    if (mixedInherit(candidateComponents)) {\n      replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator);\n    } else {\n      replaceWithShorthand(properties, candidateComponents, shorthandName, validator);\n    }\n\n    replacedCandidates.push(shorthandName);\n  }\n\n  for (i = replacedCandidates.length - 1; i >= 0; i--) {\n    delete candidates[replacedCandidates[i]];\n  }\n}\n\nfunction invalidates(candidates, shorthandName, invalidatedBy) {\n  var shorthandDescriptor = configuration[shorthandName];\n  var invalidatedByDescriptor = configuration[invalidatedBy.name];\n  var componentName;\n\n  if ('overridesShorthands' in shorthandDescriptor && shorthandDescriptor.overridesShorthands.indexOf(invalidatedBy.name) > -1) {\n    return true;\n  }\n\n  if (invalidatedByDescriptor && 'componentOf' in invalidatedByDescriptor) {\n    for (componentName in candidates[shorthandName]) {\n      if (invalidatedByDescriptor.componentOf.indexOf(componentName) > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction mixedImportance(components) {\n  var important;\n  var componentName;\n\n  for (componentName in components) {\n    if (undefined !== important && components[componentName].important != important) {\n      return true;\n    }\n\n    important = components[componentName].important;\n  }\n\n  return false;\n}\n\nfunction overridable(components, shorthandName, validator) {\n  var descriptor = configuration[shorthandName];\n  var newValuePlaceholder = [\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, shorthandName],\n    [Token.PROPERTY_VALUE, descriptor.defaultValue]\n  ];\n  var newProperty = wrapSingle(newValuePlaceholder);\n  var component;\n  var mayOverride;\n  var i, l;\n\n  populateComponents([newProperty], validator, []);\n\n  for (i = 0, l = descriptor.components.length; i < l; i++) {\n    component = components[descriptor.components[i]];\n    mayOverride = configuration[component.name].canOverride || sameValue;\n\n    if (!everyValuesPair(mayOverride.bind(null, validator), newProperty.components[i], component)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction sameValue(_validator, value1, value2) {\n  return value1 === value2;\n}\n\nfunction mergeable(components) {\n  var lastCount = null;\n  var currentCount;\n  var componentName;\n  var component;\n  var descriptor;\n  var values;\n\n  for (componentName in components) {\n    component = components[componentName];\n    descriptor = configuration[componentName];\n\n    if (!('restore' in descriptor)) {\n      continue;\n    }\n\n    restoreFromOptimizing([component.all[component.position]], restoreWithComponents);\n    values = descriptor.restore(component, configuration);\n\n    currentCount = values.length;\n\n    if (lastCount !== null && currentCount !== lastCount) {\n      return false;\n    }\n\n    lastCount = currentCount;\n  }\n\n  return true;\n}\n\nfunction mixedInherit(components) {\n  var componentName;\n  var lastValue = null;\n  var currentValue;\n\n  for (componentName in components) {\n    currentValue = hasInherit(components[componentName]);\n\n    if (lastValue !== null && lastValue !== currentValue) {\n      return true;\n    }\n\n    lastValue = currentValue;\n  }\n\n  return false;\n}\n\nfunction replaceWithInheritBestFit(properties, candidateComponents, shorthandName, validator) {\n  var viaLonghands = buildSequenceWithInheritLonghands(candidateComponents, shorthandName, validator);\n  var viaShorthand = buildSequenceWithInheritShorthand(candidateComponents, shorthandName, validator);\n  var longhandTokensSequence = viaLonghands[0];\n  var shorthandTokensSequence = viaShorthand[0];\n  var isLonghandsShorter = serializeBody(longhandTokensSequence).length < serializeBody(shorthandTokensSequence).length;\n  var newTokensSequence = isLonghandsShorter ? longhandTokensSequence : shorthandTokensSequence;\n  var newProperty = isLonghandsShorter ? viaLonghands[1] : viaShorthand[1];\n  var newComponents = isLonghandsShorter ? viaLonghands[2] : viaShorthand[2];\n  var lastComponent = candidateComponents[Object.keys(candidateComponents).pop()];\n  var all = lastComponent.all;\n  var insertAt = lastComponent.position;\n  var componentName;\n  var oldComponent;\n  var newComponent;\n  var newToken;\n\n  newProperty.position = insertAt;\n  newProperty.shorthand = true;\n  newProperty.important = lastComponent.important;\n  newProperty.multiplex = false;\n  newProperty.dirty = true;\n  newProperty.all = all;\n  newProperty.all[insertAt] = newTokensSequence[0];\n\n  properties.splice(insertAt, 1, newProperty);\n\n  for (componentName in candidateComponents) {\n    oldComponent = candidateComponents[componentName];\n    oldComponent.unused = true;\n\n    newProperty.multiplex = newProperty.multiplex || oldComponent.multiplex;\n\n    if (oldComponent.name in newComponents) {\n      newComponent = newComponents[oldComponent.name];\n      newToken = findTokenIn(newTokensSequence, componentName);\n\n      newComponent.position = all.length;\n      newComponent.all = all;\n      newComponent.all.push(newToken);\n\n      properties.push(newComponent);\n    }\n  }\n}\n\nfunction buildSequenceWithInheritLonghands(components, shorthandName, validator) {\n  var tokensSequence = [];\n  var inheritComponents = {};\n  var nonInheritComponents = {};\n  var descriptor = configuration[shorthandName];\n  var shorthandToken = [\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, shorthandName],\n    [Token.PROPERTY_VALUE, descriptor.defaultValue]\n  ];\n  var newProperty = wrapSingle(shorthandToken);\n  var component;\n  var longhandToken;\n  var newComponent;\n  var nameMetadata;\n  var i, l;\n\n  populateComponents([newProperty], validator, []);\n\n  for (i = 0, l = descriptor.components.length; i < l; i++) {\n    component = components[descriptor.components[i]];\n\n    if (hasInherit(component)) {\n      longhandToken = component.all[component.position].slice(0, 2);\n      Array.prototype.push.apply(longhandToken, component.value);\n      tokensSequence.push(longhandToken);\n\n      newComponent = deepClone(component);\n      newComponent.value = inferComponentValue(components, newComponent.name);\n\n      newProperty.components[i] = newComponent;\n      inheritComponents[component.name] = deepClone(component);\n    } else {\n      newComponent = deepClone(component);\n      newComponent.all = component.all;\n      newProperty.components[i] = newComponent;\n\n      nonInheritComponents[component.name] = component;\n    }\n  }\n\n  newProperty.important = components[Object.keys(components).pop()].important;\n\n  nameMetadata = joinMetadata(nonInheritComponents, 1);\n  shorthandToken[1].push(nameMetadata);\n\n  restoreFromOptimizing([newProperty], restoreWithComponents);\n\n  shorthandToken = shorthandToken.slice(0, 2);\n  Array.prototype.push.apply(shorthandToken, newProperty.value);\n\n  tokensSequence.unshift(shorthandToken);\n\n  return [tokensSequence, newProperty, inheritComponents];\n}\n\nfunction inferComponentValue(components, propertyName) {\n  var descriptor = configuration[propertyName];\n\n  if ('oppositeTo' in descriptor) {\n    return components[descriptor.oppositeTo].value;\n  } else {\n    return [[Token.PROPERTY_VALUE, descriptor.defaultValue]];\n  }\n}\n\nfunction joinMetadata(components, at) {\n  var metadata = [];\n  var component;\n  var originalValue;\n  var componentMetadata;\n  var componentName;\n\n  for (componentName in components) {\n    component = components[componentName];\n    originalValue = component.all[component.position];\n    componentMetadata = originalValue[at][originalValue[at].length - 1];\n\n    Array.prototype.push.apply(metadata, componentMetadata);\n  }\n\n  return metadata.sort(metadataSorter);\n}\n\nfunction metadataSorter(metadata1, metadata2) {\n  var line1 = metadata1[0];\n  var line2 = metadata2[0];\n  var column1 = metadata1[1];\n  var column2 = metadata2[1];\n\n  if (line1 < line2) {\n    return -1;\n  } else if (line1 === line2) {\n    return column1 < column2 ? -1 : 1;\n  } else {\n    return 1;\n  }\n}\n\nfunction buildSequenceWithInheritShorthand(components, shorthandName, validator) {\n  var tokensSequence = [];\n  var inheritComponents = {};\n  var nonInheritComponents = {};\n  var descriptor = configuration[shorthandName];\n  var shorthandToken = [\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, shorthandName],\n    [Token.PROPERTY_VALUE, 'inherit']\n  ];\n  var newProperty = wrapSingle(shorthandToken);\n  var component;\n  var longhandToken;\n  var nameMetadata;\n  var valueMetadata;\n  var i, l;\n\n  populateComponents([newProperty], validator, []);\n\n  for (i = 0, l = descriptor.components.length; i < l; i++) {\n    component = components[descriptor.components[i]];\n\n    if (hasInherit(component)) {\n      inheritComponents[component.name] = component;\n    } else {\n      longhandToken = component.all[component.position].slice(0, 2);\n      Array.prototype.push.apply(longhandToken, component.value);\n      tokensSequence.push(longhandToken);\n\n      nonInheritComponents[component.name] = deepClone(component);\n    }\n  }\n\n  nameMetadata = joinMetadata(inheritComponents, 1);\n  shorthandToken[1].push(nameMetadata);\n\n  valueMetadata = joinMetadata(inheritComponents, 2);\n  shorthandToken[2].push(valueMetadata);\n\n  tokensSequence.unshift(shorthandToken);\n\n  return [tokensSequence, newProperty, nonInheritComponents];\n}\n\nfunction findTokenIn(tokens, componentName) {\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    if (tokens[i][1][1] == componentName) {\n      return tokens[i];\n    }\n  }\n}\n\nfunction replaceWithShorthand(properties, candidateComponents, shorthandName, validator) {\n  var descriptor = configuration[shorthandName];\n  var nameMetadata;\n  var valueMetadata;\n  var newValuePlaceholder = [\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, shorthandName],\n    [Token.PROPERTY_VALUE, descriptor.defaultValue]\n  ];\n  var all;\n  var insertAt = inferInsertAtFrom(properties, candidateComponents, shorthandName);\n\n  var newProperty = wrapSingle(newValuePlaceholder);\n  newProperty.shorthand = true;\n  newProperty.dirty = true;\n  newProperty.multiplex = false;\n\n  populateComponents([newProperty], validator, []);\n\n  for (var i = 0, l = descriptor.components.length; i < l; i++) {\n    var component = candidateComponents[descriptor.components[i]];\n\n    newProperty.components[i] = deepClone(component);\n    newProperty.important = component.important;\n    newProperty.multiplex = newProperty.multiplex || component.multiplex;\n\n    all = component.all;\n  }\n\n  for (var componentName in candidateComponents) {\n    candidateComponents[componentName].unused = true;\n  }\n\n  nameMetadata = joinMetadata(candidateComponents, 1);\n  newValuePlaceholder[1].push(nameMetadata);\n\n  valueMetadata = joinMetadata(candidateComponents, 2);\n  newValuePlaceholder[2].push(valueMetadata);\n\n  newProperty.position = insertAt;\n  newProperty.all = all;\n  newProperty.all[insertAt] = newValuePlaceholder;\n\n  properties.splice(insertAt, 1, newProperty);\n}\n\nfunction inferInsertAtFrom(properties, candidateComponents, shorthandName) {\n  var candidateComponentNames = Object.keys(candidateComponents);\n  var firstCandidatePosition = candidateComponents[candidateComponentNames[0]].position;\n  var lastCandidatePosition = candidateComponents[candidateComponentNames[candidateComponentNames.length - 1]].position;\n\n  if (shorthandName == 'border' && traversesVia(properties.slice(firstCandidatePosition, lastCandidatePosition), 'border-image')) {\n    return firstCandidatePosition;\n  } else {\n    return lastCandidatePosition;\n  }\n}\n\nfunction traversesVia(properties, propertyName) {\n  for (var i = properties.length - 1; i >= 0; i--) {\n    if (properties[i].name == propertyName) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = mergeIntoShorthands;\n","var mergeIntoShorthands = require('./merge-into-shorthands');\nvar overrideProperties = require('./override-properties');\nvar populateComponents = require('./populate-components');\n\nvar restoreWithComponents = require('../restore-with-components');\n\nvar wrapForOptimizing = require('../../wrap-for-optimizing').all;\nvar removeUnused = require('../../remove-unused');\nvar restoreFromOptimizing = require('../../restore-from-optimizing');\n\nvar OptimizationLevel = require('../../../options/optimization-level').OptimizationLevel;\n\nfunction optimizeProperties(properties, withOverriding, withMerging, context) {\n  var levelOptions = context.options.level[OptimizationLevel.Two];\n  var _properties = wrapForOptimizing(properties, levelOptions.skipProperties);\n  var _property;\n  var i, l;\n\n  populateComponents(_properties, context.validator, context.warnings);\n\n  for (i = 0, l = _properties.length; i < l; i++) {\n    _property = _properties[i];\n    if (_property.block) {\n      optimizeProperties(_property.value[0][1], withOverriding, withMerging, context);\n    }\n  }\n\n  if (withMerging && levelOptions.mergeIntoShorthands) {\n    mergeIntoShorthands(_properties, context.validator);\n  }\n\n  if (withOverriding && levelOptions.overrideProperties) {\n    overrideProperties(_properties, withMerging, context.options.compatibility, context.validator);\n  }\n\n  restoreFromOptimizing(_properties, restoreWithComponents);\n  removeUnused(_properties);\n}\n\nmodule.exports = optimizeProperties;\n","var hasInherit = require('./has-inherit');\nvar hasUnset = require('./has-unset');\nvar everyValuesPair = require('./every-values-pair');\nvar findComponentIn = require('./find-component-in');\nvar isComponentOf = require('./is-component-of');\nvar isMergeableShorthand = require('./is-mergeable-shorthand');\nvar overridesNonComponentShorthand = require('./overrides-non-component-shorthand');\nvar sameVendorPrefixesIn = require('./../../vendor-prefixes').same;\n\nvar configuration = require('../../configuration');\nvar deepClone = require('../../clone').deep;\nvar restoreWithComponents = require('../restore-with-components');\nvar shallowClone = require('../../clone').shallow;\n\nvar restoreFromOptimizing = require('../../restore-from-optimizing');\n\nvar Token = require('../../../tokenizer/token');\nvar Marker = require('../../../tokenizer/marker');\n\nvar serializeProperty = require('../../../writer/one-time').property;\n\nfunction sameValue(_validator, value1, value2) {\n  return value1 === value2;\n}\n\nfunction wouldBreakCompatibility(property, validator) {\n  for (var i = 0; i < property.components.length; i++) {\n    var component = property.components[i];\n    var descriptor = configuration[component.name];\n    var canOverride = descriptor && descriptor.canOverride || sameValue;\n\n    var _component = shallowClone(component);\n    _component.value = [[Token.PROPERTY_VALUE, descriptor.defaultValue]];\n\n    if (!everyValuesPair(canOverride.bind(null, validator), _component, component)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction overrideIntoMultiplex(property, by) {\n  by.unused = true;\n\n  turnIntoMultiplex(by, multiplexSize(property));\n  property.value = by.value;\n}\n\nfunction overrideByMultiplex(property, by) {\n  by.unused = true;\n  property.multiplex = true;\n  property.value = by.value;\n}\n\nfunction overrideSimple(property, by) {\n  by.unused = true;\n  property.value = by.value;\n}\n\nfunction override(property, by) {\n  if (by.multiplex)\n    overrideByMultiplex(property, by);\n  else if (property.multiplex)\n    overrideIntoMultiplex(property, by);\n  else\n    overrideSimple(property, by);\n}\n\nfunction overrideShorthand(property, by) {\n  by.unused = true;\n\n  for (var i = 0, l = property.components.length; i < l; i++) {\n    override(property.components[i], by.components[i]);\n  }\n}\n\nfunction turnIntoMultiplex(property, size) {\n  property.multiplex = true;\n\n  if (configuration[property.name].shorthand) {\n    turnShorthandValueIntoMultiplex(property, size);\n  } else {\n    turnLonghandValueIntoMultiplex(property, size);\n  }\n}\n\nfunction turnShorthandValueIntoMultiplex(property, size) {\n  var component;\n  var i, l;\n\n  for (i = 0, l = property.components.length; i < l; i++) {\n    component = property.components[i];\n\n    if (!component.multiplex) {\n      turnLonghandValueIntoMultiplex(component, size);\n    }\n  }\n}\n\nfunction turnLonghandValueIntoMultiplex(property, size) {\n  var descriptor = configuration[property.name];\n  var withRealValue = descriptor.intoMultiplexMode == 'real';\n  var withValue = descriptor.intoMultiplexMode == 'real' ?\n    property.value.slice(0) :\n    (descriptor.intoMultiplexMode == 'placeholder' ? descriptor.placeholderValue : descriptor.defaultValue);\n  var i = multiplexSize(property);\n  var j;\n  var m = withValue.length;\n\n  for (; i < size; i++) {\n    property.value.push([Token.PROPERTY_VALUE, Marker.COMMA]);\n\n    if (Array.isArray(withValue)) {\n      for (j = 0; j < m; j++) {\n        property.value.push(withRealValue ? withValue[j] : [Token.PROPERTY_VALUE, withValue[j]]);\n      }\n    } else {\n      property.value.push(withRealValue ? withValue : [Token.PROPERTY_VALUE, withValue]);\n    }\n  }\n}\n\nfunction multiplexSize(component) {\n  var size = 0;\n\n  for (var i = 0, l = component.value.length; i < l; i++) {\n    if (component.value[i][1] == Marker.COMMA)\n      size++;\n  }\n\n  return size + 1;\n}\n\nfunction lengthOf(property) {\n  var fakeAsArray = [\n    Token.PROPERTY,\n    [Token.PROPERTY_NAME, property.name]\n  ].concat(property.value);\n  return serializeProperty([fakeAsArray], 0).length;\n}\n\nfunction moreSameShorthands(properties, startAt, name) {\n  // Since we run the main loop in `compactOverrides` backwards, at this point some\n  // properties may not be marked as unused.\n  // We should consider reverting the order if possible\n  var count = 0;\n\n  for (var i = startAt; i >= 0; i--) {\n    if (properties[i].name == name && !properties[i].unused)\n      count++;\n    if (count > 1)\n      break;\n  }\n\n  return count > 1;\n}\n\nfunction overridingFunction(shorthand, validator) {\n  for (var i = 0, l = shorthand.components.length; i < l; i++) {\n    if (!anyValue(validator.isUrl, shorthand.components[i]) && anyValue(validator.isFunction, shorthand.components[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction anyValue(fn, property) {\n  for (var i = 0, l = property.value.length; i < l; i++) {\n    if (property.value[i][1] == Marker.COMMA)\n      continue;\n\n    if (fn(property.value[i][1]))\n      return true;\n  }\n\n  return false;\n}\n\nfunction wouldResultInLongerValue(left, right) {\n  if (!left.multiplex && !right.multiplex || left.multiplex && right.multiplex)\n    return false;\n\n  var multiplex = left.multiplex ? left : right;\n  var simple = left.multiplex ? right : left;\n  var component;\n\n  var multiplexClone = deepClone(multiplex);\n  restoreFromOptimizing([multiplexClone], restoreWithComponents);\n\n  var simpleClone = deepClone(simple);\n  restoreFromOptimizing([simpleClone], restoreWithComponents);\n\n  var lengthBefore = lengthOf(multiplexClone) + 1 + lengthOf(simpleClone);\n\n  if (left.multiplex) {\n    component = findComponentIn(multiplexClone, simpleClone);\n    overrideIntoMultiplex(component, simpleClone);\n  } else {\n    component = findComponentIn(simpleClone, multiplexClone);\n    turnIntoMultiplex(simpleClone, multiplexSize(multiplexClone));\n    overrideByMultiplex(component, multiplexClone);\n  }\n\n  restoreFromOptimizing([simpleClone], restoreWithComponents);\n\n  var lengthAfter = lengthOf(simpleClone);\n\n  return lengthBefore <= lengthAfter;\n}\n\nfunction isCompactable(property) {\n  return property.name in configuration;\n}\n\nfunction noneOverrideHack(left, right) {\n  return !left.multiplex &&\n    (left.name == 'background' || left.name == 'background-image') &&\n    right.multiplex &&\n    (right.name == 'background' || right.name == 'background-image') &&\n    anyLayerIsNone(right.value);\n}\n\nfunction anyLayerIsNone(values) {\n  var layers = intoLayers(values);\n\n  for (var i = 0, l = layers.length; i < l; i++) {\n    if (layers[i].length == 1 && layers[i][0][1] == 'none')\n      return true;\n  }\n\n  return false;\n}\n\nfunction intoLayers(values) {\n  var layers = [];\n\n  for (var i = 0, layer = [], l = values.length; i < l; i++) {\n    var value = values[i];\n    if (value[1] == Marker.COMMA) {\n      layers.push(layer);\n      layer = [];\n    } else {\n      layer.push(value);\n    }\n  }\n\n  layers.push(layer);\n  return layers;\n}\n\nfunction overrideProperties(properties, withMerging, compatibility, validator) {\n  var mayOverride, right, left, component;\n  var overriddenComponents;\n  var overriddenComponent;\n  var overridingComponent;\n  var overridable;\n  var i, j, k;\n\n  propertyLoop:\n  for (i = properties.length - 1; i >= 0; i--) {\n    right = properties[i];\n\n    if (!isCompactable(right))\n      continue;\n\n    if (right.block)\n      continue;\n\n    mayOverride = configuration[right.name].canOverride || sameValue;\n\n    traverseLoop:\n    for (j = i - 1; j >= 0; j--) {\n      left = properties[j];\n\n      if (!isCompactable(left))\n        continue;\n\n      if (left.block)\n        continue;\n\n      if (left.dynamic || right.dynamic)\n        continue;\n\n      if (left.unused || right.unused)\n        continue;\n\n      if (left.hack && !right.hack && !right.important || !left.hack && !left.important && right.hack)\n        continue;\n\n      if (left.important == right.important && left.hack[0] != right.hack[0])\n        continue;\n\n      if (left.important == right.important && (left.hack[0] != right.hack[0] || (left.hack[1] && left.hack[1] != right.hack[1])))\n        continue;\n\n      if (hasInherit(right))\n        continue;\n\n      if (noneOverrideHack(left, right))\n        continue;\n\n      if (right.shorthand && isComponentOf(right, left)) {\n        // maybe `left` can be overridden by `right` which is a shorthand?\n        if (!right.important && left.important)\n          continue;\n\n        if (!sameVendorPrefixesIn([left], right.components))\n          continue;\n\n        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator))\n          continue;\n\n        if (!isMergeableShorthand(right)) {\n          left.unused = true;\n          continue;\n        }\n\n        component = findComponentIn(right, left);\n        mayOverride = configuration[left.name].canOverride || sameValue;\n        if (everyValuesPair(mayOverride.bind(null, validator), left, component)) {\n          left.unused = true;\n        }\n      } else if (right.shorthand && overridesNonComponentShorthand(right, left)) {\n        // `right` is a shorthand while `left` can be overriden by it, think `border` and `border-top`\n        if (!right.important && left.important) {\n          continue;\n        }\n\n        if (!sameVendorPrefixesIn([left], right.components)) {\n          continue;\n        }\n\n        if (!anyValue(validator.isFunction, left) && overridingFunction(right, validator)) {\n          continue;\n        }\n\n        overriddenComponents = left.shorthand ?\n          left.components:\n          [left];\n\n        for (k = overriddenComponents.length - 1; k >= 0; k--) {\n          overriddenComponent = overriddenComponents[k];\n          overridingComponent = findComponentIn(right, overriddenComponent);\n          mayOverride = configuration[overriddenComponent.name].canOverride || sameValue;\n\n          if (!everyValuesPair(mayOverride.bind(null, validator), left, overridingComponent)) {\n            continue traverseLoop;\n          }\n        }\n\n        left.unused = true;\n      } else if (withMerging && left.shorthand && !right.shorthand && isComponentOf(left, right, true)) {\n        // maybe `right` can be pulled into `left` which is a shorthand?\n        if (right.important && !left.important)\n          continue;\n\n        if (!right.important && left.important) {\n          right.unused = true;\n          continue;\n        }\n\n        // Pending more clever algorithm in #527\n        if (moreSameShorthands(properties, i - 1, left.name))\n          continue;\n\n        if (overridingFunction(left, validator))\n          continue;\n\n        if (!isMergeableShorthand(left))\n          continue;\n\n        if (hasUnset(left) || hasUnset(right))\n          continue;\n\n        component = findComponentIn(left, right);\n        if (everyValuesPair(mayOverride.bind(null, validator), component, right)) {\n          var disabledBackgroundMerging =\n            !compatibility.properties.backgroundClipMerging && component.name.indexOf('background-clip') > -1 ||\n            !compatibility.properties.backgroundOriginMerging && component.name.indexOf('background-origin') > -1 ||\n            !compatibility.properties.backgroundSizeMerging && component.name.indexOf('background-size') > -1;\n          var nonMergeableValue = configuration[right.name].nonMergeableValue === right.value[0][1];\n\n          if (disabledBackgroundMerging || nonMergeableValue)\n            continue;\n\n          if (!compatibility.properties.merging && wouldBreakCompatibility(left, validator))\n            continue;\n\n          if (component.value[0][1] != right.value[0][1] && (hasInherit(left) || hasInherit(right)))\n            continue;\n\n          if (wouldResultInLongerValue(left, right))\n            continue;\n\n          if (!left.multiplex && right.multiplex)\n            turnIntoMultiplex(left, multiplexSize(right));\n\n          override(component, right);\n          left.dirty = true;\n        }\n      } else if (withMerging && left.shorthand && right.shorthand && left.name == right.name) {\n        // merge if all components can be merged\n\n        if (!left.multiplex && right.multiplex)\n          continue;\n\n        if (!right.important && left.important) {\n          right.unused = true;\n          continue propertyLoop;\n        }\n\n        if (right.important && !left.important) {\n          left.unused = true;\n          continue;\n        }\n\n        if (!isMergeableShorthand(right)) {\n          left.unused = true;\n          continue;\n        }\n\n        for (k = left.components.length - 1; k >= 0; k--) {\n          var leftComponent = left.components[k];\n          var rightComponent = right.components[k];\n\n          mayOverride = configuration[leftComponent.name].canOverride || sameValue;\n          if (!everyValuesPair(mayOverride.bind(null, validator), leftComponent, rightComponent))\n            continue propertyLoop;\n        }\n\n        overrideShorthand(left, right);\n        left.dirty = true;\n      } else if (withMerging && left.shorthand && right.shorthand && isComponentOf(left, right)) {\n        // border is a shorthand but any of its components is a shorthand too\n\n        if (!left.important && right.important)\n          continue;\n\n        component = findComponentIn(left, right);\n        mayOverride = configuration[right.name].canOverride || sameValue;\n        if (!everyValuesPair(mayOverride.bind(null, validator), component, right))\n          continue;\n\n        if (left.important && !right.important) {\n          right.unused = true;\n          continue;\n        }\n\n        var rightRestored = configuration[right.name].restore(right, configuration);\n        if (rightRestored.length > 1)\n          continue;\n\n        component = findComponentIn(left, right);\n        override(component, right);\n        right.dirty = true;\n      } else if (left.name == right.name) {\n        // two non-shorthands should be merged based on understandability\n        overridable = true;\n\n        if (right.shorthand) {\n          for (k = right.components.length - 1; k >= 0 && overridable; k--) {\n            overriddenComponent = left.components[k];\n            overridingComponent = right.components[k];\n            mayOverride = configuration[overridingComponent.name].canOverride || sameValue;\n\n            overridable = everyValuesPair(mayOverride.bind(null, validator), overriddenComponent, overridingComponent);\n          }\n        } else {\n          mayOverride = configuration[right.name].canOverride || sameValue;\n          overridable = everyValuesPair(mayOverride.bind(null, validator), left, right);\n        }\n\n        if (left.important && !right.important && overridable) {\n          right.unused = true;\n          continue;\n        }\n\n        if (!left.important && right.important && overridable) {\n          left.unused = true;\n          continue;\n        }\n\n        if (!overridable) {\n          continue;\n        }\n\n        left.unused = true;\n      }\n    }\n  }\n}\n\nmodule.exports = overrideProperties;\n","var configuration = require('../../configuration');\n\nfunction overridesNonComponentShorthand(property1, property2) {\n  return property1.name in configuration &&\n    'overridesShorthands' in configuration[property1.name] &&\n    configuration[property1.name].overridesShorthands.indexOf(property2.name) > -1;\n}\n\nmodule.exports = overridesNonComponentShorthand;\n","var configuration = require('../../configuration');\nvar InvalidPropertyError = require('../../invalid-property-error');\n\nfunction populateComponents(properties, validator, warnings) {\n  var component;\n  var j, m;\n\n  for (var i = properties.length - 1; i >= 0; i--) {\n    var property = properties[i];\n    var descriptor = configuration[property.name];\n\n    if (!property.dynamic && descriptor && descriptor.shorthand) {\n      if (onlyValueIsVariable(property, validator) || moreThanOneValueIsVariable(property, validator)) {\n        property.optimizable = false;\n        continue;\n      }\n\n      property.shorthand = true;\n      property.dirty = true;\n\n      try {\n        property.components = descriptor.breakUp(property, configuration, validator);\n\n        if (descriptor.shorthandComponents) {\n          for (j = 0, m = property.components.length; j < m; j++) {\n            component = property.components[j];\n            component.components = configuration[component.name].breakUp(component, configuration, validator);\n          }\n        }\n      } catch (e) {\n        if (e instanceof InvalidPropertyError) {\n          property.components = []; // this will set property.unused to true below\n          warnings.push(e.message);\n        } else {\n          throw e;\n        }\n      }\n\n      if (property.components.length > 0)\n        property.multiplex = property.components[0].multiplex;\n      else\n        property.unused = true;\n    }\n  }\n}\n\nfunction onlyValueIsVariable(property, validator) {\n  return property.value.length == 1 && validator.isVariable(property.value[0][1]);\n}\n\nfunction moreThanOneValueIsVariable(property, validator) {\n  return property.value.length > 1 && property.value.filter(function (value) { return validator.isVariable(value[1]); }).length > 1;\n}\n\nmodule.exports = populateComponents;\n","var isMergeable = require('./is-mergeable');\n\nvar optimizeProperties = require('./properties/optimize');\n\nvar cloneArray = require('../../utils/clone-array');\n\nvar Token = require('../../tokenizer/token');\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction reduceNonAdjacent(tokens, context) {\n  var options = context.options;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var candidates = {};\n  var repeated = [];\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n\n    if (token[0] != Token.RULE) {\n      continue;\n    } else if (token[2].length === 0) {\n      continue;\n    }\n\n    var selectorAsString = serializeRules(token[1]);\n    var isComplexAndNotSpecial = token[1].length > 1 &&\n      isMergeable(selectorAsString, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging);\n    var wrappedSelectors = wrappedSelectorsFrom(token[1]);\n    var selectors = isComplexAndNotSpecial ?\n      [selectorAsString].concat(wrappedSelectors) :\n      [selectorAsString];\n\n    for (var j = 0, m = selectors.length; j < m; j++) {\n      var selector = selectors[j];\n\n      if (!candidates[selector])\n        candidates[selector] = [];\n      else\n        repeated.push(selector);\n\n      candidates[selector].push({\n        where: i,\n        list: wrappedSelectors,\n        isPartial: isComplexAndNotSpecial && j > 0,\n        isComplex: isComplexAndNotSpecial && j === 0\n      });\n    }\n  }\n\n  reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context);\n  reduceComplexNonAdjacentCases(tokens, candidates, options, context);\n}\n\nfunction wrappedSelectorsFrom(list) {\n  var wrapped = [];\n\n  for (var i = 0; i < list.length; i++) {\n    wrapped.push([list[i][1]]);\n  }\n\n  return wrapped;\n}\n\nfunction reduceSimpleNonAdjacentCases(tokens, repeated, candidates, options, context) {\n  function filterOut(idx, bodies) {\n    return data[idx].isPartial && bodies.length === 0;\n  }\n\n  function reduceBody(token, newBody, processedCount, tokenIdx) {\n    if (!data[processedCount - tokenIdx - 1].isPartial)\n      token[2] = newBody;\n  }\n\n  for (var i = 0, l = repeated.length; i < l; i++) {\n    var selector = repeated[i];\n    var data = candidates[selector];\n\n    reduceSelector(tokens, data, {\n      filterOut: filterOut,\n      callback: reduceBody\n    }, options, context);\n  }\n}\n\nfunction reduceComplexNonAdjacentCases(tokens, candidates, options, context) {\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var localContext = {};\n\n  function filterOut(idx) {\n    return localContext.data[idx].where < localContext.intoPosition;\n  }\n\n  function collectReducedBodies(token, newBody, processedCount, tokenIdx) {\n    if (tokenIdx === 0)\n      localContext.reducedBodies.push(newBody);\n  }\n\n  allSelectors:\n  for (var complexSelector in candidates) {\n    var into = candidates[complexSelector];\n    if (!into[0].isComplex)\n      continue;\n\n    var intoPosition = into[into.length - 1].where;\n    var intoToken = tokens[intoPosition];\n    var reducedBodies = [];\n\n    var selectors = isMergeable(complexSelector, mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging) ?\n      into[0].list :\n      [complexSelector];\n\n    localContext.intoPosition = intoPosition;\n    localContext.reducedBodies = reducedBodies;\n\n    for (var j = 0, m = selectors.length; j < m; j++) {\n      var selector = selectors[j];\n      var data = candidates[selector];\n\n      if (data.length < 2)\n        continue allSelectors;\n\n      localContext.data = data;\n\n      reduceSelector(tokens, data, {\n        filterOut: filterOut,\n        callback: collectReducedBodies\n      }, options, context);\n\n      if (serializeBody(reducedBodies[reducedBodies.length - 1]) != serializeBody(reducedBodies[0]))\n        continue allSelectors;\n    }\n\n    intoToken[2] = reducedBodies[0];\n  }\n}\n\nfunction reduceSelector(tokens, data, context, options, outerContext) {\n  var bodies = [];\n  var bodiesAsList = [];\n  var processedTokens = [];\n\n  for (var j = data.length - 1; j >= 0; j--) {\n    if (context.filterOut(j, bodies))\n      continue;\n\n    var where = data[j].where;\n    var token = tokens[where];\n    var clonedBody = cloneArray(token[2]);\n\n    bodies = bodies.concat(clonedBody);\n    bodiesAsList.push(clonedBody);\n    processedTokens.push(where);\n  }\n\n  optimizeProperties(bodies, true, false, outerContext);\n\n  var processedCount = processedTokens.length;\n  var propertyIdx = bodies.length - 1;\n  var tokenIdx = processedCount - 1;\n\n  while (tokenIdx >= 0) {\n     if ((tokenIdx === 0 || (bodies[propertyIdx] && bodiesAsList[tokenIdx].indexOf(bodies[propertyIdx]) > -1)) && propertyIdx > -1) {\n      propertyIdx--;\n      continue;\n    }\n\n    var newBody = bodies.splice(propertyIdx + 1);\n    context.callback(tokens[processedTokens[tokenIdx]], newBody, processedCount, tokenIdx);\n\n    tokenIdx--;\n  }\n}\n\nmodule.exports = reduceNonAdjacent;\n","var Token = require('../../tokenizer/token');\n\nvar serializeAll = require('../../writer/one-time').all;\n\nvar FONT_FACE_SCOPE = '@font-face';\n\nfunction removeDuplicateFontAtRules(tokens) {\n  var fontAtRules = [];\n  var token;\n  var key;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    if (token[0] != Token.AT_RULE_BLOCK && token[1][0][1] != FONT_FACE_SCOPE) {\n      continue;\n    }\n\n    key = serializeAll([token]);\n\n    if (fontAtRules.indexOf(key) > -1) {\n      token[2] = [];\n    } else {\n      fontAtRules.push(key);\n    }\n  }\n}\n\nmodule.exports = removeDuplicateFontAtRules;\n","var Token = require('../../tokenizer/token');\n\nvar serializeAll = require('../../writer/one-time').all;\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction removeDuplicateMediaQueries(tokens) {\n  var candidates = {};\n  var candidate;\n  var token;\n  var key;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    if (token[0] != Token.NESTED_BLOCK) {\n      continue;\n    }\n\n    key = serializeRules(token[1]) + '%' + serializeAll(token[2]);\n    candidate = candidates[key];\n\n    if (candidate) {\n      candidate[2] = [];\n    }\n\n    candidates[key] = token;\n  }\n}\n\nmodule.exports = removeDuplicateMediaQueries;\n","var Token = require('../../tokenizer/token');\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction removeDuplicates(tokens) {\n  var matched = {};\n  var moreThanOnce = [];\n  var id, token;\n  var body, bodies;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    if (token[0] != Token.RULE)\n      continue;\n\n    id = serializeRules(token[1]);\n\n    if (matched[id] && matched[id].length == 1)\n      moreThanOnce.push(id);\n    else\n      matched[id] = matched[id] || [];\n\n    matched[id].push(i);\n  }\n\n  for (i = 0, l = moreThanOnce.length; i < l; i++) {\n    id = moreThanOnce[i];\n    bodies = [];\n\n    for (var j = matched[id].length - 1; j >= 0; j--) {\n      token = tokens[matched[id][j]];\n      body = serializeBody(token[2]);\n\n      if (bodies.indexOf(body) > -1)\n        token[2] = [];\n      else\n        bodies.push(body);\n    }\n  }\n}\n\nmodule.exports = removeDuplicates;\n","var populateComponents = require('./properties/populate-components');\n\nvar wrapForOptimizing = require('../wrap-for-optimizing').single;\nvar restoreFromOptimizing = require('../restore-from-optimizing');\n\nvar Token = require('../../tokenizer/token');\n\nvar animationNameRegex = /^(\\-moz\\-|\\-o\\-|\\-webkit\\-)?animation-name$/;\nvar animationRegex = /^(\\-moz\\-|\\-o\\-|\\-webkit\\-)?animation$/;\nvar keyframeRegex = /^@(\\-moz\\-|\\-o\\-|\\-webkit\\-)?keyframes /;\nvar importantRegex = /\\s{0,31}!important$/;\nvar optionalMatchingQuotesRegex = /^(['\"]?)(.*)\\1$/;\n\nfunction normalize(value) {\n  return value\n    .replace(optionalMatchingQuotesRegex, '$2')\n    .replace(importantRegex, '');\n}\n\nfunction removeUnusedAtRules(tokens, context) {\n  removeUnusedAtRule(tokens, matchCounterStyle, markCounterStylesAsUsed, context);\n  removeUnusedAtRule(tokens, matchFontFace, markFontFacesAsUsed, context);\n  removeUnusedAtRule(tokens, matchKeyframe, markKeyframesAsUsed, context);\n  removeUnusedAtRule(tokens, matchNamespace, markNamespacesAsUsed, context);\n}\n\nfunction removeUnusedAtRule(tokens, matchCallback, markCallback, context) {\n  var atRules = {};\n  var atRule;\n  var atRuleTokens;\n  var atRuleToken;\n  var zeroAt;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    matchCallback(tokens[i], atRules);\n  }\n\n  if (Object.keys(atRules).length === 0) {\n    return;\n  }\n\n  markUsedAtRules(tokens, markCallback, atRules, context);\n\n  for (atRule in atRules) {\n    atRuleTokens = atRules[atRule];\n\n    for (i = 0, l = atRuleTokens.length; i < l; i++) {\n      atRuleToken = atRuleTokens[i];\n      zeroAt = atRuleToken[0] == Token.AT_RULE ? 1 : 2;\n      atRuleToken[zeroAt] = [];\n    }\n  }\n}\n\nfunction markUsedAtRules(tokens, markCallback, atRules, context) {\n  var boundMarkCallback = markCallback(atRules);\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    switch (tokens[i][0]) {\n      case Token.RULE:\n        boundMarkCallback(tokens[i], context);\n        break;\n      case Token.NESTED_BLOCK:\n        markUsedAtRules(tokens[i][2], markCallback, atRules, context);\n    }\n  }\n}\n\nfunction matchCounterStyle(token, atRules) {\n  var match;\n\n  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1].indexOf('@counter-style') === 0) {\n    match = token[1][0][1].split(' ')[1];\n    atRules[match] = atRules[match] || [];\n    atRules[match].push(token);\n  }\n}\n\nfunction markCounterStylesAsUsed(atRules) {\n  return function (token, context) {\n    var property;\n    var wrappedProperty;\n    var i, l;\n\n    for (i = 0, l = token[2].length; i < l; i++) {\n      property = token[2][i];\n\n      if (property[1][1] == 'list-style') {\n        wrappedProperty = wrapForOptimizing(property);\n        populateComponents([wrappedProperty], context.validator, context.warnings);\n\n        if (wrappedProperty.components[0].value[0][1] in atRules) {\n          delete atRules[property[2][1]];\n        }\n\n        restoreFromOptimizing([wrappedProperty]);\n      }\n\n      if (property[1][1] == 'list-style-type' && property[2][1] in atRules) {\n        delete atRules[property[2][1]];\n      }\n    }\n  };\n}\n\nfunction matchFontFace(token, atRules) {\n  var property;\n  var match;\n  var i, l;\n\n  if (token[0] == Token.AT_RULE_BLOCK && token[1][0][1] == '@font-face') {\n    for (i = 0, l = token[2].length; i < l; i++) {\n      property = token[2][i];\n\n      if (property[1][1] == 'font-family') {\n        match = normalize(property[2][1].toLowerCase());\n        atRules[match] = atRules[match] || [];\n        atRules[match].push(token);\n        break;\n      }\n    }\n  }\n}\n\nfunction markFontFacesAsUsed(atRules) {\n  return function (token, context) {\n    var property;\n    var wrappedProperty;\n    var component;\n    var normalizedMatch;\n    var i, l;\n    var j, m;\n\n    for (i = 0, l = token[2].length; i < l; i++) {\n      property = token[2][i];\n\n      if (property[1][1] == 'font') {\n        wrappedProperty = wrapForOptimizing(property);\n        populateComponents([wrappedProperty], context.validator, context.warnings);\n        component = wrappedProperty.components[6];\n\n        for (j = 0, m = component.value.length; j < m; j++) {\n          normalizedMatch = normalize(component.value[j][1].toLowerCase());\n\n          if (normalizedMatch in atRules) {\n            delete atRules[normalizedMatch];\n          }\n        }\n\n        restoreFromOptimizing([wrappedProperty]);\n      }\n\n      if (property[1][1] == 'font-family') {\n        for (j = 2, m = property.length; j < m; j++) {\n          normalizedMatch = normalize(property[j][1].toLowerCase());\n\n          if (normalizedMatch in atRules) {\n            delete atRules[normalizedMatch];\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction matchKeyframe(token, atRules) {\n  var match;\n\n  if (token[0] == Token.NESTED_BLOCK && keyframeRegex.test(token[1][0][1])) {\n    match = token[1][0][1].split(' ')[1];\n    atRules[match] = atRules[match] || [];\n    atRules[match].push(token);\n  }\n}\n\nfunction markKeyframesAsUsed(atRules) {\n  return function (token, context) {\n    var property;\n    var wrappedProperty;\n    var component;\n    var i, l;\n    var j, m;\n\n    for (i = 0, l = token[2].length; i < l; i++) {\n      property = token[2][i];\n\n      if (animationRegex.test(property[1][1])) {\n        wrappedProperty = wrapForOptimizing(property);\n        populateComponents([wrappedProperty], context.validator, context.warnings);\n        component = wrappedProperty.components[7];\n\n        for (j = 0, m = component.value.length; j < m; j++) {\n          if (component.value[j][1] in atRules) {\n            delete atRules[component.value[j][1]];\n          }\n        }\n\n        restoreFromOptimizing([wrappedProperty]);\n      }\n\n      if (animationNameRegex.test(property[1][1])) {\n        for (j = 2, m = property.length; j < m; j++) {\n          if (property[j][1] in atRules) {\n            delete atRules[property[j][1]];\n          }\n        }\n      }\n    }\n  };\n}\n\nfunction matchNamespace(token, atRules) {\n  var match;\n\n  if (token[0] == Token.AT_RULE && token[1].indexOf('@namespace') === 0) {\n    match = token[1].split(' ')[1];\n    atRules[match] = atRules[match] || [];\n    atRules[match].push(token);\n  }\n}\n\nfunction markNamespacesAsUsed(atRules) {\n  var namespaceRegex = new RegExp(Object.keys(atRules).join('\\\\\\||') + '\\\\\\|', 'g');\n\n  return function (token) {\n    var match;\n    var scope;\n    var normalizedMatch;\n    var i, l;\n    var j, m;\n\n    for (i = 0, l = token[1].length; i < l; i++) {\n      scope = token[1][i];\n      match = scope[1].match(namespaceRegex);\n\n      for (j = 0, m = match.length; j < m; j++) {\n        normalizedMatch = match[j].substring(0, match[j].length - 1);\n\n        if (normalizedMatch in atRules) {\n          delete atRules[normalizedMatch];\n        }\n      }\n    }\n  };\n}\n\nmodule.exports = removeUnusedAtRules;\n","// TODO: it'd be great to merge it with the other canReorder functionality\n\nvar rulesOverlap = require('./rules-overlap');\nvar specificitiesOverlap = require('./specificities-overlap');\n\nvar FLEX_PROPERTIES = /align\\-items|box\\-align|box\\-pack|flex|justify/;\nvar BORDER_PROPERTIES = /^border\\-(top|right|bottom|left|color|style|width|radius)/;\n\nfunction canReorder(left, right, cache) {\n  for (var i = right.length - 1; i >= 0; i--) {\n    for (var j = left.length - 1; j >= 0; j--) {\n      if (!canReorderSingle(left[j], right[i], cache))\n        return false;\n    }\n  }\n\n  return true;\n}\n\nfunction canReorderSingle(left, right, cache) {\n  var leftName = left[0];\n  var leftValue = left[1];\n  var leftNameRoot = left[2];\n  var leftSelector = left[5];\n  var leftInSpecificSelector = left[6];\n  var rightName = right[0];\n  var rightValue = right[1];\n  var rightNameRoot = right[2];\n  var rightSelector = right[5];\n  var rightInSpecificSelector = right[6];\n\n  if (leftName == 'font' && rightName == 'line-height' || rightName == 'font' && leftName == 'line-height')\n    return false;\n  if (FLEX_PROPERTIES.test(leftName) && FLEX_PROPERTIES.test(rightName))\n    return false;\n  if (leftNameRoot == rightNameRoot && unprefixed(leftName) == unprefixed(rightName) && (vendorPrefixed(leftName) ^ vendorPrefixed(rightName)))\n    return false;\n  if (leftNameRoot == 'border' && BORDER_PROPERTIES.test(rightNameRoot) && (leftName == 'border' || leftName == rightNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName))))\n    return false;\n  if (rightNameRoot == 'border' && BORDER_PROPERTIES.test(leftNameRoot) && (rightName == 'border' || rightName == leftNameRoot || (leftValue != rightValue && sameBorderComponent(leftName, rightName))))\n    return false;\n  if (leftNameRoot == 'border' && rightNameRoot == 'border' && leftName != rightName && (isSideBorder(leftName) && isStyleBorder(rightName) || isStyleBorder(leftName) && isSideBorder(rightName)))\n    return false;\n  if (leftNameRoot != rightNameRoot)\n    return true;\n  if (leftName == rightName && leftNameRoot == rightNameRoot && (leftValue == rightValue || withDifferentVendorPrefix(leftValue, rightValue)))\n    return true;\n  if (leftName != rightName && leftNameRoot == rightNameRoot && leftName != leftNameRoot && rightName != rightNameRoot)\n    return true;\n  if (leftName != rightName && leftNameRoot == rightNameRoot && leftValue == rightValue)\n    return true;\n  if (rightInSpecificSelector && leftInSpecificSelector && !inheritable(leftNameRoot) && !inheritable(rightNameRoot) && !rulesOverlap(rightSelector, leftSelector, false))\n    return true;\n  if (!specificitiesOverlap(leftSelector, rightSelector, cache))\n    return true;\n\n  return false;\n}\n\nfunction vendorPrefixed(name) {\n  return /^\\-(?:moz|webkit|ms|o)\\-/.test(name);\n}\n\nfunction unprefixed(name) {\n  return name.replace(/^\\-(?:moz|webkit|ms|o)\\-/, '');\n}\n\nfunction sameBorderComponent(name1, name2) {\n  return name1.split('-').pop() == name2.split('-').pop();\n}\n\nfunction isSideBorder(name) {\n  return name == 'border-top' || name == 'border-right' || name == 'border-bottom' || name == 'border-left';\n}\n\nfunction isStyleBorder(name) {\n  return name == 'border-color' || name == 'border-style' || name == 'border-width';\n}\n\nfunction withDifferentVendorPrefix(value1, value2) {\n  return vendorPrefixed(value1) && vendorPrefixed(value2) && value1.split('-')[1] != value2.split('-')[2];\n}\n\nfunction inheritable(name) {\n  // According to http://www.w3.org/TR/CSS21/propidx.html\n  // Others will be catched by other, preceeding rules\n  return name == 'font' || name == 'line-height' || name == 'list-style';\n}\n\nmodule.exports = {\n  canReorder: canReorder,\n  canReorderSingle: canReorderSingle\n};\n","var configuration = require('../configuration');\n\nfunction restoreWithComponents(property) {\n  var descriptor = configuration[property.name];\n\n  if (descriptor && descriptor.shorthand) {\n    return descriptor.restore(property, configuration);\n  } else {\n    return property.value;\n  }\n}\n\nmodule.exports = restoreWithComponents;\n","var canReorderSingle = require('./reorderable').canReorderSingle;\nvar extractProperties = require('./extract-properties');\nvar isMergeable = require('./is-mergeable');\nvar tidyRuleDuplicates = require('./tidy-rule-duplicates');\n\nvar Token = require('../../tokenizer/token');\n\nvar cloneArray = require('../../utils/clone-array');\n\nvar serializeBody = require('../../writer/one-time').body;\nvar serializeRules = require('../../writer/one-time').rules;\n\nfunction naturalSorter(a, b) {\n  return a > b ? 1 : -1;\n}\n\nfunction cloneAndMergeSelectors(propertyA, propertyB) {\n  var cloned = cloneArray(propertyA);\n  cloned[5] = cloned[5].concat(propertyB[5]);\n\n  return cloned;\n}\n\nfunction restructure(tokens, context) {\n  var options = context.options;\n  var mergeablePseudoClasses = options.compatibility.selectors.mergeablePseudoClasses;\n  var mergeablePseudoElements = options.compatibility.selectors.mergeablePseudoElements;\n  var mergeLimit = options.compatibility.selectors.mergeLimit;\n  var multiplePseudoMerging = options.compatibility.selectors.multiplePseudoMerging;\n  var specificityCache = context.cache.specificity;\n  var movableTokens = {};\n  var movedProperties = [];\n  var multiPropertyMoveCache = {};\n  var movedToBeDropped = [];\n  var maxCombinationsLevel = 2;\n  var ID_JOIN_CHARACTER = '%';\n\n  function sendToMultiPropertyMoveCache(position, movedProperty, allFits) {\n    for (var i = allFits.length - 1; i >= 0; i--) {\n      var fit = allFits[i][0];\n      var id = addToCache(movedProperty, fit);\n\n      if (multiPropertyMoveCache[id].length > 1 && processMultiPropertyMove(position, multiPropertyMoveCache[id])) {\n        removeAllMatchingFromCache(id);\n        break;\n      }\n    }\n  }\n\n  function addToCache(movedProperty, fit) {\n    var id = cacheId(fit);\n    multiPropertyMoveCache[id] = multiPropertyMoveCache[id] || [];\n    multiPropertyMoveCache[id].push([movedProperty, fit]);\n    return id;\n  }\n\n  function removeAllMatchingFromCache(matchId) {\n    var matchSelectors = matchId.split(ID_JOIN_CHARACTER);\n    var forRemoval = [];\n    var i;\n\n    for (var id in multiPropertyMoveCache) {\n      var selectors = id.split(ID_JOIN_CHARACTER);\n      for (i = selectors.length - 1; i >= 0; i--) {\n        if (matchSelectors.indexOf(selectors[i]) > -1) {\n          forRemoval.push(id);\n          break;\n        }\n      }\n    }\n\n    for (i = forRemoval.length - 1; i >= 0; i--) {\n      delete multiPropertyMoveCache[forRemoval[i]];\n    }\n  }\n\n  function cacheId(cachedTokens) {\n    var id = [];\n    for (var i = 0, l = cachedTokens.length; i < l; i++) {\n      id.push(serializeRules(cachedTokens[i][1]));\n    }\n    return id.join(ID_JOIN_CHARACTER);\n  }\n\n  function tokensToMerge(sourceTokens) {\n    var uniqueTokensWithBody = [];\n    var mergeableTokens = [];\n\n    for (var i = sourceTokens.length - 1; i >= 0; i--) {\n      if (!isMergeable(serializeRules(sourceTokens[i][1]), mergeablePseudoClasses, mergeablePseudoElements, multiplePseudoMerging)) {\n        continue;\n      }\n\n      mergeableTokens.unshift(sourceTokens[i]);\n      if (sourceTokens[i][2].length > 0 && uniqueTokensWithBody.indexOf(sourceTokens[i]) == -1)\n        uniqueTokensWithBody.push(sourceTokens[i]);\n    }\n\n    return uniqueTokensWithBody.length > 1 ?\n      mergeableTokens :\n      [];\n  }\n\n  function shortenIfPossible(position, movedProperty) {\n    var name = movedProperty[0];\n    var value = movedProperty[1];\n    var key = movedProperty[4];\n    var valueSize = name.length + value.length + 1;\n    var allSelectors = [];\n    var qualifiedTokens = [];\n\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2)\n      return;\n\n    var allFits = findAllFits(mergeableTokens, valueSize, 1);\n    var bestFit = allFits[0];\n    if (bestFit[1] > 0)\n      return sendToMultiPropertyMoveCache(position, movedProperty, allFits);\n\n    for (var i = bestFit[0].length - 1; i >=0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, [movedProperty], allSelectors, qualifiedTokens);\n  }\n\n  function fitSorter(fit1, fit2) {\n    return fit1[1] > fit2[1] ? 1 : (fit1[1] == fit2[1] ? 0 : -1);\n  }\n\n  function findAllFits(mergeableTokens, propertySize, propertiesCount) {\n    var combinations = allCombinations(mergeableTokens, propertySize, propertiesCount, maxCombinationsLevel - 1);\n    return combinations.sort(fitSorter);\n  }\n\n  function allCombinations(tokensVariant, propertySize, propertiesCount, level) {\n    var differenceVariants = [[tokensVariant, sizeDifference(tokensVariant, propertySize, propertiesCount)]];\n    if (tokensVariant.length > 2 && level > 0) {\n      for (var i = tokensVariant.length - 1; i >= 0; i--) {\n        var subVariant = Array.prototype.slice.call(tokensVariant, 0);\n        subVariant.splice(i, 1);\n        differenceVariants = differenceVariants.concat(allCombinations(subVariant, propertySize, propertiesCount, level - 1));\n      }\n    }\n\n    return differenceVariants;\n  }\n\n  function sizeDifference(tokensVariant, propertySize, propertiesCount) {\n    var allSelectorsSize = 0;\n    for (var i = tokensVariant.length - 1; i >= 0; i--) {\n      allSelectorsSize += tokensVariant[i][2].length > propertiesCount ? serializeRules(tokensVariant[i][1]).length : -1;\n    }\n    return allSelectorsSize - (tokensVariant.length - 1) * propertySize + 1;\n  }\n\n  function dropAsNewTokenAt(position, properties, allSelectors, mergeableTokens) {\n    var i, j, k, m;\n    var allProperties = [];\n\n    for (i = mergeableTokens.length - 1; i >= 0; i--) {\n      var mergeableToken = mergeableTokens[i];\n\n      for (j = mergeableToken[2].length - 1; j >= 0; j--) {\n        var mergeableProperty = mergeableToken[2][j];\n\n        for (k = 0, m = properties.length; k < m; k++) {\n          var property = properties[k];\n\n          var mergeablePropertyName = mergeableProperty[1][1];\n          var propertyName = property[0];\n          var propertyBody = property[4];\n          if (mergeablePropertyName == propertyName && serializeBody([mergeableProperty]) == propertyBody) {\n            mergeableToken[2].splice(j, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      allProperties.unshift(properties[i][3]);\n    }\n\n    var newToken = [Token.RULE, allSelectors, allProperties];\n    tokens.splice(position, 0, newToken);\n  }\n\n  function dropPropertiesAt(position, movedProperty) {\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n\n    if (toMove && toMove.length > 1) {\n      if (!shortenMultiMovesIfPossible(position, movedProperty))\n        shortenIfPossible(position, movedProperty);\n    }\n  }\n\n  function shortenMultiMovesIfPossible(position, movedProperty) {\n    var candidates = [];\n    var propertiesAndMergableTokens = [];\n    var key = movedProperty[4];\n    var j, k;\n\n    var mergeableTokens = tokensToMerge(movableTokens[key]);\n    if (mergeableTokens.length < 2)\n      return;\n\n    movableLoop:\n    for (var value in movableTokens) {\n      var tokensList = movableTokens[value];\n\n      for (j = mergeableTokens.length - 1; j >= 0; j--) {\n        if (tokensList.indexOf(mergeableTokens[j]) == -1)\n          continue movableLoop;\n      }\n\n      candidates.push(value);\n    }\n\n    if (candidates.length < 2)\n      return false;\n\n    for (j = candidates.length - 1; j >= 0; j--) {\n      for (k = movedProperties.length - 1; k >= 0; k--) {\n        if (movedProperties[k][4] == candidates[j]) {\n          propertiesAndMergableTokens.unshift([movedProperties[k], mergeableTokens]);\n          break;\n        }\n      }\n    }\n\n    return processMultiPropertyMove(position, propertiesAndMergableTokens);\n  }\n\n  function processMultiPropertyMove(position, propertiesAndMergableTokens) {\n    var valueSize = 0;\n    var properties = [];\n    var property;\n\n    for (var i = propertiesAndMergableTokens.length - 1; i >= 0; i--) {\n      property = propertiesAndMergableTokens[i][0];\n      var fullValue = property[4];\n      valueSize += fullValue.length + (i > 0 ? 1 : 0);\n\n      properties.push(property);\n    }\n\n    var mergeableTokens = propertiesAndMergableTokens[0][1];\n    var bestFit = findAllFits(mergeableTokens, valueSize, properties.length)[0];\n    if (bestFit[1] > 0)\n      return false;\n\n    var allSelectors = [];\n    var qualifiedTokens = [];\n    for (i = bestFit[0].length - 1; i >= 0; i--) {\n      allSelectors = bestFit[0][i][1].concat(allSelectors);\n      qualifiedTokens.unshift(bestFit[0][i]);\n    }\n\n    allSelectors = tidyRuleDuplicates(allSelectors);\n    dropAsNewTokenAt(position, properties, allSelectors, qualifiedTokens);\n\n    for (i = properties.length - 1; i >= 0; i--) {\n      property = properties[i];\n      var index = movedProperties.indexOf(property);\n\n      delete movableTokens[property[4]];\n\n      if (index > -1 && movedToBeDropped.indexOf(index) == -1)\n        movedToBeDropped.push(index);\n    }\n\n    return true;\n  }\n\n  function boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) {\n    var propertyName = property[0];\n    var movedPropertyName = movedProperty[0];\n    if (propertyName != movedPropertyName)\n      return false;\n\n    var key = movedProperty[4];\n    var toMove = movableTokens[key];\n    return toMove && toMove.indexOf(token) > -1;\n  }\n\n  for (var i = tokens.length - 1; i >= 0; i--) {\n    var token = tokens[i];\n    var isRule;\n    var j, k, m;\n    var samePropertyAt;\n\n    if (token[0] == Token.RULE) {\n      isRule = true;\n    } else if (token[0] == Token.NESTED_BLOCK) {\n      isRule = false;\n    } else {\n      continue;\n    }\n\n    // We cache movedProperties.length as it may change in the loop\n    var movedCount = movedProperties.length;\n\n    var properties = extractProperties(token);\n    movedToBeDropped = [];\n\n    var unmovableInCurrentToken = [];\n    for (j = properties.length - 1; j >= 0; j--) {\n      for (k = j - 1; k >= 0; k--) {\n        if (!canReorderSingle(properties[j], properties[k], specificityCache)) {\n          unmovableInCurrentToken.push(j);\n          break;\n        }\n      }\n    }\n\n    for (j = properties.length - 1; j >= 0; j--) {\n      var property = properties[j];\n      var movedSameProperty = false;\n\n      for (k = 0; k < movedCount; k++) {\n        var movedProperty = movedProperties[k];\n\n        if (movedToBeDropped.indexOf(k) == -1 && (!canReorderSingle(property, movedProperty, specificityCache) && !boundToAnotherPropertyInCurrrentToken(property, movedProperty, token) ||\n            movableTokens[movedProperty[4]] && movableTokens[movedProperty[4]].length === mergeLimit)) {\n          dropPropertiesAt(i + 1, movedProperty);\n\n          if (movedToBeDropped.indexOf(k) == -1) {\n            movedToBeDropped.push(k);\n            delete movableTokens[movedProperty[4]];\n          }\n        }\n\n        if (!movedSameProperty) {\n          movedSameProperty = property[0] == movedProperty[0] && property[1] == movedProperty[1];\n\n          if (movedSameProperty) {\n            samePropertyAt = k;\n          }\n        }\n      }\n\n      if (!isRule || unmovableInCurrentToken.indexOf(j) > -1)\n        continue;\n\n      var key = property[4];\n\n      if (movedSameProperty && movedProperties[samePropertyAt][5].length + property[5].length > mergeLimit) {\n        dropPropertiesAt(i + 1, movedProperties[samePropertyAt]);\n        movedProperties.splice(samePropertyAt, 1);\n        movableTokens[key] = [token];\n        movedSameProperty = false;\n      } else {\n        movableTokens[key] = movableTokens[key] || [];\n        movableTokens[key].push(token);\n      }\n\n      if (movedSameProperty) {\n        movedProperties[samePropertyAt] = cloneAndMergeSelectors(movedProperties[samePropertyAt], property);\n      } else {\n        movedProperties.push(property);\n      }\n    }\n\n    movedToBeDropped = movedToBeDropped.sort(naturalSorter);\n    for (j = 0, m = movedToBeDropped.length; j < m; j++) {\n      var dropAt = movedToBeDropped[j] - j;\n      movedProperties.splice(dropAt, 1);\n    }\n  }\n\n  var position = tokens[0] && tokens[0][0] == Token.AT_RULE && tokens[0][1].indexOf('@charset') === 0 ? 1 : 0;\n  for (; position < tokens.length - 1; position++) {\n    var isImportRule = tokens[position][0] === Token.AT_RULE && tokens[position][1].indexOf('@import') === 0;\n    var isComment = tokens[position][0] === Token.COMMENT;\n    if (!(isImportRule || isComment))\n      break;\n  }\n\n  for (i = 0; i < movedProperties.length; i++) {\n    dropPropertiesAt(position, movedProperties[i]);\n  }\n}\n\nmodule.exports = restructure;\n","var MODIFIER_PATTERN = /\\-\\-.+$/;\n\nfunction rulesOverlap(rule1, rule2, bemMode) {\n  var scope1;\n  var scope2;\n  var i, l;\n  var j, m;\n\n  for (i = 0, l = rule1.length; i < l; i++) {\n    scope1 = rule1[i][1];\n\n    for (j = 0, m = rule2.length; j < m; j++) {\n      scope2 = rule2[j][1];\n\n      if (scope1 == scope2) {\n        return true;\n      }\n\n      if (bemMode && withoutModifiers(scope1) == withoutModifiers(scope2)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction withoutModifiers(scope) {\n  return scope.replace(MODIFIER_PATTERN, '');\n}\n\nmodule.exports = rulesOverlap;\n","var specificity = require('./specificity');\n\nfunction specificitiesOverlap(selector1, selector2, cache) {\n  var specificity1;\n  var specificity2;\n  var i, l;\n  var j, m;\n\n  for (i = 0, l = selector1.length; i < l; i++) {\n    specificity1 = findSpecificity(selector1[i][1], cache);\n\n    for (j = 0, m = selector2.length; j < m; j++) {\n      specificity2 = findSpecificity(selector2[j][1], cache);\n\n      if (specificity1[0] === specificity2[0] && specificity1[1] === specificity2[1] && specificity1[2] === specificity2[2]) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction findSpecificity(selector, cache) {\n  var value;\n\n  if (!(selector in cache)) {\n    cache[selector] = value = specificity(selector);\n  }\n\n  return value || cache[selector];\n}\n\nmodule.exports = specificitiesOverlap;\n","var Marker = require('../../tokenizer/marker');\n\nvar Selector = {\n  ADJACENT_SIBLING: '+',\n  DESCENDANT: '>',\n  DOT: '.',\n  HASH: '#',\n  NON_ADJACENT_SIBLING: '~',\n  PSEUDO: ':'\n};\n\nvar LETTER_PATTERN = /[a-zA-Z]/;\nvar NOT_PREFIX = ':not(';\nvar SEPARATOR_PATTERN = /[\\s,\\(>~\\+]/;\n\nfunction specificity(selector) {\n  var result = [0, 0, 0];\n  var character;\n  var isEscaped;\n  var isSingleQuoted;\n  var isDoubleQuoted;\n  var roundBracketLevel = 0;\n  var couldIntroduceNewTypeSelector;\n  var withinNotPseudoClass = false;\n  var wasPseudoClass = false;\n  var i, l;\n\n  for (i = 0, l = selector.length; i < l; i++) {\n    character = selector[i];\n\n    if (isEscaped) {\n      // noop\n    } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {\n      isSingleQuoted = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isDoubleQuoted && isSingleQuoted) {\n      isSingleQuoted = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isDoubleQuoted && !isSingleQuoted) {\n      isDoubleQuoted = true;\n    } else if (character == Marker.DOUBLE_QUOTE && isDoubleQuoted && !isSingleQuoted) {\n      isDoubleQuoted = false;\n    } else if (isSingleQuoted || isDoubleQuoted) {\n      continue;\n    } else if (roundBracketLevel > 0 && !withinNotPseudoClass) {\n      // noop\n    } else if (character == Marker.OPEN_ROUND_BRACKET) {\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && roundBracketLevel == 1) {\n      roundBracketLevel--;\n      withinNotPseudoClass = false;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET) {\n      roundBracketLevel--;\n    } else if (character == Selector.HASH) {\n      result[0]++;\n    } else if (character == Selector.DOT || character == Marker.OPEN_SQUARE_BRACKET) {\n      result[1]++;\n    } else if (character == Selector.PSEUDO && !wasPseudoClass && !isNotPseudoClass(selector, i)) {\n      result[1]++;\n      withinNotPseudoClass = false;\n    } else if (character == Selector.PSEUDO) {\n      withinNotPseudoClass = true;\n    } else if ((i === 0 || couldIntroduceNewTypeSelector) && LETTER_PATTERN.test(character)) {\n      result[2]++;\n    }\n\n    isEscaped = character == Marker.BACK_SLASH;\n    wasPseudoClass = character == Selector.PSEUDO;\n    couldIntroduceNewTypeSelector = !isEscaped && SEPARATOR_PATTERN.test(character);\n  }\n\n  return result;\n}\n\nfunction isNotPseudoClass(selector, index) {\n  return selector.indexOf(NOT_PREFIX, index) === index;\n}\n\nmodule.exports = specificity;\n","function ruleSorter(s1, s2) {\n  return s1[1] > s2[1] ? 1 : -1;\n}\n\nfunction tidyRuleDuplicates(rules) {\n  var list = [];\n  var repeated = [];\n\n  for (var i = 0, l = rules.length; i < l; i++) {\n    var rule = rules[i];\n\n    if (repeated.indexOf(rule[1]) == -1) {\n      repeated.push(rule[1]);\n      list.push(rule);\n    }\n  }\n\n  return list.sort(ruleSorter);\n}\n\nmodule.exports = tidyRuleDuplicates;\n","function removeUnused(properties) {\n  for (var i = properties.length - 1; i >= 0; i--) {\n    var property = properties[i];\n\n    if (property.unused) {\n      property.all.splice(property.position, 1);\n    }\n  }\n}\n\nmodule.exports = removeUnused;\n","var Hack = require('./hack');\n\nvar Marker = require('../tokenizer/marker');\n\nvar ASTERISK_HACK = '*';\nvar BACKSLASH_HACK = '\\\\';\nvar IMPORTANT_TOKEN = '!important';\nvar UNDERSCORE_HACK = '_';\nvar BANG_HACK = '!ie';\n\nfunction restoreFromOptimizing(properties, restoreCallback) {\n  var property;\n  var restored;\n  var current;\n  var i;\n\n  for (i = properties.length - 1; i >= 0; i--) {\n    property = properties[i];\n\n    if (property.dynamic && property.important) {\n      restoreImportant(property);\n      continue;\n    }\n\n    if (property.dynamic) {\n      continue;\n    }\n\n    if (property.unused) {\n      continue;\n    }\n\n    if (!property.dirty && !property.important && !property.hack) {\n      continue;\n    }\n\n    if (property.optimizable && restoreCallback) {\n      restored = restoreCallback(property);\n      property.value = restored;\n    } else {\n      restored = property.value;\n    }\n\n    if (property.important) {\n      restoreImportant(property);\n    }\n\n    if (property.hack) {\n      restoreHack(property);\n    }\n\n    if ('all' in property) {\n      current = property.all[property.position];\n      current[1][1] = property.name;\n\n      current.splice(2, current.length - 1);\n      Array.prototype.push.apply(current, restored);\n    }\n  }\n}\n\nfunction restoreImportant(property) {\n  property.value[property.value.length - 1][1] += IMPORTANT_TOKEN;\n}\n\nfunction restoreHack(property) {\n  if (property.hack[0] == Hack.UNDERSCORE) {\n    property.name = UNDERSCORE_HACK + property.name;\n  } else if (property.hack[0] == Hack.ASTERISK) {\n    property.name = ASTERISK_HACK + property.name;\n  } else if (property.hack[0] == Hack.BACKSLASH) {\n    property.value[property.value.length - 1][1] += BACKSLASH_HACK + property.hack[1];\n  } else if (property.hack[0] == Hack.BANG) {\n    property.value[property.value.length - 1][1] += Marker.SPACE + BANG_HACK;\n  }\n}\n\nmodule.exports = restoreFromOptimizing;\n","var functionNoVendorRegexStr = '[A-Z]+(\\\\-|[A-Z]|[0-9])+\\\\(.*?\\\\)';\nvar functionVendorRegexStr = '\\\\-(\\\\-|[A-Z]|[0-9])+\\\\(.*?\\\\)';\nvar variableRegexStr = 'var\\\\(\\\\-\\\\-[^\\\\)]+\\\\)';\nvar functionAnyRegexStr = '(' + variableRegexStr + '|' + functionNoVendorRegexStr + '|' + functionVendorRegexStr + ')';\n\nvar calcRegex = new RegExp('^(\\\\-moz\\\\-|\\\\-webkit\\\\-)?calc\\\\([^\\\\)]+\\\\)$', 'i');\nvar decimalRegex = /[0-9]/;\nvar functionAnyRegex = new RegExp('^' + functionAnyRegexStr + '$', 'i');\nvar hexAlphaColorRegex = /^#(?:[0-9a-f]{4}|[0-9a-f]{8})$/i;\nvar hslColorRegex = /^hsl\\(\\s{0,31}[\\-\\.]?\\d+\\s{0,31},\\s{0,31}\\d*\\.?\\d+%\\s{0,31},\\s{0,31}\\d*\\.?\\d+%\\s{0,31}\\)|hsla\\(\\s{0,31}[\\-\\.]?\\d+\\s{0,31},\\s{0,31}\\d*\\.?\\d+%\\s{0,31},\\s{0,31}\\d*\\.?\\d+%\\s{0,31},\\s{0,31}\\.?\\d+\\s{0,31}\\)$/;\nvar identifierRegex = /^(\\-[a-z0-9_][a-z0-9\\-_]*|[a-z_][a-z0-9\\-_]*)$/i;\nvar namedEntityRegex = /^[a-z]+$/i;\nvar prefixRegex = /^-([a-z0-9]|-)*$/i;\nvar quotedTextRegex = /^(\"[^\"]*\"|'[^']*')$/i;\nvar rgbColorRegex = /^rgb\\(\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31}\\)|rgba\\(\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\d]{1,3}\\s{0,31},\\s{0,31}[\\.\\d]+\\s{0,31}\\)$/i;\nvar timeUnitPattern = /\\d+(s|ms)/;\nvar timingFunctionRegex = /^(cubic\\-bezier|steps)\\([^\\)]+\\)$/;\nvar validTimeUnits = ['ms', 's'];\nvar urlRegex = /^url\\([\\s\\S]+\\)$/i;\nvar variableRegex = new RegExp('^' + variableRegexStr + '$', 'i');\n\nvar eightValueColorRegex = /^#[0-9a-f]{8}$/i;\nvar fourValueColorRegex = /^#[0-9a-f]{4}$/i;\nvar sixValueColorRegex = /^#[0-9a-f]{6}$/i;\nvar threeValueColorRegex = /^#[0-9a-f]{3}$/i;\n\nvar DECIMAL_DOT = '.';\nvar MINUS_SIGN = '-';\nvar PLUS_SIGN = '+';\n\nvar Keywords = {\n  '^': [\n    'inherit',\n    'initial',\n    'unset'\n  ],\n  '*-style': [\n    'auto',\n    'dashed',\n    'dotted',\n    'double',\n    'groove',\n    'hidden',\n    'inset',\n    'none',\n    'outset',\n    'ridge',\n    'solid'\n  ],\n  '*-timing-function': [\n    'ease',\n    'ease-in',\n    'ease-in-out',\n    'ease-out',\n    'linear',\n    'step-end',\n    'step-start'\n  ],\n  'animation-direction': [\n    'alternate',\n    'alternate-reverse',\n    'normal',\n    'reverse'\n  ],\n  'animation-fill-mode': [\n    'backwards',\n    'both',\n    'forwards',\n    'none'\n  ],\n  'animation-iteration-count': [\n    'infinite'\n  ],\n  'animation-name': [\n    'none'\n  ],\n  'animation-play-state': [\n    'paused',\n    'running'\n  ],\n  'background-attachment': [\n    'fixed',\n    'inherit',\n    'local',\n    'scroll'\n  ],\n  'background-clip': [\n    'border-box',\n    'content-box',\n    'inherit',\n    'padding-box',\n    'text'\n  ],\n  'background-origin': [\n    'border-box',\n    'content-box',\n    'inherit',\n    'padding-box'\n  ],\n  'background-position': [\n    'bottom',\n    'center',\n    'left',\n    'right',\n    'top'\n  ],\n  'background-repeat': [\n    'no-repeat',\n    'inherit',\n    'repeat',\n    'repeat-x',\n    'repeat-y',\n    'round',\n    'space'\n  ],\n  'background-size': [\n    'auto',\n    'cover',\n    'contain'\n  ],\n  'border-collapse': [\n    'collapse',\n    'inherit',\n    'separate'\n  ],\n  'bottom': [\n    'auto'\n  ],\n  'clear': [\n    'both',\n    'left',\n    'none',\n    'right'\n  ],\n  'color': [\n    'transparent'\n  ],\n  'cursor': [\n    'all-scroll',\n    'auto',\n    'col-resize',\n    'crosshair',\n    'default',\n    'e-resize',\n    'help',\n    'move',\n    'n-resize',\n    'ne-resize',\n    'no-drop',\n    'not-allowed',\n    'nw-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    's-resize',\n    'se-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'w-resize',\n    'wait'\n  ],\n  'display': [\n    'block',\n    'inline',\n    'inline-block',\n    'inline-table',\n    'list-item',\n    'none',\n    'table',\n    'table-caption',\n    'table-cell',\n    'table-column',\n    'table-column-group',\n    'table-footer-group',\n    'table-header-group',\n    'table-row',\n    'table-row-group'\n  ],\n  'float': [\n    'left',\n    'none',\n    'right'\n  ],\n  'left': [\n    'auto'\n  ],\n  'font': [\n    'caption',\n    'icon',\n    'menu',\n    'message-box',\n    'small-caption',\n    'status-bar',\n    'unset'\n  ],\n  'font-size': [\n    'large',\n    'larger',\n    'medium',\n    'small',\n    'smaller',\n    'x-large',\n    'x-small',\n    'xx-large',\n    'xx-small'\n  ],\n  'font-stretch': [\n    'condensed',\n    'expanded',\n    'extra-condensed',\n    'extra-expanded',\n    'normal',\n    'semi-condensed',\n    'semi-expanded',\n    'ultra-condensed',\n    'ultra-expanded'\n  ],\n  'font-style': [\n    'italic',\n    'normal',\n    'oblique'\n  ],\n  'font-variant': [\n    'normal',\n    'small-caps'\n  ],\n  'font-weight': [\n    '100',\n    '200',\n    '300',\n    '400',\n    '500',\n    '600',\n    '700',\n    '800',\n    '900',\n    'bold',\n    'bolder',\n    'lighter',\n    'normal'\n  ],\n  'line-height': [\n    'normal'\n  ],\n  'list-style-position': [\n    'inside',\n    'outside'\n  ],\n  'list-style-type': [\n    'armenian',\n    'circle',\n    'decimal',\n    'decimal-leading-zero',\n    'disc',\n    'decimal|disc', // this is the default value of list-style-type, see comment in configuration.js\n    'georgian',\n    'lower-alpha',\n    'lower-greek',\n    'lower-latin',\n    'lower-roman',\n    'none',\n    'square',\n    'upper-alpha',\n    'upper-latin',\n    'upper-roman'\n  ],\n  'overflow': [\n    'auto',\n    'hidden',\n    'scroll',\n    'visible'\n  ],\n  'position': [\n    'absolute',\n    'fixed',\n    'relative',\n    'static'\n  ],\n  'right': [\n    'auto'\n  ],\n  'text-align': [\n    'center',\n    'justify',\n    'left',\n    'left|right', // this is the default value of list-style-type, see comment in configuration.js\n    'right'\n  ],\n  'text-decoration': [\n    'line-through',\n    'none',\n    'overline',\n    'underline'\n  ],\n  'text-overflow': [\n    'clip',\n    'ellipsis'\n  ],\n  'top': [\n    'auto'\n  ],\n  'vertical-align': [\n    'baseline',\n    'bottom',\n    'middle',\n    'sub',\n    'super',\n    'text-bottom',\n    'text-top',\n    'top'\n  ],\n  'visibility': [\n    'collapse',\n    'hidden',\n    'visible'\n  ],\n  'white-space': [\n    'normal',\n    'nowrap',\n    'pre'\n  ],\n  'width': [\n    'inherit',\n    'initial',\n    'medium',\n    'thick',\n    'thin'\n  ]\n};\n\nvar Units = [\n  '%',\n  'ch',\n  'cm',\n  'em',\n  'ex',\n  'in',\n  'mm',\n  'pc',\n  'pt',\n  'px',\n  'rem',\n  'vh',\n  'vm',\n  'vmax',\n  'vmin',\n  'vw'\n];\n\nfunction isColor(value) {\n  return value != 'auto' &&\n    (\n      isKeyword('color')(value) ||\n      isHexColor(value) ||\n      isColorFunction(value) ||\n      isNamedEntity(value)\n    );\n}\n\nfunction isColorFunction(value) {\n  return isRgbColor(value) || isHslColor(value);\n}\n\nfunction isDynamicUnit(value) {\n  return calcRegex.test(value);\n}\n\nfunction isFunction(value) {\n  return functionAnyRegex.test(value);\n}\n\nfunction isHexColor(value) {\n  return threeValueColorRegex.test(value) || fourValueColorRegex.test(value) || sixValueColorRegex.test(value) || eightValueColorRegex.test(value);\n}\n\nfunction isHslColor(value) {\n  return hslColorRegex.test(value);\n}\n\nfunction isHexAlphaColor(value) {\n  return hexAlphaColorRegex.test(value);\n}\n\nfunction isIdentifier(value) {\n  return identifierRegex.test(value);\n}\n\nfunction isQuotedText(value) {\n  return quotedTextRegex.test(value);\n}\n\nfunction isImage(value) {\n  return value == 'none' || value == 'inherit' || isUrl(value);\n}\n\nfunction isKeyword(propertyName) {\n  return function(value) {\n    return Keywords[propertyName].indexOf(value) > -1;\n  };\n}\n\nfunction isNamedEntity(value) {\n  return namedEntityRegex.test(value);\n}\n\nfunction isNumber(value) {\n  return scanForNumber(value) == value.length;\n}\n\nfunction isRgbColor(value) {\n  return rgbColorRegex.test(value);\n}\n\nfunction isPrefixed(value) {\n  return prefixRegex.test(value);\n}\n\nfunction isPositiveNumber(value) {\n  return isNumber(value) &&\n    parseFloat(value) >= 0;\n}\n\nfunction isVariable(value) {\n  return variableRegex.test(value);\n}\n\nfunction isTime(value) {\n  var numberUpTo = scanForNumber(value);\n\n  return numberUpTo == value.length && parseInt(value) === 0 ||\n    numberUpTo > -1 && validTimeUnits.indexOf(value.slice(numberUpTo + 1)) > -1 ||\n    isCalculatedTime(value);\n}\n\nfunction isCalculatedTime(value) {\n  return isFunction(value) && timeUnitPattern.test(value);\n}\n\nfunction isTimingFunction() {\n  var isTimingFunctionKeyword = isKeyword('*-timing-function');\n\n  return function (value) {\n    return isTimingFunctionKeyword(value) || timingFunctionRegex.test(value);\n  };\n}\n\nfunction isUnit(validUnits, value) {\n  var numberUpTo = scanForNumber(value);\n\n  return numberUpTo == value.length && parseInt(value) === 0 ||\n    numberUpTo > -1 && validUnits.indexOf(value.slice(numberUpTo + 1).toLowerCase()) > -1 ||\n    value == 'auto' ||\n    value == 'inherit';\n}\n\nfunction isUrl(value) {\n  return urlRegex.test(value);\n}\n\nfunction isZIndex(value) {\n  return value == 'auto' ||\n    isNumber(value) ||\n    isKeyword('^')(value);\n}\n\nfunction scanForNumber(value) {\n  var hasDot = false;\n  var hasSign = false;\n  var character;\n  var i, l;\n\n  for (i = 0, l = value.length; i < l; i++) {\n    character = value[i];\n\n    if (i === 0 && (character == PLUS_SIGN || character == MINUS_SIGN)) {\n      hasSign = true;\n    } else if (i > 0 && hasSign && (character == PLUS_SIGN || character == MINUS_SIGN)) {\n      return i - 1;\n    } else if (character == DECIMAL_DOT && !hasDot) {\n      hasDot = true;\n    } else if (character == DECIMAL_DOT && hasDot) {\n      return i - 1;\n    } else if (decimalRegex.test(character)) {\n      continue;\n    } else {\n      return i - 1;\n    }\n  }\n\n  return i;\n}\n\nfunction validator(compatibility) {\n  var validUnits = Units.slice(0).filter(function (value) {\n    return !(value in compatibility.units) || compatibility.units[value] === true;\n  });\n\n  if (compatibility.customUnits.rpx) {\n    validUnits.push('rpx');\n  }\n\n  return {\n    colorOpacity: compatibility.colors.opacity,\n    colorHexAlpha: compatibility.colors.hexAlpha,\n    isAnimationDirectionKeyword: isKeyword('animation-direction'),\n    isAnimationFillModeKeyword: isKeyword('animation-fill-mode'),\n    isAnimationIterationCountKeyword: isKeyword('animation-iteration-count'),\n    isAnimationNameKeyword: isKeyword('animation-name'),\n    isAnimationPlayStateKeyword: isKeyword('animation-play-state'),\n    isTimingFunction: isTimingFunction(),\n    isBackgroundAttachmentKeyword: isKeyword('background-attachment'),\n    isBackgroundClipKeyword: isKeyword('background-clip'),\n    isBackgroundOriginKeyword: isKeyword('background-origin'),\n    isBackgroundPositionKeyword: isKeyword('background-position'),\n    isBackgroundRepeatKeyword: isKeyword('background-repeat'),\n    isBackgroundSizeKeyword: isKeyword('background-size'),\n    isColor: isColor,\n    isColorFunction: isColorFunction,\n    isDynamicUnit: isDynamicUnit,\n    isFontKeyword: isKeyword('font'),\n    isFontSizeKeyword: isKeyword('font-size'),\n    isFontStretchKeyword: isKeyword('font-stretch'),\n    isFontStyleKeyword: isKeyword('font-style'),\n    isFontVariantKeyword: isKeyword('font-variant'),\n    isFontWeightKeyword: isKeyword('font-weight'),\n    isFunction: isFunction,\n    isGlobal: isKeyword('^'),\n    isHexAlphaColor: isHexAlphaColor,\n    isHslColor: isHslColor,\n    isIdentifier: isIdentifier,\n    isImage: isImage,\n    isKeyword: isKeyword,\n    isLineHeightKeyword: isKeyword('line-height'),\n    isListStylePositionKeyword: isKeyword('list-style-position'),\n    isListStyleTypeKeyword: isKeyword('list-style-type'),\n    isNumber: isNumber,\n    isPrefixed: isPrefixed,\n    isPositiveNumber: isPositiveNumber,\n    isQuotedText: isQuotedText,\n    isRgbColor: isRgbColor,\n    isStyleKeyword: isKeyword('*-style'),\n    isTime: isTime,\n    isUnit: isUnit.bind(null, validUnits),\n    isUrl: isUrl,\n    isVariable: isVariable,\n    isWidth: isKeyword('width'),\n    isZIndex: isZIndex\n  };\n}\n\nmodule.exports = validator;\n","var VENDOR_PREFIX_PATTERN = /(?:^|\\W)(\\-\\w+\\-)/g;\n\nfunction unique(value) {\n  var prefixes = [];\n  var match;\n\n  while ((match = VENDOR_PREFIX_PATTERN.exec(value)) !== null) {\n    if (prefixes.indexOf(match[0]) == -1) {\n      prefixes.push(match[0]);\n    }\n  }\n\n  return prefixes;\n}\n\nfunction same(value1, value2) {\n  return unique(value1).sort().join(',') == unique(value2).sort().join(',');\n}\n\nmodule.exports = {\n  unique: unique,\n  same: same\n};\n","var Hack = require('./hack');\n\nvar Marker = require('../tokenizer/marker');\nvar Token = require('../tokenizer/token');\n\nvar Match = {\n  ASTERISK: '*',\n  BACKSLASH: '\\\\',\n  BANG: '!',\n  BANG_SUFFIX_PATTERN: /!\\w+$/,\n  IMPORTANT_TOKEN: '!important',\n  IMPORTANT_TOKEN_PATTERN: new RegExp('!important$', 'i'),\n  IMPORTANT_WORD: 'important',\n  IMPORTANT_WORD_PATTERN: new RegExp('important$', 'i'),\n  SUFFIX_BANG_PATTERN: /!$/,\n  UNDERSCORE: '_',\n  VARIABLE_REFERENCE_PATTERN: /var\\(--.+\\)$/\n};\n\nfunction wrapAll(properties, skipProperties) {\n  var wrapped = [];\n  var single;\n  var property;\n  var i;\n\n  for (i = properties.length - 1; i >= 0; i--) {\n    property = properties[i];\n\n    if (property[0] != Token.PROPERTY) {\n      continue;\n    }\n\n    if (skipProperties && skipProperties.indexOf(property[1][1]) > -1) {\n      continue;\n    }\n\n    single = wrapSingle(property);\n    single.all = properties;\n    single.position = i;\n    wrapped.unshift(single);\n  }\n\n  return wrapped;\n}\n\nfunction someVariableReferences(property) {\n  var i, l;\n  var value;\n\n  // skipping `property` and property name tokens\n  for (i = 2, l = property.length; i < l; i++) {\n    value = property[i];\n\n    if (value[0] != Token.PROPERTY_VALUE) {\n      continue;\n    }\n\n    if (isVariableReference(value[1])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction isVariableReference(value) {\n  return Match.VARIABLE_REFERENCE_PATTERN.test(value);\n}\n\nfunction isMultiplex(property) {\n  var value;\n  var i, l;\n\n  for (i = 3, l = property.length; i < l; i++) {\n    value = property[i];\n\n    if (value[0] == Token.PROPERTY_VALUE && (value[1] == Marker.COMMA || value[1] == Marker.FORWARD_SLASH)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hackFrom(property) {\n  var match = false;\n  var name = property[1][1];\n  var lastValue = property[property.length - 1];\n\n  if (name[0] == Match.UNDERSCORE) {\n    match = [Hack.UNDERSCORE];\n  } else if (name[0] == Match.ASTERISK) {\n    match = [Hack.ASTERISK];\n  } else if (lastValue[1][0] == Match.BANG && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN)) {\n    match = [Hack.BANG];\n  } else if (lastValue[1].indexOf(Match.BANG) > 0 && !lastValue[1].match(Match.IMPORTANT_WORD_PATTERN) && Match.BANG_SUFFIX_PATTERN.test(lastValue[1])) {\n    match = [Hack.BANG];\n  } else if (lastValue[1].indexOf(Match.BACKSLASH) > 0 && lastValue[1].indexOf(Match.BACKSLASH) == lastValue[1].length - Match.BACKSLASH.length - 1) {\n    match = [Hack.BACKSLASH, lastValue[1].substring(lastValue[1].indexOf(Match.BACKSLASH) + 1)];\n  } else if (lastValue[1].indexOf(Match.BACKSLASH) === 0 && lastValue[1].length == 2) {\n    match = [Hack.BACKSLASH, lastValue[1].substring(1)];\n  }\n\n  return match;\n}\n\nfunction isImportant(property) {\n  if (property.length < 3)\n    return false;\n\n  var lastValue = property[property.length - 1];\n  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {\n    return true;\n  } else if (Match.IMPORTANT_WORD_PATTERN.test(lastValue[1]) && Match.SUFFIX_BANG_PATTERN.test(property[property.length - 2][1])) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction stripImportant(property) {\n  var lastValue = property[property.length - 1];\n  var oneButLastValue = property[property.length - 2];\n\n  if (Match.IMPORTANT_TOKEN_PATTERN.test(lastValue[1])) {\n    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_TOKEN_PATTERN, '');\n  } else {\n    lastValue[1] = lastValue[1].replace(Match.IMPORTANT_WORD_PATTERN, '');\n    oneButLastValue[1] = oneButLastValue[1].replace(Match.SUFFIX_BANG_PATTERN, '');\n  }\n\n  if (lastValue[1].length === 0) {\n    property.pop();\n  }\n\n  if (oneButLastValue[1].length === 0) {\n    property.pop();\n  }\n}\n\nfunction stripPrefixHack(property) {\n  property[1][1] = property[1][1].substring(1);\n}\n\nfunction stripSuffixHack(property, hackFrom) {\n  var lastValue = property[property.length - 1];\n  lastValue[1] = lastValue[1]\n    .substring(0, lastValue[1].indexOf(hackFrom[0] == Hack.BACKSLASH ? Match.BACKSLASH : Match.BANG))\n    .trim();\n\n  if (lastValue[1].length === 0) {\n    property.pop();\n  }\n}\n\nfunction wrapSingle(property) {\n  var importantProperty = isImportant(property);\n  if (importantProperty) {\n    stripImportant(property);\n  }\n\n  var whichHack = hackFrom(property);\n  if (whichHack[0] == Hack.ASTERISK || whichHack[0] == Hack.UNDERSCORE) {\n    stripPrefixHack(property);\n  } else if (whichHack[0] == Hack.BACKSLASH || whichHack[0] == Hack.BANG) {\n    stripSuffixHack(property, whichHack);\n  }\n\n  return {\n    block: property[2] && property[2][0] == Token.PROPERTY_BLOCK,\n    components: [],\n    dirty: false,\n    dynamic: someVariableReferences(property),\n    hack: whichHack,\n    important: importantProperty,\n    name: property[1][1],\n    multiplex: property.length > 3 ? isMultiplex(property) : false,\n    optimizable: true,\n    position: 0,\n    shorthand: false,\n    unused: false,\n    value: property.slice(2)\n  };\n}\n\nmodule.exports = {\n  all: wrapAll,\n  single: wrapSingle\n};\n","var DEFAULTS = {\n  '*': {\n    colors: {\n      hexAlpha: false, // 4- and 8-character hex notation\n      opacity: true // rgba / hsla\n    },\n    customUnits: {\n      rpx: false\n    },\n    properties: {\n      backgroundClipMerging: true, // background-clip to shorthand\n      backgroundOriginMerging: true, // background-origin to shorthand\n      backgroundSizeMerging: true, // background-size to shorthand\n      colors: true, // any kind of color transformations, like `#ff00ff` to `#f0f` or `#fff` into `red`\n      ieBangHack: false, // !ie suffix hacks on IE<8\n      ieFilters: false, // whether to preserve `filter` and `-ms-filter` properties\n      iePrefixHack: false, // underscore / asterisk prefix hacks on IE\n      ieSuffixHack: false, // \\9 suffix hacks on IE6-9, \\0 suffix hack on IE6-11\n      merging: true, // merging properties into one\n      shorterLengthUnits: false, // optimize pixel units into `pt`, `pc` or `in` units\n      spaceAfterClosingBrace: true, // 'url() no-repeat' to 'url()no-repeat'\n      urlQuotes: true, // whether to wrap content of `url()` into quotes or not\n      zeroUnits: true // 0[unit] -> 0\n    },\n    selectors: {\n      adjacentSpace: false, // div+ nav Android stock browser hack\n      ie7Hack: false, // *+html hack\n      mergeablePseudoClasses: [\n        ':active',\n        ':after',\n        ':before',\n        ':empty',\n        ':checked',\n        ':disabled',\n        ':empty',\n        ':enabled',\n        ':first-child',\n        ':first-letter',\n        ':first-line',\n        ':first-of-type',\n        ':focus',\n        ':hover',\n        ':lang',\n        ':last-child',\n        ':last-of-type',\n        ':link',\n        ':not',\n        ':nth-child',\n        ':nth-last-child',\n        ':nth-last-of-type',\n        ':nth-of-type',\n        ':only-child',\n        ':only-of-type',\n        ':root',\n        ':target',\n        ':visited'\n      ], // selectors with these pseudo-classes can be merged as these are universally supported\n      mergeablePseudoElements: [\n        '::after',\n        '::before',\n        '::first-letter',\n        '::first-line'\n      ], // selectors with these pseudo-elements can be merged as these are universally supported\n      mergeLimit: 8191, // number of rules that can be safely merged together\n      multiplePseudoMerging: true\n    },\n    units: {\n      ch: true,\n      in: true,\n      pc: true,\n      pt: true,\n      rem: true,\n      vh: true,\n      vm: true, // vm is vmin on IE9+ see https://developer.mozilla.org/en-US/docs/Web/CSS/length\n      vmax: true,\n      vmin: true,\n      vw: true\n    }\n  }\n};\n\nDEFAULTS.ie11 = merge(DEFAULTS['*'], {\n  properties: {\n    ieSuffixHack: true\n  }\n});\n\nDEFAULTS.ie10 = merge(DEFAULTS['*'], {\n  properties: {\n    ieSuffixHack: true\n  }\n});\n\nDEFAULTS.ie9 = merge(DEFAULTS['*'], {\n  properties: {\n    ieFilters: true,\n    ieSuffixHack: true\n  }\n});\n\nDEFAULTS.ie8 = merge(DEFAULTS.ie9, {\n  colors: {\n    opacity: false\n  },\n  properties: {\n    backgroundClipMerging: false,\n    backgroundOriginMerging: false,\n    backgroundSizeMerging: false,\n    iePrefixHack: true,\n    merging: false\n  },\n  selectors: {\n    mergeablePseudoClasses: [\n      ':after',\n      ':before',\n      ':first-child',\n      ':first-letter',\n      ':focus',\n      ':hover',\n      ':visited'\n    ],\n    mergeablePseudoElements: []\n  },\n  units: {\n    ch: false,\n    rem: false,\n    vh: false,\n    vm: false,\n    vmax: false,\n    vmin: false,\n    vw: false\n  }\n});\n\nDEFAULTS.ie7 = merge(DEFAULTS.ie8, {\n  properties: {\n    ieBangHack: true\n  },\n  selectors: {\n    ie7Hack: true,\n    mergeablePseudoClasses: [\n      ':first-child',\n      ':first-letter',\n      ':hover',\n      ':visited'\n    ]\n  },\n});\n\nfunction compatibilityFrom(source) {\n  return merge(DEFAULTS['*'], calculateSource(source));\n}\n\nfunction merge(source, target) {\n  for (var key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key)) {\n      var value = source[key];\n\n      if (Object.prototype.hasOwnProperty.call(target, key) && typeof value === 'object' && !Array.isArray(value)) {\n        target[key] = merge(value, target[key] || {});\n      } else {\n        target[key] = key in target ? target[key] : value;\n      }\n    }\n  }\n\n  return target;\n}\n\nfunction calculateSource(source) {\n  if (typeof source == 'object')\n    return source;\n\n  if (!/[,\\+\\-]/.test(source))\n    return DEFAULTS[source] || DEFAULTS['*'];\n\n  var parts = source.split(',');\n  var template = parts[0] in DEFAULTS ?\n    DEFAULTS[parts.shift()] :\n    DEFAULTS['*'];\n\n  source = {};\n\n  parts.forEach(function (part) {\n    var isAdd = part[0] == '+';\n    var key = part.substring(1).split('.');\n    var group = key[0];\n    var option = key[1];\n\n    source[group] = source[group] || {};\n    source[group][option] = isAdd;\n  });\n\n  return merge(template, source);\n}\n\nmodule.exports = compatibilityFrom;\n","var loadRemoteResource = require('../reader/load-remote-resource');\n\nfunction fetchFrom(callback) {\n  return callback || loadRemoteResource;\n}\n\nmodule.exports = fetchFrom;\n","var systemLineBreak = require('os').EOL;\n\nvar override = require('../utils/override');\n\nvar Breaks = {\n  AfterAtRule: 'afterAtRule',\n  AfterBlockBegins: 'afterBlockBegins',\n  AfterBlockEnds: 'afterBlockEnds',\n  AfterComment: 'afterComment',\n  AfterProperty: 'afterProperty',\n  AfterRuleBegins: 'afterRuleBegins',\n  AfterRuleEnds: 'afterRuleEnds',\n  BeforeBlockEnds: 'beforeBlockEnds',\n  BetweenSelectors: 'betweenSelectors'\n};\n\nvar BreakWith = {\n  CarriageReturnLineFeed: '\\r\\n',\n  LineFeed: '\\n',\n  System: systemLineBreak\n};\n\nvar IndentWith = {\n  Space: ' ',\n  Tab: '\\t'\n};\n\nvar Spaces = {\n  AroundSelectorRelation: 'aroundSelectorRelation',\n  BeforeBlockBegins: 'beforeBlockBegins',\n  BeforeValue: 'beforeValue'\n};\n\nvar DEFAULTS = {\n  breaks: breaks(false),\n  breakWith: BreakWith.System,\n  indentBy: 0,\n  indentWith: IndentWith.Space,\n  spaces: spaces(false),\n  wrapAt: false,\n  semicolonAfterLastProperty: false\n};\n\nvar BEAUTIFY_ALIAS = 'beautify';\nvar KEEP_BREAKS_ALIAS = 'keep-breaks';\n\nvar OPTION_SEPARATOR = ';';\nvar OPTION_NAME_VALUE_SEPARATOR = ':';\nvar HASH_VALUES_OPTION_SEPARATOR = ',';\nvar HASH_VALUES_NAME_VALUE_SEPARATOR = '=';\n\nvar FALSE_KEYWORD_1 = 'false';\nvar FALSE_KEYWORD_2 = 'off';\nvar TRUE_KEYWORD_1 = 'true';\nvar TRUE_KEYWORD_2 = 'on';\n\nfunction breaks(value) {\n  var breakOptions = {};\n\n  breakOptions[Breaks.AfterAtRule] = value;\n  breakOptions[Breaks.AfterBlockBegins] = value;\n  breakOptions[Breaks.AfterBlockEnds] = value;\n  breakOptions[Breaks.AfterComment] = value;\n  breakOptions[Breaks.AfterProperty] = value;\n  breakOptions[Breaks.AfterRuleBegins] = value;\n  breakOptions[Breaks.AfterRuleEnds] = value;\n  breakOptions[Breaks.BeforeBlockEnds] = value;\n  breakOptions[Breaks.BetweenSelectors] = value;\n\n  return breakOptions;\n}\n\nfunction spaces(value) {\n  var spaceOptions = {};\n\n  spaceOptions[Spaces.AroundSelectorRelation] = value;\n  spaceOptions[Spaces.BeforeBlockBegins] = value;\n  spaceOptions[Spaces.BeforeValue] = value;\n\n  return spaceOptions;\n}\n\nfunction formatFrom(source) {\n  if (source === undefined || source === false) {\n    return false;\n  }\n\n  if (typeof source == 'object' && 'breakWith' in source) {\n    source = override(source, { breakWith: mapBreakWith(source.breakWith) });\n  }\n\n  if (typeof source == 'object' && 'indentBy' in source) {\n    source = override(source, { indentBy: parseInt(source.indentBy) });\n  }\n\n  if (typeof source == 'object' && 'indentWith' in source) {\n    source = override(source, { indentWith: mapIndentWith(source.indentWith) });\n  }\n\n  if (typeof source == 'object') {\n    return remapBreaks(override(DEFAULTS, source));\n  }\n\n  if (typeof source == 'string' && source == BEAUTIFY_ALIAS) {\n    return remapBreaks(\n      override(DEFAULTS, {\n        breaks: breaks(true),\n        indentBy: 2,\n        spaces: spaces(true)\n      })\n    );\n  }\n\n  if (typeof source == 'string' && source == KEEP_BREAKS_ALIAS) {\n    return remapBreaks(\n      override(DEFAULTS, {\n        breaks: {\n          afterAtRule: true,\n          afterBlockBegins: true,\n          afterBlockEnds: true,\n          afterComment: true,\n          afterRuleEnds: true,\n          beforeBlockEnds: true\n        }\n      })\n    );\n  }\n\n  if (typeof source == 'string') {\n    return remapBreaks(override(DEFAULTS, toHash(source)));\n  }\n\n  return DEFAULTS;\n}\n\nfunction toHash(string) {\n  return string\n    .split(OPTION_SEPARATOR)\n    .reduce(function (accumulator, directive) {\n      var parts = directive.split(OPTION_NAME_VALUE_SEPARATOR);\n      var name = parts[0];\n      var value = parts[1];\n\n      if (name == 'breaks' || name == 'spaces') {\n        accumulator[name] = hashValuesToHash(value);\n      } else if (name == 'indentBy' || name == 'wrapAt') {\n        accumulator[name] = parseInt(value);\n      } else if (name == 'indentWith') {\n        accumulator[name] = mapIndentWith(value);\n      } else if (name == 'breakWith') {\n        accumulator[name] = mapBreakWith(value);\n      }\n\n      return accumulator;\n    }, {});\n}\n\nfunction hashValuesToHash(string) {\n  return string\n    .split(HASH_VALUES_OPTION_SEPARATOR)\n    .reduce(function (accumulator, directive) {\n      var parts = directive.split(HASH_VALUES_NAME_VALUE_SEPARATOR);\n      var name = parts[0];\n      var value = parts[1];\n\n      accumulator[name] = normalizeValue(value);\n\n      return accumulator;\n    }, {});\n}\n\n\nfunction normalizeValue(value) {\n  switch (value) {\n    case FALSE_KEYWORD_1:\n    case FALSE_KEYWORD_2:\n      return false;\n    case TRUE_KEYWORD_1:\n    case TRUE_KEYWORD_2:\n      return true;\n    default:\n      return value;\n  }\n}\n\nfunction mapBreakWith(value) {\n  switch (value) {\n    case 'windows':\n    case 'crlf':\n    case BreakWith.CarriageReturnLineFeed:\n      return BreakWith.CarriageReturnLineFeed;\n    case 'unix':\n    case 'lf':\n    case BreakWith.LineFeed:\n      return BreakWith.LineFeed;\n    default:\n      return systemLineBreak;\n  }\n}\n\nfunction mapIndentWith(value) {\n  switch (value) {\n    case 'space':\n      return IndentWith.Space;\n    case 'tab':\n      return IndentWith.Tab;\n    default:\n      return value;\n  }\n}\n\nfunction remapBreaks(source) {\n  for (var key in Breaks) {\n    var breakName = Breaks[key];\n    var breakValue = source.breaks[breakName];\n\n    if (breakValue === true) {\n      source.breaks[breakName] = source.breakWith;\n    } else if (breakValue === false) {\n      source.breaks[breakName] = '';\n    } else {\n      source.breaks[breakName] = source.breakWith.repeat(parseInt(breakValue));\n    }\n  }\n\n  return source;\n}\n\nmodule.exports = {\n  Breaks: Breaks,\n  Spaces: Spaces,\n  formatFrom: formatFrom\n};\n","var url = require('url');\n\nvar override = require('../utils/override');\n\nfunction inlineRequestFrom(option) {\n  return override(\n    /* jshint camelcase: false */\n    proxyOptionsFrom(process.env.HTTP_PROXY || process.env.http_proxy),\n    option || {}\n  );\n}\n\nfunction proxyOptionsFrom(httpProxy) {\n  return httpProxy ?\n    {\n      hostname: url.parse(httpProxy).hostname,\n      port: parseInt(url.parse(httpProxy).port)\n    } :\n    {};\n}\n\nmodule.exports = inlineRequestFrom;\n","var DEFAULT_TIMEOUT = 5000;\n\nfunction inlineTimeoutFrom(option) {\n  return option || DEFAULT_TIMEOUT;\n}\n\nmodule.exports = inlineTimeoutFrom;\n","function inlineOptionsFrom(rules) {\n  if (Array.isArray(rules)) {\n    return rules;\n  }\n\n  if (rules === false) {\n    return ['none'];\n  }\n\n  return undefined === rules ?\n    ['local'] :\n    rules.split(',');\n}\n\nmodule.exports = inlineOptionsFrom;\n","var roundingPrecisionFrom = require('./rounding-precision').roundingPrecisionFrom;\n\nvar override = require('../utils/override');\n\nvar OptimizationLevel = {\n  Zero: '0',\n  One: '1',\n  Two: '2'\n};\n\nvar DEFAULTS = {};\n\nDEFAULTS[OptimizationLevel.Zero] = {};\nDEFAULTS[OptimizationLevel.One] = {\n  cleanupCharsets: true,\n  normalizeUrls: true,\n  optimizeBackground: true,\n  optimizeBorderRadius: true,\n  optimizeFilter: true,\n  optimizeFontWeight: true,\n  optimizeOutline: true,\n  removeEmpty: true,\n  removeNegativePaddings: true,\n  removeQuotes: true,\n  removeWhitespace: true,\n  replaceMultipleZeros: true,\n  replaceTimeUnits: true,\n  replaceZeroUnits: true,\n  roundingPrecision: roundingPrecisionFrom(undefined),\n  selectorsSortingMethod: 'standard',\n  specialComments: 'all',\n  tidyAtRules: true,\n  tidyBlockScopes: true,\n  tidySelectors: true\n};\nDEFAULTS[OptimizationLevel.Two] = {\n  mergeAdjacentRules: true,\n  mergeIntoShorthands: true,\n  mergeMedia: true,\n  mergeNonAdjacentRules: true,\n  mergeSemantically: false,\n  overrideProperties: true,\n  removeEmpty: true,\n  reduceNonAdjacentRules: true,\n  removeDuplicateFontRules: true,\n  removeDuplicateMediaBlocks: true,\n  removeDuplicateRules: true,\n  removeUnusedAtRules: false,\n  restructureRules: false,\n  skipProperties: []\n};\n\nvar ALL_KEYWORD_1 = '*';\nvar ALL_KEYWORD_2 = 'all';\nvar FALSE_KEYWORD_1 = 'false';\nvar FALSE_KEYWORD_2 = 'off';\nvar TRUE_KEYWORD_1 = 'true';\nvar TRUE_KEYWORD_2 = 'on';\n\nvar LIST_VALUE_SEPARATOR = ',';\nvar OPTION_SEPARATOR = ';';\nvar OPTION_VALUE_SEPARATOR = ':';\n\nfunction optimizationLevelFrom(source) {\n  var level = override(DEFAULTS, {});\n  var Zero = OptimizationLevel.Zero;\n  var One = OptimizationLevel.One;\n  var Two = OptimizationLevel.Two;\n\n  if (undefined === source) {\n    delete level[Two];\n    return level;\n  }\n\n  if (typeof source == 'string') {\n    source = parseInt(source);\n  }\n\n  if (typeof source == 'number' && source === parseInt(Two)) {\n    return level;\n  }\n\n  if (typeof source == 'number' && source === parseInt(One)) {\n    delete level[Two];\n    return level;\n  }\n\n  if (typeof source == 'number' && source === parseInt(Zero)) {\n    delete level[Two];\n    delete level[One];\n    return level;\n  }\n\n  if (typeof source == 'object') {\n    source = covertValuesToHashes(source);\n  }\n\n  if (One in source && 'roundingPrecision' in source[One]) {\n    source[One].roundingPrecision = roundingPrecisionFrom(source[One].roundingPrecision);\n  }\n\n  if (Two in source && 'skipProperties' in source[Two] && typeof(source[Two].skipProperties) == 'string') {\n    source[Two].skipProperties = source[Two].skipProperties.split(LIST_VALUE_SEPARATOR);\n  }\n\n  if (Zero in source || One in source || Two in source) {\n    level[Zero] = override(level[Zero], source[Zero]);\n  }\n\n  if (One in source && ALL_KEYWORD_1 in source[One]) {\n    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_1])));\n    delete source[One][ALL_KEYWORD_1];\n  }\n\n  if (One in source && ALL_KEYWORD_2 in source[One]) {\n    level[One] = override(level[One], defaults(One, normalizeValue(source[One][ALL_KEYWORD_2])));\n    delete source[One][ALL_KEYWORD_2];\n  }\n\n  if (One in source || Two in source) {\n    level[One] = override(level[One], source[One]);\n  } else {\n    delete level[One];\n  }\n\n  if (Two in source && ALL_KEYWORD_1 in source[Two]) {\n    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_1])));\n    delete source[Two][ALL_KEYWORD_1];\n  }\n\n  if (Two in source && ALL_KEYWORD_2 in source[Two]) {\n    level[Two] = override(level[Two], defaults(Two, normalizeValue(source[Two][ALL_KEYWORD_2])));\n    delete source[Two][ALL_KEYWORD_2];\n  }\n\n  if (Two in source) {\n    level[Two] = override(level[Two], source[Two]);\n  } else {\n    delete level[Two];\n  }\n\n  return level;\n}\n\nfunction defaults(level, value) {\n  var options = override(DEFAULTS[level], {});\n  var key;\n\n  for (key in options) {\n    if (typeof options[key] == 'boolean') {\n      options[key] = value;\n    }\n  }\n\n  return options;\n}\n\nfunction normalizeValue(value) {\n  switch (value) {\n    case FALSE_KEYWORD_1:\n    case FALSE_KEYWORD_2:\n      return false;\n    case TRUE_KEYWORD_1:\n    case TRUE_KEYWORD_2:\n      return true;\n    default:\n      return value;\n  }\n}\n\nfunction covertValuesToHashes(source) {\n  var clonedSource = override(source, {});\n  var level;\n  var i;\n\n  for (i = 0; i <= 2; i++) {\n    level = '' + i;\n\n    if (level in clonedSource && (clonedSource[level] === undefined || clonedSource[level] === false)) {\n      delete clonedSource[level];\n    }\n\n    if (level in clonedSource && clonedSource[level] === true) {\n      clonedSource[level] = {};\n    }\n\n    if (level in clonedSource && typeof clonedSource[level] == 'string') {\n      clonedSource[level] = covertToHash(clonedSource[level], level);\n    }\n  }\n\n  return clonedSource;\n}\n\nfunction covertToHash(asString, level) {\n  return asString\n    .split(OPTION_SEPARATOR)\n    .reduce(function (accumulator, directive) {\n      var parts = directive.split(OPTION_VALUE_SEPARATOR);\n      var name = parts[0];\n      var value = parts[1];\n      var normalizedValue = normalizeValue(value);\n\n      if (ALL_KEYWORD_1 == name || ALL_KEYWORD_2 == name) {\n        accumulator = override(accumulator, defaults(level, normalizedValue));\n      } else {\n        accumulator[name] = normalizedValue;\n      }\n\n      return accumulator;\n    }, {});\n}\n\nmodule.exports = {\n  OptimizationLevel: OptimizationLevel,\n  optimizationLevelFrom: optimizationLevelFrom,\n};\n","function pluginsFrom(plugins) {\n  var flatPlugins = {\n    level1Value: [],\n    level1Property: [],\n    level2Block: []\n  };\n\n  plugins = plugins || [];\n\n  flatPlugins.level1Value = plugins\n    .map(function (plugin) { return plugin.level1 && plugin.level1.value; })\n    .filter(function (plugin) { return plugin != null; });\n\n  flatPlugins.level1Property = plugins\n    .map(function (plugin) { return plugin.level1 && plugin.level1.property; })\n    .filter(function (plugin) { return plugin != null; });\n\n  flatPlugins.level2Block = plugins\n    .map(function (plugin) { return plugin.level2 && plugin.level2.block; })\n    .filter(function (plugin) { return plugin != null; });\n\n  return flatPlugins;\n}\n\nmodule.exports = pluginsFrom;\n","var path = require('path');\n\nfunction rebaseToFrom(option) {\n  return option ? path.resolve(option) : process.cwd();\n}\n\nmodule.exports = rebaseToFrom;\n","function rebaseFrom(rebaseOption, rebaseToOption) {\n  if (undefined !== rebaseToOption) {\n    return true;\n  } else if (undefined === rebaseOption) {\n    return false;\n  } else {\n    return !!rebaseOption;\n  }\n}\n\nmodule.exports = rebaseFrom;\n","var override = require('../utils/override');\n\nvar INTEGER_PATTERN = /^\\d+$/;\n\nvar ALL_UNITS = ['*', 'all'];\nvar DEFAULT_PRECISION = 'off'; // all precision changes are disabled\nvar DIRECTIVES_SEPARATOR = ','; // e.g. *=5,px=3\nvar DIRECTIVE_VALUE_SEPARATOR = '='; // e.g. *=5\n\nfunction roundingPrecisionFrom(source) {\n  return override(defaults(DEFAULT_PRECISION), buildPrecisionFrom(source));\n}\n\nfunction defaults(value) {\n  return {\n    'ch': value,\n    'cm': value,\n    'em': value,\n    'ex': value,\n    'in': value,\n    'mm': value,\n    'pc': value,\n    'pt': value,\n    'px': value,\n    'q': value,\n    'rem': value,\n    'vh': value,\n    'vmax': value,\n    'vmin': value,\n    'vw': value,\n    '%': value\n  };\n}\n\nfunction buildPrecisionFrom(source) {\n  if (source === null || source === undefined) {\n    return {};\n  }\n\n  if (typeof source == 'boolean') {\n    return {};\n  }\n\n  if (typeof source == 'number' && source == -1) {\n    return defaults(DEFAULT_PRECISION);\n  }\n\n  if (typeof source == 'number') {\n    return defaults(source);\n  }\n\n  if (typeof source == 'string' && INTEGER_PATTERN.test(source)) {\n    return defaults(parseInt(source));\n  }\n\n  if (typeof source == 'string' && source == DEFAULT_PRECISION) {\n    return defaults(DEFAULT_PRECISION);\n  }\n\n  if (typeof source == 'object') {\n    return source;\n  }\n\n  return source\n    .split(DIRECTIVES_SEPARATOR)\n    .reduce(function (accumulator, directive) {\n      var directiveParts = directive.split(DIRECTIVE_VALUE_SEPARATOR);\n      var name = directiveParts[0];\n      var value = parseInt(directiveParts[1]);\n\n      if (isNaN(value) || value == -1) {\n        value = DEFAULT_PRECISION;\n      }\n\n      if (ALL_UNITS.indexOf(name) > -1) {\n        accumulator = override(accumulator, defaults(value));\n      } else {\n        accumulator[name] = value;\n      }\n\n      return accumulator;\n    }, {});\n}\n\nmodule.exports = {\n  DEFAULT: DEFAULT_PRECISION,\n  roundingPrecisionFrom: roundingPrecisionFrom\n};\n","var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\nvar matchDataUri = require('./match-data-uri');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\n\nvar Token = require('../tokenizer/token');\nvar hasProtocol = require('../utils/has-protocol');\nvar isDataUriResource = require('../utils/is-data-uri-resource');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar MAP_MARKER_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction applySourceMaps(tokens, context, callback) {\n  var applyContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    inputSourceMapTracker: context.inputSourceMapTracker,\n    localOnly: context.localOnly,\n    processedTokens: [],\n    rebaseTo: context.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && tokens.length > 0 ?\n    doApplySourceMaps(applyContext) :\n    callback(tokens);\n}\n\nfunction doApplySourceMaps(applyContext) {\n  var singleSourceTokens = [];\n  var lastSource = findTokenSource(applyContext.sourceTokens[0]);\n  var source;\n  var token;\n  var l;\n\n  for (l = applyContext.sourceTokens.length; applyContext.index < l; applyContext.index++) {\n    token = applyContext.sourceTokens[applyContext.index];\n    source = findTokenSource(token);\n\n    if (source != lastSource) {\n      singleSourceTokens = [];\n      lastSource = source;\n    }\n\n    singleSourceTokens.push(token);\n    applyContext.processedTokens.push(token);\n\n    if (token[0] == Token.COMMENT && MAP_MARKER_PATTERN.test(token[1])) {\n      return fetchAndApplySourceMap(token[1], source, singleSourceTokens, applyContext);\n    }\n  }\n\n  return applyContext.callback(applyContext.processedTokens);\n}\n\nfunction findTokenSource(token) {\n  var scope;\n  var metadata;\n\n  if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT || token[0] == Token.RAW) {\n    metadata = token[2][0];\n  } else {\n    scope = token[1][0];\n    metadata = scope[2][0];\n  }\n\n  return metadata[2];\n}\n\nfunction fetchAndApplySourceMap(sourceMapComment, source, singleSourceTokens, applyContext) {\n  return extractInputSourceMapFrom(sourceMapComment, applyContext, function (inputSourceMap) {\n    if (inputSourceMap) {\n      applyContext.inputSourceMapTracker.track(source, inputSourceMap);\n      applySourceMapRecursively(singleSourceTokens, applyContext.inputSourceMapTracker);\n    }\n\n    applyContext.index++;\n    return doApplySourceMaps(applyContext);\n  });\n}\n\nfunction extractInputSourceMapFrom(sourceMapComment, applyContext, whenSourceMapReady) {\n  var uri = MAP_MARKER_PATTERN.exec(sourceMapComment)[1];\n  var absoluteUri;\n  var sourceMap;\n  var rebasedMap;\n\n  if (isDataUriResource(uri)) {\n    sourceMap = extractInputSourceMapFromDataUri(uri);\n    return whenSourceMapReady(sourceMap);\n  } else if (isRemoteResource(uri)) {\n    return loadInputSourceMapFromRemoteUri(uri, applyContext, function (sourceMap) {\n      var parsedMap;\n\n      if (sourceMap) {\n        parsedMap = JSON.parse(sourceMap);\n        rebasedMap = rebaseRemoteMap(parsedMap, uri);\n        whenSourceMapReady(rebasedMap);\n      } else {\n        whenSourceMapReady(null);\n      }\n    });\n  } else {\n    // at this point `uri` is already rebased, see lib/reader/rebase.js#rebaseSourceMapComment\n    // it is rebased to be consistent with rebasing other URIs\n    // however here we need to resolve it back to read it from disk\n    absoluteUri = path.resolve(applyContext.rebaseTo, uri);\n    sourceMap = loadInputSourceMapFromLocalUri(absoluteUri, applyContext);\n\n    if (sourceMap) {\n      rebasedMap = rebaseLocalMap(sourceMap, absoluteUri, applyContext.rebaseTo);\n      return whenSourceMapReady(rebasedMap);\n    } else {\n      return whenSourceMapReady(null);\n    }\n  }\n}\n\nfunction extractInputSourceMapFromDataUri(uri) {\n  var dataUriMatch = matchDataUri(uri);\n  var charset = dataUriMatch[2] ? dataUriMatch[2].split(/[=;]/)[2] : 'us-ascii';\n  var encoding = dataUriMatch[3] ? dataUriMatch[3].split(';')[1] : 'utf8';\n  var data = encoding == 'utf8' ? global.unescape(dataUriMatch[4]) : dataUriMatch[4];\n\n  var buffer = Buffer.from(data, encoding);\n  buffer.charset = charset;\n\n  return JSON.parse(buffer.toString());\n}\n\nfunction loadInputSourceMapFromRemoteUri(uri, applyContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, applyContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (applyContext.localOnly) {\n    applyContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  applyContext.fetch(uri, applyContext.inlineRequest, applyContext.inlineTimeout, function (error, body) {\n    if (error) {\n      applyContext.warnings.push('Missing source map at \"' + uri + '\" - ' + error);\n      return whenLoaded(null);\n    }\n\n    whenLoaded(body);\n  });\n}\n\nfunction loadInputSourceMapFromLocalUri(uri, applyContext) {\n  var isAllowed = isAllowedResource(uri, false, applyContext.inline);\n  var sourceMap;\n\n  if (!fs.existsSync(uri) || !fs.statSync(uri).isFile()) {\n    applyContext.warnings.push('Ignoring local source map at \"' + uri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    applyContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  sourceMap = fs.readFileSync(uri, 'utf-8');\n  return JSON.parse(sourceMap);\n}\n\nfunction applySourceMapRecursively(tokens, inputSourceMapTracker) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.AT_RULE_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.NESTED_BLOCK_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.COMMENT:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY:\n        applySourceMapRecursively(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_BLOCK:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_NAME:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.PROPERTY_VALUE:\n        applySourceMapTo(token, inputSourceMapTracker);\n        break;\n      case Token.RULE:\n        applySourceMapRecursively(token[1], inputSourceMapTracker);\n        applySourceMapRecursively(token[2], inputSourceMapTracker);\n        break;\n      case Token.RULE_SCOPE:\n        applySourceMapTo(token, inputSourceMapTracker);\n    }\n  }\n\n  return tokens;\n}\n\nfunction applySourceMapTo(token, inputSourceMapTracker) {\n  var value = token[1];\n  var metadata = token[2];\n  var newMetadata = [];\n  var i, l;\n\n  for (i = 0, l = metadata.length; i < l; i++) {\n    newMetadata.push(inputSourceMapTracker.originalPositionFor(metadata[i], value.length));\n  }\n\n  token[2] = newMetadata;\n}\n\nmodule.exports = applySourceMaps;\n","var split = require('../utils/split');\n\nvar BRACE_PREFIX = /^\\(/;\nvar BRACE_SUFFIX = /\\)$/;\nvar IMPORT_PREFIX_PATTERN = /^@import/i;\nvar QUOTE_PREFIX_PATTERN = /['\"]\\s*/;\nvar QUOTE_SUFFIX_PATTERN = /\\s*['\"]/;\nvar URL_PREFIX_PATTERN = /^url\\(\\s*/i;\nvar URL_SUFFIX_PATTERN = /\\s*\\)/i;\n\nfunction extractImportUrlAndMedia(atRuleValue) {\n  var uri;\n  var mediaQuery;\n  var stripped;\n  var parts;\n\n  stripped = atRuleValue\n    .replace(IMPORT_PREFIX_PATTERN, '')\n    .trim()\n    .replace(URL_PREFIX_PATTERN, '(')\n    .replace(URL_SUFFIX_PATTERN, ')')\n    .replace(QUOTE_PREFIX_PATTERN, '')\n    .replace(QUOTE_SUFFIX_PATTERN, '');\n\n  parts = split(stripped, ' ');\n\n  uri = parts[0]\n    .replace(BRACE_PREFIX, '')\n    .replace(BRACE_SUFFIX, '');\n  mediaQuery = parts.slice(1).join(' ');\n\n  return [uri, mediaQuery];\n}\n\nmodule.exports = extractImportUrlAndMedia;\n","var SourceMapConsumer = require('source-map').SourceMapConsumer;\n\nfunction inputSourceMapTracker() {\n  var maps = {};\n\n  return {\n    all: all.bind(null, maps),\n    isTracking: isTracking.bind(null, maps),\n    originalPositionFor: originalPositionFor.bind(null, maps),\n    track: track.bind(null, maps)\n  };\n}\n\nfunction all(maps) {\n  return maps;\n}\n\nfunction isTracking(maps, source) {\n  return source in maps;\n}\n\nfunction originalPositionFor(maps, metadata, range, selectorFallbacks) {\n  var line = metadata[0];\n  var column = metadata[1];\n  var source = metadata[2];\n  var position = {\n    line: line,\n    column: column + range\n  };\n  var originalPosition;\n\n  while (!originalPosition && position.column > column) {\n    position.column--;\n    originalPosition = maps[source].originalPositionFor(position);\n  }\n\n  if (!originalPosition || originalPosition.column < 0) {\n    return metadata;\n  }\n\n  if (originalPosition.line === null && line > 1 && selectorFallbacks > 0) {\n    return originalPositionFor(maps, [line - 1, column, source], range, selectorFallbacks - 1);\n  }\n\n  return originalPosition.line !== null ?\n    toMetadata(originalPosition) :\n    metadata;\n}\n\nfunction toMetadata(asHash) {\n  return [asHash.line, asHash.column, asHash.source];\n}\n\nfunction track(maps, source, data) {\n  maps[source] = new SourceMapConsumer(data);\n}\n\nmodule.exports = inputSourceMapTracker;\n","var path = require('path');\nvar url = require('url');\n\nvar isRemoteResource = require('../utils/is-remote-resource');\nvar hasProtocol = require('../utils/has-protocol');\n\nvar HTTP_PROTOCOL = 'http:';\n\nfunction isAllowedResource(uri, isRemote, rules) {\n  var match;\n  var absoluteUri;\n  var allowed = isRemote ? false : true;\n  var rule;\n  var isNegated;\n  var normalizedRule;\n  var i;\n\n  if (rules.length === 0) {\n    return false;\n  }\n\n  if (isRemote && !hasProtocol(uri)) {\n    uri = HTTP_PROTOCOL + uri;\n  }\n\n  match = isRemote ?\n    url.parse(uri).host :\n    uri;\n\n  absoluteUri = isRemote ?\n    uri :\n    path.resolve(uri);\n\n  for (i = 0; i < rules.length; i++) {\n    rule = rules[i];\n    isNegated = rule[0] == '!';\n    normalizedRule = rule.substring(1);\n\n    if (isNegated && isRemote && isRemoteRule(normalizedRule)) {\n      allowed = allowed && !isAllowedResource(uri, true, [normalizedRule]);\n    } else if (isNegated && !isRemote && !isRemoteRule(normalizedRule)) {\n      allowed = allowed && !isAllowedResource(uri, false, [normalizedRule]);\n    } else if (isNegated) {\n      allowed = allowed && true;\n    } else if (rule == 'all') {\n      allowed = true;\n    } else if (isRemote && rule == 'local') {\n      allowed = allowed || false;\n    } else if (isRemote && rule == 'remote') {\n      allowed = true;\n    } else if (!isRemote && rule == 'remote') {\n      allowed = false;\n    } else if (!isRemote && rule == 'local') {\n      allowed = true;\n    } else if (rule === match) {\n      allowed = true;\n    } else if (rule === uri) {\n      allowed = true;\n    } else if (isRemote && absoluteUri.indexOf(rule) === 0) {\n      allowed = true;\n    } else if (!isRemote && absoluteUri.indexOf(path.resolve(rule)) === 0) {\n      allowed = true;\n    } else if (isRemote != isRemoteRule(normalizedRule)) {\n      allowed = allowed && true;\n    } else {\n      allowed = false;\n    }\n  }\n\n  return allowed;\n}\n\nfunction isRemoteRule(rule) {\n  return isRemoteResource(rule) || url.parse(HTTP_PROTOCOL + '//' + rule).host == rule;\n}\n\nmodule.exports = isAllowedResource;\n","var fs = require('fs');\nvar path = require('path');\n\nvar isAllowedResource = require('./is-allowed-resource');\n\nvar hasProtocol = require('../utils/has-protocol');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nfunction loadOriginalSources(context, callback) {\n  var loadContext = {\n    callback: callback,\n    fetch: context.options.fetch,\n    index: 0,\n    inline: context.options.inline,\n    inlineRequest: context.options.inlineRequest,\n    inlineTimeout: context.options.inlineTimeout,\n    localOnly: context.localOnly,\n    rebaseTo: context.options.rebaseTo,\n    sourcesContent: context.sourcesContent,\n    uriToSource: uriToSourceMapping(context.inputSourceMapTracker.all()),\n    warnings: context.warnings\n  };\n\n  return context.options.sourceMap && context.options.sourceMapInlineSources ?\n    doLoadOriginalSources(loadContext) :\n    callback();\n}\n\nfunction uriToSourceMapping(allSourceMapConsumers) {\n  var mapping = {};\n  var consumer;\n  var uri;\n  var source;\n  var i, l;\n\n  for (source in allSourceMapConsumers) {\n    consumer = allSourceMapConsumers[source];\n\n    for (i = 0, l = consumer.sources.length; i < l; i++) {\n      uri = consumer.sources[i];\n      source = consumer.sourceContentFor(uri, true);\n\n      mapping[uri] = source;\n    }\n  }\n\n  return mapping;\n}\n\nfunction doLoadOriginalSources(loadContext) {\n  var uris = Object.keys(loadContext.uriToSource);\n  var uri;\n  var source;\n  var total;\n\n  for (total = uris.length; loadContext.index < total; loadContext.index++) {\n    uri = uris[loadContext.index];\n    source = loadContext.uriToSource[uri];\n\n    if (source) {\n      loadContext.sourcesContent[uri] = source;\n    } else {\n      return loadOriginalSource(uri, loadContext);\n    }\n  }\n\n  return loadContext.callback();\n}\n\nfunction loadOriginalSource(uri, loadContext) {\n  var content;\n\n  if (isRemoteResource(uri)) {\n    return loadOriginalSourceFromRemoteUri(uri, loadContext, function (content) {\n      loadContext.index++;\n      loadContext.sourcesContent[uri] = content;\n      return doLoadOriginalSources(loadContext);\n    });\n  } else {\n    content = loadOriginalSourceFromLocalUri(uri, loadContext);\n    loadContext.index++;\n    loadContext.sourcesContent[uri] = content;\n    return doLoadOriginalSources(loadContext);\n  }\n}\n\nfunction loadOriginalSourceFromRemoteUri(uri, loadContext, whenLoaded) {\n  var isAllowed = isAllowedResource(uri, true, loadContext.inline);\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (loadContext.localOnly) {\n    loadContext.warnings.push('Cannot fetch remote resource from \"' + uri + '\" as no callback given.');\n    return whenLoaded(null);\n  } else if (isRuntimeResource) {\n    loadContext.warnings.push('Cannot fetch \"' + uri + '\" as no protocol given.');\n    return whenLoaded(null);\n  } else if (!isAllowed) {\n    loadContext.warnings.push('Cannot fetch \"' + uri + '\" as resource is not allowed.');\n    return whenLoaded(null);\n  }\n\n  loadContext.fetch(uri, loadContext.inlineRequest, loadContext.inlineTimeout, function (error, content) {\n    if (error) {\n      loadContext.warnings.push('Missing original source at \"' + uri + '\" - ' + error);\n    }\n\n    whenLoaded(content);\n  });\n}\n\nfunction loadOriginalSourceFromLocalUri(relativeUri, loadContext) {\n  var isAllowed = isAllowedResource(relativeUri, false, loadContext.inline);\n  var absoluteUri = path.resolve(loadContext.rebaseTo, relativeUri);\n\n  if (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile()) {\n    loadContext.warnings.push('Ignoring local source map at \"' + absoluteUri + '\" as resource is missing.');\n    return null;\n  } else if (!isAllowed) {\n    loadContext.warnings.push('Cannot fetch \"' + absoluteUri + '\" as resource is not allowed.');\n    return null;\n  }\n\n  return fs.readFileSync(absoluteUri, 'utf8');\n}\n\nmodule.exports = loadOriginalSources;\n","var http = require('http');\nvar https = require('https');\nvar url = require('url');\n\nvar isHttpResource = require('../utils/is-http-resource');\nvar isHttpsResource = require('../utils/is-https-resource');\nvar override = require('../utils/override');\n\nvar HTTP_PROTOCOL = 'http:';\n\nfunction loadRemoteResource(uri, inlineRequest, inlineTimeout, callback) {\n  var proxyProtocol = inlineRequest.protocol || inlineRequest.hostname;\n  var errorHandled = false;\n  var requestOptions;\n  var fetch;\n\n  requestOptions = override(\n    url.parse(uri),\n    inlineRequest || {}\n  );\n\n  if (inlineRequest.hostname !== undefined) {\n    // overwrite as we always expect a http proxy currently\n    requestOptions.protocol = inlineRequest.protocol || HTTP_PROTOCOL;\n    requestOptions.path = requestOptions.href;\n  }\n\n  fetch = (proxyProtocol && !isHttpsResource(proxyProtocol)) || isHttpResource(uri) ?\n    http.get :\n    https.get;\n\n  fetch(requestOptions, function (res) {\n    var chunks = [];\n    var movedUri;\n\n    if (errorHandled) {\n      return;\n    }\n\n    if (res.statusCode < 200 || res.statusCode > 399) {\n      return callback(res.statusCode, null);\n    } else if (res.statusCode > 299) {\n      movedUri = url.resolve(uri, res.headers.location);\n      return loadRemoteResource(movedUri, inlineRequest, inlineTimeout, callback);\n    }\n\n    res.on('data', function (chunk) {\n      chunks.push(chunk.toString());\n    });\n    res.on('end', function () {\n      var body = chunks.join('');\n      callback(null, body);\n    });\n  })\n  .on('error', function (res) {\n    if (errorHandled) {\n      return;\n    }\n\n    errorHandled = true;\n    callback(res.message, null);\n  })\n  .on('timeout', function () {\n    if (errorHandled) {\n      return;\n    }\n\n    errorHandled = true;\n    callback('timeout', null);\n  })\n  .setTimeout(inlineTimeout);\n}\n\nmodule.exports = loadRemoteResource;\n","var DATA_URI_PATTERN = /^data:(\\S*?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;\n\nfunction matchDataUri(uri) {\n  return DATA_URI_PATTERN.exec(uri);\n}\n\nmodule.exports = matchDataUri;\n","var UNIX_SEPARATOR = '/';\nvar WINDOWS_SEPARATOR_PATTERN = /\\\\/g;\n\nfunction normalizePath(path) {\n  return path.replace(WINDOWS_SEPARATOR_PATTERN, UNIX_SEPARATOR);\n}\n\nmodule.exports = normalizePath;\n","var fs = require('fs');\nvar path = require('path');\n\nvar applySourceMaps = require('./apply-source-maps');\nvar extractImportUrlAndMedia = require('./extract-import-url-and-media');\nvar isAllowedResource = require('./is-allowed-resource');\nvar loadOriginalSources = require('./load-original-sources');\nvar normalizePath = require('./normalize-path');\nvar rebase = require('./rebase');\nvar rebaseLocalMap = require('./rebase-local-map');\nvar rebaseRemoteMap = require('./rebase-remote-map');\nvar restoreImport = require('./restore-import');\n\nvar tokenize = require('../tokenizer/tokenize');\nvar Token = require('../tokenizer/token');\nvar Marker = require('../tokenizer/marker');\nvar hasProtocol = require('../utils/has-protocol');\nvar isImport = require('../utils/is-import');\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar UNKNOWN_URI = 'uri:unknown';\n\nfunction readSources(input, context, callback) {\n  return doReadSources(input, context, function (tokens) {\n    return applySourceMaps(tokens, context, function () {\n      return loadOriginalSources(context, function () { return callback(tokens); });\n    });\n  });\n}\n\nfunction doReadSources(input, context, callback) {\n  if (typeof input == 'string') {\n    return fromString(input, context, callback);\n  } else if (Buffer.isBuffer(input)) {\n    return fromString(input.toString(), context, callback);\n  } else if (Array.isArray(input)) {\n    return fromArray(input, context, callback);\n  } else if (typeof input == 'object') {\n    return fromHash(input, context, callback);\n  }\n}\n\nfunction fromString(input, context, callback) {\n  context.source = undefined;\n  context.sourcesContent[undefined] = input;\n  context.stats.originalSize += input.length;\n\n  return fromStyles(input, context, { inline: context.options.inline }, callback);\n}\n\nfunction fromArray(input, context, callback) {\n  var inputAsImports = input.reduce(function (accumulator, uriOrHash) {\n    if (typeof uriOrHash === 'string') {\n      return addStringSource(uriOrHash, accumulator);\n    } else {\n      return addHashSource(uriOrHash, context, accumulator);\n    }\n\n  }, []);\n\n  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);\n}\n\nfunction fromHash(input, context, callback) {\n  var inputAsImports = addHashSource(input, context, []);\n  return fromStyles(inputAsImports.join(''), context, { inline: ['all'] }, callback);\n}\n\nfunction addStringSource(input, imports) {\n  imports.push(restoreAsImport(normalizeUri(input)));\n  return imports;\n}\n\nfunction addHashSource(input, context, imports) {\n  var uri;\n  var normalizedUri;\n  var source;\n\n  for (uri in input) {\n    source = input[uri];\n    normalizedUri = normalizeUri(uri);\n\n    imports.push(restoreAsImport(normalizedUri));\n\n    context.sourcesContent[normalizedUri] = source.styles;\n\n    if (source.sourceMap) {\n      trackSourceMap(source.sourceMap, normalizedUri, context);\n    }\n  }\n\n  return imports;\n}\n\nfunction normalizeUri(uri) {\n  var currentPath = path.resolve('');\n  var absoluteUri;\n  var relativeToCurrentPath;\n  var normalizedUri;\n\n  if (isRemoteResource(uri)) {\n    return uri;\n  }\n\n  absoluteUri = path.isAbsolute(uri) ?\n    uri :\n    path.resolve(uri);\n  relativeToCurrentPath = path.relative(currentPath, absoluteUri);\n  normalizedUri = normalizePath(relativeToCurrentPath);\n\n  return normalizedUri;\n}\n\nfunction trackSourceMap(sourceMap, uri, context) {\n  var parsedMap = typeof sourceMap == 'string' ?\n      JSON.parse(sourceMap) :\n      sourceMap;\n  var rebasedMap = isRemoteResource(uri) ?\n    rebaseRemoteMap(parsedMap, uri) :\n    rebaseLocalMap(parsedMap, uri || UNKNOWN_URI, context.options.rebaseTo);\n\n  context.inputSourceMapTracker.track(uri, rebasedMap);\n}\n\nfunction restoreAsImport(uri) {\n  return restoreImport('url(' + uri + ')', '') + Marker.SEMICOLON;\n}\n\nfunction fromStyles(styles, context, parentInlinerContext, callback) {\n  var tokens;\n  var rebaseConfig = {};\n\n  if (!context.source) {\n    rebaseConfig.fromBase = path.resolve('');\n    rebaseConfig.toBase = context.options.rebaseTo;\n  } else if (isRemoteResource(context.source)) {\n    rebaseConfig.fromBase = context.source;\n    rebaseConfig.toBase = context.source;\n  } else if (path.isAbsolute(context.source)) {\n    rebaseConfig.fromBase = path.dirname(context.source);\n    rebaseConfig.toBase = context.options.rebaseTo;\n  } else {\n    rebaseConfig.fromBase = path.dirname(path.resolve(context.source));\n    rebaseConfig.toBase = context.options.rebaseTo;\n  }\n\n  tokens = tokenize(styles, context);\n  tokens = rebase(tokens, context.options.rebase, context.validator, rebaseConfig);\n\n  return allowsAnyImports(parentInlinerContext.inline) ?\n    inline(tokens, context, parentInlinerContext, callback) :\n    callback(tokens);\n}\n\nfunction allowsAnyImports(inline) {\n  return !(inline.length == 1 && inline[0] == 'none');\n}\n\nfunction inline(tokens, externalContext, parentInlinerContext, callback) {\n  var inlinerContext = {\n    afterContent: false,\n    callback: callback,\n    errors: externalContext.errors,\n    externalContext: externalContext,\n    fetch: externalContext.options.fetch,\n    inlinedStylesheets: parentInlinerContext.inlinedStylesheets || externalContext.inlinedStylesheets,\n    inline: parentInlinerContext.inline,\n    inlineRequest: externalContext.options.inlineRequest,\n    inlineTimeout: externalContext.options.inlineTimeout,\n    isRemote: parentInlinerContext.isRemote || false,\n    localOnly: externalContext.localOnly,\n    outputTokens: [],\n    rebaseTo: externalContext.options.rebaseTo,\n    sourceTokens: tokens,\n    warnings: externalContext.warnings\n  };\n\n  return doInlineImports(inlinerContext);\n}\n\nfunction doInlineImports(inlinerContext) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = inlinerContext.sourceTokens.length; i < l; i++) {\n    token = inlinerContext.sourceTokens[i];\n\n    if (token[0] == Token.AT_RULE && isImport(token[1])) {\n      inlinerContext.sourceTokens.splice(0, i);\n      return inlineStylesheet(token, inlinerContext);\n    } else if (token[0] == Token.AT_RULE || token[0] == Token.COMMENT) {\n      inlinerContext.outputTokens.push(token);\n    } else {\n      inlinerContext.outputTokens.push(token);\n      inlinerContext.afterContent = true;\n    }\n  }\n\n  inlinerContext.sourceTokens = [];\n  return inlinerContext.callback(inlinerContext.outputTokens);\n}\n\nfunction inlineStylesheet(token, inlinerContext) {\n  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);\n  var uri = uriAndMediaQuery[0];\n  var mediaQuery = uriAndMediaQuery[1];\n  var metadata = token[2];\n\n  return isRemoteResource(uri) ?\n    inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) :\n    inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext);\n}\n\nfunction inlineRemoteStylesheet(uri, mediaQuery, metadata, inlinerContext) {\n  var isAllowed = isAllowedResource(uri, true, inlinerContext.inline);\n  var originalUri = uri;\n  var isLoaded = uri in inlinerContext.externalContext.sourcesContent;\n  var isRuntimeResource = !hasProtocol(uri);\n\n  if (inlinerContext.inlinedStylesheets.indexOf(uri) > -1) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as it has already been imported.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (inlinerContext.localOnly && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as no callback given and after other content.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (isRuntimeResource) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as no protocol given.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (inlinerContext.localOnly && !isLoaded) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as no callback given.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (!isAllowed && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring remote @import of \"' + uri + '\" as resource is not allowed and after other content.');\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  } else if (!isAllowed) {\n    inlinerContext.warnings.push('Skipping remote @import of \"' + uri + '\" as resource is not allowed.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n    inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n    return doInlineImports(inlinerContext);\n  }\n\n  inlinerContext.inlinedStylesheets.push(uri);\n\n  function whenLoaded(error, importedStyles) {\n    if (error) {\n      inlinerContext.errors.push('Broken @import declaration of \"' + uri + '\" - ' + error);\n\n      return process.nextTick(function () {\n        inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n        inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n        doInlineImports(inlinerContext);\n      });\n    }\n\n    inlinerContext.inline = inlinerContext.externalContext.options.inline;\n    inlinerContext.isRemote = true;\n\n    inlinerContext.externalContext.source = originalUri;\n    inlinerContext.externalContext.sourcesContent[uri] = importedStyles;\n    inlinerContext.externalContext.stats.originalSize += importedStyles.length;\n\n    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {\n      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);\n\n      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);\n      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n      return doInlineImports(inlinerContext);\n    });\n  }\n\n  return isLoaded ?\n    whenLoaded(null, inlinerContext.externalContext.sourcesContent[uri]) :\n    inlinerContext.fetch(uri, inlinerContext.inlineRequest, inlinerContext.inlineTimeout, whenLoaded);\n}\n\nfunction inlineLocalStylesheet(uri, mediaQuery, metadata, inlinerContext) {\n  var currentPath = path.resolve('');\n  var absoluteUri = path.isAbsolute(uri) ?\n    path.resolve(currentPath, uri[0] == '/' ? uri.substring(1) : uri) :\n    path.resolve(inlinerContext.rebaseTo, uri);\n  var relativeToCurrentPath = path.relative(currentPath, absoluteUri);\n  var importedStyles;\n  var isAllowed = isAllowedResource(uri, false, inlinerContext.inline);\n  var normalizedPath = normalizePath(relativeToCurrentPath);\n  var isLoaded = normalizedPath in inlinerContext.externalContext.sourcesContent;\n\n  if (inlinerContext.inlinedStylesheets.indexOf(absoluteUri) > -1) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as it has already been imported.');\n  } else if (isAllowed && !isLoaded && (!fs.existsSync(absoluteUri) || !fs.statSync(absoluteUri).isFile())) {\n    inlinerContext.errors.push('Ignoring local @import of \"' + uri + '\" as resource is missing.');\n  } else if (!isAllowed && inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as resource is not allowed and after other content.');\n  } else if (inlinerContext.afterContent) {\n    inlinerContext.warnings.push('Ignoring local @import of \"' + uri + '\" as after other content.');\n  } else if (!isAllowed) {\n    inlinerContext.warnings.push('Skipping local @import of \"' + uri + '\" as resource is not allowed.');\n    inlinerContext.outputTokens = inlinerContext.outputTokens.concat(inlinerContext.sourceTokens.slice(0, 1));\n  } else {\n    importedStyles = isLoaded ?\n      inlinerContext.externalContext.sourcesContent[normalizedPath] :\n      fs.readFileSync(absoluteUri, 'utf-8');\n\n    inlinerContext.inlinedStylesheets.push(absoluteUri);\n    inlinerContext.inline = inlinerContext.externalContext.options.inline;\n\n    inlinerContext.externalContext.source = normalizedPath;\n    inlinerContext.externalContext.sourcesContent[normalizedPath] = importedStyles;\n    inlinerContext.externalContext.stats.originalSize += importedStyles.length;\n\n    return fromStyles(importedStyles, inlinerContext.externalContext, inlinerContext, function (importedTokens) {\n      importedTokens = wrapInMedia(importedTokens, mediaQuery, metadata);\n\n      inlinerContext.outputTokens = inlinerContext.outputTokens.concat(importedTokens);\n      inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n      return doInlineImports(inlinerContext);\n    });\n  }\n\n  inlinerContext.sourceTokens = inlinerContext.sourceTokens.slice(1);\n\n  return doInlineImports(inlinerContext);\n}\n\nfunction wrapInMedia(tokens, mediaQuery, metadata) {\n  if (mediaQuery) {\n    return [[Token.NESTED_BLOCK, [[Token.NESTED_BLOCK_SCOPE, '@media ' + mediaQuery, metadata]], tokens]];\n  } else {\n    return tokens;\n  }\n}\n\nmodule.exports = readSources;\n","var path = require('path');\n\nfunction rebaseLocalMap(sourceMap, sourceUri, rebaseTo) {\n  var currentPath = path.resolve('');\n  var absoluteUri = path.resolve(currentPath, sourceUri);\n  var absoluteUriDirectory = path.dirname(absoluteUri);\n\n  sourceMap.sources = sourceMap.sources.map(function(source) {\n    return path.relative(rebaseTo, path.resolve(absoluteUriDirectory, source));\n  });\n\n  return sourceMap;\n}\n\nmodule.exports = rebaseLocalMap;\n","var path = require('path');\nvar url = require('url');\n\nfunction rebaseRemoteMap(sourceMap, sourceUri) {\n  var sourceDirectory = path.dirname(sourceUri);\n\n  sourceMap.sources = sourceMap.sources.map(function(source) {\n    return url.resolve(sourceDirectory, source);\n  });\n\n  return sourceMap;\n}\n\nmodule.exports = rebaseRemoteMap;\n","var extractImportUrlAndMedia = require('./extract-import-url-and-media');\nvar restoreImport = require('./restore-import');\nvar rewriteUrl = require('./rewrite-url');\n\nvar Token = require('../tokenizer/token');\nvar isImport = require('../utils/is-import');\n\nvar SOURCE_MAP_COMMENT_PATTERN = /^\\/\\*# sourceMappingURL=(\\S+) \\*\\/$/;\n\nfunction rebase(tokens, rebaseAll, validator, rebaseConfig) {\n  return rebaseAll ?\n    rebaseEverything(tokens, validator, rebaseConfig) :\n    rebaseAtRules(tokens, validator, rebaseConfig);\n}\n\nfunction rebaseEverything(tokens, validator, rebaseConfig) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        rebaseAtRule(token, validator, rebaseConfig);\n        break;\n      case Token.AT_RULE_BLOCK:\n        rebaseProperties(token[2], validator, rebaseConfig);\n        break;\n      case Token.COMMENT:\n        rebaseSourceMapComment(token, rebaseConfig);\n        break;\n      case Token.NESTED_BLOCK:\n        rebaseEverything(token[2], validator, rebaseConfig);\n        break;\n      case Token.RULE:\n        rebaseProperties(token[2], validator, rebaseConfig);\n        break;\n    }\n  }\n\n  return tokens;\n}\n\nfunction rebaseAtRules(tokens, validator, rebaseConfig) {\n  var token;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        rebaseAtRule(token, validator, rebaseConfig);\n        break;\n    }\n  }\n\n  return tokens;\n}\n\nfunction rebaseAtRule(token, validator, rebaseConfig) {\n  if (!isImport(token[1])) {\n    return;\n  }\n\n  var uriAndMediaQuery = extractImportUrlAndMedia(token[1]);\n  var newUrl = rewriteUrl(uriAndMediaQuery[0], rebaseConfig);\n  var mediaQuery = uriAndMediaQuery[1];\n\n  token[1] = restoreImport(newUrl, mediaQuery);\n}\n\nfunction rebaseSourceMapComment(token, rebaseConfig) {\n  var matches = SOURCE_MAP_COMMENT_PATTERN.exec(token[1]);\n\n  if (matches && matches[1].indexOf('data:') === -1) {\n    token[1] = token[1].replace(matches[1], rewriteUrl(matches[1], rebaseConfig, true));\n  }\n}\n\nfunction rebaseProperties(properties, validator, rebaseConfig) {\n  var property;\n  var value;\n  var i, l;\n  var j, m;\n\n  for (i = 0, l = properties.length; i < l; i++) {\n    property = properties[i];\n\n    for (j = 2 /* 0 is Token.PROPERTY, 1 is name */, m = property.length; j < m; j++) {\n      value = property[j][1];\n\n      if (validator.isUrl(value)) {\n        property[j][1] = rewriteUrl(value, rebaseConfig);\n      }\n    }\n  }\n}\n\nmodule.exports = rebase;\n","function restoreImport(uri, mediaQuery) {\n  return ('@import ' + uri + ' ' + mediaQuery).trim();\n}\n\nmodule.exports = restoreImport;\n","var path = require('path');\nvar url = require('url');\n\nvar isDataUriResource = require('../utils/is-data-uri-resource');\n\nvar DOUBLE_QUOTE = '\"';\nvar SINGLE_QUOTE = '\\'';\nvar URL_PREFIX = 'url(';\nvar URL_SUFFIX = ')';\n\nvar PROTOCOL_LESS_PREFIX_PATTERN = /^[^\\w\\d]*\\/\\//;\nvar QUOTE_PREFIX_PATTERN = /^[\"']/;\nvar QUOTE_SUFFIX_PATTERN = /[\"']$/;\nvar ROUND_BRACKETS_PATTERN = /[\\(\\)]/;\nvar URL_PREFIX_PATTERN = /^url\\(/i;\nvar URL_SUFFIX_PATTERN = /\\)$/;\nvar WHITESPACE_PATTERN = /\\s/;\n\nvar isWindows = process.platform == 'win32';\n\nfunction rebase(uri, rebaseConfig) {\n  if (!rebaseConfig) {\n    return uri;\n  }\n\n  if (isAbsolute(uri) && !isRemote(rebaseConfig.toBase)) {\n    return uri;\n  }\n\n  if (isRemote(uri) || isSVGMarker(uri) || isInternal(uri) || isDataUriResource(uri)) {\n    return uri;\n  }\n\n  if (isRemote(rebaseConfig.toBase)) {\n    return url.resolve(rebaseConfig.toBase, uri);\n  }\n\n  return rebaseConfig.absolute ?\n    normalize(absolute(uri, rebaseConfig)) :\n    normalize(relative(uri, rebaseConfig));\n}\n\nfunction isAbsolute(uri) {\n  return path.isAbsolute(uri);\n}\n\nfunction isSVGMarker(uri) {\n  return uri[0] == '#';\n}\n\nfunction isInternal(uri) {\n  return /^\\w+:\\w+/.test(uri);\n}\n\nfunction isRemote(uri) {\n  return /^[^:]+?:\\/\\//.test(uri) || PROTOCOL_LESS_PREFIX_PATTERN.test(uri);\n}\n\nfunction absolute(uri, rebaseConfig) {\n  return path\n    .resolve(path.join(rebaseConfig.fromBase || '', uri))\n    .replace(rebaseConfig.toBase, '');\n}\n\nfunction relative(uri, rebaseConfig) {\n  return path.relative(rebaseConfig.toBase, path.join(rebaseConfig.fromBase || '', uri));\n}\n\nfunction normalize(uri) {\n  return isWindows ? uri.replace(/\\\\/g, '/') : uri;\n}\n\nfunction quoteFor(unquotedUrl) {\n  if (unquotedUrl.indexOf(SINGLE_QUOTE) > -1) {\n    return DOUBLE_QUOTE;\n  } else if (unquotedUrl.indexOf(DOUBLE_QUOTE) > -1) {\n    return SINGLE_QUOTE;\n  } else if (hasWhitespace(unquotedUrl) || hasRoundBrackets(unquotedUrl)) {\n    return SINGLE_QUOTE;\n  } else {\n    return '';\n  }\n}\n\nfunction hasWhitespace(url) {\n  return WHITESPACE_PATTERN.test(url);\n}\n\nfunction hasRoundBrackets(url) {\n  return ROUND_BRACKETS_PATTERN.test(url);\n}\n\nfunction rewriteUrl(originalUrl, rebaseConfig, pathOnly) {\n  var strippedUrl = originalUrl\n    .replace(URL_PREFIX_PATTERN, '')\n    .replace(URL_SUFFIX_PATTERN, '')\n    .trim();\n\n  var unquotedUrl = strippedUrl\n    .replace(QUOTE_PREFIX_PATTERN, '')\n    .replace(QUOTE_SUFFIX_PATTERN, '')\n    .trim();\n\n  var quote = strippedUrl[0] == SINGLE_QUOTE || strippedUrl[0] == DOUBLE_QUOTE ?\n    strippedUrl[0] :\n    quoteFor(unquotedUrl);\n\n  return pathOnly ?\n    rebase(unquotedUrl, rebaseConfig) :\n    URL_PREFIX + quote + rebase(unquotedUrl, rebaseConfig) + quote + URL_SUFFIX;\n}\n\nmodule.exports = rewriteUrl;\n","var Marker = {\n  ASTERISK: '*',\n  AT: '@',\n  BACK_SLASH: '\\\\',\n  CARRIAGE_RETURN: '\\r',\n  CLOSE_CURLY_BRACKET: '}',\n  CLOSE_ROUND_BRACKET: ')',\n  CLOSE_SQUARE_BRACKET: ']',\n  COLON: ':',\n  COMMA: ',',\n  DOUBLE_QUOTE: '\"',\n  EXCLAMATION: '!',\n  FORWARD_SLASH: '/',\n  INTERNAL: '-clean-css-',\n  NEW_LINE_NIX: '\\n',\n  OPEN_CURLY_BRACKET: '{',\n  OPEN_ROUND_BRACKET: '(',\n  OPEN_SQUARE_BRACKET: '[',\n  SEMICOLON: ';',\n  SINGLE_QUOTE: '\\'',\n  SPACE: ' ',\n  TAB: '\\t',\n  UNDERSCORE: '_'\n};\n\nmodule.exports = Marker;\n","var Token = {\n  AT_RULE: 'at-rule', // e.g. `@import`, `@charset`\n  AT_RULE_BLOCK: 'at-rule-block', // e.g. `@font-face{...}`\n  AT_RULE_BLOCK_SCOPE: 'at-rule-block-scope', // e.g. `@font-face`\n  COMMENT: 'comment', // e.g. `/* comment */`\n  NESTED_BLOCK: 'nested-block', // e.g. `@media screen{...}`, `@keyframes animation {...}`\n  NESTED_BLOCK_SCOPE: 'nested-block-scope', // e.g. `@media`, `@keyframes`\n  PROPERTY: 'property', // e.g. `color:red`\n  PROPERTY_BLOCK: 'property-block', // e.g. `--var:{color:red}`\n  PROPERTY_NAME: 'property-name', // e.g. `color`\n  PROPERTY_VALUE: 'property-value', // e.g. `red`\n  RAW: 'raw', // e.g. anything between /* clean-css ignore:start */ and /* clean-css ignore:end */ comments\n  RULE: 'rule', // e.g `div > a{...}`\n  RULE_SCOPE: 'rule-scope' // e.g `div > a`\n};\n\nmodule.exports = Token;\n","var Marker = require('./marker');\nvar Token = require('./token');\n\nvar formatPosition = require('../utils/format-position');\n\nvar Level = {\n  BLOCK: 'block',\n  COMMENT: 'comment',\n  DOUBLE_QUOTE: 'double-quote',\n  RULE: 'rule',\n  SINGLE_QUOTE: 'single-quote'\n};\n\nvar AT_RULES = [\n  '@charset',\n  '@import'\n];\n\nvar BLOCK_RULES = [\n  '@-moz-document',\n  '@document',\n  '@-moz-keyframes',\n  '@-ms-keyframes',\n  '@-o-keyframes',\n  '@-webkit-keyframes',\n  '@keyframes',\n  '@media',\n  '@supports'\n];\n\nvar IGNORE_END_COMMENT_PATTERN = /\\/\\* clean\\-css ignore:end \\*\\/$/;\nvar IGNORE_START_COMMENT_PATTERN = /^\\/\\* clean\\-css ignore:start \\*\\//;\n\nvar PAGE_MARGIN_BOXES = [\n  '@bottom-center',\n  '@bottom-left',\n  '@bottom-left-corner',\n  '@bottom-right',\n  '@bottom-right-corner',\n  '@left-bottom',\n  '@left-middle',\n  '@left-top',\n  '@right-bottom',\n  '@right-middle',\n  '@right-top',\n  '@top-center',\n  '@top-left',\n  '@top-left-corner',\n  '@top-right',\n  '@top-right-corner'\n];\n\nvar EXTRA_PAGE_BOXES = [\n  '@footnote',\n  '@footnotes',\n  '@left',\n  '@page-float-bottom',\n  '@page-float-top',\n  '@right'\n];\n\nvar REPEAT_PATTERN = /^\\[\\s{0,31}\\d+\\s{0,31}\\]$/;\nvar RULE_WORD_SEPARATOR_PATTERN = /[\\s\\(]/;\nvar TAIL_BROKEN_VALUE_PATTERN = /[\\s|\\}]*$/;\n\nfunction tokenize(source, externalContext) {\n  var internalContext = {\n    level: Level.BLOCK,\n    position: {\n      source: externalContext.source || undefined,\n      line: 1,\n      column: 0,\n      index: 0\n    }\n  };\n\n  return intoTokens(source, externalContext, internalContext, false);\n}\n\nfunction intoTokens(source, externalContext, internalContext, isNested) {\n  var allTokens = [];\n  var newTokens = allTokens;\n  var lastToken;\n  var ruleToken;\n  var ruleTokens = [];\n  var propertyToken;\n  var metadata;\n  var metadatas = [];\n  var level = internalContext.level;\n  var levels = [];\n  var buffer = [];\n  var buffers = [];\n  var isBufferEmpty = true;\n  var serializedBuffer;\n  var serializedBufferPart;\n  var roundBracketLevel = 0;\n  var isQuoted;\n  var isSpace;\n  var isNewLineNix;\n  var isNewLineWin;\n  var isCarriageReturn;\n  var isCommentStart;\n  var wasCommentStart = false;\n  var isCommentEnd;\n  var wasCommentEnd = false;\n  var isCommentEndMarker;\n  var isEscaped;\n  var wasEscaped = false;\n  var characterWithNoSpecialMeaning;\n  var isPreviousDash = false;\n  var isVariable = false;\n  var isRaw = false;\n  var seekingValue = false;\n  var seekingPropertyBlockClosing = false;\n  var position = internalContext.position;\n  var lastCommentStartAt;\n\n  for (; position.index < source.length; position.index++) {\n    var character = source[position.index];\n\n    isQuoted = level == Level.SINGLE_QUOTE || level == Level.DOUBLE_QUOTE;\n    isSpace = character == Marker.SPACE || character == Marker.TAB;\n    isNewLineNix = character == Marker.NEW_LINE_NIX;\n    isNewLineWin = character == Marker.NEW_LINE_NIX && source[position.index - 1] == Marker.CARRIAGE_RETURN;\n    isCarriageReturn = character == Marker.CARRIAGE_RETURN && source[position.index + 1] && source[position.index + 1] != Marker.NEW_LINE_NIX;\n    isCommentStart = !wasCommentEnd && level != Level.COMMENT && !isQuoted && character == Marker.ASTERISK && source[position.index - 1] == Marker.FORWARD_SLASH;\n    isCommentEndMarker = !wasCommentStart && !isQuoted && character == Marker.FORWARD_SLASH && source[position.index - 1] == Marker.ASTERISK;\n    isCommentEnd = level == Level.COMMENT && isCommentEndMarker;\n    characterWithNoSpecialMeaning = !isSpace && !isCarriageReturn && (character >= 'A' && character <= 'Z' || character >= 'a' && character <= 'z' || character >= '0' && character <= '9' || character == '-');\n    isVariable = isVariable || (!seekingValue && isPreviousDash && character === '-');\n    isPreviousDash = character === '-';\n    roundBracketLevel = Math.max(roundBracketLevel, 0);\n\n    metadata = isBufferEmpty ?\n      [position.line, position.column, position.source] :\n      metadata;\n\n    if (isEscaped) {\n      // previous character was a backslash\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (characterWithNoSpecialMeaning) {\n      // it's just an alphanumeric character or a hyphen (part of any rule or property name) so let's end it quickly\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && (isQuoted || level == Level.COMMENT)) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if ((isSpace || isNewLineNix && !isNewLineWin) && isBufferEmpty) {\n      // noop\n    } else if (!isCommentEnd && level == Level.COMMENT) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (!isCommentStart && !isCommentEnd && isRaw) {\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentStart && (level == Level.BLOCK || level == Level.RULE) && buffer.length > 1) {\n      // comment start within block preceded by some content, e.g. div/*<--\n      metadatas.push(metadata);\n      buffer.push(character);\n      buffers.push(buffer.slice(0, -2));\n      isBufferEmpty = false;\n\n      buffer = buffer.slice(-2);\n      metadata = [position.line, position.column - 1, position.source];\n\n      levels.push(level);\n      level = Level.COMMENT;\n    } else if (isCommentStart) {\n      // comment start, e.g. /*<--\n      levels.push(level);\n      level = Level.COMMENT;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (isCommentEnd && isIgnoreStartComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:start */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n\n      isRaw = true;\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd && isIgnoreEndComment(buffer)) {\n      // ignore:start comment end, e.g. /* clean-css ignore:end */<--\n      serializedBuffer = buffer.join('') + character;\n      lastCommentStartAt = serializedBuffer.lastIndexOf(Marker.FORWARD_SLASH + Marker.ASTERISK);\n\n      serializedBufferPart = serializedBuffer.substring(0, lastCommentStartAt);\n      lastToken = [Token.RAW, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n\n      serializedBufferPart = serializedBuffer.substring(lastCommentStartAt);\n      metadata = [position.line, position.column - serializedBufferPart.length + 1, position.source];\n      lastToken = [Token.COMMENT, serializedBufferPart, [originalMetadata(metadata, serializedBufferPart, externalContext)]];\n      newTokens.push(lastToken);\n\n      isRaw = false;\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEnd) {\n      // comment end, e.g. /* comment */<--\n      serializedBuffer = buffer.join('').trim() + character;\n      lastToken = [Token.COMMENT, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]];\n      newTokens.push(lastToken);\n\n      level = levels.pop();\n      metadata = metadatas.pop() || null;\n      buffer = buffers.pop() || [];\n      isBufferEmpty = buffer.length === 0;\n    } else if (isCommentEndMarker && source[position.index + 1] != Marker.ASTERISK) {\n      externalContext.warnings.push('Unexpected \\'*/\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SINGLE_QUOTE && !isQuoted) {\n      // single quotation start, e.g. a[href^='https<--\n      levels.push(level);\n      level = Level.SINGLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.SINGLE_QUOTE && level == Level.SINGLE_QUOTE) {\n      // single quotation end, e.g. a[href^='https'<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && !isQuoted) {\n      // double quotation start, e.g. a[href^=\"<--\n      levels.push(level);\n      level = Level.DOUBLE_QUOTE;\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.DOUBLE_QUOTE && level == Level.DOUBLE_QUOTE) {\n      // double quotation end, e.g. a[href^=\"https\"<--\n      level = levels.pop();\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character != Marker.CLOSE_ROUND_BRACKET && character != Marker.OPEN_ROUND_BRACKET && level != Level.COMMENT && !isQuoted && roundBracketLevel > 0) {\n      // character inside any function, e.g. hsla(.<--\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && !isQuoted && level != Level.COMMENT && !seekingValue) {\n      // round open bracket, e.g. @import url(test.css)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n\n      roundBracketLevel--;\n    } else if (character == Marker.SEMICOLON && level == Level.BLOCK && buffer[0] == Marker.AT) {\n      // semicolon ending rule at block level, e.g. @import '...';<--\n      serializedBuffer = buffer.join('').trim();\n      allTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && ruleToken) {\n      // comma separator at block level, e.g. a,div,<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.AT_RULE) {\n      // comma separator at block level, e.g. @import url(...) screen,<--\n      // keep iterating as end semicolon will create the token\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.COMMA && level == Level.BLOCK) {\n      // comma separator at block level, e.g. a,<--\n      ruleToken = [tokenTypeFrom(buffer), [], []];\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, 0)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && ruleToken && ruleToken[0] == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK && tokenTypeFrom(buffer) == Token.NESTED_BLOCK) {\n      // open brace opening at-rule at block level, e.g. @media{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [Token.NESTED_BLOCK, [], []];\n      ruleToken[1].push([Token.NESTED_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      position.column++;\n      position.index++;\n      buffer = [];\n      isBufferEmpty = true;\n\n      ruleToken[2] = intoTokens(source, externalContext, internalContext, true);\n      ruleToken = null;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.BLOCK) {\n      // open brace opening rule at block level, e.g. div{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken = ruleToken || [tokenTypeFrom(buffer), [], []];\n      ruleToken[1].push([tokenScopeFrom(ruleToken[0]), serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext, ruleToken[1].length)]]);\n      newTokens = ruleToken[2];\n      allTokens.push(ruleToken);\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && seekingValue) {\n      // open brace opening rule at rule level, e.g. div{--variable:{<--\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.PROPERTY_BLOCK, []];\n      propertyToken.push(ruleToken);\n      newTokens = ruleToken[1];\n\n      levels.push(level);\n      level = Level.RULE;\n      seekingValue = false;\n    } else if (character == Marker.OPEN_CURLY_BRACKET && level == Level.RULE && isPageMarginBox(buffer)) {\n      // open brace opening page-margin box at rule level, e.g. @page{@top-center{<--\n      serializedBuffer = buffer.join('').trim();\n      ruleTokens.push(ruleToken);\n      ruleToken = [Token.AT_RULE_BLOCK, [], []];\n      ruleToken[1].push([Token.AT_RULE_BLOCK_SCOPE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens.push(ruleToken);\n      newTokens = ruleToken[2];\n\n      levels.push(level);\n      level = Level.RULE;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COLON && level == Level.RULE && !seekingValue) {\n      // colon at rule level, e.g. a{color:<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken = [Token.PROPERTY, [Token.PROPERTY_NAME, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]];\n      newTokens.push(propertyToken);\n\n      seekingValue = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && ruleTokens.length > 0 && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon at rule level for at-rule, e.g. a{--color:{@apply(--other-color);<--\n      serializedBuffer = buffer.join('').trim();\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // semicolon at rule level, e.g. a{color:red;<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      propertyToken = null;\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty && isVariable && !propertyToken[2]) {\n      // semicolon after empty variable value at rule level, e.g. a{--color: ;<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && propertyToken && isBufferEmpty) {\n      // semicolon after bracketed value at rule level, e.g. a{color:rgb(...);<--\n      propertyToken = null;\n      seekingValue = false;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // semicolon for at-rule at rule level, e.g. a{@apply(--variable);<--\n      serializedBuffer = buffer.join('');\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && seekingPropertyBlockClosing) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;};<--\n      seekingPropertyBlockClosing = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.SEMICOLON && level == Level.RULE && isBufferEmpty) {\n      // stray semicolon at rule level, e.g. a{;<--\n      // noop\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && seekingValue && !isBufferEmpty && ruleTokens.length > 0) {\n      // close brace at rule level, e.g. a{--color:{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty && buffer[0] == Marker.AT && ruleTokens.length > 0) {\n      // close brace at rule level for at-rule, e.g. a{--color:{@apply(--other-color)}<--\n      serializedBuffer = buffer.join('');\n      ruleToken[1].push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && ruleTokens.length > 0) {\n      // close brace at rule level after space, e.g. a{--color:{color:red }<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && propertyToken && !isBufferEmpty) {\n      // close brace at rule level, e.g. a{color:red}<--\n      serializedBuffer = buffer.join('');\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && !isBufferEmpty && buffer[0] == Marker.AT) {\n      // close brace after at-rule at rule level, e.g. a{@apply(--variable)}<--\n      propertyToken = null;\n      ruleToken = null;\n      serializedBuffer = buffer.join('').trim();\n      newTokens.push([Token.AT_RULE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && levels[levels.length - 1] == Level.RULE) {\n      // close brace after a property block at rule level, e.g. a{--custom:{color:red;}<--\n      propertyToken = null;\n      ruleToken = ruleTokens.pop();\n      newTokens = ruleToken[2];\n\n      level = levels.pop();\n      seekingValue = false;\n      seekingPropertyBlockClosing = true;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE && isVariable && propertyToken && !propertyToken[2]) {\n      // close brace after an empty variable declaration inside a rule, e.g. a{--color: }<--\n      propertyToken.push([Token.PROPERTY_VALUE, ' ', [originalMetadata(metadata, ' ', externalContext)]]);\n      isVariable = false;\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.RULE) {\n      // close brace after a rule, e.g. a{color:red;}<--\n      propertyToken = null;\n      ruleToken = null;\n      newTokens = allTokens;\n\n      level = levels.pop();\n      seekingValue = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK && !isNested && position.index <= source.length - 1) {\n      // stray close brace at block level, e.g. a{color:red}color:blue}<--\n      externalContext.warnings.push('Unexpected \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n      buffer.push(character);\n      isBufferEmpty = false;\n    } else if (character == Marker.CLOSE_CURLY_BRACKET && level == Level.BLOCK) {\n      // close brace at block level, e.g. @media screen {...}<--\n      break;\n    } else if (character == Marker.OPEN_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round open bracket, e.g. a{color:hsla(<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel++;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue && roundBracketLevel == 1) {\n      // round close bracket, e.g. a{color:hsla(0,0%,0%)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      roundBracketLevel--;\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_ROUND_BRACKET && level == Level.RULE && seekingValue) {\n      // round close bracket within other brackets, e.g. a{width:calc((10rem / 2)<--\n      buffer.push(character);\n      isBufferEmpty = false;\n      roundBracketLevel--;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // forward slash within a property, e.g. a{background:url(image.png) 0 0/<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.FORWARD_SLASH && source[position.index + 1] != Marker.ASTERISK && level == Level.RULE && seekingValue) {\n      // forward slash within a property after space, e.g. a{background:url(image.png) 0 0 /<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue && !isBufferEmpty) {\n      // comma within a property, e.g. a{background:url(image.png),<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.COMMA && level == Level.RULE && seekingValue) {\n      // comma within a property after space, e.g. a{background:url(image.png) ,<--\n      propertyToken.push([Token.PROPERTY_VALUE, character, [[position.line, position.column, position.source]]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (character == Marker.CLOSE_SQUARE_BRACKET && propertyToken && propertyToken.length > 1 && !isBufferEmpty && isRepeatToken(buffer)) {\n      buffer.push(character);\n      serializedBuffer = buffer.join('').trim();\n      propertyToken[propertyToken.length - 1][1] += serializedBuffer;\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if ((isSpace || (isNewLineNix && !isNewLineWin)) && level == Level.RULE && seekingValue && propertyToken && !isBufferEmpty) {\n      // space or *nix newline within property, e.g. a{margin:0 <--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue && propertyToken && buffer.length > 1) {\n      // win newline within property, e.g. a{margin:0\\r\\n<--\n      serializedBuffer = buffer.join('').trim();\n      propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && level == Level.RULE && seekingValue) {\n      // win newline\n      buffer = [];\n      isBufferEmpty = true;\n    } else if (isNewLineWin && buffer.length == 1) {\n      // ignore windows newline which is composed of two characters\n      buffer.pop();\n      isBufferEmpty = buffer.length === 0;\n    } else if (!isBufferEmpty || !isSpace && !isNewLineNix && !isNewLineWin && !isCarriageReturn) {\n      // any character\n      buffer.push(character);\n      isBufferEmpty = false;\n    }\n\n    wasEscaped = isEscaped;\n    isEscaped = !wasEscaped && character == Marker.BACK_SLASH;\n    wasCommentStart = isCommentStart;\n    wasCommentEnd = isCommentEnd;\n\n    position.line = (isNewLineWin || isNewLineNix || isCarriageReturn) ? position.line + 1 : position.line;\n    position.column = (isNewLineWin || isNewLineNix || isCarriageReturn) ? 0 : position.column + 1;\n  }\n\n  if (seekingValue) {\n    externalContext.warnings.push('Missing \\'}\\' at ' + formatPosition([position.line, position.column, position.source]) + '.');\n  }\n\n  if (seekingValue && buffer.length > 0) {\n    serializedBuffer = buffer.join('').replace(TAIL_BROKEN_VALUE_PATTERN, '');\n    propertyToken.push([Token.PROPERTY_VALUE, serializedBuffer, [originalMetadata(metadata, serializedBuffer, externalContext)]]);\n\n    buffer = [];\n  }\n\n  if (buffer.length > 0) {\n    externalContext.warnings.push('Invalid character(s) \\'' + buffer.join('') + '\\' at ' + formatPosition(metadata) + '. Ignoring.');\n  }\n\n  return allTokens;\n}\n\nfunction isIgnoreStartComment(buffer) {\n  return IGNORE_START_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction isIgnoreEndComment(buffer) {\n  return IGNORE_END_COMMENT_PATTERN.test(buffer.join('') + Marker.FORWARD_SLASH);\n}\n\nfunction originalMetadata(metadata, value, externalContext, selectorFallbacks) {\n  var source = metadata[2];\n\n  return externalContext.inputSourceMapTracker.isTracking(source) ?\n    externalContext.inputSourceMapTracker.originalPositionFor(metadata, value.length, selectorFallbacks) :\n    metadata;\n}\n\nfunction tokenTypeFrom(buffer) {\n  var isAtRule = buffer[0] == Marker.AT || buffer[0] == Marker.UNDERSCORE;\n  var ruleWord = buffer.join('').split(RULE_WORD_SEPARATOR_PATTERN)[0];\n\n  if (isAtRule && BLOCK_RULES.indexOf(ruleWord) > -1) {\n    return Token.NESTED_BLOCK;\n  } else if (isAtRule && AT_RULES.indexOf(ruleWord) > -1) {\n    return Token.AT_RULE;\n  } else if (isAtRule) {\n    return Token.AT_RULE_BLOCK;\n  } else {\n    return Token.RULE;\n  }\n}\n\nfunction tokenScopeFrom(tokenType) {\n  if (tokenType == Token.RULE) {\n    return Token.RULE_SCOPE;\n  } else if (tokenType == Token.NESTED_BLOCK) {\n    return Token.NESTED_BLOCK_SCOPE;\n  } else if (tokenType == Token.AT_RULE_BLOCK) {\n    return Token.AT_RULE_BLOCK_SCOPE;\n  }\n}\n\nfunction isPageMarginBox(buffer) {\n  var serializedBuffer = buffer.join('').trim();\n\n  return PAGE_MARGIN_BOXES.indexOf(serializedBuffer) > -1 || EXTRA_PAGE_BOXES.indexOf(serializedBuffer) > -1;\n}\n\nfunction isRepeatToken(buffer) {\n  return REPEAT_PATTERN.test(buffer.join('') + Marker.CLOSE_SQUARE_BRACKET);\n}\n\nmodule.exports = tokenize;\n","function cloneArray(array) {\n  var cloned = array.slice(0);\n\n  for (var i = 0, l = cloned.length; i < l; i++) {\n    if (Array.isArray(cloned[i]))\n      cloned[i] = cloneArray(cloned[i]);\n  }\n\n  return cloned;\n}\n\nmodule.exports = cloneArray;\n","function formatPosition(metadata) {\n  var line = metadata[0];\n  var column = metadata[1];\n  var source = metadata[2];\n\n  return source ?\n    source + ':' + line + ':' + column :\n    line + ':' + column;\n}\n\nmodule.exports = formatPosition;\n","var NO_PROTOCOL_RESOURCE_PATTERN = /^\\/\\//;\n\nfunction hasProtocol(uri) {\n  return !NO_PROTOCOL_RESOURCE_PATTERN.test(uri);\n}\n\nmodule.exports = hasProtocol;\n","var DATA_URI_PATTERN = /^data:(\\S*?)?(;charset=(?:(?!;charset=)[^;])+)?(;[^,]+?)?,(.+)/;\n\nfunction isDataUriResource(uri) {\n  return DATA_URI_PATTERN.test(uri);\n}\n\nmodule.exports = isDataUriResource;\n","var HTTP_RESOURCE_PATTERN = /^http:\\/\\//;\n\nfunction isHttpResource(uri) {\n  return HTTP_RESOURCE_PATTERN.test(uri);\n}\n\nmodule.exports = isHttpResource;\n","var HTTPS_RESOURCE_PATTERN = /^https:\\/\\//;\n\nfunction isHttpsResource(uri) {\n  return HTTPS_RESOURCE_PATTERN.test(uri);\n}\n\nmodule.exports = isHttpsResource;\n","var IMPORT_PREFIX_PATTERN = /^@import/i;\n\nfunction isImport(value) {\n  return IMPORT_PREFIX_PATTERN.test(value);\n}\n\nmodule.exports = isImport;\n","var REMOTE_RESOURCE_PATTERN = /^(\\w+:\\/\\/|\\/\\/)/;\n\nfunction isRemoteResource(uri) {\n  return REMOTE_RESOURCE_PATTERN.test(uri);\n}\n\nmodule.exports = isRemoteResource;\n","// adapted from http://nedbatchelder.com/blog/200712.html#e20071211T054956\n\nvar NUMBER_PATTERN = /([0-9]+)/;\n\nfunction naturalCompare(value1, value2) {\n  var keys1 = ('' + value1).split(NUMBER_PATTERN).map(tryParseInt);\n  var keys2 = ('' + value2).split(NUMBER_PATTERN).map(tryParseInt);\n  var key1;\n  var key2;\n  var compareFirst = Math.min(keys1.length, keys2.length);\n  var i, l;\n\n  for (i = 0, l = compareFirst; i < l; i++) {\n    key1 = keys1[i];\n    key2 = keys2[i];\n\n    if (key1 != key2) {\n      return key1 > key2 ? 1 : -1;\n    }\n  }\n\n  return keys1.length > keys2.length ? 1 : (keys1.length == keys2.length ? 0 : -1);\n}\n\nfunction tryParseInt(value) {\n  return ('' + parseInt(value)) == value ?\n    parseInt(value) :\n    value;\n}\n\nmodule.exports = naturalCompare;\n","function override(source1, source2) {\n  var target = {};\n  var key1;\n  var key2;\n  var item;\n\n  for (key1 in source1) {\n    item = source1[key1];\n\n    if (Array.isArray(item)) {\n      target[key1] = item.slice(0);\n    } else if (typeof item == 'object' && item !== null) {\n      target[key1] = override(item, {});\n    } else {\n      target[key1] = item;\n    }\n  }\n\n  for (key2 in source2) {\n    item = source2[key2];\n\n    if (key2 in target && Array.isArray(item)) {\n      target[key2] = item.slice(0);\n    } else if (key2 in target && typeof item == 'object' && item !== null) {\n      target[key2] = override(target[key2], item);\n    } else {\n      target[key2] = item;\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = override;\n","var Marker = require('../tokenizer/marker');\n\nfunction is(value, separator, isSeparatorRegex) {\n  return isSeparatorRegex ?\n    separator.test(value) :\n    value === separator;\n}\n\nfunction split(value, separator) {\n  var openLevel = Marker.OPEN_ROUND_BRACKET;\n  var closeLevel = Marker.CLOSE_ROUND_BRACKET;\n  var level = 0;\n  var cursor = 0;\n  var lastStart = 0;\n  var lastValue;\n  var lastCharacter;\n  var len = value.length;\n  var parts = [];\n  var isSeparatorRegex = typeof(separator) == 'object' && 'exec' in separator;\n\n  if (!isSeparatorRegex && value.indexOf(separator) == -1) {\n    return [value];\n  }\n\n  if (value.indexOf(openLevel) == -1) {\n    return value.split(separator);\n  }\n\n  while (cursor < len) {\n    if (value[cursor] == openLevel) {\n      level++;\n    } else if (value[cursor] == closeLevel) {\n      level--;\n    }\n\n    if (level === 0 && cursor > 0 && cursor + 1 < len && is(value[cursor], separator, isSeparatorRegex)) {\n      parts.push(value.substring(lastStart, cursor));\n\n      if (isSeparatorRegex && separator.exec(value[cursor]).length > 1) {\n        parts.push(value[cursor]);\n      }\n\n      lastStart = cursor + 1;\n    }\n\n    cursor++;\n  }\n\n  if (lastStart < cursor + 1) {\n    lastValue = value.substring(lastStart);\n    lastCharacter = lastValue[lastValue.length - 1];\n    if (is(lastCharacter, separator, isSeparatorRegex)) {\n      lastValue = lastValue.substring(0, lastValue.length - 1);\n    }\n\n    parts.push(lastValue);\n  }\n\n  return parts;\n}\n\nmodule.exports = split;\n","var emptyCharacter = '';\n\nvar Breaks = require('../options/format').Breaks;\nvar Spaces = require('../options/format').Spaces;\n\nvar Marker = require('../tokenizer/marker');\nvar Token = require('../tokenizer/token');\n\nfunction supportsAfterClosingBrace(token) {\n  return token[1][1] == 'background' || token[1][1] == 'transform' || token[1][1] == 'src';\n}\n\nfunction afterClosingBrace(token, valueIndex) {\n  return token[valueIndex][1][token[valueIndex][1].length - 1] == Marker.CLOSE_ROUND_BRACKET;\n}\n\nfunction afterComma(token, valueIndex) {\n  return token[valueIndex][1] == Marker.COMMA;\n}\n\nfunction afterSlash(token, valueIndex) {\n  return token[valueIndex][1] == Marker.FORWARD_SLASH;\n}\n\nfunction beforeComma(token, valueIndex) {\n  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.COMMA;\n}\n\nfunction beforeSlash(token, valueIndex) {\n  return token[valueIndex + 1] && token[valueIndex + 1][1] == Marker.FORWARD_SLASH;\n}\n\nfunction inFilter(token) {\n  return token[1][1] == 'filter' || token[1][1] == '-ms-filter';\n}\n\nfunction disallowsSpace(context, token, valueIndex) {\n  return !context.spaceAfterClosingBrace && supportsAfterClosingBrace(token) && afterClosingBrace(token, valueIndex) ||\n    beforeSlash(token, valueIndex) ||\n    afterSlash(token, valueIndex) ||\n    beforeComma(token, valueIndex) ||\n    afterComma(token, valueIndex);\n}\n\nfunction rules(context, tokens) {\n  var store = context.store;\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    store(context, tokens[i]);\n\n    if (i < l - 1) {\n      store(context, comma(context));\n    }\n  }\n}\n\nfunction body(context, tokens) {\n  var lastPropertyAt = lastPropertyIndex(tokens);\n\n  for (var i = 0, l = tokens.length; i < l; i++) {\n    property(context, tokens, i, lastPropertyAt);\n  }\n}\n\nfunction lastPropertyIndex(tokens) {\n  var index = tokens.length - 1;\n\n  for (; index >= 0; index--) {\n    if (tokens[index][0] != Token.COMMENT) {\n      break;\n    }\n  }\n\n  return index;\n}\n\nfunction property(context, tokens, position, lastPropertyAt) {\n  var store = context.store;\n  var token = tokens[position];\n\n  var propertyValue = token[2];\n  var isPropertyBlock = propertyValue && propertyValue[0] === Token.PROPERTY_BLOCK;\n\n  var needsSemicolon;\n  if ( context.format ) {\n    if ( context.format.semicolonAfterLastProperty || isPropertyBlock ) {\n      needsSemicolon = true;\n    } else if ( position < lastPropertyAt ) {\n      needsSemicolon = true;\n    } else {\n      needsSemicolon = false;\n    }\n  } else {\n    needsSemicolon = position < lastPropertyAt || isPropertyBlock;\n  }\n\n  var isLast = position === lastPropertyAt;\n\n  switch (token[0]) {\n    case Token.AT_RULE:\n      store(context, token);\n      store(context, semicolon(context, Breaks.AfterProperty, false));\n      break;\n    case Token.AT_RULE_BLOCK:\n      rules(context, token[1]);\n      store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n      body(context, token[2]);\n      store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n      break;\n    case Token.COMMENT:\n      store(context, token);\n      store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);\n      break;\n    case Token.PROPERTY:\n      store(context, token[1]);\n      store(context, colon(context));\n      if (propertyValue) {\n        value(context, token);\n      }\n      store(context, needsSemicolon ? semicolon(context, Breaks.AfterProperty, isLast) : emptyCharacter);\n      break;\n    case Token.RAW:\n      store(context, token);\n  }\n}\n\nfunction value(context, token) {\n  var store = context.store;\n  var j, m;\n\n  if (token[2][0] == Token.PROPERTY_BLOCK) {\n    store(context, openBrace(context, Breaks.AfterBlockBegins, false));\n    body(context, token[2][1]);\n    store(context, closeBrace(context, Breaks.AfterBlockEnds, false, true));\n  } else {\n    for (j = 2, m = token.length; j < m; j++) {\n      store(context, token[j]);\n\n      if (j < m - 1 && (inFilter(token) || !disallowsSpace(context, token, j))) {\n        store(context, Marker.SPACE);\n      }\n    }\n  }\n}\n\nfunction breakFor(context, where) {\n  return context.format ? context.format.breaks[where] : emptyCharacter;\n}\n\nfunction allowsSpace(context, where) {\n  return context.format && context.format.spaces[where];\n}\n\nfunction openBrace(context, where, needsPrefixSpace) {\n  if (context.format) {\n    context.indentBy += context.format.indentBy;\n    context.indentWith = context.format.indentWith.repeat(context.indentBy);\n    return (needsPrefixSpace && allowsSpace(context, Spaces.BeforeBlockBegins) ? Marker.SPACE : emptyCharacter) +\n      Marker.OPEN_CURLY_BRACKET +\n      breakFor(context, where) +\n      context.indentWith;\n  } else {\n    return Marker.OPEN_CURLY_BRACKET;\n  }\n}\n\nfunction closeBrace(context, where, beforeBlockEnd, isLast) {\n  if (context.format) {\n    context.indentBy -= context.format.indentBy;\n    context.indentWith = context.format.indentWith.repeat(context.indentBy);\n    return (beforeBlockEnd ? breakFor(context, Breaks.BeforeBlockEnds) : breakFor(context, Breaks.AfterProperty)) +\n      context.indentWith +\n      Marker.CLOSE_CURLY_BRACKET +\n      (isLast ? emptyCharacter : breakFor(context, where) + context.indentWith);\n  } else {\n    return Marker.CLOSE_CURLY_BRACKET;\n  }\n}\n\nfunction colon(context) {\n  return context.format ?\n    Marker.COLON + (allowsSpace(context, Spaces.BeforeValue) ? Marker.SPACE : emptyCharacter) :\n    Marker.COLON;\n}\n\nfunction semicolon(context, where, isLast) {\n  return context.format ?\n    Marker.SEMICOLON + (isLast ? emptyCharacter : (breakFor(context, where) + context.indentWith)) :\n    Marker.SEMICOLON;\n}\n\nfunction comma(context) {\n  return context.format ?\n    Marker.COMMA + breakFor(context, Breaks.BetweenSelectors) + context.indentWith :\n    Marker.COMMA;\n}\n\nfunction all(context, tokens) {\n  var store = context.store;\n  var token;\n  var isLast;\n  var i, l;\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    token = tokens[i];\n    isLast = i == l - 1;\n\n    switch (token[0]) {\n      case Token.AT_RULE:\n        store(context, token);\n        store(context, semicolon(context, Breaks.AfterAtRule, isLast));\n        break;\n      case Token.AT_RULE_BLOCK:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n        body(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n        break;\n      case Token.NESTED_BLOCK:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterBlockBegins, true));\n        all(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterBlockEnds, true, isLast));\n        break;\n      case Token.COMMENT:\n        store(context, token);\n        store(context, breakFor(context, Breaks.AfterComment) + context.indentWith);\n        break;\n      case Token.RAW:\n        store(context, token);\n        break;\n      case Token.RULE:\n        rules(context, token[1]);\n        store(context, openBrace(context, Breaks.AfterRuleBegins, true));\n        body(context, token[2]);\n        store(context, closeBrace(context, Breaks.AfterRuleEnds, false, isLast));\n        break;\n    }\n  }\n}\n\nmodule.exports = {\n  all: all,\n  body: body,\n  property: property,\n  rules: rules,\n  value: value\n};\n","var helpers = require('./helpers');\n\nfunction store(serializeContext, token) {\n  serializeContext.output.push(typeof token == 'string' ? token : token[1]);\n}\n\nfunction context() {\n  var newContext = {\n    output: [],\n    store: store\n  };\n\n  return newContext;\n}\n\nfunction all(tokens) {\n  var oneTimeContext = context();\n  helpers.all(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction body(tokens) {\n  var oneTimeContext = context();\n  helpers.body(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction property(tokens, position) {\n  var oneTimeContext = context();\n  helpers.property(oneTimeContext, tokens, position, true);\n  return oneTimeContext.output.join('');\n}\n\nfunction rules(tokens) {\n  var oneTimeContext = context();\n  helpers.rules(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nfunction value(tokens) {\n  var oneTimeContext = context();\n  helpers.value(oneTimeContext, tokens);\n  return oneTimeContext.output.join('');\n}\n\nmodule.exports = {\n  all: all,\n  body: body,\n  property: property,\n  rules: rules,\n  value: value\n};\n","var all = require('./helpers').all;\n\nfunction store(serializeContext, token) {\n  var value = typeof token == 'string' ?\n    token :\n    token[1];\n  var wrap = serializeContext.wrap;\n\n  wrap(serializeContext, value);\n  track(serializeContext, value);\n  serializeContext.output.push(value);\n}\n\nfunction wrap(serializeContext, value) {\n  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {\n    track(serializeContext, serializeContext.format.breakWith);\n    serializeContext.output.push(serializeContext.format.breakWith);\n  }\n}\n\nfunction track(serializeContext, value) {\n  var parts = value.split('\\n');\n\n  serializeContext.line += parts.length - 1;\n  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);\n}\n\nfunction serializeStyles(tokens, context) {\n  var serializeContext = {\n    column: 0,\n    format: context.options.format,\n    indentBy: 0,\n    indentWith: '',\n    line: 1,\n    output: [],\n    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,\n    store: store,\n    wrap: context.options.format.wrapAt ?\n      wrap :\n      function () { /* noop */  }\n  };\n\n  all(serializeContext, tokens);\n\n  return {\n    styles: serializeContext.output.join('')\n  };\n}\n\nmodule.exports = serializeStyles;\n","var SourceMapGenerator = require('source-map').SourceMapGenerator;\nvar all = require('./helpers').all;\n\nvar isRemoteResource = require('../utils/is-remote-resource');\n\nvar isWindows = process.platform == 'win32';\n\nvar NIX_SEPARATOR_PATTERN = /\\//g;\nvar UNKNOWN_SOURCE = '$stdin';\nvar WINDOWS_SEPARATOR = '\\\\';\n\nfunction store(serializeContext, element) {\n  var fromString = typeof element == 'string';\n  var value = fromString ? element : element[1];\n  var mappings = fromString ? null : element[2];\n  var wrap = serializeContext.wrap;\n\n  wrap(serializeContext, value);\n  track(serializeContext, value, mappings);\n  serializeContext.output.push(value);\n}\n\nfunction wrap(serializeContext, value) {\n  if (serializeContext.column + value.length > serializeContext.format.wrapAt) {\n    track(serializeContext, serializeContext.format.breakWith, false);\n    serializeContext.output.push(serializeContext.format.breakWith);\n  }\n}\n\nfunction track(serializeContext, value, mappings) {\n  var parts = value.split('\\n');\n\n  if (mappings) {\n    trackAllMappings(serializeContext, mappings);\n  }\n\n  serializeContext.line += parts.length - 1;\n  serializeContext.column = parts.length > 1 ? 0 : (serializeContext.column + parts.pop().length);\n}\n\nfunction trackAllMappings(serializeContext, mappings) {\n  for (var i = 0, l = mappings.length; i < l; i++) {\n    trackMapping(serializeContext, mappings[i]);\n  }\n}\n\nfunction trackMapping(serializeContext, mapping) {\n  var line = mapping[0];\n  var column = mapping[1];\n  var originalSource = mapping[2];\n  var source = originalSource;\n  var storedSource = source || UNKNOWN_SOURCE;\n\n  if (isWindows && source && !isRemoteResource(source)) {\n    storedSource = source.replace(NIX_SEPARATOR_PATTERN, WINDOWS_SEPARATOR);\n  }\n\n  serializeContext.outputMap.addMapping({\n    generated: {\n      line: serializeContext.line,\n      column: serializeContext.column\n    },\n    source: storedSource,\n    original: {\n      line: line,\n      column: column\n    }\n  });\n\n  if (serializeContext.inlineSources && (originalSource in serializeContext.sourcesContent)) {\n    serializeContext.outputMap.setSourceContent(storedSource, serializeContext.sourcesContent[originalSource]);\n  }\n}\n\nfunction serializeStylesAndSourceMap(tokens, context) {\n  var serializeContext = {\n    column: 0,\n    format: context.options.format,\n    indentBy: 0,\n    indentWith: '',\n    inlineSources: context.options.sourceMapInlineSources,\n    line: 1,\n    output: [],\n    outputMap: new SourceMapGenerator(),\n    sourcesContent: context.sourcesContent,\n    spaceAfterClosingBrace: context.options.compatibility.properties.spaceAfterClosingBrace,\n    store: store,\n    wrap: context.options.format.wrapAt ?\n      wrap :\n      function () { /* noop */  }\n  };\n\n  all(serializeContext, tokens);\n\n  return {\n    sourceMap: serializeContext.outputMap,\n    styles: serializeContext.output.join('')\n  };\n}\n\nmodule.exports = serializeStylesAndSourceMap;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar parser_context_1 = require(\"./parser-context\");\nvar render_1 = require(\"./render\");\nvar CssSelectorParser = /** @class */ (function () {\n    function CssSelectorParser() {\n        this.pseudos = {};\n        this.attrEqualityMods = {};\n        this.ruleNestingOperators = {};\n        this.substitutesEnabled = false;\n    }\n    CssSelectorParser.prototype.registerSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_1 = pseudos; _a < pseudos_1.length; _a++) {\n            var pseudo = pseudos_1[_a];\n            this.pseudos[pseudo] = 'selector';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterSelectorPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_2 = pseudos; _a < pseudos_2.length; _a++) {\n            var pseudo = pseudos_2[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_3 = pseudos; _a < pseudos_3.length; _a++) {\n            var pseudo = pseudos_3[_a];\n            this.pseudos[pseudo] = 'numeric';\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNumericPseudos = function () {\n        var pseudos = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            pseudos[_i] = arguments[_i];\n        }\n        for (var _a = 0, pseudos_4 = pseudos; _a < pseudos_4.length; _a++) {\n            var pseudo = pseudos_4[_a];\n            delete this.pseudos[pseudo];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_1 = operators; _a < operators_1.length; _a++) {\n            var operator = operators_1[_a];\n            this.ruleNestingOperators[operator] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterNestingOperators = function () {\n        var operators = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operators[_i] = arguments[_i];\n        }\n        for (var _a = 0, operators_2 = operators; _a < operators_2.length; _a++) {\n            var operator = operators_2[_a];\n            delete this.ruleNestingOperators[operator];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.registerAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_1 = mods; _a < mods_1.length; _a++) {\n            var mod = mods_1[_a];\n            this.attrEqualityMods[mod] = true;\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.unregisterAttrEqualityMods = function () {\n        var mods = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            mods[_i] = arguments[_i];\n        }\n        for (var _a = 0, mods_2 = mods; _a < mods_2.length; _a++) {\n            var mod = mods_2[_a];\n            delete this.attrEqualityMods[mod];\n        }\n        return this;\n    };\n    CssSelectorParser.prototype.enableSubstitutes = function () {\n        this.substitutesEnabled = true;\n        return this;\n    };\n    CssSelectorParser.prototype.disableSubstitutes = function () {\n        this.substitutesEnabled = false;\n        return this;\n    };\n    CssSelectorParser.prototype.parse = function (str) {\n        return parser_context_1.parseCssSelector(str, 0, this.pseudos, this.attrEqualityMods, this.ruleNestingOperators, this.substitutesEnabled);\n    };\n    CssSelectorParser.prototype.render = function (path) {\n        return render_1.renderEntity(path).trim();\n    };\n    return CssSelectorParser;\n}());\nexports.CssSelectorParser = CssSelectorParser;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction parseCssSelector(str, pos, pseudos, attrEqualityMods, ruleNestingOperators, substitutesEnabled) {\n    var l = str.length;\n    var chr = '';\n    function getStr(quote, escapeTable) {\n        var result = '';\n        pos++;\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (chr === quote) {\n                pos++;\n                return result;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                chr = str.charAt(pos);\n                var esc = void 0;\n                if (chr === quote) {\n                    result += quote;\n                }\n                else if ((esc = escapeTable[chr]) !== undefined) {\n                    result += esc;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                result += chr;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function getIdent() {\n        var result = '';\n        chr = str.charAt(pos);\n        while (pos < l) {\n            if (utils_1.isIdent(chr)) {\n                result += chr;\n            }\n            else if (chr === '\\\\') {\n                pos++;\n                if (pos >= l) {\n                    throw Error('Expected symbol but end of file reached.');\n                }\n                chr = str.charAt(pos);\n                if (utils_1.identSpecialChars[chr]) {\n                    result += chr;\n                }\n                else if (utils_1.isHex(chr)) {\n                    var hex = chr;\n                    pos++;\n                    chr = str.charAt(pos);\n                    while (utils_1.isHex(chr)) {\n                        hex += chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (chr === ' ') {\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    result += String.fromCharCode(parseInt(hex, 16));\n                    continue;\n                }\n                else {\n                    result += chr;\n                }\n            }\n            else {\n                return result;\n            }\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function skipWhitespace() {\n        chr = str.charAt(pos);\n        var result = false;\n        while (chr === ' ' || chr === \"\\t\" || chr === \"\\n\" || chr === \"\\r\" || chr === \"\\f\") {\n            result = true;\n            pos++;\n            chr = str.charAt(pos);\n        }\n        return result;\n    }\n    function parse() {\n        var res = parseSelector();\n        if (pos < l) {\n            throw Error('Rule expected but \"' + str.charAt(pos) + '\" found.');\n        }\n        return res;\n    }\n    function parseSelector() {\n        var selector = parseSingleSelector();\n        if (!selector) {\n            return null;\n        }\n        var res = selector;\n        chr = str.charAt(pos);\n        while (chr === ',') {\n            pos++;\n            skipWhitespace();\n            if (res.type !== 'selectors') {\n                res = {\n                    type: 'selectors',\n                    selectors: [selector]\n                };\n            }\n            selector = parseSingleSelector();\n            if (!selector) {\n                throw Error('Rule expected after \",\".');\n            }\n            res.selectors.push(selector);\n        }\n        return res;\n    }\n    function parseSingleSelector() {\n        skipWhitespace();\n        var selector = {\n            type: 'ruleSet'\n        };\n        var rule = parseRule();\n        if (!rule) {\n            return null;\n        }\n        var currentRule = selector;\n        while (rule) {\n            rule.type = 'rule';\n            currentRule.rule = rule;\n            currentRule = rule;\n            skipWhitespace();\n            chr = str.charAt(pos);\n            if (pos >= l || chr === ',' || chr === ')') {\n                break;\n            }\n            if (ruleNestingOperators[chr]) {\n                var op = chr;\n                pos++;\n                skipWhitespace();\n                rule = parseRule();\n                if (!rule) {\n                    throw Error('Rule expected after \"' + op + '\".');\n                }\n                rule.nestingOperator = op;\n            }\n            else {\n                rule = parseRule();\n                if (rule) {\n                    rule.nestingOperator = null;\n                }\n            }\n        }\n        return selector;\n    }\n    // @ts-ignore no-overlap\n    function parseRule() {\n        var rule = null;\n        while (pos < l) {\n            chr = str.charAt(pos);\n            if (chr === '*') {\n                pos++;\n                (rule = rule || {}).tagName = '*';\n            }\n            else if (utils_1.isIdentStart(chr) || chr === '\\\\') {\n                (rule = rule || {}).tagName = getIdent();\n            }\n            else if (chr === '.') {\n                pos++;\n                rule = rule || {};\n                (rule.classNames = rule.classNames || []).push(getIdent());\n            }\n            else if (chr === '#') {\n                pos++;\n                (rule = rule || {}).id = getIdent();\n            }\n            else if (chr === '[') {\n                pos++;\n                skipWhitespace();\n                var attr = {\n                    name: getIdent()\n                };\n                skipWhitespace();\n                // @ts-ignore\n                if (chr === ']') {\n                    pos++;\n                }\n                else {\n                    var operator = '';\n                    if (attrEqualityMods[chr]) {\n                        operator = chr;\n                        pos++;\n                        chr = str.charAt(pos);\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \"=\" but end of file reached.');\n                    }\n                    if (chr !== '=') {\n                        throw Error('Expected \"=\" but \"' + chr + '\" found.');\n                    }\n                    attr.operator = operator + '=';\n                    pos++;\n                    skipWhitespace();\n                    var attrValue = '';\n                    attr.valueType = 'string';\n                    // @ts-ignore\n                    if (chr === '\"') {\n                        attrValue = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (chr === '\\'') {\n                        attrValue = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                        // @ts-ignore\n                    }\n                    else if (substitutesEnabled && chr === '$') {\n                        pos++;\n                        attrValue = getIdent();\n                        attr.valueType = 'substitute';\n                    }\n                    else {\n                        while (pos < l) {\n                            if (chr === ']') {\n                                break;\n                            }\n                            attrValue += chr;\n                            pos++;\n                            chr = str.charAt(pos);\n                        }\n                        attrValue = attrValue.trim();\n                    }\n                    skipWhitespace();\n                    if (pos >= l) {\n                        throw Error('Expected \"]\" but end of file reached.');\n                    }\n                    if (chr !== ']') {\n                        throw Error('Expected \"]\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    attr.value = attrValue;\n                }\n                rule = rule || {};\n                (rule.attrs = rule.attrs || []).push(attr);\n            }\n            else if (chr === ':') {\n                pos++;\n                var pseudoName = getIdent();\n                var pseudo = {\n                    name: pseudoName\n                };\n                // @ts-ignore\n                if (chr === '(') {\n                    pos++;\n                    var value = '';\n                    skipWhitespace();\n                    if (pseudos[pseudoName] === 'selector') {\n                        pseudo.valueType = 'selector';\n                        value = parseSelector();\n                    }\n                    else {\n                        pseudo.valueType = pseudos[pseudoName] || 'string';\n                        // @ts-ignore\n                        if (chr === '\"') {\n                            value = getStr('\"', utils_1.doubleQuotesEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (chr === '\\'') {\n                            value = getStr('\\'', utils_1.singleQuoteEscapeChars);\n                            // @ts-ignore\n                        }\n                        else if (substitutesEnabled && chr === '$') {\n                            pos++;\n                            value = getIdent();\n                            pseudo.valueType = 'substitute';\n                        }\n                        else {\n                            while (pos < l) {\n                                if (chr === ')') {\n                                    break;\n                                }\n                                value += chr;\n                                pos++;\n                                chr = str.charAt(pos);\n                            }\n                            value = value.trim();\n                        }\n                        skipWhitespace();\n                    }\n                    if (pos >= l) {\n                        throw Error('Expected \")\" but end of file reached.');\n                    }\n                    if (chr !== ')') {\n                        throw Error('Expected \")\" but \"' + chr + '\" found.');\n                    }\n                    pos++;\n                    pseudo.value = value;\n                }\n                rule = rule || {};\n                (rule.pseudos = rule.pseudos || []).push(pseudo);\n            }\n            else {\n                break;\n            }\n        }\n        return rule;\n    }\n    return parse();\n}\nexports.parseCssSelector = parseCssSelector;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar utils_1 = require(\"./utils\");\nfunction renderEntity(entity) {\n    var res = '';\n    switch (entity.type) {\n        case 'ruleSet':\n            var currentEntity = entity.rule;\n            var parts = [];\n            while (currentEntity) {\n                if (currentEntity.nestingOperator) {\n                    parts.push(currentEntity.nestingOperator);\n                }\n                parts.push(renderEntity(currentEntity));\n                currentEntity = currentEntity.rule;\n            }\n            res = parts.join(' ');\n            break;\n        case 'selectors':\n            res = entity.selectors.map(renderEntity).join(', ');\n            break;\n        case 'rule':\n            if (entity.tagName) {\n                if (entity.tagName === '*') {\n                    res = '*';\n                }\n                else {\n                    res = utils_1.escapeIdentifier(entity.tagName);\n                }\n            }\n            if (entity.id) {\n                res += \"#\" + utils_1.escapeIdentifier(entity.id);\n            }\n            if (entity.classNames) {\n                res += entity.classNames.map(function (cn) {\n                    return \".\" + (utils_1.escapeIdentifier(cn));\n                }).join('');\n            }\n            if (entity.attrs) {\n                res += entity.attrs.map(function (attr) {\n                    if ('operator' in attr) {\n                        if (attr.valueType === 'substitute') {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + \"$\" + attr.value + \"]\";\n                        }\n                        else {\n                            return \"[\" + utils_1.escapeIdentifier(attr.name) + attr.operator + utils_1.escapeStr(attr.value) + \"]\";\n                        }\n                    }\n                    else {\n                        return \"[\" + utils_1.escapeIdentifier(attr.name) + \"]\";\n                    }\n                }).join('');\n            }\n            if (entity.pseudos) {\n                res += entity.pseudos.map(function (pseudo) {\n                    if (pseudo.valueType) {\n                        if (pseudo.valueType === 'selector') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + renderEntity(pseudo.value) + \")\";\n                        }\n                        else if (pseudo.valueType === 'substitute') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"($\" + pseudo.value + \")\";\n                        }\n                        else if (pseudo.valueType === 'numeric') {\n                            return \":\" + utils_1.escapeIdentifier(pseudo.name) + \"(\" + pseudo.value + \")\";\n                        }\n                        else {\n                            return (\":\" + utils_1.escapeIdentifier(pseudo.name) +\n                                \"(\" + utils_1.escapeIdentifier(pseudo.value) + \")\");\n                        }\n                    }\n                    else {\n                        return \":\" + utils_1.escapeIdentifier(pseudo.name);\n                    }\n                }).join('');\n            }\n            break;\n        default:\n            throw Error('Unknown entity type: \"' + entity.type + '\".');\n    }\n    return res;\n}\nexports.renderEntity = renderEntity;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isIdentStart(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c === '-') || (c === '_');\n}\nexports.isIdentStart = isIdentStart;\nfunction isIdent(c) {\n    return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c === '-' || c === '_';\n}\nexports.isIdent = isIdent;\nfunction isHex(c) {\n    return (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F') || (c >= '0' && c <= '9');\n}\nexports.isHex = isHex;\nfunction escapeIdentifier(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (exports.identSpecialChars[chr]) {\n            result += '\\\\' + chr;\n        }\n        else {\n            if (!(chr === '_' || chr === '-' ||\n                (chr >= 'A' && chr <= 'Z') ||\n                (chr >= 'a' && chr <= 'z') ||\n                (i !== 0 && chr >= '0' && chr <= '9'))) {\n                var charCode = chr.charCodeAt(0);\n                if ((charCode & 0xF800) === 0xD800) {\n                    var extraCharCode = s.charCodeAt(i++);\n                    if ((charCode & 0xFC00) !== 0xD800 || (extraCharCode & 0xFC00) !== 0xDC00) {\n                        throw Error('UCS-2(decode): illegal sequence');\n                    }\n                    charCode = ((charCode & 0x3FF) << 10) + (extraCharCode & 0x3FF) + 0x10000;\n                }\n                result += '\\\\' + charCode.toString(16) + ' ';\n            }\n            else {\n                result += chr;\n            }\n        }\n        i++;\n    }\n    return result;\n}\nexports.escapeIdentifier = escapeIdentifier;\nfunction escapeStr(s) {\n    var len = s.length;\n    var result = '';\n    var i = 0;\n    var replacement;\n    while (i < len) {\n        var chr = s.charAt(i);\n        if (chr === '\"') {\n            chr = '\\\\\"';\n        }\n        else if (chr === '\\\\') {\n            chr = '\\\\\\\\';\n        }\n        else if ((replacement = exports.strReplacementsRev[chr]) !== undefined) {\n            chr = replacement;\n        }\n        result += chr;\n        i++;\n    }\n    return \"\\\"\" + result + \"\\\"\";\n}\nexports.escapeStr = escapeStr;\nexports.identSpecialChars = {\n    '!': true,\n    '\"': true,\n    '#': true,\n    '$': true,\n    '%': true,\n    '&': true,\n    '\\'': true,\n    '(': true,\n    ')': true,\n    '*': true,\n    '+': true,\n    ',': true,\n    '.': true,\n    '/': true,\n    ';': true,\n    '<': true,\n    '=': true,\n    '>': true,\n    '?': true,\n    '@': true,\n    '[': true,\n    '\\\\': true,\n    ']': true,\n    '^': true,\n    '`': true,\n    '{': true,\n    '|': true,\n    '}': true,\n    '~': true\n};\nexports.strReplacementsRev = {\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\t': '\\\\t',\n    '\\f': '\\\\f',\n    '\\v': '\\\\v'\n};\nexports.singleQuoteEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\\'': '\\''\n};\nexports.doubleQuotesEscapeChars = {\n    n: '\\n',\n    r: '\\r',\n    t: '\\t',\n    f: '\\f',\n    '\\\\': '\\\\',\n    '\"': '\"'\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = void 0;\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = exports.parse = void 0;\nvar parse_1 = require(\"./parse\");\nObject.defineProperty(exports, \"parse\", { enumerable: true, get: function () { return parse_1.parse; } });\nvar compile_1 = require(\"./compile\");\nObject.defineProperty(exports, \"compile\", { enumerable: true, get: function () { return compile_1.compile; } });\n/**\n * Parses and compiles a formula to a highly optimized function.\n * Combination of `parse` and `compile`.\n *\n * If the formula doesn't match any elements,\n * it returns [`boolbase`](https://github.com/fb55/boolbase)'s `falseFunc`.\n * Otherwise, a function accepting an _index_ is returned, which returns\n * whether or not the passed _index_ matches the formula.\n *\n * Note: The nth-rule starts counting at `1`, the returned function at `0`.\n *\n * @param formula The formula to compile.\n * @example\n * const check = nthCheck(\"2n+3\");\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction nthCheck(formula) {\n    return (0, compile_1.compile)((0, parse_1.parse)(formula));\n}\nexports.default = nthCheck;\n","\"use strict\";\n// Following http://www.w3.org/TR/css3-selectors/#nth-child-pseudo\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = void 0;\n// Whitespace as per https://www.w3.org/TR/selectors-3/#lex is \" \\t\\r\\n\\f\"\nvar whitespace = new Set([9, 10, 12, 13, 32]);\nvar ZERO = \"0\".charCodeAt(0);\nvar NINE = \"9\".charCodeAt(0);\n/**\n * Parses an expression.\n *\n * @throws An `Error` if parsing fails.\n * @returns An array containing the integer step size and the integer offset of the nth rule.\n * @example nthCheck.parse(\"2n+3\"); // returns [2, 3]\n */\nfunction parse(formula) {\n    formula = formula.trim().toLowerCase();\n    if (formula === \"even\") {\n        return [2, 0];\n    }\n    else if (formula === \"odd\") {\n        return [2, 1];\n    }\n    // Parse [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]?\n    var idx = 0;\n    var a = 0;\n    var sign = readSign();\n    var number = readNumber();\n    if (idx < formula.length && formula.charAt(idx) === \"n\") {\n        idx++;\n        a = sign * (number !== null && number !== void 0 ? number : 1);\n        skipWhitespace();\n        if (idx < formula.length) {\n            sign = readSign();\n            skipWhitespace();\n            number = readNumber();\n        }\n        else {\n            sign = number = 0;\n        }\n    }\n    // Throw if there is anything else\n    if (number === null || idx < formula.length) {\n        throw new Error(\"n-th rule couldn't be parsed ('\" + formula + \"')\");\n    }\n    return [a, sign * number];\n    function readSign() {\n        if (formula.charAt(idx) === \"-\") {\n            idx++;\n            return -1;\n        }\n        if (formula.charAt(idx) === \"+\") {\n            idx++;\n        }\n        return 1;\n    }\n    function readNumber() {\n        var start = idx;\n        var value = 0;\n        while (idx < formula.length &&\n            formula.charCodeAt(idx) >= ZERO &&\n            formula.charCodeAt(idx) <= NINE) {\n            value = value * 10 + (formula.charCodeAt(idx) - ZERO);\n            idx++;\n        }\n        // Return `null` if we didn't read anything.\n        return idx === start ? null : value;\n    }\n    function skipWhitespace() {\n        while (idx < formula.length &&\n            whitespace.has(formula.charCodeAt(idx))) {\n            idx++;\n        }\n    }\n}\nexports.parse = parse;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number is 1-based.\n *   - column: Optional. the column number in the original source.\n *    The column number is 0-based.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *    line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *    The column number is 0-based.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  if (sourceRoot) {\n    sourceRoot = util.normalize(sourceRoot);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this._absoluteSources = this._sources.toArray().map(function (s) {\n    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n  });\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this._sourceMapURL = aSourceMapURL;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Utility function to find the index of a source.  Returns -1 if not\n * found.\n */\nBasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {\n  var relativeSource = aSource;\n  if (this.sourceRoot != null) {\n    relativeSource = util.relative(this.sourceRoot, relativeSource);\n  }\n\n  if (this._sources.has(relativeSource)) {\n    return this._sources.indexOf(relativeSource);\n  }\n\n  // Maybe aSource is an absolute URL as returned by |sources|.  In\n  // this case we can't simply undo the transform.\n  var i;\n  for (i = 0; i < this._absoluteSources.length; ++i) {\n    if (this._absoluteSources[i] == aSource) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @param String aSourceMapURL\n *        The URL at which the source map can be found (optional)\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc._sourceMapURL = aSourceMapURL;\n    smc._absoluteSources = smc._sources.toArray().map(function (s) {\n      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);\n    });\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._absoluteSources.slice();\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    var index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    var relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.  The line number\n *     is 1-based.\n *   - column: The column number in the generated source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.  The\n *     line number is 1-based.\n *   - column: The column number in the original source, or null.  The\n *     column number is 0-based.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.  The line number\n *     is 1-based.\n *   - column: The column number in the original source.  The column\n *     number is 0-based.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.  The\n *     line number is 1-based. \n *   - column: The column number in the generated source, or null.\n *     The column number is 0-based.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = null;\n        if (mapping.name) {\n          name = section.consumer._names.at(mapping.name);\n          this._names.add(name);\n          name = this._names.indexOf(name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex] || '';\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   sources entry.  This value is prepended to the individual\n    //   entries in the source field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   sourceRoot, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction DEFNODE(type, props, methods, base) {\n    if (typeof base === \"undefined\") base = AST_Node;\n    props = props ? props.split(/\\s+/) : [];\n    var self_props = props;\n    if (base && base.PROPS) props = props.concat(base.PROPS);\n    var code = [\n        \"return function AST_\", type, \"(props){\",\n        // not essential, but speeds up compress by a few percent\n        \"this._bits=0;\",\n        \"if(props){\",\n    ];\n    props.forEach(function(prop) {\n        code.push(\"this.\", prop, \"=props.\", prop, \";\");\n    });\n    code.push(\"}\");\n    var proto = Object.create(base && base.prototype);\n    if (methods.initialize || proto.initialize) code.push(\"this.initialize();\");\n    code.push(\"};\");\n    var ctor = new Function(code.join(\"\"))();\n    ctor.prototype = proto;\n    ctor.prototype.CTOR = ctor;\n    ctor.prototype.TYPE = ctor.TYPE = type;\n    if (base) {\n        ctor.BASE = base;\n        base.SUBCLASSES.push(ctor);\n    }\n    ctor.DEFMETHOD = function(name, method) {\n        this.prototype[name] = method;\n    };\n    ctor.PROPS = props;\n    ctor.SELF_PROPS = self_props;\n    ctor.SUBCLASSES = [];\n    for (var name in methods) if (HOP(methods, name)) {\n        if (/^\\$/.test(name)) {\n            ctor[name.substr(1)] = methods[name];\n        } else {\n            ctor.DEFMETHOD(name, methods[name]);\n        }\n    }\n    if (typeof exports !== \"undefined\") exports[\"AST_\" + type] = ctor;\n    return ctor;\n}\n\nvar AST_Token = DEFNODE(\"Token\", \"type value line col pos endline endcol endpos nlb comments_before comments_after file raw\", {\n}, null);\n\nvar AST_Node = DEFNODE(\"Node\", \"start end\", {\n    _clone: function(deep) {\n        if (deep) {\n            var self = this.clone();\n            return self.transform(new TreeTransformer(function(node) {\n                if (node !== self) {\n                    return node.clone(true);\n                }\n            }));\n        }\n        return new this.CTOR(this);\n    },\n    clone: function(deep) {\n        return this._clone(deep);\n    },\n    $documentation: \"Base class of all AST nodes\",\n    $propdoc: {\n        start: \"[AST_Token] The first token of this node\",\n        end: \"[AST_Token] The last token of this node\"\n    },\n    walk: function(visitor) {\n        visitor.visit(this);\n    },\n    _validate: function() {\n        if (this.TYPE == \"Node\") throw new Error(\"should not instantiate AST_Node\");\n    },\n    validate: function() {\n        var ctor = this.CTOR;\n        do {\n            ctor.prototype._validate.call(this);\n        } while (ctor = ctor.BASE);\n    },\n    validate_ast: function() {\n        var marker = {};\n        this.walk(new TreeWalker(function(node) {\n            if (node.validate_visited === marker) {\n                throw new Error(string_template(\"cannot reuse {type} from [{file}:{line},{col}]\", {\n                    type: \"AST_\" + node.TYPE,\n                    file: node.start.file,\n                    line: node.start.line,\n                    col: node.start.col,\n                }));\n            }\n            node.validate_visited = marker;\n        }));\n    },\n}, null);\n\nDEF_BITPROPS(AST_Node, [\n    \"_optimized\",\n    \"_squeezed\",\n    // AST_Call\n    \"call_only\",\n    \"collapse_scanning\",\n    // AST_SymbolRef\n    \"defined\",\n    \"evaluating\",\n    \"falsy\",\n    // AST_SymbolRef\n    \"in_arg\",\n    // AST_Return\n    \"in_bool\",\n    // AST_SymbolRef\n    \"is_undefined\",\n    // AST_LambdaExpression\n    // AST_LambdaDefinition\n    \"inlined\",\n    // AST_Lambda\n    \"length_read\",\n    // AST_Yield\n    \"nested\",\n    // AST_Lambda\n    \"new\",\n    // AST_Call\n    // AST_PropAccess\n    \"optional\",\n    // AST_ClassProperty\n    \"private\",\n    // AST_Call\n    \"pure\",\n    // AST_Assign\n    \"redundant\",\n    // AST_ClassProperty\n    \"static\",\n    // AST_Call\n    // AST_PropAccess\n    \"terminal\",\n    \"truthy\",\n    // AST_Scope\n    \"uses_eval\",\n    // AST_Scope\n    \"uses_with\",\n]);\n\n(AST_Node.log_function = function(fn, verbose) {\n    if (typeof fn != \"function\") {\n        AST_Node.info = AST_Node.warn = noop;\n        return;\n    }\n    var printed = Object.create(null);\n    AST_Node.info = verbose ? function(text, props) {\n        log(\"INFO: \" + string_template(text, props));\n    } : noop;\n    AST_Node.warn = function(text, props) {\n        log(\"WARN: \" + string_template(text, props));\n    };\n\n    function log(msg) {\n        if (printed[msg]) return;\n        printed[msg] = true;\n        fn(msg);\n    }\n})();\n\nvar restore_transforms = [];\nAST_Node.enable_validation = function() {\n    AST_Node.disable_validation();\n    (function validate_transform(ctor) {\n        ctor.SUBCLASSES.forEach(validate_transform);\n        if (!HOP(ctor.prototype, \"transform\")) return;\n        var transform = ctor.prototype.transform;\n        ctor.prototype.transform = function(tw, in_list) {\n            var node = transform.call(this, tw, in_list);\n            if (node instanceof AST_Node) {\n                node.validate();\n            } else if (!(node === null || in_list && List.is_op(node))) {\n                throw new Error(\"invalid transformed value: \" + node);\n            }\n            return node;\n        };\n        restore_transforms.push(function() {\n            ctor.prototype.transform = transform;\n        });\n    })(this);\n};\n\nAST_Node.disable_validation = function() {\n    var restore;\n    while (restore = restore_transforms.pop()) restore();\n};\n\n/* -----[ statements ]----- */\n\nvar AST_Statement = DEFNODE(\"Statement\", null, {\n    $documentation: \"Base class of all statements\",\n    _validate: function() {\n        if (this.TYPE == \"Statement\") throw new Error(\"should not instantiate AST_Statement\");\n    },\n});\n\nvar AST_Debugger = DEFNODE(\"Debugger\", null, {\n    $documentation: \"Represents a debugger statement\",\n}, AST_Statement);\n\nvar AST_Directive = DEFNODE(\"Directive\", \"quote value\", {\n    $documentation: \"Represents a directive, like \\\"use strict\\\";\",\n    $propdoc: {\n        quote: \"[string?] the original quote character\",\n        value: \"[string] The value of this directive as a plain string (it's not an AST_String!)\",\n    },\n    _validate: function() {\n        if (this.quote != null) {\n            if (typeof this.quote != \"string\") throw new Error(\"quote must be string\");\n            if (!/^[\"']$/.test(this.quote)) throw new Error(\"invalid quote: \" + this.quote);\n        }\n        if (typeof this.value != \"string\") throw new Error(\"value must be string\");\n    },\n}, AST_Statement);\n\nvar AST_EmptyStatement = DEFNODE(\"EmptyStatement\", null, {\n    $documentation: \"The empty statement (empty block or simply a semicolon)\"\n}, AST_Statement);\n\nfunction is_statement(node) {\n    return node instanceof AST_Statement\n        && !(node instanceof AST_ClassExpression)\n        && !(node instanceof AST_LambdaExpression);\n}\n\nfunction validate_expression(value, prop, multiple, allow_spread, allow_hole) {\n    multiple = multiple ? \"contain\" : \"be\";\n    if (!(value instanceof AST_Node)) throw new Error(prop + \" must \" + multiple + \" AST_Node\");\n    if (value instanceof AST_DefaultValue) throw new Error(prop + \" cannot \" + multiple + \" AST_DefaultValue\");\n    if (value instanceof AST_Destructured) throw new Error(prop + \" cannot \" + multiple + \" AST_Destructured\");\n    if (value instanceof AST_Hole && !allow_hole) throw new Error(prop + \" cannot \" + multiple + \" AST_Hole\");\n    if (value instanceof AST_Spread && !allow_spread) throw new Error(prop + \" cannot \" + multiple + \" AST_Spread\");\n    if (is_statement(value)) throw new Error(prop + \" cannot \" + multiple + \" AST_Statement\");\n    if (value instanceof AST_SymbolDeclaration) {\n        throw new Error(prop + \" cannot \" + multiple + \" AST_SymbolDeclaration\");\n    }\n}\n\nfunction must_be_expression(node, prop) {\n    validate_expression(node[prop], prop);\n}\n\nvar AST_SimpleStatement = DEFNODE(\"SimpleStatement\", \"body\", {\n    $documentation: \"A statement consisting of an expression, i.e. a = 1 + 2\",\n    $propdoc: {\n        body: \"[AST_Node] an expression node (should not be instanceof AST_Statement)\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"body\");\n    },\n}, AST_Statement);\n\nvar AST_BlockScope = DEFNODE(\"BlockScope\", \"_var_names enclosed functions make_def parent_scope variables\", {\n    $documentation: \"Base class for all statements introducing a lexical scope\",\n    $propdoc: {\n        enclosed: \"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes\",\n        functions: \"[Dictionary/S] like `variables`, but only lists function declarations\",\n        parent_scope: \"[AST_Scope?/S] link to the parent scope\",\n        variables: \"[Dictionary/S] a map of name ---> SymbolDef for all variables/functions defined in this scope\",\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (this.enclosed) node.enclosed = this.enclosed.slice();\n        if (this.functions) node.functions = this.functions.clone();\n        if (this.variables) node.variables = this.variables.clone();\n        return node;\n    },\n    pinned: function() {\n        return this.resolve().pinned();\n    },\n    resolve: function() {\n        return this.parent_scope.resolve();\n    },\n    _validate: function() {\n        if (this.TYPE == \"BlockScope\") throw new Error(\"should not instantiate AST_BlockScope\");\n        if (this.parent_scope == null) return;\n        if (!(this.parent_scope instanceof AST_BlockScope)) throw new Error(\"parent_scope must be AST_BlockScope\");\n        if (!(this.resolve() instanceof AST_Scope)) throw new Error(\"must be contained within AST_Scope\");\n    },\n}, AST_Statement);\n\nfunction walk_body(node, visitor) {\n    node.body.forEach(function(node) {\n        node.walk(visitor);\n    });\n}\n\nvar AST_Block = DEFNODE(\"Block\", \"body\", {\n    $documentation: \"A body of statements (usually braced)\",\n    $propdoc: {\n        body: \"[AST_Statement*] an array of statements\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Block\") throw new Error(\"should not instantiate AST_Block\");\n        this.body.forEach(function(node) {\n            if (!is_statement(node)) throw new Error(\"body must contain AST_Statement\");\n        });\n    },\n}, AST_BlockScope);\n\nvar AST_BlockStatement = DEFNODE(\"BlockStatement\", null, {\n    $documentation: \"A block statement\",\n}, AST_Block);\n\nvar AST_StatementWithBody = DEFNODE(\"StatementWithBody\", \"body\", {\n    $documentation: \"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`\",\n    $propdoc: {\n        body: \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\"\n    },\n    _validate: function() {\n        if (this.TYPE == \"StatementWithBody\") throw new Error(\"should not instantiate AST_StatementWithBody\");\n        if (!is_statement(this.body)) throw new Error(\"body must be AST_Statement\");\n    },\n}, AST_BlockScope);\n\nvar AST_LabeledStatement = DEFNODE(\"LabeledStatement\", \"label\", {\n    $documentation: \"Statement with a label\",\n    $propdoc: {\n        label: \"[AST_Label] a label definition\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.label.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    clone: function(deep) {\n        var node = this._clone(deep);\n        if (deep) {\n            var label = node.label;\n            var def = this.label;\n            node.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_LoopControl) {\n                    if (!node.label || node.label.thedef !== def) return;\n                    node.label.thedef = label;\n                    label.references.push(node);\n                    return true;\n                }\n                if (node instanceof AST_Scope) return true;\n            }));\n        }\n        return node;\n    },\n    _validate: function() {\n        if (!(this.label instanceof AST_Label)) throw new Error(\"label must be AST_Label\");\n    },\n}, AST_StatementWithBody);\n\nvar AST_IterationStatement = DEFNODE(\"IterationStatement\", null, {\n    $documentation: \"Internal class.  All loops inherit from it.\",\n    _validate: function() {\n        if (this.TYPE == \"IterationStatement\") throw new Error(\"should not instantiate AST_IterationStatement\");\n    },\n}, AST_StatementWithBody);\n\nvar AST_DWLoop = DEFNODE(\"DWLoop\", \"condition\", {\n    $documentation: \"Base class for do/while statements\",\n    $propdoc: {\n        condition: \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\"\n    },\n    _validate: function() {\n        if (this.TYPE == \"DWLoop\") throw new Error(\"should not instantiate AST_DWLoop\");\n        must_be_expression(this, \"condition\");\n    },\n}, AST_IterationStatement);\n\nvar AST_Do = DEFNODE(\"Do\", null, {\n    $documentation: \"A `do` statement\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n            node.condition.walk(visitor);\n        });\n    }\n}, AST_DWLoop);\n\nvar AST_While = DEFNODE(\"While\", null, {\n    $documentation: \"A `while` statement\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.body.walk(visitor);\n        });\n    }\n}, AST_DWLoop);\n\nvar AST_For = DEFNODE(\"For\", \"init condition step\", {\n    $documentation: \"A `for` statement\",\n    $propdoc: {\n        init: \"[AST_Node?] the `for` initialization code, or null if empty\",\n        condition: \"[AST_Node?] the `for` termination clause, or null if empty\",\n        step: \"[AST_Node?] the `for` update clause, or null if empty\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.init) node.init.walk(visitor);\n            if (node.condition) node.condition.walk(visitor);\n            if (node.step) node.step.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.init != null) {\n            if (!(this.init instanceof AST_Node)) throw new Error(\"init must be AST_Node\");\n            if (is_statement(this.init) && !(this.init instanceof AST_Definitions)) {\n                throw new Error(\"init cannot be AST_Statement\");\n            }\n        }\n        if (this.condition != null) must_be_expression(this, \"condition\");\n        if (this.step != null) must_be_expression(this, \"step\");\n    },\n}, AST_IterationStatement);\n\nvar AST_ForEnumeration = DEFNODE(\"ForEnumeration\", \"init object\", {\n    $documentation: \"Base class for enumeration loops, i.e. `for ... in`, `for ... of` & `for await ... of`\",\n    $propdoc: {\n        init: \"[AST_Node] the assignment target during iteration\",\n        object: \"[AST_Node] the object to iterate over\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.init.walk(visitor);\n            node.object.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"ForEnumeration\") throw new Error(\"should not instantiate AST_ForEnumeration\");\n        if (this.init instanceof AST_Definitions) {\n            if (this.init.definitions.length != 1) throw new Error(\"init must have single declaration\");\n        } else {\n            validate_destructured(this.init, function(node) {\n                if (!(node instanceof AST_PropAccess || node instanceof AST_SymbolRef)) {\n                    throw new Error(\"init must be assignable: \" + node.TYPE);\n                }\n            });\n        }\n        must_be_expression(this, \"object\");\n    },\n}, AST_IterationStatement);\n\nvar AST_ForIn = DEFNODE(\"ForIn\", null, {\n    $documentation: \"A `for ... in` statement\",\n}, AST_ForEnumeration);\n\nvar AST_ForOf = DEFNODE(\"ForOf\", null, {\n    $documentation: \"A `for ... of` statement\",\n}, AST_ForEnumeration);\n\nvar AST_ForAwaitOf = DEFNODE(\"ForAwaitOf\", null, {\n    $documentation: \"A `for await ... of` statement\",\n}, AST_ForOf);\n\nvar AST_With = DEFNODE(\"With\", \"expression\", {\n    $documentation: \"A `with` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `with` expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n}, AST_StatementWithBody);\n\n/* -----[ scope and functions ]----- */\n\nvar AST_Scope = DEFNODE(\"Scope\", \"fn_defs may_call_this uses_eval uses_with\", {\n    $documentation: \"Base class for all statements introducing a lexical scope\",\n    $propdoc: {\n        uses_eval: \"[boolean/S] tells whether this scope contains a direct call to the global `eval`\",\n        uses_with: \"[boolean/S] tells whether this scope uses the `with` statement\",\n    },\n    pinned: function() {\n        return this.uses_eval || this.uses_with;\n    },\n    resolve: return_this,\n    _validate: function() {\n        if (this.TYPE == \"Scope\") throw new Error(\"should not instantiate AST_Scope\");\n    },\n}, AST_Block);\n\nvar AST_Toplevel = DEFNODE(\"Toplevel\", \"globals\", {\n    $documentation: \"The toplevel scope\",\n    $propdoc: {\n        globals: \"[Dictionary/S] a map of name ---> SymbolDef for all undeclared names\",\n    },\n    wrap: function(name) {\n        var body = this.body;\n        return parse([\n            \"(function(exports){'$ORIG';})(typeof \",\n            name,\n            \"=='undefined'?(\",\n            name,\n            \"={}):\",\n            name,\n            \");\"\n        ].join(\"\"), {\n            filename: \"wrap=\" + JSON.stringify(name)\n        }).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return List.splice(body);\n            }\n        }));\n    },\n    enclose: function(args_values) {\n        if (typeof args_values != \"string\") args_values = \"\";\n        var index = args_values.indexOf(\":\");\n        if (index < 0) index = args_values.length;\n        var body = this.body;\n        return parse([\n            \"(function(\",\n            args_values.slice(0, index),\n            '){\"$ORIG\"})(',\n            args_values.slice(index + 1),\n            \")\"\n        ].join(\"\"), {\n            filename: \"enclose=\" + JSON.stringify(args_values)\n        }).transform(new TreeTransformer(function(node) {\n            if (node instanceof AST_Directive && node.value == \"$ORIG\") {\n                return List.splice(body);\n            }\n        }));\n    }\n}, AST_Scope);\n\nvar AST_Lambda = DEFNODE(\"Lambda\", \"argnames length_read rest safe_ids uses_arguments\", {\n    $documentation: \"Base class for functions\",\n    $propdoc: {\n        argnames: \"[(AST_DefaultValue|AST_Destructured|AST_SymbolFunarg)*] array of function arguments and/or destructured literals\",\n        length_read: \"[boolean/S] whether length property of this function is accessed\",\n        rest: \"[(AST_Destructured|AST_SymbolFunarg)?] rest parameter, or null if absent\",\n        uses_arguments: \"[boolean|number/S] whether this function accesses the arguments array\",\n    },\n    each_argname: function(visit) {\n        var tw = new TreeWalker(function(node) {\n            if (node instanceof AST_DefaultValue) {\n                node.name.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                node.value.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_SymbolFunarg) visit(node);\n        });\n        this.argnames.forEach(function(argname) {\n            argname.walk(tw);\n        });\n        if (this.rest) this.rest.walk(tw);\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.name) node.name.walk(visitor);\n            node.argnames.forEach(function(argname) {\n                argname.walk(visitor);\n            });\n            if (node.rest) node.rest.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Lambda\") throw new Error(\"should not instantiate AST_Lambda\");\n        this.argnames.forEach(function(node) {\n            validate_destructured(node, function(node) {\n                if (!(node instanceof AST_SymbolFunarg)) throw new Error(\"argnames must be AST_SymbolFunarg[]\");\n            }, true);\n        });\n        if (this.rest != null) validate_destructured(this.rest, function(node) {\n            if (!(node instanceof AST_SymbolFunarg)) throw new Error(\"rest must be AST_SymbolFunarg\");\n        });\n    },\n}, AST_Scope);\n\nvar AST_Accessor = DEFNODE(\"Accessor\", null, {\n    $documentation: \"A getter/setter function\",\n    _validate: function() {\n        if (this.name != null) throw new Error(\"name must be null\");\n    },\n}, AST_Lambda);\n\nvar AST_LambdaExpression = DEFNODE(\"LambdaExpression\", \"inlined\", {\n    $documentation: \"Base class for function expressions\",\n    $propdoc: {\n        inlined: \"[boolean/S] whether this function has been inlined\",\n    },\n    _validate: function() {\n        if (this.TYPE == \"LambdaExpression\") throw new Error(\"should not instantiate AST_LambdaExpression\");\n    },\n}, AST_Lambda);\n\nfunction is_arrow(node) {\n    return node instanceof AST_Arrow || node instanceof AST_AsyncArrow;\n}\n\nfunction is_async(node) {\n    return node instanceof AST_AsyncArrow\n        || node instanceof AST_AsyncDefun\n        || node instanceof AST_AsyncFunction\n        || node instanceof AST_AsyncGeneratorDefun\n        || node instanceof AST_AsyncGeneratorFunction;\n}\n\nfunction is_generator(node) {\n    return node instanceof AST_AsyncGeneratorDefun\n        || node instanceof AST_AsyncGeneratorFunction\n        || node instanceof AST_GeneratorDefun\n        || node instanceof AST_GeneratorFunction;\n}\n\nfunction walk_lambda(node, tw) {\n    if (is_arrow(node) && node.value) {\n        node.value.walk(tw);\n    } else {\n        walk_body(node, tw);\n    }\n}\n\nvar AST_Arrow = DEFNODE(\"Arrow\", \"value\", {\n    $documentation: \"An arrow function expression\",\n    $propdoc: {\n        value: \"[AST_Node?] simple return expression, or null if using function body.\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.argnames.forEach(function(argname) {\n                argname.walk(visitor);\n            });\n            if (node.rest) node.rest.walk(visitor);\n            if (node.value) {\n                node.value.walk(visitor);\n            } else {\n                walk_body(node, visitor);\n            }\n        });\n    },\n    _validate: function() {\n        if (this.name != null) throw new Error(\"name must be null\");\n        if (this.uses_arguments) throw new Error(\"uses_arguments must be false\");\n        if (this.value != null) {\n            must_be_expression(this, \"value\");\n            if (this.body.length) throw new Error(\"body must be empty if value exists\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_AsyncArrow = DEFNODE(\"AsyncArrow\", \"value\", {\n    $documentation: \"An asynchronous arrow function expression\",\n    $propdoc: {\n        value: \"[AST_Node?] simple return expression, or null if using function body.\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.argnames.forEach(function(argname) {\n                argname.walk(visitor);\n            });\n            if (node.rest) node.rest.walk(visitor);\n            if (node.value) {\n                node.value.walk(visitor);\n            } else {\n                walk_body(node, visitor);\n            }\n        });\n    },\n    _validate: function() {\n        if (this.name != null) throw new Error(\"name must be null\");\n        if (this.uses_arguments) throw new Error(\"uses_arguments must be false\");\n        if (this.value != null) {\n            must_be_expression(this, \"value\");\n            if (this.body.length) throw new Error(\"body must be empty if value exists\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_AsyncFunction = DEFNODE(\"AsyncFunction\", \"name\", {\n    $documentation: \"An asynchronous function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function, or null if not specified\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_AsyncGeneratorFunction = DEFNODE(\"AsyncGeneratorFunction\", \"name\", {\n    $documentation: \"An asynchronous generator function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function, or null if not specified\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_Function = DEFNODE(\"Function\", \"name\", {\n    $documentation: \"A function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function, or null if not specified\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_GeneratorFunction = DEFNODE(\"GeneratorFunction\", \"name\", {\n    $documentation: \"A generator function expression\",\n    $propdoc: {\n        name: \"[AST_SymbolLambda?] the name of this function, or null if not specified\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolLambda)) throw new Error(\"name must be AST_SymbolLambda\");\n        }\n    },\n}, AST_LambdaExpression);\n\nvar AST_LambdaDefinition = DEFNODE(\"LambdaDefinition\", \"inlined name\", {\n    $documentation: \"Base class for function definitions\",\n    $propdoc: {\n        inlined: \"[boolean/S] whether this function has been inlined\",\n        name: \"[AST_SymbolDefun] the name of this function\",\n    },\n    _validate: function() {\n        if (this.TYPE == \"LambdaDefinition\") throw new Error(\"should not instantiate AST_LambdaDefinition\");\n        if (!(this.name instanceof AST_SymbolDefun)) throw new Error(\"name must be AST_SymbolDefun\");\n    },\n}, AST_Lambda);\n\nvar AST_AsyncDefun = DEFNODE(\"AsyncDefun\", null, {\n    $documentation: \"An asynchronous function definition\",\n}, AST_LambdaDefinition);\n\nvar AST_AsyncGeneratorDefun = DEFNODE(\"AsyncGeneratorDefun\", null, {\n    $documentation: \"An asynchronous generator function definition\",\n}, AST_LambdaDefinition);\n\nvar AST_Defun = DEFNODE(\"Defun\", null, {\n    $documentation: \"A function definition\",\n}, AST_LambdaDefinition);\n\nvar AST_GeneratorDefun = DEFNODE(\"GeneratorDefun\", null, {\n    $documentation: \"A generator function definition\",\n}, AST_LambdaDefinition);\n\n/* -----[ classes ]----- */\n\nvar AST_Class = DEFNODE(\"Class\", \"extends name properties\", {\n    $documentation: \"Base class for class literals\",\n    $propdoc: {\n        extends: \"[AST_Node?] the super class, or null if not specified\",\n        properties: \"[AST_ClassProperty*] array of class properties\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.name) node.name.walk(visitor);\n            if (node.extends) node.extends.walk(visitor);\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Class\") throw new Error(\"should not instantiate AST_Class\");\n        if (this.extends != null) must_be_expression(this, \"extends\");\n        this.properties.forEach(function(node) {\n            if (!(node instanceof AST_ClassProperty)) throw new Error(\"properties must contain AST_ClassProperty\");\n        });\n    },\n}, AST_BlockScope);\n\nvar AST_DefClass = DEFNODE(\"DefClass\", null, {\n    $documentation: \"A class definition\",\n    $propdoc: {\n        name: \"[AST_SymbolDefClass] the name of this class\",\n    },\n    _validate: function() {\n        if (!(this.name instanceof AST_SymbolDefClass)) throw new Error(\"name must be AST_SymbolDefClass\");\n    },\n}, AST_Class);\n\nvar AST_ClassExpression = DEFNODE(\"ClassExpression\", null, {\n    $documentation: \"A class expression\",\n    $propdoc: {\n        name: \"[AST_SymbolClass?] the name of this class, or null if not specified\",\n    },\n    _validate: function() {\n        if (this.name != null) {\n            if (!(this.name instanceof AST_SymbolClass)) throw new Error(\"name must be AST_SymbolClass\");\n        }\n    },\n}, AST_Class);\n\nvar AST_ClassProperty = DEFNODE(\"ClassProperty\", \"key private static value\", {\n    $documentation: \"Base class for `class` properties\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name (AST_Node for computed property)\",\n        private: \"[boolean] whether this is a private property\",\n        static: \"[boolean] whether this is a static property\",\n        value: \"[AST_Node?] property value (AST_Accessor for getters/setters, AST_LambdaExpression for methods, null if not specified for fields)\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.key instanceof AST_Node) node.key.walk(visitor);\n            if (node.value) node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"ClassProperty\") throw new Error(\"should not instantiate AST_ClassProperty\");\n        if (typeof this.key != \"string\") {\n            if (!(this.key instanceof AST_Node)) throw new Error(\"key must be string or AST_Node\");\n            must_be_expression(this, \"key\");\n        }\n        if(this.value != null) {\n            if (!(this.value instanceof AST_Node)) throw new Error(\"value must be AST_Node\");\n        }\n    },\n});\n\nvar AST_ClassField = DEFNODE(\"ClassField\", null, {\n    $documentation: \"A `class` field\",\n    _validate: function() {\n        if(this.value != null) must_be_expression(this, \"value\");\n    },\n}, AST_ClassProperty);\n\nvar AST_ClassGetter = DEFNODE(\"ClassGetter\", null, {\n    $documentation: \"A `class` getter\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ClassProperty);\n\nvar AST_ClassSetter = DEFNODE(\"ClassSetter\", null, {\n    $documentation: \"A `class` setter\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ClassProperty);\n\nvar AST_ClassMethod = DEFNODE(\"ClassMethod\", null, {\n    $documentation: \"A `class` method\",\n    _validate: function() {\n        if (!(this.value instanceof AST_LambdaExpression)) throw new Error(\"value must be AST_LambdaExpression\");\n        if (is_arrow(this.value)) throw new Error(\"value cannot be AST_Arrow or AST_AsyncArrow\");\n        if (this.value.name != null) throw new Error(\"name of class method's lambda must be null\");\n    },\n}, AST_ClassProperty);\n\n/* -----[ JUMPS ]----- */\n\nvar AST_Jump = DEFNODE(\"Jump\", null, {\n    $documentation: \"Base class for jumps (for now that's `return`, `throw`, `break` and `continue`)\",\n    _validate: function() {\n        if (this.TYPE == \"Jump\") throw new Error(\"should not instantiate AST_Jump\");\n    },\n}, AST_Statement);\n\nvar AST_Exit = DEFNODE(\"Exit\", \"value\", {\n    $documentation: \"Base class for exits (`return` and `throw`)\",\n    $propdoc: {\n        value: \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.value) node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Exit\") throw new Error(\"should not instantiate AST_Exit\");\n    },\n}, AST_Jump);\n\nvar AST_Return = DEFNODE(\"Return\", null, {\n    $documentation: \"A `return` statement\",\n    _validate: function() {\n        if (this.value != null) must_be_expression(this, \"value\");\n    },\n}, AST_Exit);\n\nvar AST_Throw = DEFNODE(\"Throw\", null, {\n    $documentation: \"A `throw` statement\",\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n}, AST_Exit);\n\nvar AST_LoopControl = DEFNODE(\"LoopControl\", \"label\", {\n    $documentation: \"Base class for loop control statements (`break` and `continue`)\",\n    $propdoc: {\n        label: \"[AST_LabelRef?] the label, or null if none\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.label) node.label.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"LoopControl\") throw new Error(\"should not instantiate AST_LoopControl\");\n        if (this.label != null) {\n            if (!(this.label instanceof AST_LabelRef)) throw new Error(\"label must be AST_LabelRef\");\n        }\n    },\n}, AST_Jump);\n\nvar AST_Break = DEFNODE(\"Break\", null, {\n    $documentation: \"A `break` statement\"\n}, AST_LoopControl);\n\nvar AST_Continue = DEFNODE(\"Continue\", null, {\n    $documentation: \"A `continue` statement\"\n}, AST_LoopControl);\n\n/* -----[ IF ]----- */\n\nvar AST_If = DEFNODE(\"If\", \"condition alternative\", {\n    $documentation: \"A `if` statement\",\n    $propdoc: {\n        condition: \"[AST_Node] the `if` condition\",\n        alternative: \"[AST_Statement?] the `else` part, or null if not present\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.body.walk(visitor);\n            if (node.alternative) node.alternative.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"condition\");\n        if (this.alternative != null) {\n            if (!is_statement(this.alternative)) throw new Error(\"alternative must be AST_Statement\");\n        }\n    },\n}, AST_StatementWithBody);\n\n/* -----[ SWITCH ]----- */\n\nvar AST_Switch = DEFNODE(\"Switch\", \"expression\", {\n    $documentation: \"A `switch` statement\",\n    $propdoc: {\n        expression: \"[AST_Node] the `switch` discriminant\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n        this.body.forEach(function(node) {\n            if (!(node instanceof AST_SwitchBranch)) throw new Error(\"body must be AST_SwitchBranch[]\");\n        });\n    },\n}, AST_Block);\n\nvar AST_SwitchBranch = DEFNODE(\"SwitchBranch\", null, {\n    $documentation: \"Base class for `switch` branches\",\n    _validate: function() {\n        if (this.TYPE == \"SwitchBranch\") throw new Error(\"should not instantiate AST_SwitchBranch\");\n    },\n}, AST_Block);\n\nvar AST_Default = DEFNODE(\"Default\", null, {\n    $documentation: \"A `default` switch branch\",\n}, AST_SwitchBranch);\n\nvar AST_Case = DEFNODE(\"Case\", \"expression\", {\n    $documentation: \"A `case` switch branch\",\n    $propdoc: {\n        expression: \"[AST_Node] the `case` expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n}, AST_SwitchBranch);\n\n/* -----[ EXCEPTIONS ]----- */\n\nvar AST_Try = DEFNODE(\"Try\", \"bcatch bfinally\", {\n    $documentation: \"A `try` statement\",\n    $propdoc: {\n        bcatch: \"[AST_Catch?] the catch block, or null if not present\",\n        bfinally: \"[AST_Finally?] the finally block, or null if not present\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            walk_body(node, visitor);\n            if (node.bcatch) node.bcatch.walk(visitor);\n            if (node.bfinally) node.bfinally.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.bcatch != null) {\n            if (!(this.bcatch instanceof AST_Catch)) throw new Error(\"bcatch must be AST_Catch\");\n        }\n        if (this.bfinally != null) {\n            if (!(this.bfinally instanceof AST_Finally)) throw new Error(\"bfinally must be AST_Finally\");\n        }\n    },\n}, AST_Block);\n\nvar AST_Catch = DEFNODE(\"Catch\", \"argname\", {\n    $documentation: \"A `catch` node; only makes sense as part of a `try` statement\",\n    $propdoc: {\n        argname: \"[(AST_Destructured|AST_SymbolCatch)?] symbol for the exception, or null if not present\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.argname) node.argname.walk(visitor);\n            walk_body(node, visitor);\n        });\n    },\n    _validate: function() {\n        if (this.argname != null) validate_destructured(this.argname, function(node) {\n            if (!(node instanceof AST_SymbolCatch)) throw new Error(\"argname must be AST_SymbolCatch\");\n        });\n    },\n}, AST_Block);\n\nvar AST_Finally = DEFNODE(\"Finally\", null, {\n    $documentation: \"A `finally` node; only makes sense as part of a `try` statement\"\n}, AST_Block);\n\n/* -----[ VAR ]----- */\n\nvar AST_Definitions = DEFNODE(\"Definitions\", \"definitions\", {\n    $documentation: \"Base class for `var` nodes (variable declarations/initializations)\",\n    $propdoc: {\n        definitions: \"[AST_VarDef*] array of variable definitions\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.definitions.forEach(function(defn) {\n                defn.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Definitions\") throw new Error(\"should not instantiate AST_Definitions\");\n        if (this.definitions.length < 1) throw new Error(\"must have at least one definition\");\n    },\n}, AST_Statement);\n\nvar AST_Const = DEFNODE(\"Const\", null, {\n    $documentation: \"A `const` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolConst)) throw new Error(\"name must be AST_SymbolConst\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_Let = DEFNODE(\"Let\", null, {\n    $documentation: \"A `let` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolLet)) throw new Error(\"name must be AST_SymbolLet\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_Var = DEFNODE(\"Var\", null, {\n    $documentation: \"A `var` statement\",\n    _validate: function() {\n        this.definitions.forEach(function(node) {\n            if (!(node instanceof AST_VarDef)) throw new Error(\"definitions must be AST_VarDef[]\");\n            validate_destructured(node.name, function(node) {\n                if (!(node instanceof AST_SymbolVar)) throw new Error(\"name must be AST_SymbolVar\");\n            });\n        });\n    },\n}, AST_Definitions);\n\nvar AST_VarDef = DEFNODE(\"VarDef\", \"name value\", {\n    $documentation: \"A variable declaration; only appears in a AST_Definitions node\",\n    $propdoc: {\n        name: \"[AST_Destructured|AST_SymbolVar] name of the variable\",\n        value: \"[AST_Node?] initializer, or null of there's no initializer\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.name.walk(visitor);\n            if (node.value) node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.value != null) must_be_expression(this, \"value\");\n    },\n});\n\n/* -----[ OTHER ]----- */\n\nvar AST_ExportDeclaration = DEFNODE(\"ExportDeclaration\", \"body\", {\n    $documentation: \"An `export` statement\",\n    $propdoc: {\n        body: \"[AST_DefClass|AST_Definitions|AST_LambdaDefinition] the statement to export\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (!(this.body instanceof AST_DefClass\n            || this.body instanceof AST_Definitions\n            || this.body instanceof AST_LambdaDefinition)) {\n            throw new Error(\"body must be AST_DefClass, AST_Definitions or AST_LambdaDefinition\");\n        }\n    },\n}, AST_Statement);\n\nvar AST_ExportDefault = DEFNODE(\"ExportDefault\", \"body\", {\n    $documentation: \"An `export default` statement\",\n    $propdoc: {\n        body: \"[AST_Node] the default export\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.body.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (!(this.body instanceof AST_DefClass || this.body instanceof AST_LambdaDefinition)) {\n            must_be_expression(this, \"body\");\n        }\n    },\n}, AST_Statement);\n\nvar AST_ExportForeign = DEFNODE(\"ExportForeign\", \"aliases keys path quote\", {\n    $documentation: \"An `export ... from '...'` statement\",\n    $propdoc: {\n        aliases: \"[string*] array of aliases to export\",\n        keys: \"[string*] array of keys to import\",\n        path: \"[string] the path to import module\",\n        quote: \"[string?] the original quote character\",\n    },\n    _validate: function() {\n        if (this.aliases.length != this.keys.length) {\n            throw new Error(\"aliases:key length mismatch: \" + this.aliases.length + \" != \" + this.keys.length);\n        }\n        this.aliases.forEach(function(name) {\n            if (typeof name != \"string\") throw new Error(\"aliases must contain string\");\n        });\n        this.keys.forEach(function(name) {\n            if (typeof name != \"string\") throw new Error(\"keys must contain string\");\n        });\n        if (typeof this.path != \"string\") throw new Error(\"path must be string\");\n        if (this.quote != null) {\n            if (typeof this.quote != \"string\") throw new Error(\"quote must be string\");\n            if (!/^[\"']$/.test(this.quote)) throw new Error(\"invalid quote: \" + this.quote);\n        }\n    },\n}, AST_Statement);\n\nvar AST_ExportReferences = DEFNODE(\"ExportReferences\", \"properties\", {\n    $documentation: \"An `export { ... }` statement\",\n    $propdoc: {\n        properties: \"[AST_SymbolExport*] array of aliases to export\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        this.properties.forEach(function(prop) {\n            if (!(prop instanceof AST_SymbolExport)) throw new Error(\"properties must contain AST_SymbolExport\");\n        });\n    },\n}, AST_Statement);\n\nvar AST_Import = DEFNODE(\"Import\", \"all default path properties quote\", {\n    $documentation: \"An `import` statement\",\n    $propdoc: {\n        all: \"[AST_SymbolImport?] the imported namespace, or null if not specified\",\n        default: \"[AST_SymbolImport?] the alias for default `export`, or null if not specified\",\n        path: \"[string] the path to import module\",\n        properties: \"[(AST_SymbolImport*)?] array of aliases, or null if not specified\",\n        quote: \"[string?] the original quote character\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.all) node.all.walk(visitor);\n            if (node.default) node.default.walk(visitor);\n            if (node.properties) node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.all != null) {\n            if (!(this.all instanceof AST_SymbolImport)) throw new Error(\"all must be AST_SymbolImport\");\n            if (this.properties != null) throw new Error(\"cannot import both * and {} in the same statement\");\n        }\n        if (this.default != null) {\n            if (!(this.default instanceof AST_SymbolImport)) throw new Error(\"default must be AST_SymbolImport\");\n            if (this.default.key !== \"\") throw new Error(\"invalid default key: \" + this.default.key);\n        }\n        if (typeof this.path != \"string\") throw new Error(\"path must be string\");\n        if (this.properties != null) this.properties.forEach(function(node) {\n            if (!(node instanceof AST_SymbolImport)) throw new Error(\"properties must contain AST_SymbolImport\");\n        });\n        if (this.quote != null) {\n            if (typeof this.quote != \"string\") throw new Error(\"quote must be string\");\n            if (!/^[\"']$/.test(this.quote)) throw new Error(\"invalid quote: \" + this.quote);\n        }\n    },\n}, AST_Statement);\n\nvar AST_DefaultValue = DEFNODE(\"DefaultValue\", \"name value\", {\n    $documentation: \"A default value declaration\",\n    $propdoc: {\n        name: \"[AST_Destructured|AST_SymbolDeclaration] name of the variable\",\n        value: \"[AST_Node] value to assign if variable is `undefined`\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.name.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n});\n\nfunction must_be_expressions(node, prop, allow_spread, allow_hole) {\n    node[prop].forEach(function(node) {\n        validate_expression(node, prop, true, allow_spread, allow_hole);\n    });\n}\n\nvar AST_Call = DEFNODE(\"Call\", \"args expression optional pure terminal\", {\n    $documentation: \"A function call expression\",\n    $propdoc: {\n        args: \"[AST_Node*] array of arguments\",\n        expression: \"[AST_Node] expression to invoke as function\",\n        optional: \"[boolean] whether the expression is optional chaining\",\n        pure: \"[boolean/S] marker for side-effect-free call expression\",\n        terminal: \"[boolean] whether the chain has ended\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.args.forEach(function(arg) {\n                arg.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n        must_be_expressions(this, \"args\", true);\n    },\n});\n\nvar AST_New = DEFNODE(\"New\", null, {\n    $documentation: \"An object instantiation.  Derives from a function call since it has exactly the same properties\",\n    _validate: function() {\n        if (this.optional) throw new Error(\"optional must be false\");\n        if (this.terminal) throw new Error(\"terminal must be false\");\n    },\n}, AST_Call);\n\nvar AST_Sequence = DEFNODE(\"Sequence\", \"expressions\", {\n    $documentation: \"A sequence expression (comma-separated expressions)\",\n    $propdoc: {\n        expressions: \"[AST_Node*] array of expressions (at least two)\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expressions.forEach(function(expr) {\n                expr.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.expressions.length < 2) throw new Error(\"expressions must contain multiple elements\");\n        must_be_expressions(this, \"expressions\");\n    },\n});\n\nfunction root_expr(prop) {\n    while (prop instanceof AST_PropAccess) prop = prop.expression;\n    return prop;\n}\n\nvar AST_PropAccess = DEFNODE(\"PropAccess\", \"expression optional property terminal\", {\n    $documentation: \"Base class for property access expressions, i.e. `a.foo` or `a[\\\"foo\\\"]`\",\n    $propdoc: {\n        expression: \"[AST_Node] the container expression\",\n        optional: \"[boolean] whether the expression is optional chaining\",\n        property: \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\",\n        terminal: \"[boolean] whether the chain has ended\",\n    },\n    get_property: function() {\n        var p = this.property;\n        if (p instanceof AST_Constant) return p.value;\n        if (p instanceof AST_UnaryPrefix && p.operator == \"void\" && p.expression instanceof AST_Constant) return;\n        return p;\n    },\n    _validate: function() {\n        if (this.TYPE == \"PropAccess\") throw new Error(\"should not instantiate AST_PropAccess\");\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_Dot = DEFNODE(\"Dot\", null, {\n    $documentation: \"A dotted property access expression\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.property != \"string\") throw new Error(\"property must be string\");\n    },\n}, AST_PropAccess);\n\nvar AST_Sub = DEFNODE(\"Sub\", null, {\n    $documentation: \"Index-style property access, i.e. `a[\\\"foo\\\"]`\",\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n            node.property.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"property\");\n    },\n}, AST_PropAccess);\n\nvar AST_Spread = DEFNODE(\"Spread\", \"expression\", {\n    $documentation: \"Spread expression in array/object literals or function calls\",\n    $propdoc: {\n        expression: \"[AST_Node] expression to be expanded\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_Unary = DEFNODE(\"Unary\", \"operator expression\", {\n    $documentation: \"Base class for unary expressions\",\n    $propdoc: {\n        operator: \"[string] the operator\",\n        expression: \"[AST_Node] expression that this unary operator applies to\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"Unary\") throw new Error(\"should not instantiate AST_Unary\");\n        if (typeof this.operator != \"string\") throw new Error(\"operator must be string\");\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_UnaryPrefix = DEFNODE(\"UnaryPrefix\", null, {\n    $documentation: \"Unary prefix expression, i.e. `typeof i` or `++i`\"\n}, AST_Unary);\n\nvar AST_UnaryPostfix = DEFNODE(\"UnaryPostfix\", null, {\n    $documentation: \"Unary postfix expression, i.e. `i++`\"\n}, AST_Unary);\n\nvar AST_Binary = DEFNODE(\"Binary\", \"operator left right\", {\n    $documentation: \"Binary expression, i.e. `a + b`\",\n    $propdoc: {\n        left: \"[AST_Node] left-hand side expression\",\n        operator: \"[string] the operator\",\n        right: \"[AST_Node] right-hand side expression\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.left.walk(visitor);\n            node.right.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (!(this instanceof AST_Assign)) must_be_expression(this, \"left\");\n        if (typeof this.operator != \"string\") throw new Error(\"operator must be string\");\n        must_be_expression(this, \"right\");\n    },\n});\n\nvar AST_Conditional = DEFNODE(\"Conditional\", \"condition consequent alternative\", {\n    $documentation: \"Conditional expression using the ternary operator, i.e. `a ? b : c`\",\n    $propdoc: {\n        condition: \"[AST_Node]\",\n        consequent: \"[AST_Node]\",\n        alternative: \"[AST_Node]\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.condition.walk(visitor);\n            node.consequent.walk(visitor);\n            node.alternative.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"condition\");\n        must_be_expression(this, \"consequent\");\n        must_be_expression(this, \"alternative\");\n    },\n});\n\nvar AST_Assign = DEFNODE(\"Assign\", null, {\n    $documentation: \"An assignment expression  `a = b + 5`\",\n    _validate: function() {\n        if (this.operator.indexOf(\"=\") < 0) throw new Error('operator must contain \"=\"');\n        if (this.left instanceof AST_Destructured) {\n            if (this.operator != \"=\") throw new Error(\"invalid destructuring operator: \" + this.operator);\n            validate_destructured(this.left, function(node) {\n                if (!(node instanceof AST_PropAccess || node instanceof AST_SymbolRef)) {\n                    throw new Error(\"left must be assignable: \" + node.TYPE);\n                }\n            });\n        }\n    },\n}, AST_Binary);\n\nvar AST_Await = DEFNODE(\"Await\", \"expression\", {\n    $documentation: \"An await expression\",\n    $propdoc: {\n        expression: \"[AST_Node] expression with Promise to resolve on\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        must_be_expression(this, \"expression\");\n    },\n});\n\nvar AST_Yield = DEFNODE(\"Yield\", \"expression nested\", {\n    $documentation: \"A yield expression\",\n    $propdoc: {\n        expression: \"[AST_Node?] return value for iterator, or null if undefined\",\n        nested: \"[boolean] whether to iterate over expression as generator\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.expression) node.expression.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.expression != null) {\n            must_be_expression(this, \"expression\");\n        } else if (this.nested) {\n            throw new Error(\"yield* must contain expression\");\n        }\n    },\n});\n\n/* -----[ LITERALS ]----- */\n\nvar AST_Array = DEFNODE(\"Array\", \"elements\", {\n    $documentation: \"An array literal\",\n    $propdoc: {\n        elements: \"[AST_Node*] array of elements\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.elements.forEach(function(element) {\n                element.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        must_be_expressions(this, \"elements\", true, true);\n    },\n});\n\nvar AST_Destructured = DEFNODE(\"Destructured\", \"rest\", {\n    $documentation: \"Base class for destructured literal\",\n    $propdoc: {\n        rest: \"[(AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)?] rest parameter, or null if absent\",\n    },\n    _validate: function() {\n        if (this.TYPE == \"Destructured\") throw new Error(\"should not instantiate AST_Destructured\");\n    },\n});\n\nfunction validate_destructured(node, check, allow_default) {\n    if (node instanceof AST_DefaultValue && allow_default) return validate_destructured(node.name, check);\n    if (node instanceof AST_Destructured) {\n        if (node.rest != null) validate_destructured(node.rest, check);\n        if (node instanceof AST_DestructuredArray) return node.elements.forEach(function(node) {\n            if (!(node instanceof AST_Hole)) validate_destructured(node, check, true);\n        });\n        if (node instanceof AST_DestructuredObject) return node.properties.forEach(function(prop) {\n            validate_destructured(prop.value, check, true);\n        });\n    }\n    check(node);\n}\n\nvar AST_DestructuredArray = DEFNODE(\"DestructuredArray\", \"elements\", {\n    $documentation: \"A destructured array literal\",\n    $propdoc: {\n        elements: \"[(AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef)*] array of elements\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.elements.forEach(function(element) {\n                element.walk(visitor);\n            });\n            if (node.rest) node.rest.walk(visitor);\n        });\n    },\n}, AST_Destructured);\n\nvar AST_DestructuredKeyVal = DEFNODE(\"DestructuredKeyVal\", \"key value\", {\n    $documentation: \"A key: value destructured property\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name.  For computed property this is an AST_Node.\",\n        value: \"[AST_DefaultValue|AST_Destructured|AST_SymbolDeclaration|AST_SymbolRef] property value\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.key instanceof AST_Node) node.key.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (typeof this.key != \"string\") {\n            if (!(this.key instanceof AST_Node)) throw new Error(\"key must be string or AST_Node\");\n            must_be_expression(this, \"key\");\n        }\n        if (!(this.value instanceof AST_Node)) throw new Error(\"value must be AST_Node\");\n    },\n});\n\nvar AST_DestructuredObject = DEFNODE(\"DestructuredObject\", \"properties\", {\n    $documentation: \"A destructured object literal\",\n    $propdoc: {\n        properties: \"[AST_DestructuredKeyVal*] array of properties\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n            if (node.rest) node.rest.walk(visitor);\n        });\n    },\n    _validate: function() {\n        this.properties.forEach(function(node) {\n            if (!(node instanceof AST_DestructuredKeyVal)) throw new Error(\"properties must be AST_DestructuredKeyVal[]\");\n        });\n    },\n}, AST_Destructured);\n\nvar AST_Object = DEFNODE(\"Object\", \"properties\", {\n    $documentation: \"An object literal\",\n    $propdoc: {\n        properties: \"[(AST_ObjectProperty|AST_Spread)*] array of properties\"\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            node.properties.forEach(function(prop) {\n                prop.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        this.properties.forEach(function(node) {\n            if (!(node instanceof AST_ObjectProperty || node instanceof AST_Spread)) {\n                throw new Error(\"properties must contain AST_ObjectProperty and/or AST_Spread only\");\n            }\n        });\n    },\n});\n\nvar AST_ObjectProperty = DEFNODE(\"ObjectProperty\", \"key value\", {\n    $documentation: \"Base class for literal object properties\",\n    $propdoc: {\n        key: \"[string|AST_Node] property name.  For computed property this is an AST_Node.\",\n        value: \"[AST_Node] property value.  For getters and setters this is an AST_Accessor.\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.key instanceof AST_Node) node.key.walk(visitor);\n            node.value.walk(visitor);\n        });\n    },\n    _validate: function() {\n        if (this.TYPE == \"ObjectProperty\") throw new Error(\"should not instantiate AST_ObjectProperty\");\n        if (typeof this.key != \"string\") {\n            if (!(this.key instanceof AST_Node)) throw new Error(\"key must be string or AST_Node\");\n            must_be_expression(this, \"key\");\n        }\n        if (!(this.value instanceof AST_Node)) throw new Error(\"value must be AST_Node\");\n    },\n});\n\nvar AST_ObjectKeyVal = DEFNODE(\"ObjectKeyVal\", null, {\n    $documentation: \"A key: value object property\",\n    _validate: function() {\n        must_be_expression(this, \"value\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_ObjectMethod = DEFNODE(\"ObjectMethod\", null, {\n    $documentation: \"A key(){} object property\",\n    _validate: function() {\n        if (!(this.value instanceof AST_LambdaExpression)) throw new Error(\"value must be AST_LambdaExpression\");\n        if (is_arrow(this.value)) throw new Error(\"value cannot be AST_Arrow or AST_AsyncArrow\");\n        if (this.value.name != null) throw new Error(\"name of object method's lambda must be null\");\n    },\n}, AST_ObjectKeyVal);\n\nvar AST_ObjectSetter = DEFNODE(\"ObjectSetter\", null, {\n    $documentation: \"An object setter property\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_ObjectGetter = DEFNODE(\"ObjectGetter\", null, {\n    $documentation: \"An object getter property\",\n    _validate: function() {\n        if (!(this.value instanceof AST_Accessor)) throw new Error(\"value must be AST_Accessor\");\n    },\n}, AST_ObjectProperty);\n\nvar AST_Symbol = DEFNODE(\"Symbol\", \"scope name thedef\", {\n    $documentation: \"Base class for all symbols\",\n    $propdoc: {\n        name: \"[string] name of this symbol\",\n        scope: \"[AST_Scope/S] the current scope (not necessarily the definition scope)\",\n        thedef: \"[SymbolDef/S] the definition of this symbol\"\n    },\n    _validate: function() {\n        if (this.TYPE == \"Symbol\") throw new Error(\"should not instantiate AST_Symbol\");\n        if (typeof this.name != \"string\") throw new Error(\"name must be string\");\n    },\n});\n\nvar AST_SymbolDeclaration = DEFNODE(\"SymbolDeclaration\", \"init\", {\n    $documentation: \"A declaration symbol (symbol in var, function name or argument, symbol in catch)\",\n}, AST_Symbol);\n\nvar AST_SymbolConst = DEFNODE(\"SymbolConst\", null, {\n    $documentation: \"Symbol defining a constant\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolImport = DEFNODE(\"SymbolImport\", \"key\", {\n    $documentation: \"Symbol defined by an `import` statement\",\n    $propdoc: {\n        key: \"[string] the original `export` name\",\n    },\n    _validate: function() {\n        if (typeof this.key != \"string\") throw new Error(\"key must be string\");\n    },\n}, AST_SymbolConst);\n\nvar AST_SymbolLet = DEFNODE(\"SymbolLet\", null, {\n    $documentation: \"Symbol defining a lexical-scoped variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolVar = DEFNODE(\"SymbolVar\", null, {\n    $documentation: \"Symbol defining a variable\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolFunarg = DEFNODE(\"SymbolFunarg\", \"unused\", {\n    $documentation: \"Symbol naming a function argument\",\n}, AST_SymbolVar);\n\nvar AST_SymbolDefun = DEFNODE(\"SymbolDefun\", null, {\n    $documentation: \"Symbol defining a function\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolLambda = DEFNODE(\"SymbolLambda\", null, {\n    $documentation: \"Symbol naming a function expression\",\n}, AST_SymbolDeclaration);\n\nvar AST_SymbolDefClass = DEFNODE(\"SymbolDefClass\", null, {\n    $documentation: \"Symbol defining a class\",\n}, AST_SymbolConst);\n\nvar AST_SymbolClass = DEFNODE(\"SymbolClass\", null, {\n    $documentation: \"Symbol naming a class expression\",\n}, AST_SymbolConst);\n\nvar AST_SymbolCatch = DEFNODE(\"SymbolCatch\", null, {\n    $documentation: \"Symbol naming the exception in catch\",\n}, AST_SymbolDeclaration);\n\nvar AST_Label = DEFNODE(\"Label\", \"references\", {\n    $documentation: \"Symbol naming a label (declaration)\",\n    $propdoc: {\n        references: \"[AST_LoopControl*] a list of nodes referring to this label\"\n    },\n    initialize: function() {\n        this.references = [];\n        this.thedef = this;\n    }\n}, AST_Symbol);\n\nvar AST_SymbolRef = DEFNODE(\"SymbolRef\", \"fixed in_arg redef\", {\n    $documentation: \"Reference to some symbol (not definition/declaration)\",\n}, AST_Symbol);\n\nvar AST_SymbolExport = DEFNODE(\"SymbolExport\", \"alias\", {\n    $documentation: \"Reference in an `export` statement\",\n    $propdoc: {\n        alias: \"[string] the `export` alias\",\n    },\n    _validate: function() {\n        if (typeof this.alias != \"string\") throw new Error(\"alias must be string\");\n    },\n}, AST_SymbolRef);\n\nvar AST_LabelRef = DEFNODE(\"LabelRef\", null, {\n    $documentation: \"Reference to a label symbol\",\n}, AST_Symbol);\n\nvar AST_ObjectIdentity = DEFNODE(\"ObjectIdentity\", null, {\n    $documentation: \"Base class for `super` & `this`\",\n    _validate: function() {\n        if (this.TYPE == \"ObjectIdentity\") throw new Error(\"should not instantiate AST_ObjectIdentity\");\n    },\n}, AST_Symbol);\n\nvar AST_Super = DEFNODE(\"Super\", null, {\n    $documentation: \"The `super` symbol\",\n    _validate: function() {\n        if (this.name !== \"super\") throw new Error('name must be \"super\"');\n    },\n}, AST_ObjectIdentity);\n\nvar AST_This = DEFNODE(\"This\", null, {\n    $documentation: \"The `this` symbol\",\n    _validate: function() {\n        if (this.TYPE == \"This\" && this.name !== \"this\") throw new Error('name must be \"this\"');\n    },\n}, AST_ObjectIdentity);\n\nvar AST_NewTarget = DEFNODE(\"NewTarget\", null, {\n    $documentation: \"The `new.target` symbol\",\n    initialize: function() {\n        this.name = \"new.target\";\n    },\n    _validate: function() {\n        if (this.name !== \"new.target\") throw new Error('name must be \"new.target\": ' + this.name);\n    },\n}, AST_This);\n\nvar AST_Template = DEFNODE(\"Template\", \"expressions strings tag\", {\n    $documentation: \"A template literal, i.e. tag`str1${expr1}...strN${exprN}strN+1`\",\n    $propdoc: {\n        expressions: \"[AST_Node*] the placeholder expressions\",\n        strings: \"[string*] the raw text segments\",\n        tag: \"[AST_Node] tag function, or null if absent\",\n    },\n    walk: function(visitor) {\n        var node = this;\n        visitor.visit(node, function() {\n            if (node.tag) node.tag.walk(visitor);\n            node.expressions.forEach(function(expr) {\n                expr.walk(visitor);\n            });\n        });\n    },\n    _validate: function() {\n        if (this.expressions.length + 1 != this.strings.length) {\n            throw new Error(\"malformed template with \" + this.expressions.length + \" placeholder(s) but \" + this.strings.length + \" text segment(s)\");\n        }\n        must_be_expressions(this, \"expressions\");\n        this.strings.forEach(function(string) {\n            if (typeof string != \"string\") throw new Error(\"strings must contain string\");\n        });\n        if (this.tag != null) must_be_expression(this, \"tag\");\n    },\n});\n\nvar AST_Constant = DEFNODE(\"Constant\", null, {\n    $documentation: \"Base class for all constants\",\n    _validate: function() {\n        if (this.TYPE == \"Constant\") throw new Error(\"should not instantiate AST_Constant\");\n    },\n});\n\nvar AST_String = DEFNODE(\"String\", \"quote value\", {\n    $documentation: \"A string literal\",\n    $propdoc: {\n        quote: \"[string?] the original quote character\",\n        value: \"[string] the contents of this string\",\n    },\n    _validate: function() {\n        if (this.quote != null) {\n            if (typeof this.quote != \"string\") throw new Error(\"quote must be string\");\n            if (!/^[\"']$/.test(this.quote)) throw new Error(\"invalid quote: \" + this.quote);\n        }\n        if (typeof this.value != \"string\") throw new Error(\"value must be string\");\n    },\n}, AST_Constant);\n\nvar AST_Number = DEFNODE(\"Number\", \"value\", {\n    $documentation: \"A number literal\",\n    $propdoc: {\n        value: \"[number] the numeric value\",\n    },\n    _validate: function() {\n        if (typeof this.value != \"number\") throw new Error(\"value must be number\");\n        if (!isFinite(this.value)) throw new Error(\"value must be finite\");\n        if (this.value < 0) throw new Error(\"value cannot be negative\");\n    },\n}, AST_Constant);\n\nvar AST_BigInt = DEFNODE(\"BigInt\", \"value\", {\n    $documentation: \"A BigInt literal\",\n    $propdoc: {\n        value: \"[string] the numeric representation\",\n    },\n    _validate: function() {\n        if (typeof this.value != \"string\") throw new Error(\"value must be string\");\n        if (this.value[0] == \"-\") throw new Error(\"value cannot be negative\");\n    },\n}, AST_Constant);\n\nvar AST_RegExp = DEFNODE(\"RegExp\", \"value\", {\n    $documentation: \"A regexp literal\",\n    $propdoc: {\n        value: \"[RegExp] the actual regexp\"\n    },\n    _validate: function() {\n        if (!(this.value instanceof RegExp)) throw new Error(\"value must be RegExp\");\n    },\n}, AST_Constant);\n\nvar AST_Atom = DEFNODE(\"Atom\", null, {\n    $documentation: \"Base class for atoms\",\n    _validate: function() {\n        if (this.TYPE == \"Atom\") throw new Error(\"should not instantiate AST_Atom\");\n    },\n}, AST_Constant);\n\nvar AST_Null = DEFNODE(\"Null\", null, {\n    $documentation: \"The `null` atom\",\n    value: null\n}, AST_Atom);\n\nvar AST_NaN = DEFNODE(\"NaN\", null, {\n    $documentation: \"The impossible value\",\n    value: 0/0\n}, AST_Atom);\n\nvar AST_Undefined = DEFNODE(\"Undefined\", null, {\n    $documentation: \"The `undefined` value\",\n    value: function(){}()\n}, AST_Atom);\n\nvar AST_Hole = DEFNODE(\"Hole\", null, {\n    $documentation: \"A hole in an array\",\n    value: function(){}()\n}, AST_Atom);\n\nvar AST_Infinity = DEFNODE(\"Infinity\", null, {\n    $documentation: \"The `Infinity` value\",\n    value: 1/0\n}, AST_Atom);\n\nvar AST_Boolean = DEFNODE(\"Boolean\", null, {\n    $documentation: \"Base class for booleans\",\n    _validate: function() {\n        if (this.TYPE == \"Boolean\") throw new Error(\"should not instantiate AST_Boolean\");\n    },\n}, AST_Atom);\n\nvar AST_False = DEFNODE(\"False\", null, {\n    $documentation: \"The `false` atom\",\n    value: false\n}, AST_Boolean);\n\nvar AST_True = DEFNODE(\"True\", null, {\n    $documentation: \"The `true` atom\",\n    value: true\n}, AST_Boolean);\n\n/* -----[ TreeWalker ]----- */\n\nfunction TreeWalker(callback) {\n    this.callback = callback;\n    this.directives = Object.create(null);\n    this.stack = [];\n}\nTreeWalker.prototype = {\n    visit: function(node, descend) {\n        this.push(node);\n        var done = this.callback(node, descend || noop);\n        if (!done && descend) descend();\n        this.pop();\n    },\n    parent: function(n) {\n        return this.stack[this.stack.length - 2 - (n || 0)];\n    },\n    push: function(node) {\n        if (node instanceof AST_Lambda) {\n            this.directives = Object.create(this.directives);\n        } else if (node instanceof AST_Directive && !this.directives[node.value]) {\n            this.directives[node.value] = node;\n        }\n        this.stack.push(node);\n    },\n    pop: function() {\n        var node = this.stack.pop();\n        if (node instanceof AST_Lambda) {\n            this.directives = Object.getPrototypeOf(this.directives);\n        }\n    },\n    self: function() {\n        return this.stack[this.stack.length - 1];\n    },\n    find_parent: function(type) {\n        var stack = this.stack;\n        for (var i = stack.length - 1; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof type) return x;\n        }\n    },\n    has_directive: function(type) {\n        var dir = this.directives[type];\n        if (dir) return dir;\n        var node = this.stack[this.stack.length - 1];\n        if (node instanceof AST_Scope) {\n            for (var i = 0; i < node.body.length; ++i) {\n                var st = node.body[i];\n                if (!(st instanceof AST_Directive)) break;\n                if (st.value == type) return st;\n            }\n        }\n    },\n    loopcontrol_target: function(node) {\n        var stack = this.stack;\n        if (node.label) for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_LabeledStatement && x.label.name == node.label.name)\n                return x.body;\n        } else for (var i = stack.length; --i >= 0;) {\n            var x = stack[i];\n            if (x instanceof AST_IterationStatement\n                || node instanceof AST_Break && x instanceof AST_Switch)\n                return x;\n        }\n    },\n    in_boolean_context: function() {\n        var self = this.self();\n        for (var i = 0, p; p = this.parent(i); i++) {\n            if (p instanceof AST_Conditional && p.condition === self\n                || p instanceof AST_DWLoop && p.condition === self\n                || p instanceof AST_For && p.condition === self\n                || p instanceof AST_If && p.condition === self\n                || p instanceof AST_Return && p.in_bool\n                || p instanceof AST_Sequence && p.tail_node() !== self\n                || p instanceof AST_SimpleStatement\n                || p instanceof AST_UnaryPrefix && p.operator == \"!\" && p.expression === self) {\n                return true;\n            }\n            if (p instanceof AST_Binary && (p.operator == \"&&\" || p.operator == \"||\")\n                || p instanceof AST_Conditional\n                || p.tail_node() === self) {\n                self = p;\n            } else if (p instanceof AST_Return) {\n                for (var call, fn = p; call = this.parent(++i); fn = call) {\n                    if (call.TYPE == \"Call\") {\n                        if (!(fn instanceof AST_Lambda) || fn.name) return false;\n                    } else if (fn instanceof AST_Lambda) {\n                        return false;\n                    }\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n};\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction Compressor(options, false_by_default) {\n    if (!(this instanceof Compressor))\n        return new Compressor(options, false_by_default);\n    TreeTransformer.call(this, this.before, this.after);\n    this.options = defaults(options, {\n        annotations     : !false_by_default,\n        arguments       : !false_by_default,\n        arrows          : !false_by_default,\n        assignments     : !false_by_default,\n        awaits          : !false_by_default,\n        booleans        : !false_by_default,\n        collapse_vars   : !false_by_default,\n        comparisons     : !false_by_default,\n        conditionals    : !false_by_default,\n        dead_code       : !false_by_default,\n        default_values  : !false_by_default,\n        directives      : !false_by_default,\n        drop_console    : false,\n        drop_debugger   : !false_by_default,\n        evaluate        : !false_by_default,\n        expression      : false,\n        functions       : !false_by_default,\n        global_defs     : false,\n        hoist_exports   : !false_by_default,\n        hoist_funs      : false,\n        hoist_props     : !false_by_default,\n        hoist_vars      : false,\n        ie              : false,\n        if_return       : !false_by_default,\n        imports         : !false_by_default,\n        inline          : !false_by_default,\n        join_vars       : !false_by_default,\n        keep_fargs      : false_by_default,\n        keep_fnames     : false,\n        keep_infinity   : false,\n        loops           : !false_by_default,\n        merge_vars      : !false_by_default,\n        negate_iife     : !false_by_default,\n        objects         : !false_by_default,\n        optional_chains : !false_by_default,\n        passes          : 1,\n        properties      : !false_by_default,\n        pure_funcs      : null,\n        pure_getters    : !false_by_default && \"strict\",\n        reduce_funcs    : !false_by_default,\n        reduce_vars     : !false_by_default,\n        rests           : !false_by_default,\n        sequences       : !false_by_default,\n        side_effects    : !false_by_default,\n        spreads         : !false_by_default,\n        strings         : !false_by_default,\n        switches        : !false_by_default,\n        templates       : !false_by_default,\n        top_retain      : null,\n        toplevel        : !!(options && options[\"top_retain\"]),\n        typeofs         : !false_by_default,\n        unsafe          : false,\n        unsafe_comps    : false,\n        unsafe_Function : false,\n        unsafe_math     : false,\n        unsafe_proto    : false,\n        unsafe_regexp   : false,\n        unsafe_undefined: false,\n        unused          : !false_by_default,\n        varify          : !false_by_default,\n        webkit          : false,\n        yields          : !false_by_default,\n    }, true);\n    var evaluate = this.options[\"evaluate\"];\n    this.eval_threshold = /eager/.test(evaluate) ? 1 / 0 : +evaluate;\n    var global_defs = this.options[\"global_defs\"];\n    if (typeof global_defs == \"object\") for (var key in global_defs) {\n        if (/^@/.test(key) && HOP(global_defs, key)) {\n            global_defs[key.slice(1)] = parse(global_defs[key], {\n                expression: true\n            });\n        }\n    }\n    if (this.options[\"inline\"] === true) this.options[\"inline\"] = 3;\n    this.drop_fargs = this.options[\"keep_fargs\"] ? return_false : function(lambda, parent) {\n        if (lambda.length_read) return false;\n        var name = lambda.name;\n        if (!name) return parent && parent.TYPE == \"Call\" && parent.expression === lambda;\n        if (name.fixed_value() !== lambda) return false;\n        var def = name.definition();\n        if (def.direct_access) return false;\n        var escaped = def.escaped;\n        return escaped && escaped.depth != 1;\n    };\n    var pure_funcs = this.options[\"pure_funcs\"];\n    if (typeof pure_funcs == \"function\") {\n        this.pure_funcs = pure_funcs;\n    } else if (typeof pure_funcs == \"string\") {\n        this.pure_funcs = function(node) {\n            var expr;\n            if (node instanceof AST_Call) {\n                expr = node.expression;\n            } else if (node instanceof AST_Template) {\n                expr = node.tag;\n            }\n            return !(expr && pure_funcs === expr.print_to_string());\n        };\n    } else if (Array.isArray(pure_funcs)) {\n        this.pure_funcs = function(node) {\n            var expr;\n            if (node instanceof AST_Call) {\n                expr = node.expression;\n            } else if (node instanceof AST_Template) {\n                expr = node.tag;\n            }\n            return !(expr && member(expr.print_to_string(), pure_funcs));\n        };\n    } else {\n        this.pure_funcs = return_true;\n    }\n    var sequences = this.options[\"sequences\"];\n    this.sequences_limit = sequences == 1 ? 800 : sequences | 0;\n    var top_retain = this.options[\"top_retain\"];\n    if (top_retain instanceof RegExp) {\n        this.top_retain = function(def) {\n            return top_retain.test(def.name);\n        };\n    } else if (typeof top_retain == \"function\") {\n        this.top_retain = top_retain;\n    } else if (top_retain) {\n        if (typeof top_retain == \"string\") {\n            top_retain = top_retain.split(/,/);\n        }\n        this.top_retain = function(def) {\n            return member(def.name, top_retain);\n        };\n    }\n    var toplevel = this.options[\"toplevel\"];\n    this.toplevel = typeof toplevel == \"string\" ? {\n        funcs: /funcs/.test(toplevel),\n        vars: /vars/.test(toplevel)\n    } : {\n        funcs: toplevel,\n        vars: toplevel\n    };\n}\n\nCompressor.prototype = new TreeTransformer(function(node, descend, in_list) {\n    if (node._squeezed) return node;\n    var is_scope = node instanceof AST_Scope;\n    if (is_scope) {\n        node.hoist_properties(this);\n        node.hoist_declarations(this);\n        node.process_boolean_returns(this);\n    }\n    // Before https://github.com/mishoo/UglifyJS/pull/1602 AST_Node.optimize()\n    // would call AST_Node.transform() if a different instance of AST_Node is\n    // produced after OPT().\n    // This corrupts TreeWalker.stack, which cause AST look-ups to malfunction.\n    // Migrate and defer all children's AST_Node.transform() to below, which\n    // will now happen after this parent AST_Node has been properly substituted\n    // thus gives a consistent AST snapshot.\n    descend(node, this);\n    // Existing code relies on how AST_Node.optimize() worked, and omitting the\n    // following replacement call would result in degraded efficiency of both\n    // output and performance.\n    descend(node, this);\n    var opt = node.optimize(this);\n    if (is_scope && opt === node && !this.has_directive(\"use asm\") && !opt.pinned()) {\n        opt.drop_unused(this);\n        if (opt.merge_variables(this)) opt.drop_unused(this);\n        descend(opt, this);\n    }\n    if (opt === node) opt._squeezed = true;\n    return opt;\n});\nCompressor.prototype.option = function(key) {\n    return this.options[key];\n};\nCompressor.prototype.exposed = function(def) {\n    if (def.exported) return true;\n    if (def.undeclared) return true;\n    if (!(def.global || def.scope.resolve() instanceof AST_Toplevel)) return false;\n    var toplevel = this.toplevel;\n    return !all(def.orig, function(sym) {\n        return toplevel[sym instanceof AST_SymbolDefun ? \"funcs\" : \"vars\"];\n    });\n};\nCompressor.prototype.compress = function(node) {\n    node = node.resolve_defines(this);\n    node.hoist_exports(this);\n    if (this.option(\"expression\")) {\n        node.process_expression(true);\n    }\n    var merge_vars = this.options.merge_vars;\n    var passes = +this.options.passes || 1;\n    var min_count = 1 / 0;\n    var stopping = false;\n    var mangle = { ie: this.option(\"ie\") };\n    for (var pass = 0; pass < passes; pass++) {\n        node.figure_out_scope(mangle);\n        if (pass > 0 || this.option(\"reduce_vars\"))\n            node.reset_opt_flags(this);\n        this.options.merge_vars = merge_vars && (stopping || pass == passes - 1);\n        node = node.transform(this);\n        if (passes > 1) {\n            var count = 0;\n            node.walk(new TreeWalker(function() {\n                count++;\n            }));\n            AST_Node.info(\"pass {pass}: last_count: {min_count}, count: {count}\", {\n                pass: pass,\n                min_count: min_count,\n                count: count,\n            });\n            if (count < min_count) {\n                min_count = count;\n                stopping = false;\n            } else if (stopping) {\n                break;\n            } else {\n                stopping = true;\n            }\n        }\n    }\n    if (this.option(\"expression\")) {\n        node.process_expression(false);\n    }\n    return node;\n};\n\n(function(OPT) {\n    OPT(AST_Node, function(self, compressor) {\n        return self;\n    });\n\n    AST_Node.DEFMETHOD(\"equivalent_to\", function(node) {\n        return this.TYPE == node.TYPE && this.print_to_string() == node.print_to_string();\n    });\n\n    AST_Toplevel.DEFMETHOD(\"hoist_exports\", function(compressor) {\n        if (!compressor.option(\"hoist_exports\")) return;\n        var body = this.body, props = [];\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (stat instanceof AST_ExportDeclaration) {\n                body[i] = stat = stat.body;\n                if (stat instanceof AST_Definitions) {\n                    stat.definitions.forEach(function(defn) {\n                        defn.name.match_symbol(export_symbol, true);\n                    });\n                } else {\n                    export_symbol(stat.name);\n                }\n            } else if (stat instanceof AST_ExportReferences) {\n                body.splice(i--, 1);\n                [].push.apply(props, stat.properties);\n            }\n        }\n        if (props.length) body.push(make_node(AST_ExportReferences, this, { properties: props }));\n\n        function export_symbol(sym) {\n            if (!(sym instanceof AST_SymbolDeclaration)) return;\n            var node = make_node(AST_SymbolExport, sym, sym);\n            node.alias = node.name;\n            props.push(node);\n        }\n    });\n\n    AST_Scope.DEFMETHOD(\"process_expression\", function(insert, transform) {\n        var self = this;\n        var tt = new TreeTransformer(function(node) {\n            if (insert && node instanceof AST_SimpleStatement) {\n                return transform ? transform(node) : make_node(AST_Return, node, { value: node.body });\n            }\n            if (!insert && node instanceof AST_Return) {\n                return transform ? transform(node) : make_node(AST_SimpleStatement, node, {\n                    body: node.value || make_node(AST_UnaryPrefix, node, {\n                        operator: \"void\",\n                        expression: make_node(AST_Number, node, { value: 0 }),\n                    }),\n                });\n            }\n            if (node instanceof AST_Block) {\n                if (node instanceof AST_Lambda) {\n                    if (node !== self) return node;\n                } else if (insert === \"awaits\" && node instanceof AST_Try) {\n                    if (node.bfinally) return node;\n                }\n                for (var index = node.body.length; --index >= 0;) {\n                    var stat = node.body[index];\n                    if (!is_declaration(stat, true)) {\n                        node.body[index] = stat.transform(tt);\n                        break;\n                    }\n                }\n            } else if (node instanceof AST_If) {\n                node.body = node.body.transform(tt);\n                if (node.alternative) {\n                    node.alternative = node.alternative.transform(tt);\n                }\n            } else if (node instanceof AST_With) {\n                node.body = node.body.transform(tt);\n            }\n            return node;\n        });\n        self.transform(tt);\n    });\n\n    function read_property(obj, node) {\n        var key = node.get_property();\n        if (key instanceof AST_Node) return;\n        var value;\n        if (obj instanceof AST_Array) {\n            var elements = obj.elements;\n            if (key == \"length\") return make_node_from_constant(elements.length, obj);\n            if (typeof key == \"number\" && key in elements) value = elements[key];\n        } else if (obj instanceof AST_Lambda) {\n            if (key == \"length\") {\n                obj.length_read = true;\n                return make_node_from_constant(obj.argnames.length, obj);\n            }\n        } else if (obj instanceof AST_Object) {\n            key = \"\" + key;\n            var props = obj.properties;\n            for (var i = props.length; --i >= 0;) {\n                var prop = props[i];\n                if (!can_hoist_property(prop)) return;\n                if (!value && props[i].key === key) value = props[i].value;\n            }\n        }\n        return value instanceof AST_SymbolRef && value.fixed_value() || value;\n    }\n\n    function is_read_only_fn(value, name) {\n        if (value instanceof AST_Boolean) return native_fns.Boolean[name];\n        if (value instanceof AST_Number) return native_fns.Number[name];\n        if (value instanceof AST_String) return native_fns.String[name];\n        if (name == \"valueOf\") return false;\n        if (value instanceof AST_Array) return native_fns.Array[name];\n        if (value instanceof AST_Lambda) return native_fns.Function[name];\n        if (value instanceof AST_Object) return native_fns.Object[name];\n        if (value instanceof AST_RegExp) return native_fns.RegExp[name] && !value.value.global;\n    }\n\n    function is_modified(compressor, tw, node, value, level, immutable, recursive) {\n        var parent = tw.parent(level);\n        if (compressor.option(\"unsafe\") && parent instanceof AST_Dot && is_read_only_fn(value, parent.property)) {\n            return;\n        }\n        var lhs = is_lhs(node, parent);\n        if (lhs) return lhs;\n        if (level == 0 && value && value.is_constant()) return;\n        if (parent instanceof AST_Array) return is_modified(compressor, tw, parent, parent, level + 1);\n        if (parent instanceof AST_Assign) switch (parent.operator) {\n          case \"=\":\n            return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);\n          case \"&&=\":\n          case \"||=\":\n          case \"??=\":\n            return is_modified(compressor, tw, parent, parent, level + 1);\n          default:\n            return;\n        }\n        if (parent instanceof AST_Binary) {\n            if (!lazy_op[parent.operator]) return;\n            return is_modified(compressor, tw, parent, parent, level + 1);\n        }\n        if (parent instanceof AST_Call) {\n            return !immutable\n                && parent.expression === node\n                && !parent.is_expr_pure(compressor)\n                && (!(value instanceof AST_LambdaExpression) || !(parent instanceof AST_New) && value.contains_this());\n        }\n        if (parent instanceof AST_Conditional) {\n            if (parent.condition === node) return;\n            return is_modified(compressor, tw, parent, parent, level + 1);\n        }\n        if (parent instanceof AST_ForEnumeration) return parent.init === node;\n        if (parent instanceof AST_ObjectKeyVal) {\n            if (parent.value !== node) return;\n            var obj = tw.parent(level + 1);\n            return is_modified(compressor, tw, obj, obj, level + 2);\n        }\n        if (parent instanceof AST_PropAccess) {\n            if (parent.expression !== node) return;\n            var prop = read_property(value, parent);\n            return (!immutable || recursive) && is_modified(compressor, tw, parent, prop, level + 1);\n        }\n        if (parent instanceof AST_Sequence) {\n            if (parent.tail_node() !== node) return;\n            return is_modified(compressor, tw, parent, value, level + 1, immutable, recursive);\n        }\n    }\n\n    function is_lambda(node) {\n        return node instanceof AST_Class || node instanceof AST_Lambda;\n    }\n\n    function safe_for_extends(node) {\n        return node instanceof AST_Class || node instanceof AST_Defun || node instanceof AST_Function;\n    }\n\n    function is_arguments(def) {\n        return def.name == \"arguments\" && def.scope.uses_arguments;\n    }\n\n    function is_funarg(def) {\n        return def.orig[0] instanceof AST_SymbolFunarg || def.orig[1] instanceof AST_SymbolFunarg;\n    }\n\n    function cross_scope(def, sym) {\n        do {\n            if (def === sym) return false;\n            if (sym instanceof AST_Scope) return true;\n        } while (sym = sym.parent_scope);\n    }\n\n    function can_drop_symbol(ref, compressor, keep_lambda) {\n        var def = ref.redef || ref.definition();\n        if (ref.in_arg && is_funarg(def)) return false;\n        return all(def.orig, function(sym) {\n            if (sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet) {\n                return compressor && can_varify(compressor, sym);\n            }\n            return !(keep_lambda && sym instanceof AST_SymbolLambda);\n        });\n    }\n\n    function has_escaped(d, scope, node, parent) {\n        if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.right === node;\n        if (parent instanceof AST_Call) return parent.expression !== node || parent instanceof AST_New;\n        if (parent instanceof AST_Exit) return parent.value === node && scope.resolve() !== d.scope.resolve();\n        if (parent instanceof AST_VarDef) return parent.value === node;\n    }\n\n    var RE_POSITIVE_INTEGER = /^(0|[1-9][0-9]*)$/;\n    (function(def) {\n        def(AST_Node, noop);\n\n        function reset_def(tw, compressor, def) {\n            def.assignments = 0;\n            def.bool_fn = 0;\n            def.cross_loop = false;\n            def.direct_access = false;\n            def.escaped = [];\n            def.fixed = !def.const_redefs\n                && !def.scope.pinned()\n                && !compressor.exposed(def)\n                && !(def.init instanceof AST_LambdaExpression && def.init !== def.scope)\n                && def.init;\n            def.reassigned = 0;\n            def.recursive_refs = 0;\n            def.references = [];\n            def.should_replace = undefined;\n            def.single_use = undefined;\n        }\n\n        function reset_block_variables(tw, compressor, scope) {\n            scope.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n        }\n\n        function reset_variables(tw, compressor, scope) {\n            scope.fn_defs = [];\n            scope.variables.each(function(def) {\n                reset_def(tw, compressor, def);\n                var init = def.init;\n                if (init instanceof AST_LambdaDefinition) {\n                    scope.fn_defs.push(init);\n                    init.safe_ids = null;\n                }\n                if (def.fixed === null) {\n                    def.safe_ids = tw.safe_ids;\n                    mark(tw, def);\n                } else if (def.fixed) {\n                    tw.loop_ids[def.id] = tw.in_loop;\n                    mark(tw, def);\n                }\n            });\n            scope.may_call_this = function() {\n                scope.may_call_this = scope.contains_this() ? return_true : return_false;\n            };\n            if (scope.uses_arguments) scope.each_argname(function(node) {\n                node.definition().last_ref = false;\n            });\n            if (compressor.option(\"ie\")) scope.variables.each(function(def) {\n                var d = def.orig[0].definition();\n                if (d !== def) d.fixed = false;\n            });\n        }\n\n        function safe_to_visit(tw, fn) {\n            var marker = fn.safe_ids;\n            return marker === undefined || marker === tw.safe_ids;\n        }\n\n        function walk_fn_def(tw, fn) {\n            var was_scanning = tw.fn_scanning;\n            tw.fn_scanning = fn;\n            fn.walk(tw);\n            tw.fn_scanning = was_scanning;\n        }\n\n        function revisit_fn_def(tw, fn) {\n            fn.enclosed.forEach(function(d) {\n                if (fn.variables.get(d.name) === d) return;\n                if (safe_to_read(tw, d)) return;\n                d.single_use = false;\n                var fixed = d.fixed;\n                if (typeof fixed == \"function\") fixed = fixed();\n                if (fixed instanceof AST_Lambda && fixed.safe_ids !== undefined) return;\n                d.fixed = false;\n            });\n        }\n\n        function mark_fn_def(tw, def, fn) {\n            var marker = fn.safe_ids;\n            if (marker === undefined) return;\n            if (marker === false) return;\n            if (fn.parent_scope.resolve().may_call_this === return_true) {\n                if (member(fn, tw.fn_visited)) revisit_fn_def(tw, fn);\n            } else if (marker) {\n                var visited = member(fn, tw.fn_visited);\n                if (marker === tw.safe_ids) {\n                    if (!visited) walk_fn_def(tw, fn);\n                } else if (visited) {\n                    revisit_fn_def(tw, fn);\n                } else {\n                    fn.safe_ids = false;\n                }\n            } else if (tw.fn_scanning && tw.fn_scanning !== def.scope.resolve()) {\n                fn.safe_ids = false;\n            } else {\n                fn.safe_ids = tw.safe_ids;\n                walk_fn_def(tw, fn);\n            }\n        }\n\n        function pop_scope(tw, scope) {\n            var fn_defs = scope.fn_defs;\n            var tangled = scope.may_call_this === return_true ? fn_defs : fn_defs.filter(function(fn) {\n                if (fn.safe_ids === false) return true;\n                fn.safe_ids = tw.safe_ids;\n                walk_fn_def(tw, fn);\n                return false;\n            });\n            pop(tw);\n            tangled.forEach(function(fn) {\n                fn.safe_ids = tw.safe_ids;\n                walk_fn_def(tw, fn);\n            });\n            fn_defs.forEach(function(fn) {\n                fn.safe_ids = undefined;\n            });\n            scope.fn_defs = undefined;\n            scope.may_call_this = undefined;\n        }\n\n        function push(tw) {\n            tw.safe_ids = Object.create(tw.safe_ids);\n        }\n\n        function pop(tw) {\n            tw.safe_ids = Object.getPrototypeOf(tw.safe_ids);\n        }\n\n        function mark(tw, def) {\n            tw.safe_ids[def.id] = {};\n        }\n\n        function push_ref(def, ref) {\n            def.references.push(ref);\n            if (def.last_ref !== false) def.last_ref = ref;\n        }\n\n        function safe_to_read(tw, def) {\n            if (def.single_use == \"m\") return false;\n            var safe = tw.safe_ids[def.id];\n            if (safe) {\n                var in_order = HOP(tw.safe_ids, def.id);\n                if (!in_order) safe.read = safe.read && safe.read !== tw.safe_ids ? true : tw.safe_ids;\n                if (def.fixed == null) {\n                    if (is_arguments(def)) return false;\n                    if (def.global && def.name == \"arguments\") return false;\n                    tw.loop_ids[def.id] = null;\n                    def.fixed = make_node(AST_Undefined, def.orig[0]);\n                    if (in_order) def.safe_ids = undefined;\n                    return true;\n                }\n                return !safe.assign || safe.assign === tw.safe_ids;\n            }\n            return def.fixed instanceof AST_LambdaDefinition;\n        }\n\n        function safe_to_assign(tw, def, declare) {\n            if (!declare) {\n                if (is_funarg(def) && def.scope.uses_arguments && !tw.has_directive(\"use strict\")) return false;\n                if (!all(def.orig, function(sym) {\n                    return !(sym instanceof AST_SymbolConst);\n                })) return false;\n            }\n            if (def.fixed === undefined) return declare || all(def.orig, function(sym) {\n                return !(sym instanceof AST_SymbolLet);\n            });\n            if (def.fixed === false || def.fixed === 0) return false;\n            var safe = tw.safe_ids[def.id];\n            if (def.safe_ids) {\n                def.safe_ids[def.id] = false;\n                def.safe_ids = undefined;\n                return def.fixed === null || HOP(tw.safe_ids, def.id) && !safe.read;\n            }\n            if (!HOP(tw.safe_ids, def.id)) {\n                if (!safe) return false;\n                if (safe.read) {\n                    var scope = tw.find_parent(AST_BlockScope);\n                    if (scope instanceof AST_Class) return false;\n                    if (def.scope.resolve() !== scope.resolve()) return false;\n                }\n                safe.assign = safe.assign && safe.assign !== tw.safe_ids ? true : tw.safe_ids;\n            }\n            if (def.fixed != null && safe.read) {\n                if (safe.read !== tw.safe_ids) return false;\n                if (tw.loop_ids[def.id] !== tw.in_loop) return false;\n            }\n            return safe_to_read(tw, def) && all(def.orig, function(sym) {\n                return !(sym instanceof AST_SymbolLambda);\n            });\n        }\n\n        function make_ref(ref, fixed) {\n            var node = make_node(AST_SymbolRef, ref, ref);\n            node.fixed = fixed || make_node(AST_Undefined, ref);\n            return node;\n        }\n\n        function ref_once(compressor, def) {\n            return compressor.option(\"unused\")\n                && !def.scope.pinned()\n                && def.single_use !== false\n                && def.references.length - def.recursive_refs == 1\n                && !(is_funarg(def) && def.scope.uses_arguments);\n        }\n\n        function is_immutable(value) {\n            if (!value) return false;\n            if (value instanceof AST_Assign) {\n                var op = value.operator;\n                return op == \"=\" ? is_immutable(value.right) : !lazy_op[op.slice(0, -1)];\n            }\n            if (value instanceof AST_Sequence) return is_immutable(value.tail_node());\n            return value.is_constant() || is_lambda(value) || value instanceof AST_ObjectIdentity;\n        }\n\n        function value_in_use(node, parent) {\n            if (parent instanceof AST_Array) return true;\n            if (parent instanceof AST_Binary) return lazy_op[parent.operator];\n            if (parent instanceof AST_Conditional) return parent.condition !== node;\n            if (parent instanceof AST_Sequence) return parent.tail_node() === node;\n            if (parent instanceof AST_Spread) return true;\n        }\n\n        function mark_escaped(tw, d, scope, node, value, level, depth) {\n            var parent = tw.parent(level);\n            if (value && value.is_constant()) return;\n            if (has_escaped(d, scope, node, parent)) {\n                d.escaped.push(parent);\n                if (depth > 1 && !(value && value.is_constant_expression(scope))) depth = 1;\n                if (!d.escaped.depth || d.escaped.depth > depth) d.escaped.depth = depth;\n                if (d.scope.resolve() !== scope.resolve()) d.escaped.cross_scope = true;\n                if (d.fixed) d.fixed.escaped = d.escaped;\n                return;\n            } else if (value_in_use(node, parent)) {\n                mark_escaped(tw, d, scope, parent, parent, level + 1, depth);\n            } else if (parent instanceof AST_ObjectKeyVal && parent.value === node) {\n                var obj = tw.parent(level + 1);\n                mark_escaped(tw, d, scope, obj, obj, level + 2, depth);\n            } else if (parent instanceof AST_PropAccess && parent.expression === node) {\n                value = read_property(value, parent);\n                mark_escaped(tw, d, scope, parent, value, level + 1, depth + 1);\n                if (value) return;\n            }\n            if (level > 0) return;\n            if (parent instanceof AST_Call && parent.expression === node) return;\n            if (parent instanceof AST_Sequence && parent.tail_node() !== node) return;\n            if (parent instanceof AST_SimpleStatement) return;\n            if (parent instanceof AST_Unary && !unary_side_effects[parent.operator]) return;\n            d.direct_access = true;\n            if (d.fixed) d.fixed.direct_access = true;\n        }\n\n        function mark_assignment_to_arguments(node) {\n            if (!(node instanceof AST_Sub)) return;\n            var expr = node.expression;\n            if (!(expr instanceof AST_SymbolRef)) return;\n            var def = expr.definition();\n            if (!is_arguments(def)) return;\n            var key = node.property;\n            if (key.is_constant()) key = key.value;\n            if (!(key instanceof AST_Node) && !RE_POSITIVE_INTEGER.test(key)) return;\n            def.reassigned++;\n            (key instanceof AST_Node ? def.scope.argnames : [ def.scope.argnames[key] ]).forEach(function(argname) {\n                if (argname instanceof AST_SymbolFunarg) argname.definition().fixed = false;\n            });\n        }\n\n        function scan_declaration(tw, compressor, lhs, fixed, visit) {\n            var scanner = new TreeWalker(function(node) {\n                if (node instanceof AST_DefaultValue) {\n                    reset_flags(node);\n                    push(tw);\n                    node.value.walk(tw);\n                    pop(tw);\n                    var save = fixed;\n                    if (save) fixed = function() {\n                        var value = save();\n                        var ev;\n                        if (is_undefined(value, compressor)\n                            || (ev = fuzzy_eval(compressor, value, true)) === undefined) {\n                            return make_sequence(node, [ value, node.value ]);\n                        }\n                        return ev instanceof AST_Node ? node : value;\n                    };\n                    node.name.walk(scanner);\n                    fixed = save;\n                    return true;\n                }\n                if (node instanceof AST_DestructuredArray) {\n                    reset_flags(node);\n                    var save = fixed;\n                    node.elements.forEach(function(node, index) {\n                        if (node instanceof AST_Hole) return reset_flags(node);\n                        if (save) fixed = function() {\n                            return make_node(AST_Sub, node, {\n                                expression: save(),\n                                property: make_node(AST_Number, node, { value: index }),\n                            });\n                        };\n                        node.walk(scanner);\n                    });\n                    if (node.rest) {\n                        var fixed_node;\n                        if (save) fixed = compressor.option(\"rests\") && function() {\n                            var value = save();\n                            if (!(value instanceof AST_Array)) return node;\n                            if (!fixed_node) fixed_node = make_node(AST_Array, node);\n                            fixed_node.elements = value.elements.slice(node.elements.length);\n                            return fixed_node;\n                        };\n                        node.rest.walk(scanner);\n                    }\n                    fixed = save;\n                    return true;\n                }\n                if (node instanceof AST_DestructuredObject) {\n                    reset_flags(node);\n                    var save = fixed;\n                    node.properties.forEach(function(node) {\n                        reset_flags(node);\n                        if (node.key instanceof AST_Node) {\n                            push(tw);\n                            node.key.walk(tw);\n                            pop(tw);\n                        }\n                        if (save) fixed = function() {\n                            var key = node.key;\n                            var type = AST_Sub;\n                            if (typeof key == \"string\") {\n                                if (is_identifier_string(key)) {\n                                    type = AST_Dot;\n                                } else {\n                                    key = make_node_from_constant(key, node);\n                                }\n                            }\n                            return make_node(type, node, {\n                                expression: save(),\n                                property: key\n                            });\n                        };\n                        node.value.walk(scanner);\n                    });\n                    if (node.rest) {\n                        fixed = false;\n                        node.rest.walk(scanner);\n                    }\n                    fixed = save;\n                    return true;\n                }\n                visit(node, fixed, function() {\n                    var save_len = tw.stack.length;\n                    for (var i = 0, len = scanner.stack.length - 1; i < len; i++) {\n                        tw.stack.push(scanner.stack[i]);\n                    }\n                    node.walk(tw);\n                    tw.stack.length = save_len;\n                });\n                return true;\n            });\n            lhs.walk(scanner);\n        }\n\n        function reduce_iife(tw, descend, compressor) {\n            var fn = this;\n            fn.inlined = false;\n            var iife = tw.parent();\n            var hit = is_async(fn) || is_generator(fn);\n            var aborts = false;\n            fn.walk(new TreeWalker(function(node) {\n                if (hit) return aborts = true;\n                if (node instanceof AST_Return) return hit = true;\n                if (node instanceof AST_Scope && node !== fn) return true;\n            }));\n            if (aborts) push(tw);\n            reset_variables(tw, compressor, fn);\n            // Virtually turn IIFE parameters into variable definitions:\n            //   (function(a,b) {...})(c,d) ---> (function() {var a=c,b=d; ...})()\n            // So existing transformation rules can work on them.\n            var safe = !fn.uses_arguments || tw.has_directive(\"use strict\");\n            fn.argnames.forEach(function(argname, i) {\n                var value = iife.args[i];\n                scan_declaration(tw, compressor, argname, function() {\n                    var j = fn.argnames.indexOf(argname);\n                    var arg = j < 0 ? value : iife.args[j];\n                    if (arg instanceof AST_Sequence && arg.expressions.length < 2) arg = arg.expressions[0];\n                    return arg || make_node(AST_Undefined, iife);\n                }, visit);\n            });\n            var rest = fn.rest, fixed_node;\n            if (rest) scan_declaration(tw, compressor, rest, compressor.option(\"rests\") && function() {\n                if (fn.rest !== rest) return rest;\n                if (!fixed_node) fixed_node = make_node(AST_Array, fn);\n                fixed_node.elements = iife.args.slice(fn.argnames.length);\n                return fixed_node;\n            }, visit);\n            walk_lambda(fn, tw);\n            var safe_ids = tw.safe_ids;\n            pop_scope(tw, fn);\n            if (!aborts) tw.safe_ids = safe_ids;\n            return true;\n\n            function visit(node, fixed) {\n                var d = node.definition();\n                if (fixed && safe && d.fixed === undefined) {\n                    mark(tw, d);\n                    tw.loop_ids[d.id] = tw.in_loop;\n                    d.fixed = fixed;\n                    d.fixed.assigns = [ node ];\n                } else {\n                    d.fixed = false;\n                }\n            }\n        }\n\n        def(AST_Assign, function(tw, descend, compressor) {\n            var node = this;\n            var left = node.left;\n            var right = node.right;\n            var ld = left instanceof AST_SymbolRef && left.definition();\n            var scan = ld || left instanceof AST_Destructured;\n            switch (node.operator) {\n              case \"=\":\n                if (left.equivalent_to(right) && !left.has_side_effects(compressor)) {\n                    right.walk(tw);\n                    walk_prop(left);\n                    node.redundant = true;\n                    return true;\n                }\n                if (ld && right instanceof AST_LambdaExpression) {\n                    walk_assign();\n                    right.parent_scope.resolve().fn_defs.push(right);\n                    right.safe_ids = null;\n                    if (!ld.fixed || !node.write_only) mark_fn_def(tw, ld, right);\n                    return true;\n                }\n                if (scan) {\n                    right.walk(tw);\n                    walk_assign();\n                    return true;\n                }\n                mark_assignment_to_arguments(left);\n                return;\n              case \"&&=\":\n              case \"||=\":\n              case \"??=\":\n                var lazy = true;\n              default:\n                if (!scan) {\n                    mark_assignment_to_arguments(left);\n                    return walk_lazy();\n                }\n                ld.assignments++;\n                var fixed = ld.fixed;\n                if (is_modified(compressor, tw, node, node, 0)) {\n                    ld.fixed = false;\n                    return walk_lazy();\n                }\n                var safe = safe_to_read(tw, ld);\n                if (lazy) push(tw);\n                right.walk(tw);\n                if (lazy) pop(tw);\n                if (safe && !left.in_arg && safe_to_assign(tw, ld)) {\n                    push_ref(ld, left);\n                    mark(tw, ld);\n                    if (ld.single_use) ld.single_use = false;\n                    left.fixed = ld.fixed = function() {\n                        return make_node(AST_Binary, node, {\n                            operator: node.operator.slice(0, -1),\n                            left: make_ref(left, fixed),\n                            right: node.right,\n                        });\n                    };\n                    left.fixed.assigns = !fixed || !fixed.assigns ? [] : fixed.assigns.slice();\n                    left.fixed.assigns.push(node);\n                } else {\n                    left.walk(tw);\n                    ld.fixed = false;\n                }\n                return true;\n            }\n\n            function walk_prop(lhs) {\n                if (lhs instanceof AST_Dot) {\n                    walk_prop(lhs.expression);\n                } else if (lhs instanceof AST_Sub) {\n                    walk_prop(lhs.expression);\n                    lhs.property.walk(tw);\n                } else if (lhs instanceof AST_SymbolRef) {\n                    var d = lhs.definition();\n                    push_ref(d, lhs);\n                    if (d.fixed) {\n                        lhs.fixed = d.fixed;\n                        if (lhs.fixed.assigns) {\n                            lhs.fixed.assigns.push(node);\n                        } else {\n                            lhs.fixed.assigns = [ node ];\n                        }\n                    }\n                } else {\n                    lhs.walk(tw);\n                }\n            }\n\n            function walk_assign() {\n                var recursive = ld && recursive_ref(tw, ld);\n                var modified = is_modified(compressor, tw, node, right, 0, is_immutable(right), recursive);\n                scan_declaration(tw, compressor, left, function() {\n                    return node.right;\n                }, function(sym, fixed, walk) {\n                    if (!(sym instanceof AST_SymbolRef)) {\n                        mark_assignment_to_arguments(sym);\n                        walk();\n                        return;\n                    }\n                    var d = sym.definition();\n                    d.assignments++;\n                    if (!fixed || sym.in_arg || !safe_to_assign(tw, d)) {\n                        walk();\n                        d.fixed = false;\n                    } else if (modified) {\n                        walk();\n                        d.fixed = 0;\n                    } else {\n                        push_ref(d, sym);\n                        mark(tw, d);\n                        if (left instanceof AST_Destructured\n                            || d.orig.length == 1 && d.orig[0] instanceof AST_SymbolDefun) {\n                            d.single_use = false;\n                        }\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        sym.fixed = d.fixed = fixed;\n                        sym.fixed.assigns = [ node ];\n                        mark_escaped(tw, d, sym.scope, node, right, 0, 1);\n                    }\n                });\n            }\n\n            function walk_lazy() {\n                if (!lazy) return;\n                left.walk(tw);\n                push(tw);\n                right.walk(tw);\n                pop(tw);\n                return true;\n            }\n        });\n        def(AST_Binary, function(tw) {\n            if (!lazy_op[this.operator]) return;\n            this.left.walk(tw);\n            push(tw);\n            this.right.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_BlockScope, function(tw, descend, compressor) {\n            reset_block_variables(tw, compressor, this);\n        });\n        def(AST_Call, function(tw, descend) {\n            var node = this;\n            var exp = node.expression;\n            if (exp instanceof AST_LambdaExpression) {\n                var iife = is_iife_single(node);\n                node.args.forEach(function(arg) {\n                    arg.walk(tw);\n                    if (arg instanceof AST_Spread) iife = false;\n                });\n                if (iife) exp.reduce_vars = reduce_iife;\n                exp.walk(tw);\n                if (iife) delete exp.reduce_vars;\n                return true;\n            }\n            if (node.TYPE == \"Call\" && tw.in_boolean_context()) {\n                if (exp instanceof AST_SymbolRef) {\n                    exp.definition().bool_fn++;\n                } else if (exp instanceof AST_Assign && exp.operator == \"=\" && exp.left instanceof AST_SymbolRef) {\n                    exp.left.definition().bool_fn++;\n                }\n            }\n            exp.walk(tw);\n            var optional = node.optional;\n            if (optional) push(tw);\n            node.args.forEach(function(arg) {\n                arg.walk(tw);\n            });\n            if (optional) pop(tw);\n            var fixed = exp instanceof AST_SymbolRef && exp.fixed_value();\n            if (fixed instanceof AST_Lambda) {\n                mark_fn_def(tw, exp.definition(), fixed);\n            } else {\n                tw.find_parent(AST_Scope).may_call_this();\n            }\n            return true;\n        });\n        def(AST_Class, function(tw, descend, compressor) {\n            var node = this;\n            reset_block_variables(tw, compressor, node);\n            if (node.extends) node.extends.walk(tw);\n            var props = node.properties.filter(function(prop) {\n                reset_flags(prop);\n                if (prop.key instanceof AST_Node) prop.key.walk(tw);\n                return prop.value;\n            });\n            if (node.name) {\n                var d = node.name.definition();\n                var parent = tw.parent();\n                if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault) d.single_use = false;\n                if (safe_to_assign(tw, d, true)) {\n                    mark(tw, d);\n                    tw.loop_ids[d.id] = tw.in_loop;\n                    d.fixed = function() {\n                        return node;\n                    };\n                    d.fixed.assigns = [ node ];\n                    if (!is_safe_lexical(d)) d.single_use = false;\n                } else {\n                    d.fixed = false;\n                }\n            }\n            props.forEach(function(prop) {\n                if (!prop.static || prop instanceof AST_ClassField && prop.value.contains_this()) {\n                    push(tw);\n                    prop.value.walk(tw);\n                    pop(tw);\n                } else {\n                    prop.value.walk(tw);\n                }\n            });\n            return true;\n        });\n        def(AST_Conditional, function(tw) {\n            this.condition.walk(tw);\n            push(tw);\n            this.consequent.walk(tw);\n            pop(tw);\n            push(tw);\n            this.alternative.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_DefaultValue, function(tw) {\n            this.name.walk(tw);\n            push(tw);\n            this.value.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_Do, function(tw) {\n            var save_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            this.body.walk(tw);\n            if (has_loop_control(this, tw.parent())) {\n                pop(tw);\n                push(tw);\n            }\n            this.condition.walk(tw);\n            pop(tw);\n            tw.in_loop = save_loop;\n            return true;\n        });\n        def(AST_For, function(tw, descend, compressor) {\n            var node = this;\n            reset_block_variables(tw, compressor, node);\n            if (node.init) node.init.walk(tw);\n            var save_loop = tw.in_loop;\n            tw.in_loop = node;\n            push(tw);\n            if (node.condition) node.condition.walk(tw);\n            node.body.walk(tw);\n            if (node.step) {\n                if (has_loop_control(node, tw.parent())) {\n                    pop(tw);\n                    push(tw);\n                }\n                node.step.walk(tw);\n            }\n            pop(tw);\n            tw.in_loop = save_loop;\n            return true;\n        });\n        def(AST_ForEnumeration, function(tw, descend, compressor) {\n            var node = this;\n            reset_block_variables(tw, compressor, node);\n            node.object.walk(tw);\n            var save_loop = tw.in_loop;\n            tw.in_loop = node;\n            push(tw);\n            var init = node.init;\n            if (init instanceof AST_Definitions) {\n                init.definitions[0].name.mark_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) {\n                        var def = node.definition();\n                        def.assignments++;\n                        def.fixed = false;\n                    }\n                }, tw);\n            } else if (init instanceof AST_Destructured || init instanceof AST_SymbolRef) {\n                init.mark_symbol(function(node) {\n                    if (node instanceof AST_SymbolRef) {\n                        var def = node.definition();\n                        push_ref(def, node);\n                        def.assignments++;\n                        if (!node.is_immutable()) def.fixed = false;\n                    }\n                }, tw);\n            } else {\n                init.walk(tw);\n            }\n            node.body.walk(tw);\n            pop(tw);\n            tw.in_loop = save_loop;\n            return true;\n        });\n        def(AST_If, function(tw) {\n            this.condition.walk(tw);\n            push(tw);\n            this.body.walk(tw);\n            pop(tw);\n            if (this.alternative) {\n                push(tw);\n                this.alternative.walk(tw);\n                pop(tw);\n            }\n            return true;\n        });\n        def(AST_LabeledStatement, function(tw) {\n            push(tw);\n            this.body.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_Lambda, function(tw, descend, compressor) {\n            var fn = this;\n            if (!safe_to_visit(tw, fn)) return true;\n            if (!push_uniq(tw.fn_visited, fn)) return true;\n            fn.inlined = false;\n            push(tw);\n            reset_variables(tw, compressor, fn);\n            descend();\n            pop_scope(tw, fn);\n            if (fn.name) mark_escaped(tw, fn.name.definition(), fn, fn.name, fn, 0, 1);\n            return true;\n        });\n        def(AST_LambdaDefinition, function(tw, descend, compressor) {\n            var fn = this;\n            var def = fn.name.definition();\n            var parent = tw.parent();\n            if (parent instanceof AST_ExportDeclaration || parent instanceof AST_ExportDefault) def.single_use = false;\n            if (!safe_to_visit(tw, fn)) return true;\n            if (!push_uniq(tw.fn_visited, fn)) return true;\n            fn.inlined = false;\n            push(tw);\n            reset_variables(tw, compressor, fn);\n            descend();\n            pop_scope(tw, fn);\n            return true;\n        });\n        def(AST_Sub, function(tw) {\n            if (!this.optional) return;\n            this.expression.walk(tw);\n            push(tw);\n            this.property.walk(tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_Switch, function(tw, descend, compressor) {\n            var node = this;\n            reset_block_variables(tw, compressor, node);\n            node.expression.walk(tw);\n            var first = true;\n            node.body.forEach(function(branch) {\n                if (branch instanceof AST_Default) return;\n                branch.expression.walk(tw);\n                if (first) {\n                    first = false;\n                    push(tw);\n                }\n            })\n            if (!first) pop(tw);\n            walk_body(node, tw);\n            return true;\n        });\n        def(AST_SwitchBranch, function(tw) {\n            push(tw);\n            walk_body(this, tw);\n            pop(tw);\n            return true;\n        });\n        def(AST_SymbolCatch, function() {\n            this.definition().fixed = false;\n        });\n        def(AST_SymbolImport, function() {\n            this.definition().fixed = false;\n        });\n        def(AST_SymbolRef, function(tw, descend, compressor) {\n            var d = this.definition();\n            push_ref(d, this);\n            if (d.references.length == 1 && !d.fixed && d.orig[0] instanceof AST_SymbolDefun) {\n                tw.loop_ids[d.id] = tw.in_loop;\n            }\n            var recursive = recursive_ref(tw, d);\n            if (recursive) recursive.enclosed.forEach(function(def) {\n                if (d === def) return;\n                if (def.scope.resolve() === recursive) return;\n                var assigns = def.fixed && def.fixed.assigns;\n                if (!assigns) return;\n                if (assigns[assigns.length - 1] instanceof AST_VarDef) return;\n                var safe = tw.safe_ids[def.id];\n                if (!safe) return;\n                safe.assign = true;\n            });\n            if (d.fixed === false || d.fixed === 0) {\n                var redef = d.redefined();\n                if (redef && cross_scope(d.scope, this.scope)) redef.single_use = false;\n            } else if (d.fixed === undefined || !safe_to_read(tw, d)) {\n                d.fixed = false;\n            } else if (d.fixed) {\n                if (this.in_arg && d.orig[0] instanceof AST_SymbolLambda) this.fixed = d.scope;\n                var value = this.fixed_value();\n                if (recursive) {\n                    d.recursive_refs++;\n                } else if (value && ref_once(compressor, d)) {\n                    d.in_loop = tw.loop_ids[d.id] !== tw.in_loop;\n                    d.single_use = is_lambda(value)\n                            && !value.pinned()\n                            && (!d.in_loop || tw.parent() instanceof AST_Call)\n                        || !d.in_loop\n                            && d.scope === this.scope.resolve()\n                            && value.is_constant_expression();\n                } else {\n                    d.single_use = false;\n                }\n                if (is_modified(compressor, tw, this, value, 0, is_immutable(value), recursive)) {\n                    if (d.single_use) {\n                        d.single_use = \"m\";\n                    } else {\n                        d.fixed = 0;\n                    }\n                }\n                if (d.fixed && tw.loop_ids[d.id] !== tw.in_loop) d.cross_loop = true;\n                mark_escaped(tw, d, this.scope, this, value, 0, 1);\n            }\n            if (!this.fixed) this.fixed = d.fixed;\n            var parent;\n            if (value instanceof AST_Lambda\n                && !((parent = tw.parent()) instanceof AST_Call && parent.expression === this)) {\n                mark_fn_def(tw, d, value);\n            }\n        });\n        def(AST_Template, function(tw, descend) {\n            var node = this;\n            var tag = node.tag;\n            if (!tag) return;\n            if (tag instanceof AST_LambdaExpression) {\n                node.expressions.forEach(function(exp) {\n                    exp.walk(tw);\n                });\n                tag.walk(tw);\n                return true;\n            }\n            tag.walk(tw);\n            node.expressions.forEach(function(exp) {\n                exp.walk(tw);\n            });\n            var fixed = tag instanceof AST_SymbolRef && tag.fixed_value();\n            if (fixed instanceof AST_Lambda) {\n                mark_fn_def(tw, tag.definition(), fixed);\n            } else {\n                tw.find_parent(AST_Scope).may_call_this();\n            }\n            return true;\n        });\n        def(AST_Toplevel, function(tw, descend, compressor) {\n            var node = this;\n            node.globals.each(function(def) {\n                reset_def(tw, compressor, def);\n            });\n            push(tw);\n            reset_variables(tw, compressor, node);\n            descend();\n            pop_scope(tw, node);\n            return true;\n        });\n        def(AST_Try, function(tw, descend, compressor) {\n            var node = this;\n            reset_block_variables(tw, compressor, node);\n            push(tw);\n            walk_body(node, tw);\n            pop(tw);\n            if (node.bcatch) {\n                push(tw);\n                node.bcatch.walk(tw);\n                pop(tw);\n            }\n            if (node.bfinally) node.bfinally.walk(tw);\n            return true;\n        });\n        def(AST_Unary, function(tw, descend) {\n            var node = this;\n            if (!UNARY_POSTFIX[node.operator]) return;\n            var exp = node.expression;\n            if (!(exp instanceof AST_SymbolRef)) {\n                mark_assignment_to_arguments(exp);\n                return;\n            }\n            var d = exp.definition();\n            d.assignments++;\n            var fixed = d.fixed;\n            if (safe_to_read(tw, d) && !exp.in_arg && safe_to_assign(tw, d)) {\n                push_ref(d, exp);\n                mark(tw, d);\n                if (d.single_use) d.single_use = false;\n                d.fixed = function() {\n                    return make_node(AST_Binary, node, {\n                        operator: node.operator.slice(0, -1),\n                        left: make_node(AST_UnaryPrefix, node, {\n                            operator: \"+\",\n                            expression: make_ref(exp, fixed)\n                        }),\n                        right: make_node(AST_Number, node, {\n                            value: 1\n                        })\n                    });\n                };\n                d.fixed.assigns = fixed && fixed.assigns ? fixed.assigns.slice() : [];\n                d.fixed.assigns.push(node);\n                if (node instanceof AST_UnaryPrefix) {\n                    exp.fixed = d.fixed;\n                } else {\n                    exp.fixed = function() {\n                        return make_node(AST_UnaryPrefix, node, {\n                            operator: \"+\",\n                            expression: make_ref(exp, fixed)\n                        });\n                    };\n                    exp.fixed.assigns = fixed && fixed.assigns;\n                }\n            } else {\n                exp.walk(tw);\n                d.fixed = false;\n            }\n            return true;\n        });\n        def(AST_VarDef, function(tw, descend, compressor) {\n            var node = this;\n            var value = node.value;\n            if (value instanceof AST_LambdaExpression && node.name instanceof AST_SymbolDeclaration) {\n                walk_defn();\n                value.parent_scope.resolve().fn_defs.push(value);\n                value.safe_ids = null;\n                var ld = node.name.definition();\n                if (!ld.fixed) mark_fn_def(tw, ld, value);\n            } else if (value) {\n                value.walk(tw);\n                walk_defn();\n            } else if (tw.parent() instanceof AST_Let) {\n                walk_defn();\n            }\n            return true;\n\n            function walk_defn() {\n                scan_declaration(tw, compressor, node.name, function() {\n                    return node.value || make_node(AST_Undefined, node);\n                }, function(name, fixed) {\n                    var d = name.definition();\n                    if (fixed && safe_to_assign(tw, d, true)) {\n                        mark(tw, d);\n                        tw.loop_ids[d.id] = tw.in_loop;\n                        d.fixed = fixed;\n                        d.fixed.assigns = [ node ];\n                        if (name instanceof AST_SymbolConst && d.redefined()\n                            || !(can_drop_symbol(name) || is_safe_lexical(d))) {\n                            d.single_use = false;\n                        }\n                    } else {\n                        d.fixed = false;\n                    }\n                });\n            }\n        });\n        def(AST_While, function(tw, descend) {\n            var save_loop = tw.in_loop;\n            tw.in_loop = this;\n            push(tw);\n            descend();\n            pop(tw);\n            tw.in_loop = save_loop;\n            return true;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"reduce_vars\", func);\n    });\n\n    function reset_flags(node) {\n        node._squeezed = false;\n        node._optimized = false;\n        if (node instanceof AST_BlockScope) node._var_names = undefined;\n        if (node instanceof AST_SymbolRef) node.fixed = undefined;\n    }\n\n    AST_Toplevel.DEFMETHOD(\"reset_opt_flags\", function(compressor) {\n        var tw = new TreeWalker(compressor.option(\"reduce_vars\") ? function(node, descend) {\n            reset_flags(node);\n            return node.reduce_vars(tw, descend, compressor);\n        } : reset_flags);\n        // Flow control for visiting lambda definitions\n        tw.fn_scanning = null;\n        tw.fn_visited = [];\n        // Record the loop body in which `AST_SymbolDeclaration` is first encountered\n        tw.in_loop = null;\n        tw.loop_ids = Object.create(null);\n        // Stack of look-up tables to keep track of whether a `SymbolDef` has been\n        // properly assigned before use:\n        // - `push()` & `pop()` when visiting conditional branches\n        // - backup & restore via `save_ids` when visiting out-of-order sections\n        tw.safe_ids = Object.create(null);\n        this.walk(tw);\n    });\n\n    AST_Symbol.DEFMETHOD(\"fixed_value\", function() {\n        var fixed = this.definition().fixed;\n        if (fixed) {\n            if (this.fixed) fixed = this.fixed;\n            return fixed instanceof AST_Node ? fixed : fixed();\n        }\n        fixed = fixed === 0 && this.fixed;\n        if (!fixed) return fixed;\n        var value = fixed instanceof AST_Node ? fixed : fixed();\n        return value.is_constant() && value;\n    });\n\n    AST_SymbolRef.DEFMETHOD(\"is_immutable\", function() {\n        var def = this.redef || this.definition();\n        return (this.in_arg || def.orig.length == 1) && def.orig[0] instanceof AST_SymbolLambda;\n    });\n\n    AST_Node.DEFMETHOD(\"convert_symbol\", noop);\n    function convert_destructured(type, process) {\n        return this.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_DefaultValue) {\n                node = node.clone();\n                node.name = node.name.transform(this);\n                return node;\n            }\n            if (node instanceof AST_Destructured) {\n                node = node.clone();\n                descend(node, this);\n                return node;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                node = node.clone();\n                node.value = node.value.transform(this);\n                return node;\n            }\n            return node.convert_symbol(type, process);\n        }));\n    }\n    AST_DefaultValue.DEFMETHOD(\"convert_symbol\", convert_destructured);\n    AST_Destructured.DEFMETHOD(\"convert_symbol\", convert_destructured);\n    function convert_symbol(type, process) {\n        var node = make_node(type, this, this);\n        process(node, this);\n        return node;\n    }\n    AST_SymbolDeclaration.DEFMETHOD(\"convert_symbol\", convert_symbol);\n    AST_SymbolRef.DEFMETHOD(\"convert_symbol\", convert_symbol);\n\n    function mark_destructured(process, tw) {\n        var marker = new TreeWalker(function(node) {\n            if (node instanceof AST_DefaultValue) {\n                node.value.walk(tw);\n                node.name.walk(marker);\n                return true;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                if (node.key instanceof AST_Node) node.key.walk(tw);\n                node.value.walk(marker);\n                return true;\n            }\n            return process(node);\n        });\n        this.walk(marker);\n    }\n    AST_DefaultValue.DEFMETHOD(\"mark_symbol\", mark_destructured);\n    AST_Destructured.DEFMETHOD(\"mark_symbol\", mark_destructured);\n    function mark_symbol(process) {\n        return process(this);\n    }\n    AST_SymbolDeclaration.DEFMETHOD(\"mark_symbol\", mark_symbol);\n    AST_SymbolRef.DEFMETHOD(\"mark_symbol\", mark_symbol);\n\n    AST_Node.DEFMETHOD(\"match_symbol\", function(predicate) {\n        return predicate(this);\n    });\n    function match_destructured(predicate, ignore_side_effects) {\n        var found = false;\n        var tw = new TreeWalker(function(node) {\n            if (found) return true;\n            if (node instanceof AST_DefaultValue) {\n                if (!ignore_side_effects) return found = true;\n                node.name.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_DestructuredKeyVal) {\n                if (!ignore_side_effects && node.key instanceof AST_Node) return found = true;\n                node.value.walk(tw);\n                return true;\n            }\n            if (predicate(node)) return found = true;\n        });\n        this.walk(tw);\n        return found;\n    }\n    AST_DefaultValue.DEFMETHOD(\"match_symbol\", match_destructured);\n    AST_Destructured.DEFMETHOD(\"match_symbol\", match_destructured);\n\n    function in_async_generator(scope) {\n        return scope instanceof AST_AsyncGeneratorDefun || scope instanceof AST_AsyncGeneratorFunction;\n    }\n\n    function find_scope(compressor) {\n        var level = 0, node;\n        while (node = compressor.parent(level++)) {\n            if (node.variables) return node;\n        }\n    }\n\n    var identifier_atom = makePredicate(\"Infinity NaN undefined\");\n    function is_lhs_read_only(lhs, compressor) {\n        if (lhs instanceof AST_ObjectIdentity) return true;\n        if (lhs instanceof AST_PropAccess) {\n            if (lhs.property === \"__proto__\") return true;\n            lhs = lhs.expression;\n            if (lhs instanceof AST_SymbolRef) {\n                if (lhs.is_immutable()) return false;\n                lhs = lhs.fixed_value();\n            }\n            if (!lhs) return true;\n            if (lhs.tail_node().is_constant()) return true;\n            return is_lhs_read_only(lhs, compressor);\n        }\n        if (lhs instanceof AST_SymbolRef) {\n            if (lhs.is_immutable()) return true;\n            var def = lhs.definition();\n            return compressor.exposed(def) && identifier_atom[def.name];\n        }\n        return false;\n    }\n\n    function make_node(ctor, orig, props) {\n        if (!props) props = {};\n        if (orig) {\n            if (!props.start) props.start = orig.start;\n            if (!props.end) props.end = orig.end;\n        }\n        return new ctor(props);\n    }\n\n    function make_sequence(orig, expressions) {\n        if (expressions.length == 1) return expressions[0];\n        return make_node(AST_Sequence, orig, {\n            expressions: expressions.reduce(merge_sequence, [])\n        });\n    }\n\n    function make_node_from_constant(val, orig) {\n        switch (typeof val) {\n          case \"string\":\n            return make_node(AST_String, orig, {\n                value: val\n            });\n          case \"number\":\n            if (isNaN(val)) return make_node(AST_NaN, orig);\n            if (isFinite(val)) {\n                return 1 / val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                    operator: \"-\",\n                    expression: make_node(AST_Number, orig, { value: -val })\n                }) : make_node(AST_Number, orig, { value: val });\n            }\n            return val < 0 ? make_node(AST_UnaryPrefix, orig, {\n                operator: \"-\",\n                expression: make_node(AST_Infinity, orig)\n            }) : make_node(AST_Infinity, orig);\n          case \"boolean\":\n            return make_node(val ? AST_True : AST_False, orig);\n          case \"undefined\":\n            return make_node(AST_Undefined, orig);\n          default:\n            if (val === null) {\n                return make_node(AST_Null, orig, { value: null });\n            }\n            if (val instanceof RegExp) {\n                return make_node(AST_RegExp, orig, { value: val });\n            }\n            throw new Error(string_template(\"Can't handle constant of type: {type}\", {\n                type: typeof val\n            }));\n        }\n    }\n\n    function needs_unbinding(compressor, val) {\n        return val instanceof AST_PropAccess\n            || is_undeclared_ref(val) && val.name == \"eval\";\n    }\n\n    // we shouldn't compress (1,func)(something) to\n    // func(something) because that changes the meaning of\n    // the func (becomes lexical instead of global).\n    function maintain_this_binding(compressor, parent, orig, val) {\n        var wrap = false;\n        if (parent.TYPE == \"Call\") {\n            wrap = parent.expression === orig && needs_unbinding(compressor, val);\n        } else if (parent instanceof AST_Template) {\n            wrap = parent.tag === orig && needs_unbinding(compressor, val);\n        } else if (parent instanceof AST_UnaryPrefix) {\n            wrap = parent.operator == \"delete\"\n                || parent.operator == \"typeof\" && is_undeclared_ref(val);\n        }\n        return wrap ? make_sequence(orig, [ make_node(AST_Number, orig, { value: 0 }), val ]) : val;\n    }\n\n    function merge_sequence(array, node) {\n        if (node instanceof AST_Sequence) {\n            array.push.apply(array, node.expressions);\n        } else {\n            array.push(node);\n        }\n        return array;\n    }\n\n    function is_lexical_definition(stat) {\n        return stat instanceof AST_Const || stat instanceof AST_DefClass || stat instanceof AST_Let;\n    }\n\n    function safe_to_trim(stat) {\n        if (stat instanceof AST_LambdaDefinition) {\n            var def = stat.name.definition();\n            var scope = stat.name.scope;\n            return def.scope === scope || all(def.references, function(ref) {\n                var s = ref.scope;\n                do {\n                    if (s === scope) return true;\n                } while (s = s.parent_scope);\n            });\n        }\n        return !is_lexical_definition(stat);\n    }\n\n    function as_statement_array(thing) {\n        if (thing === null) return [];\n        if (thing instanceof AST_BlockStatement) return all(thing.body, safe_to_trim) ? thing.body : [ thing ];\n        if (thing instanceof AST_EmptyStatement) return [];\n        if (is_statement(thing)) return [ thing ];\n        throw new Error(\"Can't convert thing to statement array\");\n    }\n\n    function is_empty(thing) {\n        if (thing === null) return true;\n        if (thing instanceof AST_EmptyStatement) return true;\n        if (thing instanceof AST_BlockStatement) return thing.body.length == 0;\n        return false;\n    }\n\n    function has_declarations_only(block) {\n        return all(block.body, function(stat) {\n            return is_empty(stat)\n                || stat instanceof AST_Defun\n                || stat instanceof AST_Var && declarations_only(stat);\n        });\n    }\n\n    function loop_body(x) {\n        if (x instanceof AST_IterationStatement) {\n            return x.body instanceof AST_BlockStatement ? x.body : x;\n        }\n        return x;\n    }\n\n    function is_iife_call(node) {\n        if (node.TYPE != \"Call\") return false;\n        do {\n            node = node.expression;\n        } while (node instanceof AST_PropAccess);\n        return node instanceof AST_LambdaExpression ? !is_arrow(node) : is_iife_call(node);\n    }\n\n    function is_iife_single(call) {\n        var exp = call.expression;\n        if (exp.name) return false;\n        if (!(call instanceof AST_New)) return true;\n        var found = false;\n        exp.walk(new TreeWalker(function(node) {\n            if (found) return true;\n            if (node instanceof AST_NewTarget) return found = true;\n            if (node instanceof AST_Scope && node !== exp) return true;\n        }));\n        return !found;\n    }\n\n    function is_undeclared_ref(node) {\n        return node instanceof AST_SymbolRef && node.definition().undeclared;\n    }\n\n    var global_names = makePredicate(\"Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Map Math Number parseFloat parseInt RangeError ReferenceError RegExp Object Set setInterval setTimeout String SyntaxError TypeError unescape URIError WeakMap WeakSet\");\n    AST_SymbolRef.DEFMETHOD(\"is_declared\", function(compressor) {\n        return this.defined\n            || !this.definition().undeclared\n            || compressor.option(\"unsafe\") && global_names[this.name];\n    });\n\n    function declarations_only(node) {\n        return all(node.definitions, function(var_def) {\n            return !var_def.value;\n        });\n    }\n\n    function is_declaration(stat, lexical) {\n        if (stat instanceof AST_DefClass) return lexical && !stat.extends && all(stat.properties, function(prop) {\n            if (prop.key instanceof AST_Node) return false;\n            if (prop instanceof AST_ClassField && prop.static && prop.value) return false;\n            return true;\n        });\n        if (stat instanceof AST_Definitions) return (lexical || stat instanceof AST_Var) && declarations_only(stat);\n        if (stat instanceof AST_ExportDeclaration) return is_declaration(stat.body, lexical);\n        if (stat instanceof AST_ExportDefault) return is_declaration(stat.body, lexical);\n        return stat instanceof AST_LambdaDefinition;\n    }\n\n    function is_last_statement(body, stat) {\n        var index = body.lastIndexOf(stat);\n        if (index < 0) return false;\n        while (++index < body.length) {\n            if (!is_declaration(body[index], true)) return false;\n        }\n        return true;\n    }\n\n    function tighten_body(statements, compressor) {\n        var in_loop, in_try, scope;\n        find_loop_scope_try();\n        var CHANGED, max_iter = 10;\n        do {\n            CHANGED = false;\n            eliminate_spurious_blocks(statements);\n            if (compressor.option(\"dead_code\")) {\n                eliminate_dead_code(statements, compressor);\n            }\n            if (compressor.option(\"if_return\")) {\n                handle_if_return(statements, compressor);\n            }\n            if (compressor.sequences_limit > 0) {\n                sequencesize(statements, compressor);\n                sequencesize_2(statements, compressor);\n            }\n            if (compressor.option(\"join_vars\")) {\n                join_consecutive_vars(statements);\n            }\n            if (compressor.option(\"collapse_vars\")) {\n                collapse(statements, compressor);\n            }\n        } while (CHANGED && max_iter-- > 0);\n        return statements;\n\n        function find_loop_scope_try() {\n            var node = compressor.self(), level = 0;\n            do {\n                if (node instanceof AST_Catch) {\n                    if (compressor.parent(level).bfinally) {\n                        if (!in_try) in_try = {};\n                        in_try.bfinally = true;\n                    }\n                    level++;\n                } else if (node instanceof AST_Finally) {\n                    level++;\n                } else if (node instanceof AST_IterationStatement) {\n                    in_loop = true;\n                } else if (node instanceof AST_Scope) {\n                    scope = node;\n                    break;\n                } else if (node instanceof AST_Try) {\n                    if (!in_try) in_try = {};\n                    if (node.bcatch) in_try.bcatch = true;\n                    if (node.bfinally) in_try.bfinally = true;\n                }\n            } while (node = compressor.parent(level++));\n        }\n\n        // Search from right to left for assignment-like expressions:\n        // - `var a = x;`\n        // - `a = x;`\n        // - `++a`\n        // For each candidate, scan from left to right for first usage, then try\n        // to fold assignment into the site for compression.\n        // Will not attempt to collapse assignments into or past code blocks\n        // which are not sequentially executed, e.g. loops and conditionals.\n        function collapse(statements, compressor) {\n            if (scope.pinned()) return statements;\n            var args;\n            var assignments = new Dictionary();\n            var candidates = [];\n            var declare_only = new Dictionary();\n            var force_single;\n            var stat_index = statements.length;\n            var scanner = new TreeTransformer(function(node, descend) {\n                if (abort) return node;\n                // Skip nodes before `candidate` as quickly as possible\n                if (!hit) {\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    if (hit_index < hit_stack.length) return handle_custom_scan_order(node, scanner);\n                    hit = true;\n                    stop_after = (value_def ? find_stop_value : find_stop)(node, 0);\n                    if (stop_after === node) abort = true;\n                    return node;\n                }\n                // Stop immediately if these node types are encountered\n                var parent = scanner.parent();\n                if (should_stop(node, parent)) {\n                    abort = true;\n                    return node;\n                }\n                // Stop only if candidate is found within conditional branches\n                if (!stop_if_hit && in_conditional(node, parent)) {\n                    stop_if_hit = parent;\n                }\n                // Skip transient nodes caused by single-use variable replacement\n                if (node.single_use && parent instanceof AST_VarDef && parent.value === node) return node;\n                // Replace variable with assignment when found\n                var hit_rhs;\n                if (!(node instanceof AST_SymbolDeclaration)\n                    && (scan_lhs && lhs.equivalent_to(node)\n                        || scan_rhs && (hit_rhs = scan_rhs(node, this)))) {\n                    if (!can_replace || stop_if_hit && (hit_rhs || !lhs_local || !replace_all)) {\n                        if (!hit_rhs && !value_def) abort = true;\n                        return node;\n                    }\n                    if (is_lhs(node, parent)) {\n                        if (value_def && !hit_rhs) assign_used = true;\n                        return node;\n                    } else if (value_def) {\n                        if (stop_if_hit && assign_pos == 0) assign_pos = remaining - replaced;\n                        if (!hit_rhs) replaced++;\n                        return node;\n                    } else {\n                        replaced++;\n                    }\n                    CHANGED = abort = true;\n                    AST_Node.info(\"Collapsing {node} [{file}:{line},{col}]\", {\n                        node: node,\n                        file: node.start.file,\n                        line: node.start.line,\n                        col: node.start.col,\n                    });\n                    if (candidate.TYPE == \"Binary\") return make_node(AST_Assign, candidate, {\n                        operator: \"=\",\n                        left: candidate.right.left,\n                        right: make_node(AST_Conditional, candidate, {\n                            condition: candidate.operator == \"&&\" ? candidate.left : candidate.left.negate(compressor),\n                            consequent: candidate.right.right,\n                            alternative: node,\n                        }),\n                    });\n                    if (candidate instanceof AST_UnaryPostfix) {\n                        if (lhs instanceof AST_SymbolRef) lhs.definition().fixed = false;\n                        return make_node(AST_UnaryPrefix, candidate, candidate);\n                    }\n                    if (candidate instanceof AST_VarDef) {\n                        var def = candidate.name.definition();\n                        if (def.references.length - def.replaced == 1 && !compressor.exposed(def)) {\n                            def.replaced++;\n                            return maintain_this_binding(compressor, parent, node, candidate.value);\n                        }\n                        return make_node(AST_Assign, candidate, {\n                            operator: \"=\",\n                            left: make_node(AST_SymbolRef, candidate.name, candidate.name),\n                            right: candidate.value,\n                        });\n                    }\n                    var assign = candidate;\n                    while (assign.write_only) {\n                        assign.write_only = false;\n                        if (!(assign instanceof AST_Assign)) break;\n                        assign = assign.right;\n                    }\n                    return candidate;\n                }\n                // These node types have child nodes that execute sequentially,\n                // but are otherwise not safe to scan into or beyond them.\n                if (is_last_node(node, parent) || may_throw(node)) {\n                    stop_after = node;\n                    if (node instanceof AST_Scope) abort = true;\n                }\n                // Scan but don't replace inside getter/setter\n                if (node instanceof AST_Accessor) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    descend(node, scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                // Scan but don't replace inside destructuring expression\n                if (node instanceof AST_Destructured) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    descend(node, scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                // Scan but don't replace inside default value\n                if (node instanceof AST_DefaultValue) {\n                    node.name = node.name.transform(scanner);\n                    var replace = can_replace;\n                    can_replace = false;\n                    node.value = node.value.transform(scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                // Scan but don't replace inside block scope with colliding variable\n                if (node instanceof AST_BlockScope\n                    && !(node instanceof AST_Scope)\n                    && !(node.variables && node.variables.all(function(def) {\n                        return !lvalues.has(def.name);\n                    }))) {\n                    var replace = can_replace;\n                    can_replace = false;\n                    if (!handle_custom_scan_order(node, scanner)) descend(node, scanner);\n                    can_replace = replace;\n                    return signal_abort(node);\n                }\n                return handle_custom_scan_order(node, scanner);\n            }, signal_abort);\n            var multi_replacer = new TreeTransformer(function(node) {\n                if (abort) return node;\n                // Skip nodes before `candidate` as quickly as possible\n                if (!hit) {\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    switch (hit_stack.length - hit_index) {\n                      case 0:\n                        hit = true;\n                        if (assign_used) return node;\n                        if (node !== candidate) return node;\n                        if (node instanceof AST_VarDef) return node;\n                        def.replaced++;\n                        var parent = multi_replacer.parent();\n                        if (parent instanceof AST_Sequence && parent.tail_node() !== node) {\n                            value_def.replaced++;\n                            return List.skip;\n                        }\n                        return rvalue;\n                      case 1:\n                        if (!assign_used && node.body === candidate) {\n                            hit = true;\n                            def.replaced++;\n                            value_def.replaced++;\n                            return null;\n                        }\n                      default:\n                        return handle_custom_scan_order(node, multi_replacer);\n                    }\n                }\n                // Replace variable when found\n                if (node instanceof AST_SymbolRef && node.definition() === def) {\n                    if (is_lhs(node, multi_replacer.parent())) return node;\n                    if (!--replaced) abort = true;\n                    var ref = rvalue.clone();\n                    ref.scope = node.scope;\n                    ref.reference();\n                    if (replaced == assign_pos) {\n                        abort = true;\n                        return make_node(AST_Assign, candidate, {\n                            operator: \"=\",\n                            left: node,\n                            right: ref,\n                        });\n                    }\n                    def.replaced++;\n                    return ref;\n                }\n                // Skip (non-executed) functions and (leading) default case in switch statements\n                if (node instanceof AST_Default || node instanceof AST_Scope) return node;\n            }, patch_sequence);\n            while (--stat_index >= 0) {\n                // Treat parameters as collapsible in IIFE, i.e.\n                //   function(a, b){ ... }(x());\n                // would be translated into equivalent assignments:\n                //   var a = x(), b = undefined;\n                if (stat_index == 0 && compressor.option(\"unused\")) extract_args();\n                // Find collapsible assignments\n                var hit_stack = [];\n                extract_candidates(statements[stat_index]);\n                while (candidates.length > 0) {\n                    hit_stack = candidates.pop();\n                    var hit_index = 0;\n                    var candidate = hit_stack[hit_stack.length - 1];\n                    var assign_pos = -1;\n                    var assign_used = false;\n                    var remaining;\n                    var value_def = null;\n                    var stop_after = null;\n                    var stop_if_hit = null;\n                    var lhs = get_lhs(candidate);\n                    var side_effects = lhs && lhs.has_side_effects(compressor);\n                    var scan_lhs = lhs && !side_effects && !is_lhs_read_only(lhs, compressor);\n                    var scan_rhs = foldable(candidate);\n                    if (!scan_lhs && !scan_rhs) continue;\n                    var funarg = candidate.name instanceof AST_SymbolFunarg;\n                    var may_throw = return_false;\n                    if (candidate.may_throw(compressor)) {\n                        if (funarg && is_async(scope)) continue;\n                        may_throw = in_try ? function(node) {\n                            return node.has_side_effects(compressor);\n                        } : side_effects_external;\n                    }\n                    var read_toplevel = false;\n                    var modify_toplevel = false;\n                    // Locate symbols which may execute code outside of scanning range\n                    var well_defined = true;\n                    var lvalues = get_lvalues(candidate);\n                    var lhs_local = is_lhs_local(lhs);\n                    var rvalue = get_rvalue(candidate);\n                    if (!side_effects) side_effects = value_has_side_effects();\n                    var check_destructured = in_try || !lhs_local ? function(node) {\n                        return node instanceof AST_Destructured;\n                    } : return_false;\n                    var replace_all = replace_all_symbols(candidate);\n                    var hit = funarg;\n                    var abort = false;\n                    var replaced = 0;\n                    var can_replace = !args || !hit;\n                    if (!can_replace) {\n                        for (var j = candidate.arg_index + 1; !abort && j < args.length; j++) {\n                            if (args[j]) args[j].transform(scanner);\n                        }\n                        can_replace = true;\n                    }\n                    for (var i = stat_index; !abort && i < statements.length; i++) {\n                        statements[i].transform(scanner);\n                    }\n                    if (value_def) {\n                        if (!replaced || remaining > replaced + assign_used) {\n                            candidates.push(hit_stack);\n                            force_single = true;\n                            continue;\n                        }\n                        if (replaced == assign_pos) assign_used = true;\n                        var def = lhs.definition();\n                        abort = false;\n                        hit_index = 0;\n                        hit = funarg;\n                        for (var i = stat_index; !abort && i < statements.length; i++) {\n                            if (!statements[i].transform(multi_replacer)) statements.splice(i--, 1);\n                        }\n                        replaced = candidate instanceof AST_VarDef\n                            && candidate === hit_stack[hit_stack.length - 1]\n                            && def.references.length == def.replaced\n                            && !compressor.exposed(def);\n                        value_def.last_ref = false;\n                        value_def.single_use = false;\n                        CHANGED = true;\n                    }\n                    if (replaced && !remove_candidate(candidate)) statements.splice(stat_index, 1);\n                }\n            }\n\n            function signal_abort(node) {\n                if (abort) return node;\n                if (stop_after === node) abort = true;\n                if (stop_if_hit === node) stop_if_hit = null;\n                return node;\n            }\n\n            function handle_custom_scan_order(node, tt) {\n                if (!(node instanceof AST_BlockScope)) {\n                    if (!(node instanceof AST_ClassProperty && !node.static)) return;\n                    // Skip non-static class property values\n                    if (node.key instanceof AST_Node) node.key = node.key.transform(tt);\n                    return node;\n                }\n                // Skip (non-executed) functions\n                if (node instanceof AST_Scope) return node;\n                // Scan object only in a for-in/of statement\n                if (node instanceof AST_ForEnumeration) {\n                    node.object = node.object.transform(tt);\n                    abort = true;\n                    return node;\n                }\n                // Scan first case expression only in a switch statement\n                if (node instanceof AST_Switch) {\n                    node.expression = node.expression.transform(tt);\n                    for (var i = 0; !abort && i < node.body.length; i++) {\n                        var branch = node.body[i];\n                        if (branch instanceof AST_Case) {\n                            if (!hit) {\n                                if (branch !== hit_stack[hit_index]) continue;\n                                hit_index++;\n                            }\n                            branch.expression = branch.expression.transform(tt);\n                            if (!replace_all) break;\n                            scan_rhs = false;\n                        }\n                    }\n                    abort = true;\n                    return node;\n                }\n            }\n\n            function is_direct_assignment(node, parent) {\n                if (parent instanceof AST_Assign) return parent.operator == \"=\" && parent.left === node;\n                if (parent instanceof AST_DefaultValue) return parent.name === node;\n                if (parent instanceof AST_DestructuredArray) return true;\n                if (parent instanceof AST_DestructuredKeyVal) return parent.value === node;\n            }\n\n            function should_stop(node, parent) {\n                if (node === rvalue) return true;\n                if (parent instanceof AST_For) {\n                    if (node !== parent.init) return true;\n                }\n                if (node instanceof AST_Assign) {\n                    return node.operator != \"=\" && lhs.equivalent_to(node.left);\n                }\n                if (node instanceof AST_Call) {\n                    if (!(lhs instanceof AST_PropAccess)) return false;\n                    if (!lhs.equivalent_to(node.expression)) return false;\n                    return !(rvalue instanceof AST_LambdaExpression && !rvalue.contains_this());\n                }\n                if (node instanceof AST_Class) return !compressor.has_directive(\"use strict\");\n                if (node instanceof AST_Debugger) return true;\n                if (node instanceof AST_Defun) return funarg && lhs.name === node.name.name;\n                if (node instanceof AST_DestructuredKeyVal) return node.key instanceof AST_Node;\n                if (node instanceof AST_DWLoop) return true;\n                if (node instanceof AST_LoopControl) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (node.is_declared(compressor)) {\n                        if (node.fixed_value()) return false;\n                        if (can_drop_symbol(node)) {\n                            return !(parent instanceof AST_PropAccess && parent.expression === node)\n                                && is_arguments(node.definition());\n                        }\n                    } else if (is_direct_assignment(node, parent)) {\n                        return false;\n                    }\n                    if (!replace_all) return true;\n                    scan_rhs = false;\n                    return false;\n                }\n                if (node instanceof AST_Try) return true;\n                if (node instanceof AST_With) return true;\n                return false;\n            }\n\n            function in_conditional(node, parent) {\n                if (parent instanceof AST_Assign) return parent.left !== node && lazy_op[parent.operator.slice(0, -1)];\n                if (parent instanceof AST_Binary) return parent.left !== node && lazy_op[parent.operator];\n                if (parent instanceof AST_Call) return parent.optional && parent.expression !== node;\n                if (parent instanceof AST_Case) return parent.expression !== node;\n                if (parent instanceof AST_Conditional) return parent.condition !== node;\n                if (parent instanceof AST_If) return parent.condition !== node;\n                if (parent instanceof AST_Sub) return parent.optional && parent.expression !== node;\n            }\n\n            function is_last_node(node, parent) {\n                if (node instanceof AST_Await) return true;\n                if (node.TYPE == \"Binary\") return node.operator == \"in\" && !is_object(node.right);\n                if (node instanceof AST_Call) {\n                    var def, fn = node.expression;\n                    if (fn instanceof AST_SymbolRef) {\n                        def = fn.definition();\n                        fn = fn.fixed_value();\n                    }\n                    if (!(fn instanceof AST_Lambda)) return !node.is_expr_pure(compressor);\n                    if (def && recursive_ref(compressor, def, fn)) return true;\n                    if (fn.collapse_scanning) return false;\n                    fn.collapse_scanning = true;\n                    var replace = can_replace;\n                    can_replace = false;\n                    var after = stop_after;\n                    var if_hit = stop_if_hit;\n                    if (!all(fn.argnames, function(argname) {\n                        if (argname instanceof AST_DefaultValue) {\n                            argname.value.transform(scanner);\n                            if (abort) return false;\n                            argname = argname.name;\n                        }\n                        return !(argname instanceof AST_Destructured);\n                    })) {\n                        abort = true;\n                    } else if (is_arrow(fn) && fn.value) {\n                        fn.value.transform(scanner);\n                    } else for (var i = 0; !abort && i < fn.body.length; i++) {\n                        var stat = fn.body[i];\n                        if (stat instanceof AST_Return) {\n                            if (stat.value) stat.value.transform(scanner);\n                            break;\n                        }\n                        stat.transform(scanner);\n                    }\n                    stop_if_hit = if_hit;\n                    stop_after = after;\n                    can_replace = replace;\n                    fn.collapse_scanning = false;\n                    if (!abort) return false;\n                    abort = false;\n                    return true;\n                }\n                if (node instanceof AST_Exit) {\n                    if (in_try) {\n                        if (in_try.bfinally) return true;\n                        if (in_try.bcatch && node instanceof AST_Throw) return true;\n                    }\n                    return side_effects || lhs instanceof AST_PropAccess || may_modify(lhs);\n                }\n                if (node instanceof AST_Function) {\n                    return compressor.option(\"ie\") && node.name && lvalues.has(node.name.name);\n                }\n                if (node instanceof AST_ObjectIdentity) return symbol_in_lvalues(node, parent);\n                if (node instanceof AST_PropAccess) {\n                    if (side_effects) return true;\n                    var exp = node.expression;\n                    if (exp instanceof AST_SymbolRef && is_arguments(exp.definition())) return true;\n                    if (compressor.option(\"unsafe\")) {\n                        if (is_undeclared_ref(exp) && global_names[exp.name]) return false;\n                        if (is_static_fn(exp)) return false;\n                    }\n                    if (!well_defined) return true;\n                    if (value_def) return false;\n                    if (!in_try && lhs_local) return false;\n                    if (node.optional) return false;\n                    return exp.may_throw_on_access(compressor);\n                }\n                if (node instanceof AST_Spread) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (symbol_in_lvalues(node, parent)) return !is_direct_assignment(node, parent);\n                    if (side_effects && may_modify(node)) return true;\n                    var def = node.definition();\n                    return (in_try || def.scope.resolve() !== scope) && !can_drop_symbol(node);\n                }\n                if (node instanceof AST_Template) return !node.is_expr_pure(compressor);\n                if (node instanceof AST_VarDef) {\n                    if (check_destructured(node.name)) return true;\n                    return (node.value || parent instanceof AST_Let) && node.name.match_symbol(function(node) {\n                        return node instanceof AST_SymbolDeclaration\n                            && (lvalues.has(node.name) || side_effects && may_modify(node));\n                    }, true);\n                }\n                if (node instanceof AST_Yield) return true;\n                var sym = is_lhs(node.left, node);\n                if (!sym) return false;\n                if (sym instanceof AST_PropAccess) return true;\n                if (check_destructured(sym)) return true;\n                return sym.match_symbol(function(node) {\n                    return node instanceof AST_SymbolRef\n                        && (lvalues.has(node.name) || read_toplevel && compressor.exposed(node.definition()));\n                }, true);\n            }\n\n            function may_throw_destructured(node, value) {\n                if (!value) return !(node instanceof AST_Symbol);\n                if (node instanceof AST_DefaultValue) {\n                    return value.has_side_effects(compressor)\n                        || node.value.has_side_effects(compressor)\n                        || may_throw_destructured(node.name, is_undefined(value) && node.value);\n                }\n                if (node instanceof AST_Destructured) {\n                    if (node.rest && may_throw_destructured(node.rest)) return true;\n                    if (node instanceof AST_DestructuredArray) {\n                        if (!(value instanceof AST_Array || value.is_string(compressor))) return true;\n                        return !all(node.elements, function(element) {\n                            return !may_throw_destructured(element);\n                        });\n                    }\n                    if (node instanceof AST_DestructuredObject) {\n                        if (!value.is_defined(compressor)) return true;\n                        return !all(node.properties, function(prop) {\n                            if (prop instanceof AST_Node && prop.has_side_effects(compressor)) return false;\n                            return !may_throw_destructured(prop.value);\n                        });\n                    }\n                }\n            }\n\n            function extract_args() {\n                var iife, fn = compressor.self();\n                if (fn instanceof AST_LambdaExpression\n                    && !is_generator(fn)\n                    && !fn.uses_arguments\n                    && !fn.pinned()\n                    && (iife = compressor.parent()) instanceof AST_Call\n                    && iife.expression === fn\n                    && is_iife_single(iife)\n                    && all(iife.args, function(arg) {\n                        return !(arg instanceof AST_Spread);\n                    })) {\n                    var fn_strict = compressor.has_directive(\"use strict\");\n                    if (fn_strict && !member(fn_strict, fn.body)) fn_strict = false;\n                    var has_await = is_async(fn) ? function(node) {\n                        return node instanceof AST_Symbol && node.name == \"await\";\n                    } : function(node) {\n                        return node instanceof AST_Await && !tw.find_parent(AST_Scope);\n                    };\n                    var arg_scope = null;\n                    var tw = new TreeWalker(function(node, descend) {\n                        if (!arg) return true;\n                        if (has_await(node) || node instanceof AST_Yield) {\n                            arg = null;\n                            return true;\n                        }\n                        if (node instanceof AST_ObjectIdentity && (fn_strict || !arg_scope)) {\n                            arg = null;\n                            return true;\n                        }\n                        if (node instanceof AST_SymbolRef && fn.variables.has(node.name)) {\n                            var s = node.definition().scope;\n                            if (s !== scope) while (s = s.parent_scope) {\n                                if (s === scope) return true;\n                            }\n                            arg = null;\n                        }\n                        if (node instanceof AST_Scope && !is_arrow(node)) {\n                            var save_scope = arg_scope;\n                            arg_scope = node;\n                            descend();\n                            arg_scope = save_scope;\n                            return true;\n                        }\n                    });\n                    args = iife.args.slice();\n                    var len = args.length;\n                    var names = new Dictionary();\n                    for (var i = fn.argnames.length; --i >= 0;) {\n                        var sym = fn.argnames[i];\n                        var arg = args[i];\n                        var value;\n                        if (sym instanceof AST_DefaultValue) {\n                            value = sym.value;\n                            sym = sym.name;\n                            args[len + i] = value;\n                        }\n                        if (sym instanceof AST_Destructured) {\n                            if (!may_throw_destructured(sym, arg)) continue;\n                            candidates.length = 0;\n                            break;\n                        }\n                        if (names.has(sym.name)) continue;\n                        names.set(sym.name, true);\n                        if (value) arg = !arg || is_undefined(arg) ? value : null;\n                        if (!arg && !value) {\n                            arg = make_node(AST_Undefined, sym).transform(compressor);\n                        } else if (arg instanceof AST_Lambda && arg.pinned()) {\n                            arg = null;\n                        } else if (arg) {\n                            arg.walk(tw);\n                        }\n                        if (!arg) continue;\n                        var candidate = make_node(AST_VarDef, sym, {\n                            name: sym,\n                            value: arg,\n                        });\n                        candidate.name_index = i;\n                        candidate.arg_index = value ? len + i : i;\n                        candidates.unshift([ candidate ]);\n                    }\n                }\n            }\n\n            function extract_candidates(expr, unused) {\n                hit_stack.push(expr);\n                if (expr instanceof AST_Array) {\n                    expr.elements.forEach(function(node) {\n                        extract_candidates(node, unused);\n                    });\n                } else if (expr instanceof AST_Assign) {\n                    var lhs = expr.left;\n                    if (!(lhs instanceof AST_Destructured)) candidates.push(hit_stack.slice());\n                    extract_candidates(lhs);\n                    extract_candidates(expr.right);\n                    if (lhs instanceof AST_SymbolRef && expr.operator == \"=\") {\n                        assignments.set(lhs.name, (assignments.get(lhs.name) || 0) + 1);\n                    }\n                } else if (expr instanceof AST_Await) {\n                    extract_candidates(expr.expression, unused);\n                } else if (expr instanceof AST_Binary) {\n                    var lazy = lazy_op[expr.operator];\n                    if (unused\n                        && lazy\n                        && expr.operator != \"??\"\n                        && expr.right instanceof AST_Assign\n                        && expr.right.operator == \"=\"\n                        && !(expr.right.left instanceof AST_Destructured)) {\n                        candidates.push(hit_stack.slice());\n                    }\n                    extract_candidates(expr.left, !lazy && unused);\n                    extract_candidates(expr.right, unused);\n                } else if (expr instanceof AST_Call) {\n                    extract_candidates(expr.expression);\n                    expr.args.forEach(extract_candidates);\n                } else if (expr instanceof AST_Case) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_Conditional) {\n                    extract_candidates(expr.condition);\n                    extract_candidates(expr.consequent, unused);\n                    extract_candidates(expr.alternative, unused);\n                } else if (expr instanceof AST_Definitions) {\n                    expr.definitions.forEach(extract_candidates);\n                } else if (expr instanceof AST_Dot) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_DWLoop) {\n                    extract_candidates(expr.condition);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_Exit) {\n                    if (expr.value) extract_candidates(expr.value);\n                } else if (expr instanceof AST_For) {\n                    if (expr.init) extract_candidates(expr.init, true);\n                    if (expr.condition) extract_candidates(expr.condition);\n                    if (expr.step) extract_candidates(expr.step, true);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_ForEnumeration) {\n                    extract_candidates(expr.object);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                } else if (expr instanceof AST_If) {\n                    extract_candidates(expr.condition);\n                    if (!(expr.body instanceof AST_Block)) {\n                        extract_candidates(expr.body);\n                    }\n                    if (expr.alternative && !(expr.alternative instanceof AST_Block)) {\n                        extract_candidates(expr.alternative);\n                    }\n                } else if (expr instanceof AST_Object) {\n                    expr.properties.forEach(function(prop) {\n                        hit_stack.push(prop);\n                        if (prop.key instanceof AST_Node) extract_candidates(prop.key);\n                        if (prop instanceof AST_ObjectKeyVal) extract_candidates(prop.value, unused);\n                        hit_stack.pop();\n                    });\n                } else if (expr instanceof AST_Sequence) {\n                    var end = expr.expressions.length - (unused ? 0 : 1);\n                    expr.expressions.forEach(function(node, index) {\n                        extract_candidates(node, index < end);\n                    });\n                } else if (expr instanceof AST_SimpleStatement) {\n                    extract_candidates(expr.body, true);\n                } else if (expr instanceof AST_Spread) {\n                    extract_candidates(expr.expression);\n                } else if (expr instanceof AST_Sub) {\n                    extract_candidates(expr.expression);\n                    extract_candidates(expr.property);\n                } else if (expr instanceof AST_Switch) {\n                    extract_candidates(expr.expression);\n                    expr.body.forEach(extract_candidates);\n                } else if (expr instanceof AST_Unary) {\n                    if (UNARY_POSTFIX[expr.operator]) {\n                        candidates.push(hit_stack.slice());\n                    } else {\n                        extract_candidates(expr.expression);\n                    }\n                } else if (expr instanceof AST_VarDef) {\n                    if (expr.name instanceof AST_SymbolVar) {\n                        if (expr.value) {\n                            var def = expr.name.definition();\n                            if (def.references.length > def.replaced) {\n                                candidates.push(hit_stack.slice());\n                            }\n                        } else {\n                            declare_only.set(expr.name.name, (declare_only.get(expr.name.name) || 0) + 1);\n                        }\n                    }\n                    if (expr.value) extract_candidates(expr.value);\n                } else if (expr instanceof AST_Yield) {\n                    if (expr.expression) extract_candidates(expr.expression);\n                }\n                hit_stack.pop();\n            }\n\n            function find_stop(node, level) {\n                var parent = scanner.parent(level);\n                if (parent instanceof AST_Array) return node;\n                if (parent instanceof AST_Assign) return node;\n                if (parent instanceof AST_Await) return node;\n                if (parent instanceof AST_Binary) return node;\n                if (parent instanceof AST_Call) return node;\n                if (parent instanceof AST_Case) return node;\n                if (parent instanceof AST_Conditional) return node;\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Exit) return node;\n                if (parent instanceof AST_If) return node;\n                if (parent instanceof AST_IterationStatement) return node;\n                if (parent instanceof AST_ObjectProperty) return node;\n                if (parent instanceof AST_PropAccess) return node;\n                if (parent instanceof AST_Sequence) {\n                    return (parent.tail_node() === node ? find_stop : find_stop_unused)(parent, level + 1);\n                }\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return node;\n                if (parent instanceof AST_Switch) return node;\n                if (parent instanceof AST_Unary) return node;\n                if (parent instanceof AST_VarDef) return node;\n                if (parent instanceof AST_Yield) return node;\n                return null;\n            }\n\n            function find_stop_logical(parent, op, level) {\n                var node;\n                do {\n                    node = parent;\n                    parent = scanner.parent(++level);\n                } while (parent instanceof AST_Assign && parent.operator.slice(0, -1) == op\n                    || parent instanceof AST_Binary && parent.operator == op);\n                return node;\n            }\n\n            function find_stop_expr(expr, cont, node, parent, level) {\n                var replace = can_replace;\n                can_replace = false;\n                var after = stop_after;\n                var if_hit = stop_if_hit;\n                var stack = scanner.stack;\n                scanner.stack = [ parent ];\n                expr.transform(scanner);\n                scanner.stack = stack;\n                stop_if_hit = if_hit;\n                stop_after = after;\n                can_replace = replace;\n                if (abort) {\n                    abort = false;\n                    return node;\n                }\n                return cont(parent, level + 1);\n            }\n\n            function find_stop_value(node, level) {\n                var parent = scanner.parent(level);\n                if (parent instanceof AST_Array) return find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Assign) {\n                    if (may_throw(parent)) return node;\n                    if (parent.left.match_symbol(function(ref) {\n                        return ref instanceof AST_SymbolRef && (lhs.name == ref.name || value_def.name == ref.name);\n                    })) return node;\n                    var op;\n                    if (parent.left === node || !lazy_op[op = parent.operator.slice(0, -1)]) {\n                        return find_stop_value(parent, level + 1);\n                    }\n                    return find_stop_logical(parent, op, level);\n                }\n                if (parent instanceof AST_Binary) {\n                    var op;\n                    if (parent.left === node || !lazy_op[op = parent.operator]) {\n                        return find_stop_value(parent, level + 1);\n                    }\n                    return find_stop_logical(parent, op, level);\n                }\n                if (parent instanceof AST_Call) return parent;\n                if (parent instanceof AST_Case) {\n                    if (parent.expression !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Conditional) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Do) return node;\n                if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_For) {\n                    if (parent.init !== node && parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_ForEnumeration) {\n                    if (parent.init !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_If) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_ObjectProperty) {\n                    var obj = scanner.parent(level + 1);\n                    return all(obj.properties, function(prop) {\n                        return prop instanceof AST_ObjectKeyVal;\n                    }) ? find_stop_value(obj, level + 2) : obj;\n                }\n                if (parent instanceof AST_PropAccess) {\n                    var exp = parent.expression;\n                    return exp === node ? find_stop_value(parent, level + 1) : node;\n                }\n                if (parent instanceof AST_Sequence) {\n                    return (parent.tail_node() === node ? find_stop_value : find_stop_unused)(parent, level + 1);\n                }\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return find_stop_value(parent, level + 1);\n                if (parent instanceof AST_Switch) {\n                    if (parent.expression !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Unary) {\n                    if (parent.operator == \"delete\") return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_VarDef) return parent.name.match_symbol(function(sym) {\n                    return sym instanceof AST_SymbolDeclaration && (lhs.name == sym.name || value_def.name == sym.name);\n                }) ? node : find_stop_value(parent, level + 1);\n                if (parent instanceof AST_While) {\n                    if (parent.condition !== node) return node;\n                    return find_stop_value(parent, level + 1);\n                }\n                if (parent instanceof AST_Yield) return find_stop_value(parent, level + 1);\n                return null;\n            }\n\n            function find_stop_unused(node, level) {\n                var parent = scanner.parent(level);\n                if (is_last_node(node, parent)) return node;\n                if (in_conditional(node, parent)) return node;\n                if (parent instanceof AST_Array) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Assign) return check_assignment(parent.left);\n                if (parent instanceof AST_Await) return node;\n                if (parent instanceof AST_Binary) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Call) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Case) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Conditional) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Definitions) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Exit) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_If) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_IterationStatement) return node;\n                if (parent instanceof AST_ObjectProperty) {\n                    var obj = scanner.parent(level + 1);\n                    return all(obj.properties, function(prop) {\n                        return prop instanceof AST_ObjectKeyVal;\n                    }) ? find_stop_unused(obj, level + 2) : obj;\n                }\n                if (parent instanceof AST_PropAccess) {\n                    var exp = parent.expression;\n                    if (exp === node) return find_stop_unused(parent, level + 1);\n                    return find_stop_expr(exp, find_stop_unused, node, parent, level);\n                }\n                if (parent instanceof AST_Sequence) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_SimpleStatement) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Spread) return node;\n                if (parent instanceof AST_Switch) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_Unary) return find_stop_unused(parent, level + 1);\n                if (parent instanceof AST_VarDef) return check_assignment(parent.name);\n                if (parent instanceof AST_Yield) return node;\n                return null;\n\n                function check_assignment(lhs) {\n                    if (may_throw(parent)) return node;\n                    if (lhs !== node && lhs instanceof AST_Destructured) {\n                        return find_stop_expr(lhs, find_stop_unused, node, parent, level);\n                    }\n                    return find_stop_unused(parent, level + 1);\n                }\n            }\n\n            function mangleable_var(rhs) {\n                if (force_single) {\n                    force_single = false;\n                    return;\n                }\n                if (remaining < 1) return;\n                var value = rhs instanceof AST_Assign && rhs.operator == \"=\" ? rhs.left : rhs;\n                if (!(value instanceof AST_SymbolRef)) return;\n                var def = value.definition();\n                if (def.undeclared) return;\n                if (is_arguments(def)) return;\n                if (value !== rhs) {\n                    if (is_lhs_read_only(value, compressor)) return;\n                    var referenced = def.references.length - def.replaced;\n                    if (referenced < 2) return;\n                    var expr = candidate.clone();\n                    expr[expr instanceof AST_Assign ? \"right\" : \"value\"] = value;\n                    if (candidate.name_index >= 0) {\n                        expr.name_index = candidate.name_index;\n                        expr.arg_index = candidate.arg_index;\n                    }\n                    candidate = expr;\n                }\n                return value_def = def;\n            }\n\n            function remaining_refs(def) {\n                return def.references.length - def.replaced - (assignments.get(def.name) || 0);\n            }\n\n            function get_lhs(expr) {\n                if (expr instanceof AST_Assign) {\n                    var lhs = expr.left;\n                    if (expr.operator != \"=\") return lhs;\n                    if (!(lhs instanceof AST_SymbolRef)) return lhs;\n                    var def = lhs.definition();\n                    if (scope.uses_arguments && is_funarg(def)) return lhs;\n                    if (compressor.exposed(def)) return lhs;\n                    remaining = remaining_refs(def);\n                    if (def.fixed && lhs.fixed) {\n                        var matches = def.references.filter(function(ref) {\n                            return ref.fixed === lhs.fixed;\n                        }).length - 1;\n                        if (matches < remaining) {\n                            remaining = matches;\n                            assign_pos = 0;\n                        }\n                    }\n                    mangleable_var(expr.right);\n                    return lhs;\n                }\n                if (expr instanceof AST_Binary) return expr.right.left;\n                if (expr instanceof AST_Unary) return expr.expression;\n                if (expr instanceof AST_VarDef) {\n                    var lhs = expr.name;\n                    var def = lhs.definition();\n                    if (def.const_redefs) return;\n                    if (!member(lhs, def.orig)) return;\n                    if (scope.uses_arguments && is_funarg(def)) return;\n                    var declared = def.orig.length - def.eliminated - (declare_only.get(def.name) || 0);\n                    remaining = remaining_refs(def);\n                    if (def.fixed) remaining = Math.min(remaining, def.references.filter(function(ref) {\n                        if (!ref.fixed) return true;\n                        if (!ref.fixed.assigns) return true;\n                        var assign = ref.fixed.assigns[0];\n                        return assign === lhs || get_rvalue(assign) === expr.value;\n                    }).length);\n                    if (declared > 1 && !(lhs instanceof AST_SymbolFunarg)) {\n                        mangleable_var(expr.value);\n                        return make_node(AST_SymbolRef, lhs, lhs);\n                    }\n                    if (mangleable_var(expr.value) || remaining == 1 && !compressor.exposed(def)) {\n                        return make_node(AST_SymbolRef, lhs, lhs);\n                    }\n                    return;\n                }\n            }\n\n            function get_rvalue(expr) {\n                if (expr instanceof AST_Assign) return expr.right;\n                if (expr instanceof AST_Binary) {\n                    var node = expr.clone();\n                    node.right = expr.right.right;\n                    return node;\n                }\n                if (expr instanceof AST_VarDef) return expr.value;\n            }\n\n            function invariant(expr) {\n                if (expr instanceof AST_Array) return false;\n                if (expr instanceof AST_Binary && lazy_op[expr.operator]) {\n                    return invariant(expr.left) && invariant(expr.right);\n                }\n                if (expr instanceof AST_Call) return false;\n                if (expr instanceof AST_Conditional) {\n                    return invariant(expr.consequent) && invariant(expr.alternative);\n                }\n                if (expr instanceof AST_Object) return false;\n                return !expr.has_side_effects(compressor);\n            }\n\n            function foldable(expr) {\n                if (expr instanceof AST_Assign && expr.right.single_use) return;\n                var lhs_ids = Object.create(null);\n                var marker = new TreeWalker(function(node) {\n                    if (node instanceof AST_SymbolRef) lhs_ids[node.definition().id] = true;\n                });\n                while (expr instanceof AST_Assign && expr.operator == \"=\") {\n                    expr.left.walk(marker);\n                    expr = expr.right;\n                }\n                if (expr instanceof AST_ObjectIdentity) return rhs_exact_match;\n                if (expr instanceof AST_SymbolRef) {\n                    var value = expr.evaluate(compressor);\n                    if (value === expr) return rhs_exact_match;\n                    return rhs_fuzzy_match(value, rhs_exact_match);\n                }\n                if (expr.is_truthy()) return rhs_fuzzy_match(true, return_false);\n                if (expr.is_constant()) {\n                    var ev = expr.evaluate(compressor);\n                    if (!(ev instanceof AST_Node)) return rhs_fuzzy_match(ev, rhs_exact_match);\n                }\n                if (!(lhs instanceof AST_SymbolRef)) return false;\n                if (!invariant(expr)) return false;\n                var circular;\n                expr.walk(new TreeWalker(function(node) {\n                    if (circular) return true;\n                    if (node instanceof AST_SymbolRef && lhs_ids[node.definition().id]) circular = true;\n                }));\n                return !circular && rhs_exact_match;\n\n                function rhs_exact_match(node) {\n                    return expr.equivalent_to(node);\n                }\n            }\n\n            function rhs_fuzzy_match(value, fallback) {\n                return function(node, tw) {\n                    if (tw.in_boolean_context()) {\n                        if (value && node.is_truthy() && !node.has_side_effects(compressor)) {\n                            return true;\n                        }\n                        if (node.is_constant()) {\n                            var ev = node.evaluate(compressor);\n                            if (!(ev instanceof AST_Node)) return !ev == !value;\n                        }\n                    }\n                    return fallback(node);\n                };\n            }\n\n            function may_be_global(node) {\n                if (node instanceof AST_SymbolRef) {\n                    node = node.fixed_value();\n                    if (!node) return true;\n                }\n                if (node instanceof AST_Assign) return node.operator == \"=\" && may_be_global(node.right);\n                return node instanceof AST_PropAccess || node instanceof AST_ObjectIdentity;\n            }\n\n            function get_lvalues(expr) {\n                var lvalues = new Dictionary();\n                if (expr instanceof AST_VarDef) {\n                    if (!expr.name.definition().fixed) well_defined = false;\n                    lvalues.add(expr.name.name, lhs);\n                }\n                var find_arguments = scope.uses_arguments && !compressor.has_directive(\"use strict\");\n                var scan_toplevel = scope instanceof AST_Toplevel;\n                var tw = new TreeWalker(function(node) {\n                    var value;\n                    if (node instanceof AST_SymbolRef) {\n                        value = node.fixed_value();\n                        if (!value) {\n                            value = node;\n                            var def = node.definition();\n                            var escaped = node.fixed && node.fixed.escaped || def.escaped;\n                            if (!def.undeclared\n                                && (def.assignments || !escaped || escaped.cross_scope)\n                                && (has_escaped(def, node.scope, node, tw.parent()) || !same_scope(def))) {\n                                well_defined = false;\n                            }\n                        }\n                    } else if (node instanceof AST_ObjectIdentity) {\n                        value = node;\n                    }\n                    if (value) {\n                        lvalues.add(node.name, is_modified(compressor, tw, node, value, 0));\n                    } else if (node instanceof AST_Lambda) {\n                        for (var level = 0, parent, child = node; parent = tw.parent(level++); child = parent) {\n                            if (parent instanceof AST_Assign) {\n                                if (parent.left === child) break;\n                                if (parent.operator == \"=\") continue;\n                                if (lazy_op[parent.operator.slice(0, -1)]) continue;\n                                break;\n                            }\n                            if (parent instanceof AST_Binary) {\n                                if (lazy_op[parent.operator]) continue;\n                                break;\n                            }\n                            if (parent instanceof AST_Call) return;\n                            if (parent instanceof AST_Scope) return;\n                            if (parent instanceof AST_Sequence) {\n                                if (parent.tail_node() === child) continue;\n                                break;\n                            }\n                            if (parent instanceof AST_Template) {\n                                if (parent.tag) return;\n                                break;\n                            }\n                        }\n                        return true;\n                    } else if (find_arguments && node instanceof AST_Sub) {\n                        scope.each_argname(function(argname) {\n                            if (!compressor.option(\"reduce_vars\") || argname.definition().assignments) {\n                                if (!argname.definition().fixed) well_defined = false;\n                                lvalues.add(argname.name, true);\n                            }\n                        });\n                        find_arguments = false;\n                    }\n                    if (!scan_toplevel) return;\n                    if (node.TYPE == \"Call\") {\n                        if (modify_toplevel) return;\n                        var exp = node.expression;\n                        if (exp instanceof AST_PropAccess) return;\n                        if (exp instanceof AST_LambdaExpression && !exp.contains_this()) return;\n                        modify_toplevel = true;\n                    } else if (node instanceof AST_PropAccess && may_be_global(node.expression)) {\n                        if (node === lhs && !(expr instanceof AST_Unary)) {\n                            modify_toplevel = true;\n                        } else {\n                            read_toplevel = true;\n                        }\n                    }\n                });\n                expr.walk(tw);\n                return lvalues;\n            }\n\n            function remove_candidate(expr) {\n                var index = expr.name_index;\n                if (index >= 0) {\n                    var argname = scope.argnames[index];\n                    if (argname instanceof AST_DefaultValue) {\n                        argname.value = make_node(AST_Number, argname, {\n                            value: 0\n                        });\n                        argname.name.definition().fixed = false;\n                    } else {\n                        var args = compressor.parent().args;\n                        if (args[index]) {\n                            args[index] = make_node(AST_Number, args[index], {\n                                value: 0\n                            });\n                            argname.definition().fixed = false;\n                        }\n                    }\n                    return true;\n                }\n                var end = hit_stack.length - 1;\n                if (hit_stack[end - 1].body === hit_stack[end]) end--;\n                var tt = new TreeTransformer(function(node, descend, in_list) {\n                    if (hit) return node;\n                    if (node !== hit_stack[hit_index]) return node;\n                    hit_index++;\n                    if (hit_index <= end) return handle_custom_scan_order(node, tt);\n                    hit = true;\n                    if (node instanceof AST_VarDef) {\n                        declare_only.set(node.name.name, (declare_only.get(node.name.name) || 0) + 1);\n                        if (value_def) value_def.replaced++;\n                        node = node.clone();\n                        node.value = null;\n                        return node;\n                    }\n                    return in_list ? List.skip : null;\n                }, patch_sequence);\n                abort = false;\n                hit = false;\n                hit_index = 0;\n                return statements[stat_index].transform(tt);\n            }\n\n            function patch_sequence(node) {\n                if (node instanceof AST_Sequence) switch (node.expressions.length) {\n                  case 0: return null;\n                  case 1: return maintain_this_binding(compressor, this.parent(), node, node.expressions[0]);\n                }\n            }\n\n            function is_lhs_local(lhs) {\n                var sym = root_expr(lhs);\n                return sym instanceof AST_SymbolRef\n                    && sym.definition().scope.resolve() === scope\n                    && !(in_loop\n                        && (lvalues.has(sym.name) && lvalues.get(sym.name)[0] !== lhs\n                            || candidate instanceof AST_Unary\n                            || candidate instanceof AST_Assign && candidate.operator != \"=\"));\n            }\n\n            function value_has_side_effects() {\n                if (candidate instanceof AST_Unary) return false;\n                return rvalue.has_side_effects(compressor);\n            }\n\n            function replace_all_symbols(expr) {\n                if (expr instanceof AST_Unary) return false;\n                if (side_effects) return false;\n                if (value_def) return true;\n                if (!(lhs instanceof AST_SymbolRef)) return false;\n                var referenced;\n                if (expr instanceof AST_VarDef) {\n                    referenced = 1;\n                } else if (expr.operator == \"=\") {\n                    referenced = 2;\n                } else {\n                    return false;\n                }\n                var def = lhs.definition();\n                if (def.references.length - def.replaced == referenced) return true;\n                return def.fixed && lhs.fixed && def.references.filter(function(ref) {\n                    return ref.fixed === lhs.fixed;\n                }).length == referenced;\n            }\n\n            function symbol_in_lvalues(sym, parent) {\n                var lvalue = lvalues.get(sym.name);\n                if (!lvalue || all(lvalue, function(lhs) {\n                    return !lhs;\n                })) return;\n                if (lvalue[0] !== lhs) return true;\n                scan_rhs = false;\n            }\n\n            function may_modify(sym) {\n                var def = sym.definition();\n                if (def.orig.length == 1 && def.orig[0] instanceof AST_SymbolDefun) return false;\n                if (def.scope.resolve() !== scope) return true;\n                if (modify_toplevel && compressor.exposed(def)) return true;\n                return !all(def.references, function(ref) {\n                    return ref.scope.resolve() === scope;\n                });\n            }\n\n            function side_effects_external(node, lhs) {\n                if (node instanceof AST_Assign) return side_effects_external(node.left, true);\n                if (node instanceof AST_Unary) return side_effects_external(node.expression, true);\n                if (node instanceof AST_VarDef) return node.value && side_effects_external(node.value);\n                if (lhs) {\n                    if (node instanceof AST_Dot) return side_effects_external(node.expression, true);\n                    if (node instanceof AST_Sub) return side_effects_external(node.expression, true);\n                    if (node instanceof AST_SymbolRef) return node.definition().scope.resolve() !== scope;\n                }\n                return false;\n            }\n        }\n\n        function eliminate_spurious_blocks(statements) {\n            var seen_dirs = [];\n            for (var i = 0; i < statements.length;) {\n                var stat = statements[i];\n                if (stat instanceof AST_BlockStatement) {\n                    if (all(stat.body, safe_to_trim)) {\n                        CHANGED = true;\n                        eliminate_spurious_blocks(stat.body);\n                        [].splice.apply(statements, [i, 1].concat(stat.body));\n                        i += stat.body.length;\n                        continue;\n                    }\n                }\n                if (stat instanceof AST_Directive) {\n                    if (member(stat.value, seen_dirs)) {\n                        CHANGED = true;\n                        statements.splice(i, 1);\n                        continue;\n                    }\n                    seen_dirs.push(stat.value);\n                }\n                if (stat instanceof AST_EmptyStatement) {\n                    CHANGED = true;\n                    statements.splice(i, 1);\n                    continue;\n                }\n                i++;\n            }\n        }\n\n        function handle_if_return(statements, compressor) {\n            var self = compressor.self();\n            var parent = compressor.parent();\n            var in_lambda = last_of(function(node) {\n                return node instanceof AST_Lambda;\n            });\n            var in_iife = in_lambda && parent && parent.TYPE == \"Call\";\n            var multiple_if_returns = has_multiple_if_returns(statements);\n            for (var i = statements.length; --i >= 0;) {\n                var stat = statements[i];\n                var j = next_index(i);\n                var next = statements[j];\n\n                if (in_lambda && !next && stat instanceof AST_Return) {\n                    if (!stat.value) {\n                        CHANGED = true;\n                        statements.splice(i, 1);\n                        continue;\n                    }\n                    var tail = stat.value.tail_node();\n                    if (tail instanceof AST_UnaryPrefix && tail.operator == \"void\") {\n                        CHANGED = true;\n                        var body;\n                        if (tail === stat.value) {\n                            body = tail.expression;\n                        } else {\n                            body = stat.value.clone();\n                            body.expressions[body.length - 1] = tail.expression;\n                        }\n                        statements[i] = make_node(AST_SimpleStatement, stat, {\n                            body: body,\n                        });\n                        continue;\n                    }\n                }\n\n                if (stat instanceof AST_If) {\n                    var ab = aborts(stat.body);\n                    if (can_merge_flow(ab)) {\n                        if (ab.label) remove(ab.label.thedef.references, ab);\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.condition = stat.condition.negate(compressor);\n                        var body = as_statement_array_with_return(stat.body, ab);\n                        stat.body = make_node(AST_BlockStatement, stat, {\n                            body: as_statement_array(stat.alternative).concat(extract_functions())\n                        });\n                        stat.alternative = make_node(AST_BlockStatement, stat, {\n                            body: body\n                        });\n                        statements[i] = stat;\n                        statements[i] = stat.transform(compressor);\n                        continue;\n                    }\n\n                    if (ab && !stat.alternative && stat.body instanceof AST_BlockStatement && next instanceof AST_Jump) {\n                        var negated = stat.condition.negate(compressor);\n                        if (negated.print_to_string().length <= stat.condition.print_to_string().length) {\n                            CHANGED = true;\n                            stat = stat.clone();\n                            stat.condition = negated;\n                            statements[j] = stat.body;\n                            stat.body = next;\n                            statements[i] = stat;\n                            statements[i] = stat.transform(compressor);\n                            continue;\n                        }\n                    }\n\n                    var alt = aborts(stat.alternative);\n                    if (can_merge_flow(alt)) {\n                        if (alt.label) remove(alt.label.thedef.references, alt);\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.body = make_node(AST_BlockStatement, stat.body, {\n                            body: as_statement_array(stat.body).concat(extract_functions())\n                        });\n                        var body = as_statement_array_with_return(stat.alternative, alt);\n                        stat.alternative = make_node(AST_BlockStatement, stat.alternative, {\n                            body: body\n                        });\n                        statements[i] = stat;\n                        statements[i] = stat.transform(compressor);\n                        continue;\n                    }\n\n                    if (compressor.option(\"typeofs\")) {\n                        if (ab && !alt) {\n                            mark_locally_defined(stat.condition, null, make_node(AST_BlockStatement, self, {\n                                body: statements.slice(i + 1)\n                            }));\n                        }\n                        if (!ab && alt) {\n                            mark_locally_defined(stat.condition, make_node(AST_BlockStatement, self, {\n                                body: statements.slice(i + 1)\n                            }));\n                        }\n                    }\n                }\n\n                if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                    var value = stat.body.value;\n                    var in_bool = stat.body.in_bool || next instanceof AST_Return && next.in_bool;\n                    //---\n                    // pretty silly case, but:\n                    // if (foo()) return; return; ---> foo(); return;\n                    if (!value && !stat.alternative\n                        && (in_lambda && !next || next instanceof AST_Return && !next.value)) {\n                        CHANGED = true;\n                        statements[i] = make_node(AST_SimpleStatement, stat.condition, {\n                            body: stat.condition\n                        });\n                        continue;\n                    }\n                    //---\n                    // if (foo()) return x; return y; ---> return foo() ? x : y;\n                    if (!stat.alternative && next instanceof AST_Return) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = next;\n                        statements.splice(i, 1, stat.transform(compressor));\n                        statements.splice(j, 1);\n                        continue;\n                    }\n                    //---\n                    // if (foo()) return x; [ return ; ] ---> return foo() ? x : undefined;\n                    if (!stat.alternative && !next && in_lambda && (in_bool || value && multiple_if_returns)) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = make_node(AST_Return, stat, {\n                            value: null\n                        });\n                        statements.splice(i, 1, stat.transform(compressor));\n                        continue;\n                    }\n                    //---\n                    // if (a) return b; if (c) return d; e; ---> return a ? b : c ? d : void e;\n                    //\n                    // if sequences is not enabled, this can lead to an endless loop (issue #866).\n                    // however, with sequences on this helps producing slightly better output for\n                    // the example code.\n                    var prev = statements[prev_index(i)];\n                    if (compressor.option(\"sequences\") && in_lambda && !stat.alternative\n                        && (!prev && in_iife || prev instanceof AST_If && prev.body instanceof AST_Return)\n                        && next_index(j) == statements.length && next instanceof AST_SimpleStatement) {\n                        CHANGED = true;\n                        stat = stat.clone();\n                        stat.alternative = make_node(AST_BlockStatement, next, {\n                            body: [\n                                next,\n                                make_node(AST_Return, next, {\n                                    value: null\n                                })\n                            ]\n                        });\n                        statements.splice(i, 1, stat.transform(compressor));\n                        statements.splice(j, 1);\n                        continue;\n                    }\n                }\n            }\n\n            function has_multiple_if_returns(statements) {\n                var n = 0;\n                for (var i = statements.length; --i >= 0;) {\n                    var stat = statements[i];\n                    if (stat instanceof AST_If && stat.body instanceof AST_Return) {\n                        if (++n > 1) return true;\n                    }\n                }\n                return false;\n            }\n\n            function is_return_void(value) {\n                return !value || value instanceof AST_UnaryPrefix && value.operator == \"void\";\n            }\n\n            function last_of(predicate) {\n                var block = self, stat, level = 0;\n                do {\n                    do {\n                        if (predicate(block)) return true;\n                        block = compressor.parent(level++);\n                    } while (block instanceof AST_If && (stat = block));\n                } while ((block instanceof AST_BlockStatement || block instanceof AST_Scope)\n                    && is_last_statement(block.body, stat));\n            }\n\n            function match_target(target) {\n                return last_of(function(node) {\n                    return node === target;\n                });\n            }\n\n            function can_drop_abort(ab) {\n                if (ab instanceof AST_Return) return in_lambda && is_return_void(ab.value);\n                if (!(ab instanceof AST_LoopControl)) return false;\n                var lct = compressor.loopcontrol_target(ab);\n                if (ab instanceof AST_Continue) return match_target(loop_body(lct));\n                if (lct instanceof AST_IterationStatement) return false;\n                return match_target(lct);\n            }\n\n            function can_merge_flow(ab) {\n                if (!can_drop_abort(ab)) return false;\n                for (var j = statements.length; --j > i;) {\n                    var stat = statements[j];\n                    if (stat instanceof AST_DefClass) {\n                        if (stat.name.definition().preinit) return false;\n                    } else if (stat instanceof AST_Const || stat instanceof AST_Let) {\n                        if (!all(stat.definitions, function(defn) {\n                            return !defn.name.match_symbol(function(node) {\n                                return node instanceof AST_SymbolDeclaration && node.definition().preinit;\n                            });\n                        })) return false;\n                    }\n                }\n                return true;\n            }\n\n            function extract_functions() {\n                var defuns = [];\n                var lexical = false;\n                var tail = statements.splice(i + 1).filter(function(stat) {\n                    if (stat instanceof AST_LambdaDefinition) {\n                        defuns.push(stat);\n                        return false;\n                    }\n                    if (is_lexical_definition(stat)) lexical = true;\n                    return true;\n                });\n                [].push.apply(lexical ? tail : statements, defuns);\n                return tail;\n            }\n\n            function as_statement_array_with_return(node, ab) {\n                var body = as_statement_array(node);\n                var block = body, last;\n                while ((last = block[block.length - 1]) !== ab) {\n                    block = last.body;\n                }\n                block.pop();\n                if (ab.value) block.push(make_node(AST_SimpleStatement, ab.value, {\n                    body: ab.value.expression\n                }));\n                return body;\n            }\n\n            function next_index(i) {\n                for (var j = i + 1; j < statements.length; j++) {\n                    if (!is_declaration(statements[j])) break;\n                }\n                return j;\n            }\n\n            function prev_index(i) {\n                for (var j = i; --j >= 0;) {\n                    if (!is_declaration(statements[j])) break;\n                }\n                return j;\n            }\n        }\n\n        function eliminate_dead_code(statements, compressor) {\n            var has_quit;\n            var self = compressor.self();\n            for (var i = 0, n = 0, len = statements.length; i < len; i++) {\n                var stat = statements[i];\n                if (stat instanceof AST_LoopControl) {\n                    var lct = compressor.loopcontrol_target(stat);\n                    if (loop_body(lct) !== self\n                        || stat instanceof AST_Break && lct instanceof AST_IterationStatement) {\n                        statements[n++] = stat;\n                    } else if (stat.label) {\n                        remove(stat.label.thedef.references, stat);\n                    }\n                } else {\n                    statements[n++] = stat;\n                }\n                if (aborts(stat)) {\n                    has_quit = statements.slice(i + 1);\n                    break;\n                }\n            }\n            statements.length = n;\n            if (has_quit) has_quit.forEach(function(stat) {\n                extract_declarations_from_unreachable_code(compressor, stat, statements);\n            });\n            CHANGED = statements.length != len;\n        }\n\n        function sequencesize(statements, compressor) {\n            if (statements.length < 2) return;\n            var seq = [], n = 0;\n            function push_seq() {\n                if (!seq.length) return;\n                var body = make_sequence(seq[0], seq);\n                statements[n++] = make_node(AST_SimpleStatement, body, { body: body });\n                seq = [];\n            }\n            for (var i = 0, len = statements.length; i < len; i++) {\n                var stat = statements[i];\n                if (stat instanceof AST_SimpleStatement) {\n                    if (seq.length >= compressor.sequences_limit) push_seq();\n                    var body = stat.body;\n                    if (seq.length > 0) body = body.drop_side_effect_free(compressor);\n                    if (body) merge_sequence(seq, body);\n                } else if (is_declaration(stat)) {\n                    statements[n++] = stat;\n                } else {\n                    push_seq();\n                    statements[n++] = stat;\n                }\n            }\n            push_seq();\n            statements.length = n;\n            if (n != len) CHANGED = true;\n        }\n\n        function to_simple_statement(block, decls) {\n            if (!(block instanceof AST_BlockStatement)) return block;\n            var stat = null;\n            for (var i = 0; i < block.body.length; i++) {\n                var line = block.body[i];\n                if (line instanceof AST_Var && declarations_only(line)) {\n                    decls.push(line);\n                } else if (stat || is_lexical_definition(line)) {\n                    return false;\n                } else {\n                    stat = line;\n                }\n            }\n            return stat;\n        }\n\n        function sequencesize_2(statements, compressor) {\n            function cons_seq(right) {\n                n--;\n                CHANGED = true;\n                var left = prev.body;\n                return make_sequence(left, [ left, right ]);\n            }\n            var n = 0, prev;\n            for (var i = 0; i < statements.length; i++) {\n                var stat = statements[i];\n                if (prev) {\n                    if (stat instanceof AST_Exit) {\n                        if (stat.value || !in_async_generator(scope)) {\n                            stat.value = cons_seq(stat.value || make_node(AST_Undefined, stat)).optimize(compressor);\n                        }\n                    } else if (stat instanceof AST_For) {\n                        if (!(stat.init instanceof AST_Definitions)) {\n                            var abort = false;\n                            prev.body.walk(new TreeWalker(function(node) {\n                                if (abort || node instanceof AST_Scope) return true;\n                                if (node instanceof AST_Binary && node.operator == \"in\") {\n                                    abort = true;\n                                    return true;\n                                }\n                            }));\n                            if (!abort) {\n                                if (stat.init) stat.init = cons_seq(stat.init);\n                                else {\n                                    stat.init = prev.body;\n                                    n--;\n                                    CHANGED = true;\n                                }\n                            }\n                        }\n                    } else if (stat instanceof AST_ForIn) {\n                        if (!is_lexical_definition(stat.init)) stat.object = cons_seq(stat.object);\n                    } else if (stat instanceof AST_If) {\n                        stat.condition = cons_seq(stat.condition);\n                    } else if (stat instanceof AST_Switch) {\n                        stat.expression = cons_seq(stat.expression);\n                    } else if (stat instanceof AST_With) {\n                        stat.expression = cons_seq(stat.expression);\n                    }\n                }\n                if (compressor.option(\"conditionals\") && stat instanceof AST_If) {\n                    var decls = [];\n                    var body = to_simple_statement(stat.body, decls);\n                    var alt = to_simple_statement(stat.alternative, decls);\n                    if (body !== false && alt !== false && decls.length > 0) {\n                        var len = decls.length;\n                        decls.push(make_node(AST_If, stat, {\n                            condition: stat.condition,\n                            body: body || make_node(AST_EmptyStatement, stat.body),\n                            alternative: alt\n                        }));\n                        decls.unshift(n, 1);\n                        [].splice.apply(statements, decls);\n                        i += len;\n                        n += len + 1;\n                        prev = null;\n                        CHANGED = true;\n                        continue;\n                    }\n                }\n                statements[n++] = stat;\n                prev = stat instanceof AST_SimpleStatement ? stat : null;\n            }\n            statements.length = n;\n        }\n\n        function extract_exprs(body) {\n            if (body instanceof AST_Assign) return [ body ];\n            if (body instanceof AST_Sequence) return body.expressions.slice();\n        }\n\n        function join_assigns(defn, body, keep) {\n            var exprs = extract_exprs(body);\n            if (!exprs) return;\n            var trimmed = false;\n            for (var i = exprs.length - (keep || 0); --i >= 0;) {\n                var expr = exprs[i];\n                if (!can_trim(expr)) continue;\n                var tail;\n                if (expr.left instanceof AST_SymbolRef) {\n                    tail = exprs.slice(i + 1);\n                } else if (expr.left instanceof AST_PropAccess && can_trim(expr.left.expression)) {\n                    tail = exprs.slice(i + 1);\n                    var flattened = expr.clone();\n                    expr = expr.left.expression;\n                    flattened.left = flattened.left.clone();\n                    flattened.left.expression = expr.left.clone();\n                    tail.unshift(flattened);\n                } else {\n                    continue;\n                }\n                if (tail.length == 0) continue;\n                if (!trim_assigns(expr.left, expr.right, tail)) continue;\n                trimmed = true;\n                exprs = exprs.slice(0, i).concat(expr, tail);\n            }\n            if (defn instanceof AST_Definitions) {\n                keep = keep || 0;\n                for (var i = defn.definitions.length; --i >= 0;) {\n                    var def = defn.definitions[i];\n                    if (!def.value) continue;\n                    if (trim_assigns(def.name, def.value, exprs)) trimmed = true;\n                    if (merge_conditional_assignments(def, exprs, keep)) trimmed = true;\n                    break;\n                }\n                if (defn instanceof AST_Var && join_var_assign(defn.definitions, exprs, keep)) trimmed = true;\n            }\n            return trimmed && exprs;\n\n            function can_trim(node) {\n                return node instanceof AST_Assign && node.operator == \"=\";\n            }\n        }\n\n        function merge_assigns(prev, defn) {\n            if (!(prev instanceof AST_SimpleStatement)) return;\n            if (declarations_only(defn)) return;\n            var exprs = extract_exprs(prev.body);\n            if (!exprs) return;\n            var definitions = [];\n            if (!join_var_assign(definitions, exprs.reverse(), 0)) return;\n            defn.definitions = definitions.reverse().concat(defn.definitions);\n            return exprs.reverse();\n        }\n\n        function merge_conditional_assignments(var_def, exprs, keep) {\n            if (!compressor.option(\"conditionals\")) return;\n            if (var_def.name instanceof AST_Destructured) return;\n            var trimmed = false;\n            var def = var_def.name.definition();\n            while (exprs.length > keep) {\n                var cond = to_conditional_assignment(compressor, def, var_def.value, exprs[0]);\n                if (!cond) break;\n                var_def.value = cond;\n                exprs.shift();\n                trimmed = true;\n            }\n            return trimmed;\n        }\n\n        function join_var_assign(definitions, exprs, keep) {\n            var trimmed = false;\n            while (exprs.length > keep) {\n                var expr = exprs[0];\n                if (!(expr instanceof AST_Assign)) break;\n                if (expr.operator != \"=\") break;\n                var lhs = expr.left;\n                if (!(lhs instanceof AST_SymbolRef)) break;\n                if (is_undeclared_ref(lhs)) break;\n                if (lhs.scope.resolve() !== scope) break;\n                var def = lhs.definition();\n                if (def.scope !== scope) break;\n                if (def.orig.length > def.eliminated + 1) break;\n                if (def.orig[0].TYPE != \"SymbolVar\") break;\n                var name = make_node(AST_SymbolVar, lhs, lhs);\n                definitions.push(make_node(AST_VarDef, expr, {\n                    name: name,\n                    value: expr.right\n                }));\n                def.orig.push(name);\n                def.replaced++;\n                exprs.shift();\n                trimmed = true;\n            }\n            return trimmed;\n        }\n\n        function trim_assigns(name, value, exprs) {\n            var names = new Dictionary();\n            names.set(name.name, true);\n            while (value instanceof AST_Assign && value.operator == \"=\") {\n                if (value.left instanceof AST_SymbolRef) names.set(value.left.name, true);\n                value = value.right;\n            }\n            if (!(value instanceof AST_Object)) return;\n            var trimmed = false;\n            do {\n                if (!try_join(exprs[0])) break;\n                exprs.shift();\n                trimmed = true;\n            } while (exprs.length);\n            return trimmed;\n\n            function try_join(node) {\n                if (!(node instanceof AST_Assign)) return;\n                if (node.operator != \"=\") return;\n                if (!(node.left instanceof AST_PropAccess)) return;\n                var sym = node.left.expression;\n                if (!(sym instanceof AST_SymbolRef)) return;\n                if (!names.has(sym.name)) return;\n                if (!node.right.is_constant_expression(scope)) return;\n                var prop = node.left.property;\n                if (prop instanceof AST_Node) {\n                    if (try_join(prop)) prop = node.left.property = prop.right.clone();\n                    prop = prop.evaluate(compressor);\n                }\n                if (prop instanceof AST_Node) return;\n                prop = \"\" + prop;\n                var diff = prop == \"__proto__\" || compressor.has_directive(\"use strict\") ? function(node) {\n                    var key = node.key;\n                    return typeof key == \"string\" && key != prop && key != \"__proto__\";\n                } : function(node) {\n                    var key = node.key;\n                    if (node instanceof AST_ObjectGetter || node instanceof AST_ObjectSetter) {\n                        return typeof key == \"string\" && key != prop;\n                    }\n                    return key !== \"__proto__\";\n                };\n                if (!all(value.properties, diff)) return;\n                value.properties.push(make_node(AST_ObjectKeyVal, node, {\n                    key: prop,\n                    value: node.right,\n                }));\n                return true;\n            }\n        }\n\n        function join_consecutive_vars(statements) {\n            var defs;\n            for (var i = 0, j = -1; i < statements.length; i++) {\n                var stat = statements[i];\n                var prev = statements[j];\n                if (stat instanceof AST_Definitions) {\n                    if (prev && prev.TYPE == stat.TYPE) {\n                        prev.definitions = prev.definitions.concat(stat.definitions);\n                        CHANGED = true;\n                    } else if (defs && defs.TYPE == stat.TYPE && declarations_only(stat)) {\n                        defs.definitions = defs.definitions.concat(stat.definitions);\n                        CHANGED = true;\n                    } else if (stat instanceof AST_Var) {\n                        var exprs = merge_assigns(prev, stat);\n                        if (exprs) {\n                            if (exprs.length) {\n                                prev.body = make_sequence(prev, exprs);\n                                j++;\n                            }\n                            CHANGED = true;\n                        } else {\n                            j++;\n                        }\n                        statements[j] = defs = stat;\n                    } else {\n                        statements[++j] = stat;\n                    }\n                    continue;\n                } else if (stat instanceof AST_Exit) {\n                    stat.value = join_assigns_expr(stat.value);\n                } else if (stat instanceof AST_For) {\n                    var exprs = join_assigns(prev, stat.init);\n                    if (exprs) {\n                        CHANGED = true;\n                        stat.init = exprs.length ? make_sequence(stat.init, exprs) : null;\n                    } else if (prev instanceof AST_Var && (!stat.init || stat.init.TYPE == prev.TYPE)) {\n                        if (stat.init) {\n                            prev.definitions = prev.definitions.concat(stat.init.definitions);\n                        }\n                        defs = stat.init = prev;\n                        statements[j] = merge_defns(stat);\n                        CHANGED = true;\n                        continue;\n                    } else if (defs && stat.init && defs.TYPE == stat.init.TYPE && declarations_only(stat.init)) {\n                        defs.definitions = defs.definitions.concat(stat.init.definitions);\n                        stat.init = null;\n                        CHANGED = true;\n                    } else if (stat.init instanceof AST_Var) {\n                        defs = stat.init;\n                        exprs = merge_assigns(prev, stat.init);\n                        if (exprs) {\n                            CHANGED = true;\n                            if (exprs.length == 0) {\n                                statements[j] = merge_defns(stat);\n                                continue;\n                            }\n                            prev.body = make_sequence(prev, exprs);\n                        }\n                    }\n                } else if (stat instanceof AST_ForEnumeration) {\n                    if (defs && defs.TYPE == stat.init.TYPE) {\n                        var defns = defs.definitions.slice();\n                        stat.init = stat.init.definitions[0].name.convert_symbol(AST_SymbolRef, function(ref, name) {\n                            defns.push(make_node(AST_VarDef, name, {\n                                name: name,\n                                value: null,\n                            }));\n                            name.definition().references.push(ref);\n                        });\n                        defs.definitions = defns;\n                        CHANGED = true;\n                    }\n                    stat.object = join_assigns_expr(stat.object);\n                } else if (stat instanceof AST_If) {\n                    stat.condition = join_assigns_expr(stat.condition);\n                } else if (stat instanceof AST_SimpleStatement) {\n                    var exprs = join_assigns(prev, stat.body);\n                    if (exprs) {\n                        CHANGED = true;\n                        if (!exprs.length) continue;\n                        stat.body = make_sequence(stat.body, exprs);\n                    }\n                } else if (stat instanceof AST_Switch) {\n                    stat.expression = join_assigns_expr(stat.expression);\n                } else if (stat instanceof AST_With) {\n                    stat.expression = join_assigns_expr(stat.expression);\n                }\n                statements[++j] = defs ? merge_defns(stat) : stat;\n            }\n            statements.length = j + 1;\n\n            function join_assigns_expr(value) {\n                var exprs = join_assigns(prev, value, 1);\n                if (!exprs) return value;\n                CHANGED = true;\n                var tail = value.tail_node();\n                if (exprs[exprs.length - 1] !== tail) exprs.push(tail.left);\n                return make_sequence(value, exprs);\n            }\n\n            function merge_defns(stat) {\n                return stat.transform(new TreeTransformer(function(node, descend, in_list) {\n                    if (node instanceof AST_Definitions) {\n                        if (defs === node) return node;\n                        if (defs.TYPE != node.TYPE) return node;\n                        var parent = this.parent();\n                        if (parent instanceof AST_ForEnumeration && parent.init === node) return node;\n                        if (!declarations_only(node)) return node;\n                        defs.definitions = defs.definitions.concat(node.definitions);\n                        CHANGED = true;\n                        if (parent instanceof AST_For && parent.init === node) return null;\n                        return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    }\n                    if (node instanceof AST_ExportDeclaration) return node;\n                    if (node instanceof AST_Scope) return node;\n                    if (!is_statement(node)) return node;\n                }));\n            }\n        }\n    }\n\n    function extract_declarations_from_unreachable_code(compressor, stat, target) {\n        var block;\n        var dropped = false;\n        stat.walk(new TreeWalker(function(node, descend) {\n            if (node instanceof AST_DefClass) {\n                node.extends = null;\n                node.properties = [];\n                push(node);\n                return true;\n            }\n            if (node instanceof AST_Definitions) {\n                var defns = [];\n                if (node.remove_initializers(compressor, defns)) {\n                    AST_Node.warn(\"Dropping initialization in unreachable code [{file}:{line},{col}]\", node.start);\n                }\n                if (defns.length > 0) {\n                    node.definitions = defns;\n                    push(node);\n                }\n                return true;\n            }\n            if (node instanceof AST_LambdaDefinition) {\n                push(node);\n                return true;\n            }\n            if (node instanceof AST_Scope) return true;\n            if (node instanceof AST_BlockScope) {\n                var save = block;\n                block = [];\n                descend();\n                if (block.required) {\n                    target.push(make_node(AST_BlockStatement, stat, { body: block }));\n                } else if (block.length) {\n                    [].push.apply(target, block);\n                }\n                block = save;\n                return true;\n            }\n            if (!(node instanceof AST_LoopControl)) dropped = true;\n        }));\n        if (dropped) AST_Node.warn(\"Dropping unreachable code [{file}:{line},{col}]\", stat.start);\n\n        function push(node) {\n            if (block) {\n                block.push(node);\n                if (!safe_to_trim(node)) block.required = true;\n            } else {\n                target.push(node);\n            }\n        }\n    }\n\n    function is_undefined(node, compressor) {\n        return node.is_undefined\n            || node instanceof AST_Undefined\n            || node instanceof AST_UnaryPrefix\n                && node.operator == \"void\"\n                && !(compressor && node.expression.has_side_effects(compressor));\n    }\n\n    // is_truthy()\n    // return true if `!!node === true`\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Array, return_true);\n        def(AST_Assign, function() {\n            return this.operator == \"=\" && this.right.is_truthy();\n        });\n        def(AST_Lambda, return_true);\n        def(AST_Object, return_true);\n        def(AST_RegExp, return_true);\n        def(AST_Sequence, function() {\n            return this.tail_node().is_truthy();\n        });\n        def(AST_SymbolRef, function() {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_truthy = return_false;\n            var result = fixed.is_truthy();\n            delete this.is_truthy;\n            return result;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_truthy\", func);\n    });\n\n    // is_negative_zero()\n    // return true if the node may represent -0\n    (function(def) {\n        def(AST_Node, return_true);\n        def(AST_Array, return_false);\n        function binary(op, left, right) {\n            switch (op) {\n              case \"-\":\n                return left.is_negative_zero()\n                    && (!(right instanceof AST_Constant) || right.value == 0);\n              case \"&&\":\n              case \"||\":\n                return left.is_negative_zero() || right.is_negative_zero();\n              case \"*\":\n              case \"/\":\n              case \"%\":\n              case \"**\":\n                return true;\n              default:\n                return false;\n            }\n        }\n        def(AST_Assign, function() {\n            var op = this.operator;\n            if (op == \"=\") return this.right.is_negative_zero();\n            return binary(op.slice(0, -1), this.left, this.right);\n        });\n        def(AST_Binary, function() {\n            return binary(this.operator, this.left, this.right);\n        });\n        def(AST_Constant, function() {\n            return this.value == 0 && 1 / this.value < 0;\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Object, return_false);\n        def(AST_RegExp, return_false);\n        def(AST_Sequence, function() {\n            return this.tail_node().is_negative_zero();\n        });\n        def(AST_SymbolRef, function() {\n            var fixed = this.fixed_value();\n            if (!fixed) return true;\n            this.is_negative_zero = return_true;\n            var result = fixed.is_negative_zero();\n            delete this.is_negative_zero;\n            return result;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"+\" && this.expression.is_negative_zero()\n                || this.operator == \"-\";\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_negative_zero\", func);\n    });\n\n    // may_throw_on_access()\n    // returns true if this node may be null, undefined or contain `AST_Accessor`\n    (function(def) {\n        AST_Node.DEFMETHOD(\"may_throw_on_access\", function(compressor, force) {\n            return !compressor.option(\"pure_getters\") || this._dot_throw(compressor, force);\n        });\n        function is_strict(compressor, force) {\n            return force || /strict/.test(compressor.option(\"pure_getters\"));\n        }\n        def(AST_Node, is_strict);\n        def(AST_Array, return_false);\n        def(AST_Assign, function(compressor) {\n            var op = this.operator;\n            var sym = this.left;\n            var rhs = this.right;\n            if (op != \"=\") {\n                return lazy_op[op.slice(0, -1)] && (sym._dot_throw(compressor) || rhs._dot_throw(compressor));\n            }\n            if (!rhs._dot_throw(compressor)) return false;\n            if (!(sym instanceof AST_SymbolRef)) return true;\n            if (rhs instanceof AST_Binary && rhs.operator == \"||\" && sym.name == rhs.left.name) {\n                return rhs.right._dot_throw(compressor);\n            }\n            return true;\n        });\n        def(AST_Binary, function(compressor) {\n            return lazy_op[this.operator] && (this.left._dot_throw(compressor) || this.right._dot_throw(compressor));\n        });\n        def(AST_Class, return_false);\n        def(AST_Conditional, function(compressor) {\n            return this.consequent._dot_throw(compressor) || this.alternative._dot_throw(compressor);\n        });\n        def(AST_Constant, return_false);\n        def(AST_Dot, function(compressor, force) {\n            if (!is_strict(compressor, force)) return false;\n            var exp = this.expression;\n            if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n            return !(this.property == \"prototype\" && is_lambda(exp));\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Null, return_true);\n        def(AST_Object, function(compressor, force) {\n            return is_strict(compressor, force) && !all(this.properties, function(prop) {\n                if (!(prop instanceof AST_ObjectKeyVal)) return false;\n                return !(prop.key === \"__proto__\" && prop.value._dot_throw(compressor, force));\n            });\n        });\n        def(AST_ObjectIdentity, function(compressor, force) {\n            return is_strict(compressor, force) && !this.scope.resolve().new;\n        });\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node()._dot_throw(compressor);\n        });\n        def(AST_SymbolRef, function(compressor, force) {\n            if (this.is_undefined) return true;\n            if (!is_strict(compressor, force)) return false;\n            if (is_undeclared_ref(this) && this.is_declared(compressor)) return false;\n            if (this.is_immutable()) return false;\n            var def = this.definition();\n            if (is_arguments(def) && !def.scope.rest && all(def.scope.argnames, function(argname) {\n                return argname instanceof AST_SymbolFunarg;\n            })) return def.scope.uses_arguments > 2;\n            var fixed = this.fixed_value();\n            if (!fixed) return true;\n            this._dot_throw = return_true;\n            if (fixed._dot_throw(compressor)) {\n                delete this._dot_throw;\n                return true;\n            }\n            this._dot_throw = return_false;\n            return false;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"void\";\n        });\n        def(AST_UnaryPostfix, return_false);\n        def(AST_Undefined, return_true);\n    })(function(node, func) {\n        node.DEFMETHOD(\"_dot_throw\", func);\n    });\n\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Array, return_true);\n        function is_binary_defined(compressor, op, node) {\n            switch (op) {\n              case \"&&\":\n                return node.left.is_defined(compressor) && node.right.is_defined(compressor);\n              case \"||\":\n                return node.left.is_truthy() || node.right.is_defined(compressor);\n              case \"??\":\n                return node.left.is_defined(compressor) || node.right.is_defined(compressor);\n              default:\n                return true;\n            }\n        }\n        def(AST_Assign, function(compressor) {\n            var op = this.operator;\n            if (op == \"=\") return this.right.is_defined(compressor);\n            return is_binary_defined(compressor, op.slice(0, -1), this);\n        });\n        def(AST_Binary, function(compressor) {\n            return is_binary_defined(compressor, this.operator, this);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_defined(compressor) && this.alternative.is_defined(compressor);\n        });\n        def(AST_Constant, return_true);\n        def(AST_Hole, return_false);\n        def(AST_Lambda, return_true);\n        def(AST_Object, return_true);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_defined(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            if (this.is_undefined) return false;\n            if (is_undeclared_ref(this) && this.is_declared(compressor)) return true;\n            if (this.is_immutable()) return true;\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_defined = return_false;\n            var result = fixed.is_defined(compressor);\n            delete this.is_defined;\n            return result;\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator != \"void\";\n        });\n        def(AST_UnaryPostfix, return_true);\n        def(AST_Undefined, return_false);\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_defined\", func);\n    });\n\n    /* -----[ boolean/negation helpers ]----- */\n\n    // methods to determine whether an expression has a boolean result type\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Assign, function(compressor) {\n            return this.operator == \"=\" && this.right.is_boolean(compressor);\n        });\n        var binary = makePredicate(\"in instanceof == != === !== < <= >= >\");\n        def(AST_Binary, function(compressor) {\n            return binary[this.operator] || lazy_op[this.operator]\n                && this.left.is_boolean(compressor)\n                && this.right.is_boolean(compressor);\n        });\n        def(AST_Boolean, return_true);\n        var fn = makePredicate(\"every hasOwnProperty isPrototypeOf propertyIsEnumerable some\");\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && (fn[exp.property]\n                || exp.property == \"test\" && exp.expression instanceof AST_RegExp);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_boolean(compressor) && this.alternative.is_boolean(compressor);\n        });\n        def(AST_New, return_false);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_boolean(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_boolean = return_false;\n            var result = fixed.is_boolean(compressor);\n            delete this.is_boolean;\n            return result;\n        });\n        var unary = makePredicate(\"! delete\");\n        def(AST_UnaryPrefix, function() {\n            return unary[this.operator];\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_boolean\", func);\n    });\n\n    // methods to determine if an expression has a numeric result type\n    (function(def) {\n        def(AST_Node, return_false);\n        var binary = makePredicate(\"- * / % ** & | ^ << >> >>>\");\n        def(AST_Assign, function(compressor) {\n            return binary[this.operator.slice(0, -1)]\n                || this.operator == \"=\" && this.right.is_number(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            if (binary[this.operator]) return true;\n            if (this.operator != \"+\") return false;\n            return (this.left.is_boolean(compressor) || this.left.is_number(compressor))\n                && (this.right.is_boolean(compressor) || this.right.is_number(compressor));\n        });\n        var fn = makePredicate([\n            \"charCodeAt\",\n            \"getDate\",\n            \"getDay\",\n            \"getFullYear\",\n            \"getHours\",\n            \"getMilliseconds\",\n            \"getMinutes\",\n            \"getMonth\",\n            \"getSeconds\",\n            \"getTime\",\n            \"getTimezoneOffset\",\n            \"getUTCDate\",\n            \"getUTCDay\",\n            \"getUTCFullYear\",\n            \"getUTCHours\",\n            \"getUTCMilliseconds\",\n            \"getUTCMinutes\",\n            \"getUTCMonth\",\n            \"getUTCSeconds\",\n            \"getYear\",\n            \"indexOf\",\n            \"lastIndexOf\",\n            \"localeCompare\",\n            \"push\",\n            \"search\",\n            \"setDate\",\n            \"setFullYear\",\n            \"setHours\",\n            \"setMilliseconds\",\n            \"setMinutes\",\n            \"setMonth\",\n            \"setSeconds\",\n            \"setTime\",\n            \"setUTCDate\",\n            \"setUTCFullYear\",\n            \"setUTCHours\",\n            \"setUTCMilliseconds\",\n            \"setUTCMinutes\",\n            \"setUTCMonth\",\n            \"setUTCSeconds\",\n            \"setYear\",\n            \"toExponential\",\n            \"toFixed\",\n            \"toPrecision\",\n        ]);\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && (fn[exp.property]\n                || is_undeclared_ref(exp.expression) && exp.expression.name == \"Math\");\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_number(compressor) && this.alternative.is_number(compressor);\n        });\n        def(AST_New, return_false);\n        def(AST_Number, return_true);\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_number(compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_number = return_false;\n            var result = fixed.is_number(compressor);\n            delete this.is_number;\n            return result;\n        });\n        var unary = makePredicate(\"+ - ~ ++ --\");\n        def(AST_Unary, function() {\n            return unary[this.operator];\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_number\", func);\n    });\n\n    // methods to determine if an expression has a string result type\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Assign, function(compressor) {\n            switch (this.operator) {\n              case \"+=\":\n                if (this.left.is_string(compressor)) return true;\n              case \"=\":\n                return this.right.is_string(compressor);\n            }\n        });\n        def(AST_Binary, function(compressor) {\n            return this.operator == \"+\" &&\n                (this.left.is_string(compressor) || this.right.is_string(compressor));\n        });\n        var fn = makePredicate([\n            \"charAt\",\n            \"substr\",\n            \"substring\",\n            \"toLowerCase\",\n            \"toString\",\n            \"toUpperCase\",\n            \"trim\",\n        ]);\n        def(AST_Call, function(compressor) {\n            if (!compressor.option(\"unsafe\")) return false;\n            var exp = this.expression;\n            return exp instanceof AST_Dot && fn[exp.property];\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.consequent.is_string(compressor) && this.alternative.is_string(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return this.tail_node().is_string(compressor);\n        });\n        def(AST_String, return_true);\n        def(AST_SymbolRef, function(compressor) {\n            var fixed = this.fixed_value();\n            if (!fixed) return false;\n            this.is_string = return_false;\n            var result = fixed.is_string(compressor);\n            delete this.is_string;\n            return result;\n        });\n        def(AST_Template, function(compressor) {\n            return !this.tag || is_raw_tag(compressor, this.tag);\n        });\n        def(AST_UnaryPrefix, function() {\n            return this.operator == \"typeof\";\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_string\", func);\n    });\n\n    var lazy_op = makePredicate(\"&& || ??\");\n\n    (function(def) {\n        function to_node(value, orig) {\n            if (value instanceof AST_Node) return value.clone(true);\n            if (Array.isArray(value)) return make_node(AST_Array, orig, {\n                elements: value.map(function(value) {\n                    return to_node(value, orig);\n                })\n            });\n            if (value && typeof value == \"object\") {\n                var props = [];\n                for (var key in value) if (HOP(value, key)) {\n                    props.push(make_node(AST_ObjectKeyVal, orig, {\n                        key: key,\n                        value: to_node(value[key], orig)\n                    }));\n                }\n                return make_node(AST_Object, orig, {\n                    properties: props\n                });\n            }\n            return make_node_from_constant(value, orig);\n        }\n\n        function warn(node) {\n            AST_Node.warn(\"global_defs {node} redefined [{file}:{line},{col}]\", {\n                node: node,\n                file: node.start.file,\n                line: node.start.line,\n                col: node.start.col,\n            });\n        }\n\n        AST_Toplevel.DEFMETHOD(\"resolve_defines\", function(compressor) {\n            if (!compressor.option(\"global_defs\")) return this;\n            this.figure_out_scope({ ie: compressor.option(\"ie\") });\n            return this.transform(new TreeTransformer(function(node) {\n                var def = node._find_defs(compressor, \"\");\n                if (!def) return;\n                var level = 0, child = node, parent;\n                while (parent = this.parent(level++)) {\n                    if (!(parent instanceof AST_PropAccess)) break;\n                    if (parent.expression !== child) break;\n                    child = parent;\n                }\n                if (is_lhs(child, parent)) {\n                    warn(node);\n                    return;\n                }\n                return def;\n            }));\n        });\n        def(AST_Node, noop);\n        def(AST_Dot, function(compressor, suffix) {\n            return this.expression._find_defs(compressor, \".\" + this.property + suffix);\n        });\n        def(AST_SymbolDeclaration, function(compressor) {\n            if (!this.definition().global) return;\n            if (HOP(compressor.option(\"global_defs\"), this.name)) warn(this);\n        });\n        def(AST_SymbolRef, function(compressor, suffix) {\n            if (!this.definition().global) return;\n            var defines = compressor.option(\"global_defs\");\n            var name = this.name + suffix;\n            if (HOP(defines, name)) return to_node(defines[name], this);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"_find_defs\", func);\n    });\n\n    function best_of_expression(ast1, ast2, threshold) {\n        var delta = ast2.print_to_string().length - ast1.print_to_string().length;\n        return delta < (threshold || 0) ? ast2 : ast1;\n    }\n\n    function best_of_statement(ast1, ast2, threshold) {\n        return best_of_expression(make_node(AST_SimpleStatement, ast1, {\n            body: ast1\n        }), make_node(AST_SimpleStatement, ast2, {\n            body: ast2\n        }), threshold).body;\n    }\n\n    function best_of(compressor, ast1, ast2, threshold) {\n        return (first_in_statement(compressor) ? best_of_statement : best_of_expression)(ast1, ast2, threshold);\n    }\n\n    function convert_to_predicate(obj) {\n        var map = Object.create(null);\n        Object.keys(obj).forEach(function(key) {\n            map[key] = makePredicate(obj[key]);\n        });\n        return map;\n    }\n\n    function skip_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_Directive)) return stat;\n        }\n    }\n\n    function arrow_first_statement() {\n        if (this.value) return make_node(AST_Return, this.value, {\n            value: this.value\n        });\n        return skip_directives(this.body);\n    }\n    AST_Arrow.DEFMETHOD(\"first_statement\", arrow_first_statement);\n    AST_AsyncArrow.DEFMETHOD(\"first_statement\", arrow_first_statement);\n    AST_Lambda.DEFMETHOD(\"first_statement\", function() {\n        return skip_directives(this.body);\n    });\n\n    AST_Lambda.DEFMETHOD(\"length\", function() {\n        var argnames = this.argnames;\n        for (var i = 0; i < argnames.length; i++) {\n            if (argnames[i] instanceof AST_DefaultValue) break;\n        }\n        return i;\n    });\n\n    function try_evaluate(compressor, node) {\n        var ev = node.evaluate(compressor);\n        if (ev === node) return node;\n        ev = make_node_from_constant(ev, node).optimize(compressor);\n        return best_of(compressor, node, ev, compressor.eval_threshold);\n    }\n\n    var object_fns = [\n        \"constructor\",\n        \"toString\",\n        \"valueOf\",\n    ];\n    var native_fns = convert_to_predicate({\n        Array: [\n            \"indexOf\",\n            \"join\",\n            \"lastIndexOf\",\n            \"slice\",\n        ].concat(object_fns),\n        Boolean: object_fns,\n        Function: object_fns,\n        Number: [\n            \"toExponential\",\n            \"toFixed\",\n            \"toPrecision\",\n        ].concat(object_fns),\n        Object: object_fns,\n        RegExp: [\n            \"exec\",\n            \"test\",\n        ].concat(object_fns),\n        String: [\n            \"charAt\",\n            \"charCodeAt\",\n            \"concat\",\n            \"indexOf\",\n            \"italics\",\n            \"lastIndexOf\",\n            \"match\",\n            \"replace\",\n            \"search\",\n            \"slice\",\n            \"split\",\n            \"substr\",\n            \"substring\",\n            \"toLowerCase\",\n            \"toUpperCase\",\n            \"trim\",\n        ].concat(object_fns),\n    });\n    var static_fns = convert_to_predicate({\n        Array: [\n            \"isArray\",\n        ],\n        Math: [\n            \"abs\",\n            \"acos\",\n            \"asin\",\n            \"atan\",\n            \"ceil\",\n            \"cos\",\n            \"exp\",\n            \"floor\",\n            \"log\",\n            \"round\",\n            \"sin\",\n            \"sqrt\",\n            \"tan\",\n            \"atan2\",\n            \"pow\",\n            \"max\",\n            \"min\",\n        ],\n        Number: [\n            \"isFinite\",\n            \"isNaN\",\n        ],\n        Object: [\n            \"create\",\n            \"getOwnPropertyDescriptor\",\n            \"getOwnPropertyNames\",\n            \"getPrototypeOf\",\n            \"isExtensible\",\n            \"isFrozen\",\n            \"isSealed\",\n            \"keys\",\n        ],\n        String: [\n            \"fromCharCode\",\n            \"raw\",\n        ],\n    });\n\n    function is_static_fn(node) {\n        if (!(node instanceof AST_Dot)) return false;\n        var expr = node.expression;\n        if (!is_undeclared_ref(expr)) return false;\n        var static_fn = static_fns[expr.name];\n        return static_fn && (static_fn[node.property] || expr.name == \"Math\" && node.property == \"random\");\n    }\n\n    // Accomodate when compress option evaluate=false\n    // as well as the common constant expressions !0 and -1\n    (function(def) {\n        def(AST_Node, return_false);\n        def(AST_Constant, return_true);\n        def(AST_RegExp, return_false);\n        var unaryPrefix = makePredicate(\"! ~ - + void\");\n        def(AST_UnaryPrefix, function() {\n            return unaryPrefix[this.operator] && this.expression instanceof AST_Constant;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_constant\", func);\n    });\n\n    // methods to evaluate a constant expression\n    (function(def) {\n        // If the node has been successfully reduced to a constant,\n        // then its value is returned; otherwise the element itself\n        // is returned.\n        //\n        // They can be distinguished as constant value is never a\n        // descendant of AST_Node.\n        //\n        // When `ignore_side_effects` is `true`, inspect the constant value\n        // produced without worrying about any side effects caused by said\n        // expression.\n        AST_Node.DEFMETHOD(\"evaluate\", function(compressor, ignore_side_effects) {\n            if (!compressor.option(\"evaluate\")) return this;\n            var cached = [];\n            var val = this._eval(compressor, ignore_side_effects, cached, 1);\n            cached.forEach(function(node) {\n                delete node._eval;\n            });\n            if (ignore_side_effects) return val;\n            if (!val || val instanceof RegExp) return val;\n            if (typeof val == \"function\" || typeof val == \"object\") return this;\n            return val;\n        });\n        var scan_modified = new TreeWalker(function(node) {\n            if (node instanceof AST_Assign) modified(node.left);\n            if (node instanceof AST_Unary && UNARY_POSTFIX[node.operator]) modified(node.expression);\n        });\n        function modified(node) {\n            if (node instanceof AST_DestructuredArray) {\n                node.elements.forEach(modified);\n            } else if (node instanceof AST_DestructuredObject) {\n                node.properties.forEach(function(prop) {\n                    modified(prop.value);\n                });\n            } else if (node instanceof AST_PropAccess) {\n                modified(node.expression);\n            } else if (node instanceof AST_SymbolRef) {\n                node.definition().references.forEach(function(ref) {\n                    delete ref._eval;\n                });\n            }\n        }\n        def(AST_Statement, function() {\n            throw new Error(string_template(\"Cannot evaluate a statement [{file}:{line},{col}]\", this.start));\n        });\n        def(AST_Accessor, return_this);\n        def(AST_BigInt, return_this);\n        def(AST_Class, return_this);\n        def(AST_Node, return_this);\n        def(AST_Constant, function() {\n            return this.value;\n        });\n        def(AST_Assign, function(compressor, ignore_side_effects, cached, depth) {\n            var lhs = this.left;\n            if (!ignore_side_effects) {\n                if (!(lhs instanceof AST_SymbolRef)) return this;\n                if (!HOP(lhs, \"_eval\")) {\n                    if (!lhs.fixed) return this;\n                    var def = lhs.definition();\n                    if (!def.fixed) return this;\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== lhs) return this;\n                    if (def.single_use == \"m\") return this;\n                }\n            }\n            var op = this.operator;\n            var node;\n            if (!HOP(lhs, \"_eval\") && lhs instanceof AST_SymbolRef && lhs.fixed && lhs.definition().fixed) {\n                node = lhs;\n            } else if (op == \"=\") {\n                node = this.right;\n            } else {\n                node = make_node(AST_Binary, this, {\n                    operator: op.slice(0, -1),\n                    left: lhs,\n                    right: this.right,\n                });\n            }\n            lhs.walk(scan_modified);\n            var value = node._eval(compressor, ignore_side_effects, cached, depth);\n            if (typeof value == \"object\") return this;\n            modified(lhs);\n            return value;\n        });\n        def(AST_Sequence, function(compressor, ignore_side_effects, cached, depth) {\n            if (!ignore_side_effects) return this;\n            var exprs = this.expressions;\n            for (var i = 0, last = exprs.length - 1; i < last; i++) {\n                exprs[i].walk(scan_modified);\n            }\n            var tail = exprs[last];\n            var value = tail._eval(compressor, ignore_side_effects, cached, depth);\n            return value === tail ? this : value;\n        });\n        def(AST_Lambda, function(compressor) {\n            if (compressor.option(\"unsafe\")) {\n                var fn = function() {};\n                fn.node = this;\n                fn.toString = function() {\n                    return \"function(){}\";\n                };\n                return fn;\n            }\n            return this;\n        });\n        def(AST_Array, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var elements = [];\n                for (var i = 0; i < this.elements.length; i++) {\n                    var element = this.elements[i];\n                    if (element instanceof AST_Hole) return this;\n                    var value = element._eval(compressor, ignore_side_effects, cached, depth);\n                    if (element === value) return this;\n                    elements.push(value);\n                }\n                return elements;\n            }\n            return this;\n        });\n        def(AST_Object, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var val = {};\n                for (var i = 0; i < this.properties.length; i++) {\n                    var prop = this.properties[i];\n                    if (!(prop instanceof AST_ObjectKeyVal)) return this;\n                    var key = prop.key;\n                    if (key instanceof AST_Node) {\n                        key = key._eval(compressor, ignore_side_effects, cached, depth);\n                        if (key === prop.key) return this;\n                    }\n                    switch (key) {\n                      case \"__proto__\":\n                      case \"toString\":\n                      case \"valueOf\":\n                        return this;\n                    }\n                    val[key] = prop.value._eval(compressor, ignore_side_effects, cached, depth);\n                    if (val[key] === prop.value) return this;\n                }\n                return val;\n            }\n            return this;\n        });\n        var non_converting_unary = makePredicate(\"! typeof void\");\n        def(AST_UnaryPrefix, function(compressor, ignore_side_effects, cached, depth) {\n            var e = this.expression;\n            var op = this.operator;\n            // Function would be evaluated to an array and so typeof would\n            // incorrectly return \"object\". Hence making is a special case.\n            if (compressor.option(\"typeofs\")\n                && op == \"typeof\"\n                && (e instanceof AST_Lambda\n                    || e instanceof AST_SymbolRef\n                        && e.fixed_value() instanceof AST_Lambda)) {\n                return typeof function(){};\n            }\n            var def = e instanceof AST_SymbolRef && e.definition();\n            if (!non_converting_unary[op] && !(def && def.fixed)) depth++;\n            e.walk(scan_modified);\n            var v = e._eval(compressor, ignore_side_effects, cached, depth);\n            if (v === e) {\n                if (ignore_side_effects && op == \"void\") return;\n                return this;\n            }\n            switch (op) {\n              case \"!\": return !v;\n              case \"typeof\":\n                // typeof <RegExp> returns \"object\" or \"function\" on different platforms\n                // so cannot evaluate reliably\n                if (v instanceof RegExp) return this;\n                return typeof v;\n              case \"void\": return;\n              case \"~\": return ~v;\n              case \"-\": return -v;\n              case \"+\": return +v;\n              case \"++\":\n              case \"--\":\n                if (!def) return this;\n                if (!ignore_side_effects) {\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== e) return this;\n                }\n                if (HOP(e, \"_eval\")) v = +(op[0] + 1) + +v;\n                modified(e);\n                return v;\n            }\n            return this;\n        });\n        def(AST_UnaryPostfix, function(compressor, ignore_side_effects, cached, depth) {\n            var e = this.expression;\n            if (!(e instanceof AST_SymbolRef)) {\n                if (!ignore_side_effects) return this;\n            } else if (!HOP(e, \"_eval\")) {\n                if (!e.fixed) return this;\n                if (!ignore_side_effects) {\n                    var def = e.definition();\n                    if (!def.fixed) return this;\n                    if (def.undeclared) return this;\n                    if (def.last_ref !== e) return this;\n                }\n            }\n            if (!(e instanceof AST_SymbolRef && e.definition().fixed)) depth++;\n            e.walk(scan_modified);\n            var v = e._eval(compressor, ignore_side_effects, cached, depth);\n            if (v === e) return this;\n            modified(e);\n            return +v;\n        });\n        var non_converting_binary = makePredicate(\"&& || === !==\");\n        def(AST_Binary, function(compressor, ignore_side_effects, cached, depth) {\n            if (!non_converting_binary[this.operator]) depth++;\n            var left = this.left._eval(compressor, ignore_side_effects, cached, depth);\n            if (left === this.left) return this;\n            if (this.operator == (left ? \"||\" : \"&&\")) return left;\n            var rhs_ignore_side_effects = ignore_side_effects && !(left && typeof left == \"object\");\n            var right = this.right._eval(compressor, rhs_ignore_side_effects, cached, depth);\n            if (right === this.right) return this;\n            var result;\n            switch (this.operator) {\n              case \"&&\" : result = left &&  right; break;\n              case \"||\" : result = left ||  right; break;\n              case \"??\" :\n                result = left == null ? right : left;\n                break;\n              case \"|\"  : result = left |   right; break;\n              case \"&\"  : result = left &   right; break;\n              case \"^\"  : result = left ^   right; break;\n              case \"+\"  : result = left +   right; break;\n              case \"-\"  : result = left -   right; break;\n              case \"*\"  : result = left *   right; break;\n              case \"/\"  : result = left /   right; break;\n              case \"%\"  : result = left %   right; break;\n              case \"<<\" : result = left <<  right; break;\n              case \">>\" : result = left >>  right; break;\n              case \">>>\": result = left >>> right; break;\n              case \"==\" : result = left ==  right; break;\n              case \"===\": result = left === right; break;\n              case \"!=\" : result = left !=  right; break;\n              case \"!==\": result = left !== right; break;\n              case \"<\"  : result = left <   right; break;\n              case \"<=\" : result = left <=  right; break;\n              case \">\"  : result = left >   right; break;\n              case \">=\" : result = left >=  right; break;\n              case \"**\":\n                result = Math.pow(left, right);\n                break;\n              case \"in\":\n                if (right && typeof right == \"object\" && HOP(right, left)) {\n                    result = true;\n                    break;\n                }\n              default:\n                return this;\n            }\n            if (isNaN(result)) return compressor.find_parent(AST_With) ? this : result;\n            if (compressor.option(\"unsafe_math\")\n                && !ignore_side_effects\n                && result\n                && typeof result == \"number\"\n                && (this.operator == \"+\" || this.operator == \"-\")) {\n                var digits = Math.max(0, decimals(left), decimals(right));\n                // 53-bit significand ---> 15.95 decimal places\n                if (digits < 16) return +result.toFixed(digits);\n            }\n            return result;\n\n            function decimals(operand) {\n                var match = /(\\.[0-9]*)?(e.+)?$/.exec(+operand);\n                return (match[1] || \".\").length - 1 - (match[2] || \"\").slice(1);\n            }\n        });\n        def(AST_Conditional, function(compressor, ignore_side_effects, cached, depth) {\n            var condition = this.condition._eval(compressor, ignore_side_effects, cached, depth);\n            if (condition === this.condition) return this;\n            var node = condition ? this.consequent : this.alternative;\n            var value = node._eval(compressor, ignore_side_effects, cached, depth);\n            return value === node ? this : value;\n        });\n        function verify_escaped(ref, depth) {\n            var escaped = ref.definition().escaped;\n            switch (escaped.length) {\n              case 0:\n                return true;\n              case 1:\n                var found = false;\n                escaped[0].walk(new TreeWalker(function(node) {\n                    if (found) return true;\n                    if (node === ref) return found = true;\n                    if (node instanceof AST_Scope) return true;\n                }));\n                return found;\n              default:\n                return depth <= escaped.depth;\n            }\n        }\n        def(AST_SymbolRef, function(compressor, ignore_side_effects, cached, depth) {\n            var fixed = this.fixed_value();\n            if (!fixed) return this;\n            var value;\n            if (HOP(fixed, \"_eval\")) {\n                value = fixed._eval();\n            } else {\n                this._eval = return_this;\n                value = fixed._eval(compressor, ignore_side_effects, cached, depth);\n                delete this._eval;\n                if (value === fixed) return this;\n                fixed._eval = function() {\n                    return value;\n                };\n                cached.push(fixed);\n            }\n            return value && typeof value == \"object\" && !verify_escaped(this, depth) ? this : value;\n        });\n        var global_objs = {\n            Array: Array,\n            Math: Math,\n            Number: Number,\n            Object: Object,\n            String: String,\n        };\n        var static_values = convert_to_predicate({\n            Math: [\n                \"E\",\n                \"LN10\",\n                \"LN2\",\n                \"LOG2E\",\n                \"LOG10E\",\n                \"PI\",\n                \"SQRT1_2\",\n                \"SQRT2\",\n            ],\n            Number: [\n                \"MAX_VALUE\",\n                \"MIN_VALUE\",\n                \"NaN\",\n                \"NEGATIVE_INFINITY\",\n                \"POSITIVE_INFINITY\",\n            ],\n        });\n        var regexp_props = makePredicate(\"global ignoreCase multiline source\");\n        def(AST_PropAccess, function(compressor, ignore_side_effects, cached, depth) {\n            if (compressor.option(\"unsafe\")) {\n                var val;\n                var exp = this.expression;\n                if (!is_undeclared_ref(exp)) {\n                    val = exp._eval(compressor, ignore_side_effects, cached, depth + 1);\n                    if (val == null || val === exp) return this;\n                }\n                var key = this.property;\n                if (key instanceof AST_Node) {\n                    key = key._eval(compressor, ignore_side_effects, cached, depth);\n                    if (key === this.property) return this;\n                }\n                if (val === undefined) {\n                    var static_value = static_values[exp.name];\n                    if (!static_value || !static_value[key]) return this;\n                    val = global_objs[exp.name];\n                } else if (val instanceof RegExp) {\n                    if (!regexp_props[key]) return this;\n                } else if (typeof val == \"object\") {\n                    if (!HOP(val, key)) return this;\n                } else if (typeof val == \"function\") switch (key) {\n                  case \"name\":\n                    return val.node.name ? val.node.name.name : \"\";\n                  case \"length\":\n                    return val.node.length();\n                  default:\n                    return this;\n                }\n                return val[key];\n            }\n            return this;\n        });\n        function eval_all(nodes, compressor, ignore_side_effects, cached, depth) {\n            var values = [];\n            for (var i = 0; i < nodes.length; i++) {\n                var node = nodes[i];\n                var value = node._eval(compressor, ignore_side_effects, cached, depth);\n                if (node === value) return;\n                values.push(value);\n            }\n            return values;\n        }\n        def(AST_Call, function(compressor, ignore_side_effects, cached, depth) {\n            var exp = this.expression;\n            var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n            if (fn instanceof AST_Arrow || fn instanceof AST_Defun || fn instanceof AST_Function) {\n                if (fn.evaluating) return this;\n                if (fn.name && fn.name.definition().recursive_refs > 0) return this;\n                if (this.is_expr_pure(compressor)) return this;\n                var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);\n                if (!all(fn.argnames, function(sym, index) {\n                    if (sym instanceof AST_DefaultValue) {\n                        if (!args) return false;\n                        if (args[index] === undefined) {\n                            var value = sym.value._eval(compressor, ignore_side_effects, cached, depth);\n                            if (value === sym.value) return false;\n                            args[index] = value;\n                        }\n                        sym = sym.name;\n                    }\n                    return !(sym instanceof AST_Destructured);\n                })) return this;\n                if (fn.rest instanceof AST_Destructured) return this;\n                if (!args && !ignore_side_effects) return this;\n                var stat = fn.first_statement();\n                if (!(stat instanceof AST_Return)) {\n                    if (ignore_side_effects) {\n                        fn.walk(scan_modified);\n                        var found = false;\n                        fn.evaluating = true;\n                        walk_body(fn, new TreeWalker(function(node) {\n                            if (found) return true;\n                            if (node instanceof AST_Return) {\n                                if (node.value && node.value._eval(compressor, true, cached, depth) !== undefined) {\n                                    found = true;\n                                }\n                                return true;\n                            }\n                            if (node instanceof AST_Scope && node !== fn) return true;\n                        }));\n                        fn.evaluating = false;\n                        if (!found) return;\n                    }\n                    return this;\n                }\n                var val = stat.value;\n                if (!val) return;\n                var cached_args = [];\n                if (!args || all(fn.argnames, function(sym, i) {\n                    return assign(sym, args[i]);\n                }) && !(fn.rest && !assign(fn.rest, args.slice(fn.argnames.length))) || ignore_side_effects) {\n                    if (ignore_side_effects) fn.argnames.forEach(function(sym) {\n                        if (sym instanceof AST_DefaultValue) sym.value.walk(scan_modified);\n                    });\n                    fn.evaluating = true;\n                    val = val._eval(compressor, ignore_side_effects, cached, depth);\n                    fn.evaluating = false;\n                }\n                cached_args.forEach(function(node) {\n                    delete node._eval;\n                });\n                return val === stat.value ? this : val;\n            } else if (compressor.option(\"unsafe\") && exp instanceof AST_PropAccess) {\n                var key = exp.property;\n                if (key instanceof AST_Node) {\n                    key = key._eval(compressor, ignore_side_effects, cached, depth);\n                    if (key === exp.property) return this;\n                }\n                var val;\n                var e = exp.expression;\n                if (is_undeclared_ref(e)) {\n                    var static_fn = static_fns[e.name];\n                    if (!static_fn || !static_fn[key]) return this;\n                    val = global_objs[e.name];\n                } else {\n                    val = e._eval(compressor, ignore_side_effects, cached, depth + 1);\n                    if (val == null || val === e) return this;\n                    var native_fn = native_fns[val.constructor.name];\n                    if (!native_fn || !native_fn[key]) return this;\n                    if (val instanceof RegExp && val.global && !(e instanceof AST_RegExp)) return this;\n                }\n                var args = eval_all(this.args, compressor, ignore_side_effects, cached, depth);\n                if (!args) return this;\n                if (key == \"replace\" && typeof args[1] == \"function\") return this;\n                try {\n                    return val[key].apply(val, args);\n                } catch (ex) {\n                    AST_Node.warn(\"Error evaluating {code} [{file}:{line},{col}]\", {\n                        code: this,\n                        file: this.start.file,\n                        line: this.start.line,\n                        col: this.start.col,\n                    });\n                } finally {\n                    if (val instanceof RegExp) val.lastIndex = 0;\n                }\n            }\n            return this;\n\n            function assign(sym, arg) {\n                if (sym instanceof AST_DefaultValue) sym = sym.name;\n                var def = sym.definition();\n                if (def.orig[def.orig.length - 1] !== sym) return false;\n                var value = arg;\n                def.references.forEach(function(node) {\n                    node._eval = function() {\n                        return value;\n                    };\n                    cached_args.push(node);\n                });\n                return true;\n            }\n        });\n        def(AST_New, return_this);\n        def(AST_Template, function(compressor, ignore_side_effects, cached, depth) {\n            if (!compressor.option(\"templates\")) return this;\n            if (this.tag) {\n                if (!is_raw_tag(compressor, this.tag)) return this;\n                decode = function(str) {\n                    return str;\n                };\n            }\n            var exprs = eval_all(this.expressions, compressor, ignore_side_effects, cached, depth);\n            if (!exprs) return this;\n            var malformed = false;\n            var ret = decode(this.strings[0]);\n            for (var i = 0; i < exprs.length; i++) {\n                ret += exprs[i] + decode(this.strings[i + 1]);\n            }\n            if (!malformed) return ret;\n            this._eval = return_this;\n            return this;\n\n            function decode(str) {\n                str = decode_template(str);\n                if (typeof str != \"string\") malformed = true;\n                return str;\n            }\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"_eval\", func);\n    });\n\n    // method to negate an expression\n    (function(def) {\n        function basic_negation(exp) {\n            return make_node(AST_UnaryPrefix, exp, {\n                operator: \"!\",\n                expression: exp\n            });\n        }\n        function best(orig, alt, first_in_statement) {\n            var negated = basic_negation(orig);\n            if (first_in_statement) {\n                var stat = make_node(AST_SimpleStatement, alt, {\n                    body: alt\n                });\n                return best_of_expression(negated, stat) === stat ? alt : negated;\n            }\n            return best_of_expression(negated, alt);\n        }\n        def(AST_Node, function() {\n            return basic_negation(this);\n        });\n        def(AST_Statement, function() {\n            throw new Error(\"Cannot negate a statement\");\n        });\n        def(AST_Binary, function(compressor, first_in_statement) {\n            var self = this.clone(), op = this.operator;\n            if (compressor.option(\"unsafe_comps\")) {\n                switch (op) {\n                  case \"<=\" : self.operator = \">\"  ; return self;\n                  case \"<\"  : self.operator = \">=\" ; return self;\n                  case \">=\" : self.operator = \"<\"  ; return self;\n                  case \">\"  : self.operator = \"<=\" ; return self;\n                }\n            }\n            switch (op) {\n              case \"==\" : self.operator = \"!=\"; return self;\n              case \"!=\" : self.operator = \"==\"; return self;\n              case \"===\": self.operator = \"!==\"; return self;\n              case \"!==\": self.operator = \"===\"; return self;\n              case \"&&\":\n                self.operator = \"||\";\n                self.left = self.left.negate(compressor, first_in_statement);\n                self.right = self.right.negate(compressor);\n                return best(this, self, first_in_statement);\n              case \"||\":\n                self.operator = \"&&\";\n                self.left = self.left.negate(compressor, first_in_statement);\n                self.right = self.right.negate(compressor);\n                return best(this, self, first_in_statement);\n            }\n            return basic_negation(this);\n        });\n        def(AST_ClassExpression, function() {\n            return basic_negation(this);\n        });\n        def(AST_Conditional, function(compressor, first_in_statement) {\n            var self = this.clone();\n            self.consequent = self.consequent.negate(compressor);\n            self.alternative = self.alternative.negate(compressor);\n            return best(this, self, first_in_statement);\n        });\n        def(AST_LambdaExpression, function() {\n            return basic_negation(this);\n        });\n        def(AST_Sequence, function(compressor) {\n            var expressions = this.expressions.slice();\n            expressions.push(expressions.pop().negate(compressor));\n            return make_sequence(this, expressions);\n        });\n        def(AST_UnaryPrefix, function() {\n            if (this.operator == \"!\")\n                return this.expression;\n            return basic_negation(this);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"negate\", function(compressor, first_in_statement) {\n            return func.call(this, compressor, first_in_statement);\n        });\n    });\n\n    var global_pure_fns = makePredicate(\"Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError\");\n    var global_pure_constructors = makePredicate(\"Map Set WeakMap WeakSet\");\n    AST_Call.DEFMETHOD(\"is_expr_pure\", function(compressor) {\n        if (compressor.option(\"unsafe\")) {\n            var expr = this.expression;\n            if (is_undeclared_ref(expr)) {\n                if (global_pure_fns[expr.name]) return true;\n                if (this instanceof AST_New && global_pure_constructors[expr.name]) return true;\n            }\n            if (is_static_fn(expr)) return true;\n        }\n        return compressor.option(\"annotations\") && this.pure || !compressor.pure_funcs(this);\n    });\n    AST_Template.DEFMETHOD(\"is_expr_pure\", function(compressor) {\n        var tag = this.tag;\n        if (!tag) return true;\n        if (compressor.option(\"unsafe\")) {\n            if (is_undeclared_ref(tag) && global_pure_fns[tag.name]) return true;\n            if (tag instanceof AST_Dot && is_undeclared_ref(tag.expression)) {\n                var static_fn = static_fns[tag.expression.name];\n                return static_fn && (static_fn[tag.property]\n                    || tag.expression.name == \"Math\" && tag.property == \"random\");\n            }\n        }\n        return !compressor.pure_funcs(this);\n    });\n    AST_Node.DEFMETHOD(\"is_call_pure\", return_false);\n    AST_Call.DEFMETHOD(\"is_call_pure\", function(compressor) {\n        if (!compressor.option(\"unsafe\")) return false;\n        var dot = this.expression;\n        if (!(dot instanceof AST_Dot)) return false;\n        var exp = dot.expression;\n        var map;\n        var prop = dot.property;\n        if (exp instanceof AST_Array) {\n            map = native_fns.Array;\n        } else if (exp.is_boolean(compressor)) {\n            map = native_fns.Boolean;\n        } else if (exp.is_number(compressor)) {\n            map = native_fns.Number;\n        } else if (exp instanceof AST_RegExp) {\n            map = native_fns.RegExp;\n        } else if (exp.is_string(compressor)) {\n            map = native_fns.String;\n            if (prop == \"replace\") {\n                var arg = this.args[1];\n                if (arg && !arg.is_string(compressor)) return false;\n            }\n        } else if (!dot.may_throw_on_access(compressor)) {\n            map = native_fns.Object;\n        }\n        return map && map[prop];\n    });\n\n    function spread_side_effects(exp) {\n        while ((exp = exp.tail_node()) instanceof AST_SymbolRef) {\n            exp = exp.fixed_value();\n            if (!exp) return true;\n        }\n        return !(exp instanceof AST_Array\n            || exp.TYPE == \"Binary\" && !lazy_op[exp.operator]\n            || exp instanceof AST_Constant\n            || exp instanceof AST_Lambda\n            || exp instanceof AST_Object && all(exp.properties, function(prop) {\n                return !(prop instanceof AST_ObjectGetter || prop instanceof AST_Spread);\n            })\n            || exp instanceof AST_ObjectIdentity\n            || exp instanceof AST_Unary);\n    }\n\n    // determine if expression has side effects\n    (function(def) {\n        function any(list, compressor, spread) {\n            return !all(list, spread ? function(node) {\n                return node instanceof AST_Spread ? !spread(node, compressor) : !node.has_side_effects(compressor);\n            } : function(node) {\n                return !node.has_side_effects(compressor);\n            });\n        }\n        function array_spread(node, compressor) {\n            return !node.expression.is_string(compressor) || node.expression.has_side_effects(compressor);\n        }\n        def(AST_Node, return_true);\n        def(AST_Array, function(compressor) {\n            return any(this.elements, compressor, array_spread);\n        });\n        def(AST_Assign, function(compressor) {\n            var lhs = this.left;\n            if (!(lhs instanceof AST_PropAccess)) return true;\n            var node = lhs.expression;\n            return !(node instanceof AST_ObjectIdentity)\n                || !node.scope.resolve().new\n                || lhs instanceof AST_Sub && lhs.property.has_side_effects(compressor)\n                || this.right.has_side_effects(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            return this.left.has_side_effects(compressor)\n                || this.right.has_side_effects(compressor)\n                || this.operator == \"in\" && !is_object(this.right);\n        });\n        def(AST_Block, function(compressor) {\n            return any(this.body, compressor);\n        });\n        def(AST_Call, function(compressor) {\n            if (!this.is_expr_pure(compressor)\n                && (!this.is_call_pure(compressor) || this.expression.has_side_effects(compressor))) {\n                return true;\n            }\n            return any(this.args, compressor, array_spread);\n        });\n        def(AST_Case, function(compressor) {\n            return this.expression.has_side_effects(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_Class, function(compressor) {\n            var base = this.extends;\n            if (base) {\n                if (base instanceof AST_SymbolRef) base = base.fixed_value();\n                if (!safe_for_extends(base)) return true;\n            }\n            return any(this.properties, compressor);\n        });\n        def(AST_ClassProperty, function(compressor) {\n            return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                || this.static && this.value && this.value.has_side_effects(compressor);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.condition.has_side_effects(compressor)\n                || this.consequent.has_side_effects(compressor)\n                || this.alternative.has_side_effects(compressor);\n        });\n        def(AST_Constant, return_false);\n        def(AST_Definitions, function(compressor) {\n            return any(this.definitions, compressor);\n        });\n        def(AST_DestructuredArray, function(compressor) {\n            return any(this.elements, compressor);\n        });\n        def(AST_DestructuredKeyVal, function(compressor) {\n            return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                || this.value.has_side_effects(compressor);\n        });\n        def(AST_DestructuredObject, function(compressor) {\n            return any(this.properties, compressor);\n        });\n        def(AST_Dot, function(compressor) {\n            return !this.optional && this.expression.may_throw_on_access(compressor)\n                || this.expression.has_side_effects(compressor);\n        });\n        def(AST_EmptyStatement, return_false);\n        def(AST_If, function(compressor) {\n            return this.condition.has_side_effects(compressor)\n                || this.body && this.body.has_side_effects(compressor)\n                || this.alternative && this.alternative.has_side_effects(compressor);\n        });\n        def(AST_LabeledStatement, function(compressor) {\n            return this.body.has_side_effects(compressor);\n        });\n        def(AST_Lambda, return_false);\n        def(AST_Object, function(compressor) {\n            return any(this.properties, compressor, function(node, compressor) {\n                var exp = node.expression;\n                return spread_side_effects(exp) || exp.has_side_effects(compressor);\n            });\n        });\n        def(AST_ObjectIdentity, return_false);\n        def(AST_ObjectProperty, function(compressor) {\n            return this.key instanceof AST_Node && this.key.has_side_effects(compressor)\n                || this.value.has_side_effects(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return any(this.expressions, compressor);\n        });\n        def(AST_SimpleStatement, function(compressor) {\n            return this.body.has_side_effects(compressor);\n        });\n        def(AST_Sub, function(compressor) {\n            return !this.optional && this.expression.may_throw_on_access(compressor)\n                || this.expression.has_side_effects(compressor)\n                || this.property.has_side_effects(compressor);\n        });\n        def(AST_Switch, function(compressor) {\n            return this.expression.has_side_effects(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_SymbolDeclaration, return_false);\n        def(AST_SymbolRef, function(compressor) {\n            return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);\n        });\n        def(AST_Template, function(compressor) {\n            return !this.is_expr_pure(compressor) || any(this.expressions, compressor);\n        });\n        def(AST_Try, function(compressor) {\n            return any(this.body, compressor)\n                || this.bcatch && this.bcatch.has_side_effects(compressor)\n                || this.bfinally && this.bfinally.has_side_effects(compressor);\n        });\n        def(AST_Unary, function(compressor) {\n            return unary_side_effects[this.operator]\n                || this.expression.has_side_effects(compressor);\n        });\n        def(AST_VarDef, function() {\n            return this.value;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"has_side_effects\", func);\n    });\n\n    // determine if expression may throw\n    (function(def) {\n        def(AST_Node, return_true);\n\n        def(AST_Constant, return_false);\n        def(AST_Destructured, return_true);\n        def(AST_EmptyStatement, return_false);\n        def(AST_Lambda, return_false);\n        def(AST_ObjectIdentity, return_false);\n        def(AST_SymbolDeclaration, return_false);\n\n        function any(list, compressor) {\n            for (var i = list.length; --i >= 0;)\n                if (list[i].may_throw(compressor))\n                    return true;\n            return false;\n        }\n\n        function call_may_throw(exp, compressor) {\n            if (exp.may_throw(compressor)) return true;\n            if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n            if (!(exp instanceof AST_Lambda)) return true;\n            if (any(exp.argnames, compressor)) return true;\n            if (any(exp.body, compressor)) return true;\n            return is_arrow(exp) && exp.value && exp.value.may_throw(compressor);\n        }\n\n        def(AST_Array, function(compressor) {\n            return any(this.elements, compressor);\n        });\n        def(AST_Assign, function(compressor) {\n            if (this.right.may_throw(compressor)) return true;\n            if (!compressor.has_directive(\"use strict\")\n                && this.operator == \"=\"\n                && this.left instanceof AST_SymbolRef) {\n                return false;\n            }\n            return this.left.may_throw(compressor);\n        });\n        def(AST_Binary, function(compressor) {\n            return this.left.may_throw(compressor)\n                || this.right.may_throw(compressor)\n                || this.operator == \"in\" && !is_object(this.right);\n        });\n        def(AST_Block, function(compressor) {\n            return any(this.body, compressor);\n        });\n        def(AST_Call, function(compressor) {\n            if (any(this.args, compressor)) return true;\n            if (this.is_expr_pure(compressor)) return false;\n            this.may_throw = return_true;\n            var ret = call_may_throw(this.expression, compressor);\n            delete this.may_throw;\n            return ret;\n        });\n        def(AST_Case, function(compressor) {\n            return this.expression.may_throw(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_Conditional, function(compressor) {\n            return this.condition.may_throw(compressor)\n                || this.consequent.may_throw(compressor)\n                || this.alternative.may_throw(compressor);\n        });\n        def(AST_DefaultValue, function(compressor) {\n            return this.name.may_throw(compressor)\n                || this.value && this.value.may_throw(compressor);\n        });\n        def(AST_Definitions, function(compressor) {\n            return any(this.definitions, compressor);\n        });\n        def(AST_Dot, function(compressor) {\n            return !this.optional && this.expression.may_throw_on_access(compressor)\n                || this.expression.may_throw(compressor);\n        });\n        def(AST_If, function(compressor) {\n            return this.condition.may_throw(compressor)\n                || this.body && this.body.may_throw(compressor)\n                || this.alternative && this.alternative.may_throw(compressor);\n        });\n        def(AST_LabeledStatement, function(compressor) {\n            return this.body.may_throw(compressor);\n        });\n        def(AST_Object, function(compressor) {\n            return any(this.properties, compressor);\n        });\n        def(AST_ObjectProperty, function(compressor) {\n            return this.value.may_throw(compressor)\n                || this.key instanceof AST_Node && this.key.may_throw(compressor);\n        });\n        def(AST_Return, function(compressor) {\n            return this.value && this.value.may_throw(compressor);\n        });\n        def(AST_Sequence, function(compressor) {\n            return any(this.expressions, compressor);\n        });\n        def(AST_SimpleStatement, function(compressor) {\n            return this.body.may_throw(compressor);\n        });\n        def(AST_Sub, function(compressor) {\n            return !this.optional && this.expression.may_throw_on_access(compressor)\n                || this.expression.may_throw(compressor)\n                || this.property.may_throw(compressor);\n        });\n        def(AST_Switch, function(compressor) {\n            return this.expression.may_throw(compressor)\n                || any(this.body, compressor);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            return !this.is_declared(compressor) || !can_drop_symbol(this, compressor);\n        });\n        def(AST_Template, function(compressor) {\n            if (any(this.expressions, compressor)) return true;\n            if (this.is_expr_pure(compressor)) return false;\n            if (!this.tag) return false;\n            this.may_throw = return_true;\n            var ret = call_may_throw(this.tag, compressor);\n            delete this.may_throw;\n            return ret;\n        });\n        def(AST_Try, function(compressor) {\n            return (this.bcatch ? this.bcatch.may_throw(compressor) : any(this.body, compressor))\n                || this.bfinally && this.bfinally.may_throw(compressor);\n        });\n        def(AST_Unary, function(compressor) {\n            return this.expression.may_throw(compressor)\n                && !(this.operator == \"typeof\" && this.expression instanceof AST_SymbolRef);\n        });\n        def(AST_VarDef, function(compressor) {\n            return this.name.may_throw(compressor)\n                || this.value && this.value.may_throw(compressor);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"may_throw\", func);\n    });\n\n    // determine if expression is constant\n    (function(def) {\n        function all_constant(list, scope) {\n            for (var i = list.length; --i >= 0;)\n                if (!list[i].is_constant_expression(scope))\n                    return false;\n            return true;\n        }\n        def(AST_Node, return_false);\n        def(AST_Array, function(scope) {\n            return all_constant(this.elements, scope);\n        });\n        def(AST_Binary, function(scope) {\n            return this.left.is_constant_expression(scope)\n                && this.right.is_constant_expression(scope)\n                && (this.operator != \"in\" || is_object(this.right));\n        });\n        def(AST_Class, function(scope) {\n            var base = this.extends;\n            if (base && !safe_for_extends(base)) return false;\n            return all_constant(this.properties, scope);\n        });\n        def(AST_ClassProperty, function(scope) {\n            return typeof this.key == \"string\" && (!this.value || this.value.is_constant_expression(scope));\n        });\n        def(AST_Constant, return_true);\n        def(AST_Lambda, function(scope) {\n            var self = this;\n            var result = true;\n            var scopes = [];\n            self.walk(new TreeWalker(function(node, descend) {\n                if (!result) return true;\n                if (node instanceof AST_BlockScope) {\n                    if (node === self) return;\n                    scopes.push(node);\n                    descend();\n                    scopes.pop();\n                    return true;\n                }\n                if (node instanceof AST_SymbolRef) {\n                    if (self.inlined || node.redef) {\n                        result = false;\n                        return true;\n                    }\n                    if (self.variables.has(node.name)) return true;\n                    var def = node.definition();\n                    if (member(def.scope, scopes)) return true;\n                    if (scope && !def.redefined()) {\n                        var scope_def = scope.find_variable(node.name);\n                        if (scope_def ? scope_def === def : def.undeclared) {\n                            result = \"f\";\n                            return true;\n                        }\n                    }\n                    result = false;\n                    return true;\n                }\n                if (node instanceof AST_ObjectIdentity) {\n                    if (is_arrow(self) && all(scopes, function(s) {\n                        return !(s instanceof AST_Scope) || is_arrow(s);\n                    })) result = false;\n                    return true;\n                }\n            }));\n            return result;\n        });\n        def(AST_Object, function(scope) {\n            return all_constant(this.properties, scope);\n        });\n        def(AST_ObjectProperty, function(scope) {\n            return typeof this.key == \"string\" && this.value.is_constant_expression(scope);\n        });\n        def(AST_Unary, function(scope) {\n            return this.expression.is_constant_expression(scope);\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"is_constant_expression\", func);\n    });\n\n    // tell me if a statement aborts\n    function aborts(thing) {\n        return thing && thing.aborts();\n    }\n    (function(def) {\n        def(AST_Statement, return_null);\n        def(AST_Jump, return_this);\n        function block_aborts() {\n            var n = this.body.length;\n            return n > 0 && aborts(this.body[n - 1]);\n        }\n        def(AST_BlockStatement, block_aborts);\n        def(AST_SwitchBranch, block_aborts);\n        def(AST_If, function() {\n            return this.alternative && aborts(this.body) && aborts(this.alternative) && this;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"aborts\", func);\n    });\n\n    /* -----[ optimizers ]----- */\n\n    var directives = makePredicate([\"use asm\", \"use strict\"]);\n    OPT(AST_Directive, function(self, compressor) {\n        if (compressor.option(\"directives\")\n            && (!directives[self.value] || compressor.has_directive(self.value) !== self)) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        return self;\n    });\n\n    OPT(AST_Debugger, function(self, compressor) {\n        if (compressor.option(\"drop_debugger\"))\n            return make_node(AST_EmptyStatement, self);\n        return self;\n    });\n\n    OPT(AST_LabeledStatement, function(self, compressor) {\n        if (compressor.option(\"dead_code\")\n            && self.body instanceof AST_Break\n            && compressor.loopcontrol_target(self.body) === self.body) {\n            return make_node(AST_EmptyStatement, self);\n        }\n        return compressor.option(\"unused\") && self.label.references.length == 0 ? self.body : self;\n    });\n\n    OPT(AST_LoopControl, function(self, compressor) {\n        if (!compressor.option(\"dead_code\")) return self;\n        var label = self.label;\n        if (label) {\n            var lct = compressor.loopcontrol_target(self);\n            self.label = null;\n            if (compressor.loopcontrol_target(self) === lct) {\n                remove(label.thedef.references, self);\n            } else {\n                self.label = label;\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_Block, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        return self;\n    });\n\n    function trim_block(node, parent, in_list) {\n        switch (node.body.length) {\n          case 0:\n            return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n          case 1:\n            var stat = node.body[0];\n            if (!safe_to_trim(stat)) return node;\n            if (parent instanceof AST_IterationStatement && stat instanceof AST_LambdaDefinition) return node;\n            return stat;\n        }\n        return node;\n    }\n\n    OPT(AST_BlockStatement, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        return trim_block(self, compressor.parent());\n    });\n\n    function drop_rest_farg(fn, compressor) {\n        if (!compressor.option(\"rests\")) return;\n        if (fn.uses_arguments) return;\n        if (!(fn.rest instanceof AST_DestructuredArray)) return;\n        if (!compressor.drop_fargs(fn, compressor.parent())) return;\n        fn.argnames = fn.argnames.concat(fn.rest.elements);\n        fn.rest = fn.rest.rest;\n    }\n\n    OPT(AST_Lambda, function(self, compressor) {\n        drop_rest_farg(self, compressor);\n        self.body = tighten_body(self.body, compressor);\n        return self;\n    });\n\n    function opt_arrow(self, compressor) {\n        if (!compressor.option(\"arrows\")) return self;\n        drop_rest_farg(self, compressor);\n        var body = tighten_body(self.value ? [ self.first_statement() ] : self.body, compressor);\n        switch (body.length) {\n          case 1:\n            var stat = body[0];\n            if (stat instanceof AST_Return) {\n                self.body.length = 0;\n                self.value = stat.value;\n                break;\n            }\n          default:\n            self.body = body;\n            self.value = null;\n            break;\n        }\n        return self;\n    }\n    OPT(AST_Arrow, opt_arrow);\n    OPT(AST_AsyncArrow, opt_arrow);\n\n    OPT(AST_Function, function(self, compressor) {\n        drop_rest_farg(self, compressor);\n        self.body = tighten_body(self.body, compressor);\n        var parent = compressor.parent();\n        if (compressor.option(\"inline\")) for (var i = 0; i < self.body.length; i++) {\n            var stat = self.body[i];\n            if (stat instanceof AST_Directive) continue;\n            if (stat instanceof AST_Return) {\n                if (i != self.body.length - 1) break;\n                var call = stat.value;\n                if (!call || call.TYPE != \"Call\") break;\n                if (call.is_expr_pure(compressor)) break;\n                var fn = call.expression;\n                if (fn instanceof AST_SymbolRef) {\n                    if (self.name && self.name.definition() === fn.definition()) break;\n                    fn = fn.fixed_value();\n                }\n                if (!(fn instanceof AST_Defun || fn instanceof AST_Function)) break;\n                if (fn.rest) break;\n                if (fn.uses_arguments) break;\n                if (fn === call.expression) {\n                    if (fn.parent_scope !== self) break;\n                    if (!all(fn.enclosed, function(def) {\n                        return def.scope !== self;\n                    })) break;\n                }\n                if (fn.name\n                    && (parent instanceof AST_ClassMethod || parent instanceof AST_ObjectMethod)\n                    && parent.value === compressor.self()) break;\n                if (fn.contains_this()) break;\n                var len = fn.argnames.length;\n                if (len > 0 && compressor.option(\"inline\") < 2) break;\n                if (len > self.argnames.length) break;\n                if (!all(self.argnames, function(argname) {\n                    return argname instanceof AST_SymbolFunarg;\n                })) break;\n                if (!all(call.args, function(arg) {\n                    return !(arg instanceof AST_Spread);\n                })) break;\n                for (var j = 0; j < len; j++) {\n                    var arg = call.args[j];\n                    if (!(arg instanceof AST_SymbolRef)) break;\n                    if (arg.definition() !== self.argnames[j].definition()) break;\n                }\n                if (j < len) break;\n                for (; j < call.args.length; j++) {\n                    if (call.args[j].has_side_effects(compressor)) break;\n                }\n                if (j < call.args.length) break;\n                if (len < self.argnames.length && !compressor.drop_fargs(self, parent)) {\n                    if (!compressor.drop_fargs(fn, call)) break;\n                    do {\n                        fn.argnames.push(fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + len));\n                    } while (++len < self.argnames.length);\n                }\n                return call.expression;\n            }\n            break;\n        }\n        return self;\n    });\n\n    var NO_MERGE = makePredicate(\"arguments await yield\");\n    AST_Scope.DEFMETHOD(\"merge_variables\", function(compressor) {\n        if (!compressor.option(\"merge_vars\")) return;\n        var in_try, root, segment = {}, self = this;\n        var first = [], last = [], index = 0;\n        var declarations = new Dictionary();\n        var references = Object.create(null);\n        var prev = Object.create(null);\n        var tw = new TreeWalker(function(node, descend) {\n            if (node instanceof AST_Assign) {\n                var lhs = node.left;\n                var rhs = node.right;\n                if (lhs instanceof AST_Destructured) {\n                    rhs.walk(tw);\n                    var marker = new TreeWalker(function(node) {\n                        if (node instanceof AST_Destructured) return;\n                        if (node instanceof AST_DefaultValue) {\n                            push();\n                            node.value.walk(tw);\n                            pop();\n                            node.name.walk(marker);\n                        } else if (node instanceof AST_DestructuredKeyVal) {\n                            if (node.key instanceof AST_Node) {\n                                push();\n                                segment.block = node;\n                                node.key.walk(tw);\n                                node.value.walk(marker);\n                                pop();\n                            } else {\n                                node.value.walk(marker);\n                            }\n                        } else if (node instanceof AST_SymbolRef) {\n                            mark(node);\n                        } else {\n                            node.walk(tw);\n                        }\n                        return true;\n                    });\n                    lhs.walk(marker);\n                    return true;\n                }\n                if (lazy_op[node.operator.slice(0, -1)]) {\n                    lhs.walk(tw);\n                    push();\n                    rhs.walk(tw);\n                    if (lhs instanceof AST_SymbolRef) mark(lhs);\n                    pop();\n                    return true;\n                }\n                if (lhs instanceof AST_SymbolRef) {\n                    if (node.operator != \"=\") mark(lhs, true);\n                    rhs.walk(tw);\n                    mark(lhs);\n                    return true;\n                }\n                return;\n            }\n            if (node instanceof AST_Binary) {\n                if (!lazy_op[node.operator]) return;\n                node.left.walk(tw);\n                push();\n                node.right.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Break) {\n                var target = tw.loopcontrol_target(node);\n                if (!(target instanceof AST_IterationStatement)) insert(target);\n                return true;\n            }\n            if (node instanceof AST_Call) {\n                var exp = node.expression;\n                var tail = exp.tail_node();\n                if (!is_lambda(tail)) {\n                    descend();\n                    return mark_expression(exp);\n                }\n                if (exp !== tail) exp.expressions.slice(0, -1).forEach(function(node) {\n                    node.walk(tw);\n                });\n                node.args.forEach(function(arg) {\n                    arg.walk(tw);\n                });\n                tail.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_Conditional) {\n                node.condition.walk(tw);\n                push();\n                node.consequent.walk(tw);\n                pop();\n                push();\n                node.alternative.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Continue) {\n                var target = tw.loopcontrol_target(node);\n                if (target instanceof AST_Do) insert(target);\n                return true;\n            }\n            if (node instanceof AST_Do) {\n                push();\n                segment.block = node;\n                segment.loop = true;\n                var save = segment;\n                node.body.walk(tw);\n                if (segment.inserted === node) segment = save;\n                node.condition.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_For) {\n                if (node.init) node.init.walk(tw);\n                push();\n                segment.block = node;\n                segment.loop = true;\n                if (node.condition) node.condition.walk(tw);\n                node.body.walk(tw);\n                if (node.step) node.step.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_ForEnumeration) {\n                node.object.walk(tw);\n                push();\n                segment.block = node;\n                segment.loop = true;\n                node.init.walk(tw);\n                node.body.walk(tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_If) {\n                node.condition.walk(tw);\n                push();\n                node.body.walk(tw);\n                pop();\n                if (node.alternative) {\n                    push();\n                    node.alternative.walk(tw);\n                    pop();\n                }\n                return true;\n            }\n            if (node instanceof AST_LabeledStatement) {\n                push();\n                segment.block = node;\n                var save = segment;\n                node.body.walk(tw);\n                if (segment.inserted === node) segment = save;\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Scope) {\n                push();\n                segment.block = node;\n                if (node === self) root = segment;\n                if (node instanceof AST_Lambda) {\n                    if (node.name) references[node.name.definition().id] = false;\n                    var marker = node.uses_arguments && !tw.has_directive(\"use strict\") ? function(node) {\n                        if (node instanceof AST_SymbolFunarg) references[node.definition().id] = false;\n                    } : function(node) {\n                        if (node instanceof AST_SymbolFunarg) mark(node);\n                    };\n                    var scanner = new TreeWalker(function(ref) {\n                        if (ref instanceof AST_SymbolDeclaration) references[ref.definition().id] = false;\n                        if (!(ref instanceof AST_SymbolRef)) return;\n                        var def = ref.definition();\n                        var ldef = node.variables.get(ref.name);\n                        if (ldef && (ldef === def\n                            || def.undeclared\n                            || node.parent_scope.find_variable(ref.name) === def)) {\n                            references[def.id] = false;\n                            references[ldef.id] = false;\n                        } else {\n                            var save = segment;\n                            pop();\n                            mark(ref, true);\n                            segment = save;\n                        }\n                        return true;\n                    });\n                    node.argnames.forEach(function(argname) {\n                        argname.mark_symbol(marker, scanner);\n                    });\n                    if (node.rest) node.rest.mark_symbol(marker, scanner);\n                }\n                walk_lambda(node, tw);\n                pop();\n                return true;\n            }\n            if (node instanceof AST_Sub) {\n                var exp = node.expression;\n                if (node.optional) {\n                    exp.walk(tw);\n                    push();\n                    node.property.walk(tw);\n                    pop();\n                } else {\n                    descend();\n                }\n                return mark_expression(exp);\n            }\n            if (node instanceof AST_Switch) {\n                node.expression.walk(tw);\n                var save = segment;\n                node.body.forEach(function(branch) {\n                    if (branch instanceof AST_Default) return;\n                    branch.expression.walk(tw);\n                    if (save === segment) push();\n                });\n                segment = save;\n                node.body.forEach(function(branch) {\n                    push();\n                    segment.block = node;\n                    var save = segment;\n                    walk_body(branch, tw);\n                    if (segment.inserted === node) segment = save;\n                    pop();\n                });\n                return true;\n            }\n            if (node instanceof AST_SymbolConst || node instanceof AST_SymbolLet) {\n                references[node.definition().id] = false;\n                return true;\n            }\n            if (node instanceof AST_SymbolRef) {\n                mark(node, true);\n                return true;\n            }\n            if (node instanceof AST_Try) {\n                var save_try = in_try;\n                in_try = node;\n                var save = segment;\n                walk_body(node, tw);\n                segment = save;\n                if (node.bcatch) {\n                    if (node.bcatch.argname) node.bcatch.argname.mark_symbol(function(node) {\n                        if (node instanceof AST_SymbolCatch) {\n                            var def = node.definition();\n                            references[def.id] = false;\n                            if (def = def.redefined()) references[def.id] = false;\n                        }\n                    }, tw);\n                    if (node.bfinally || (in_try = save_try)) {\n                        walk_body(node.bcatch, tw);\n                    } else {\n                        push();\n                        walk_body(node.bcatch, tw);\n                        pop();\n                    }\n                }\n                in_try = save_try;\n                segment = save;\n                if (node.bfinally) node.bfinally.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_Unary) {\n                if (!UNARY_POSTFIX[node.operator]) return;\n                var sym = node.expression;\n                if (!(sym instanceof AST_SymbolRef)) return;\n                mark(sym, true);\n                return true;\n            }\n            if (node instanceof AST_VarDef) {\n                var assigned = node.value;\n                if (assigned) {\n                    assigned.walk(tw);\n                } else {\n                    assigned = segment.block instanceof AST_ForEnumeration && segment.block.init === tw.parent();\n                }\n                node.name.mark_symbol(assigned ? function(node) {\n                    if (!(node instanceof AST_SymbolDeclaration)) return;\n                    if (node instanceof AST_SymbolVar) {\n                        mark(node);\n                    } else {\n                        references[node.definition().id] = false;\n                    }\n                    return true;\n                } : function(node) {\n                    if (!(node instanceof AST_SymbolDeclaration)) return;\n                    var id = node.definition().id;\n                    if (!(node instanceof AST_SymbolVar)) {\n                        references[id] = false;\n                    } else if (!(id in references)) {\n                        declarations.add(id, node);\n                    } else if (references[id]) {\n                        references[id].push(node);\n                    }\n                    return true;\n                }, tw);\n                return true;\n            }\n            if (node instanceof AST_While) {\n                push();\n                segment.block = node;\n                segment.loop = true;\n                descend();\n                pop();\n                return true;\n            }\n\n            function mark_expression(exp) {\n                if (compressor.option(\"ie\")) {\n                    var sym = root_expr(exp);\n                    if (sym instanceof AST_SymbolRef) sym.walk(tw);\n                }\n                return true;\n            }\n        });\n        tw.directives = Object.create(compressor.directives);\n        self.walk(tw);\n        var changed = false;\n        var merged = Object.create(null);\n        while (first.length && last.length) {\n            var head = first.pop();\n            var def = head.definition;\n            if (!(def.id in prev)) continue;\n            if (!references[def.id]) continue;\n            var head_refs = {\n                start: references[def.id].start,\n            };\n            while (def.id in merged) def = merged[def.id];\n            head_refs.end = references[def.id].end;\n            var skipped = [];\n            do {\n                var tail = last.pop();\n                if (!tail) continue;\n                if (tail.index > head.index) continue;\n                var id = tail.definition.id;\n                var tail_refs = references[id];\n                if (!tail_refs) continue;\n                if (head_refs.start.block !== tail_refs.start.block\n                    || !mergeable(head_refs, tail_refs)\n                    || (head_refs.start.loop || !same_scope(def)) && !mergeable(tail_refs, head_refs)\n                    || compressor.option(\"webkit\") && is_funarg(def) !== is_funarg(tail.definition)\n                    || !all(tail_refs, function(sym) {\n                        return sym.scope.find_variable(def.name) === def;\n                    })) {\n                    skipped.unshift(tail);\n                    continue;\n                }\n                var orig = [], refs = [];\n                tail_refs.forEach(function(sym) {\n                    sym.thedef = def;\n                    sym.name = def.name;\n                    if (sym instanceof AST_SymbolRef) {\n                        refs.push(sym);\n                    } else {\n                        orig.push(sym);\n                    }\n                });\n                def.orig = orig.concat(def.orig);\n                def.references = refs.concat(def.references);\n                def.fixed = tail.definition.fixed && def.fixed;\n                merged[id] = def;\n                changed = true;\n                break;\n            } while (last.length);\n            if (skipped.length) last = last.concat(skipped);\n        }\n        return changed;\n\n        function push() {\n            segment = Object.create(segment);\n        }\n\n        function pop() {\n            segment = Object.getPrototypeOf(segment);\n        }\n\n        function mark(sym, read) {\n            var def = sym.definition(), ldef, seg = segment;\n            if (in_try) {\n                push();\n                seg = segment;\n                pop();\n            }\n            if (def.id in references) {\n                var refs = references[def.id];\n                if (!refs) return;\n                if (refs.start.block !== seg.block) return references[def.id] = false;\n                refs.push(sym);\n                refs.end = seg;\n                if (def.id in prev) {\n                    last[prev[def.id]] = null;\n                } else if (!read) {\n                    return;\n                }\n            } else if ((ldef = self.variables.get(def.name)) !== def) {\n                if (ldef && root === seg) references[ldef.id] = false;\n                return references[def.id] = false;\n            } else if (compressor.exposed(def) || NO_MERGE[sym.name]) {\n                return references[def.id] = false;\n            } else {\n                var refs = declarations.get(def.id) || [];\n                refs.push(sym);\n                references[def.id] = refs;\n                if (!read) {\n                    refs.start = seg;\n                    return first.push({\n                        index: index++,\n                        definition: def,\n                    });\n                }\n                if (seg.block !== self) return references[def.id] = false;\n                refs.start = root;\n            }\n            prev[def.id] = last.length;\n            last.push({\n                index: index++,\n                definition: def,\n            });\n        }\n\n        function insert(target) {\n            var stack = [];\n            while (true) {\n                if (HOP(segment, \"block\")) {\n                    var block = segment.block;\n                    if (block instanceof AST_LabeledStatement) block = block.body;\n                    if (block === target) break;\n                }\n                stack.push(segment);\n                pop();\n            }\n            segment.inserted = segment.block;\n            push();\n            while (stack.length) {\n                var seg = stack.pop();\n                push();\n                if (HOP(seg, \"block\")) segment.block = seg.block;\n                if (HOP(seg, \"loop\")) segment.loop = seg.loop;\n            }\n        }\n\n        function must_visit(base, segment) {\n            return base === segment || base.isPrototypeOf(segment);\n        }\n\n        function mergeable(head, tail) {\n            return must_visit(head.start, head.end) || must_visit(head.start, tail.start);\n        }\n    });\n\n    function fill_holes(orig, elements) {\n        for (var i = elements.length; --i >= 0;) {\n            if (!elements[i]) elements[i] = make_node(AST_Hole, orig);\n        }\n    }\n\n    function to_class_expr(defcl, drop_name) {\n        var cl = make_node(AST_ClassExpression, defcl, defcl);\n        cl.name = drop_name ? null : make_node(AST_SymbolClass, defcl.name, defcl.name);\n        return cl;\n    }\n\n    function to_func_expr(defun, drop_name) {\n        var ctor;\n        switch (defun.CTOR) {\n          case AST_AsyncDefun:\n            ctor = AST_AsyncFunction;\n            break;\n          case AST_AsyncGeneratorDefun:\n            ctor = AST_AsyncGeneratorFunction;\n            break;\n          case AST_Defun:\n            ctor = AST_Function;\n            break;\n          case AST_GeneratorDefun:\n            ctor = AST_GeneratorFunction;\n            break;\n        }\n        var fn = make_node(ctor, defun, defun);\n        fn.name = drop_name ? null : make_node(AST_SymbolLambda, defun.name, defun.name);\n        return fn;\n    }\n\n    AST_Scope.DEFMETHOD(\"drop_unused\", function(compressor) {\n        if (!compressor.option(\"unused\")) return;\n        var self = this;\n        var drop_funcs = !(self instanceof AST_Toplevel) || compressor.toplevel.funcs;\n        var drop_vars = !(self instanceof AST_Toplevel) || compressor.toplevel.vars;\n        var assign_as_unused = /keep_assign/.test(compressor.option(\"unused\")) ? return_false : function(node, props) {\n            var sym, nested = false;\n            if (node instanceof AST_Assign) {\n                if (node.write_only || node.operator == \"=\") sym = extract_reference(node.left, props);\n            } else if (node instanceof AST_Unary) {\n                if (node.write_only) sym = extract_reference(node.expression, props);\n            }\n            if (!(sym instanceof AST_SymbolRef)) return;\n            var def = sym.definition();\n            if (export_defaults[def.id]) return;\n            if (compressor.exposed(def)) return;\n            if (!can_drop_symbol(sym, compressor, nested)) return;\n            return sym;\n\n            function extract_reference(node, props) {\n                if (node instanceof AST_PropAccess) {\n                    var expr = node.expression;\n                    if (!expr.may_throw_on_access(compressor, true)) {\n                        nested = true;\n                        if (props && node instanceof AST_Sub) props.unshift(node.property);\n                        return extract_reference(expr, props);\n                    }\n                } else if (node instanceof AST_Assign && node.operator == \"=\") {\n                    node.write_only = \"p\";\n                    var ref = extract_reference(node.right);\n                    if (!props) return ref;\n                    props.assign = node;\n                    return ref instanceof AST_SymbolRef ? ref : node.left;\n                }\n                return node;\n            }\n        };\n        var assign_in_use = Object.create(null);\n        var export_defaults = Object.create(null);\n        var find_variable = function(name) {\n            find_variable = compose(self, 0, noop);\n            return find_variable(name);\n\n            function compose(child, level, find) {\n                var parent = compressor.parent(level);\n                if (!parent) return find;\n                var in_arg = parent instanceof AST_Lambda && member(child, parent.argnames);\n                return compose(parent, level + 1, in_arg ? function(name) {\n                    var def = find(name);\n                    if (def) return def;\n                    def = parent.variables.get(name);\n                    if (def) {\n                        var sym = def.orig[0];\n                        if (sym instanceof AST_SymbolFunarg || sym instanceof AST_SymbolLambda) return def;\n                    }\n                } : parent.variables ? function(name) {\n                    return find(name) || parent.variables.get(name);\n                } : find);\n            }\n        };\n        var for_ins = Object.create(null);\n        var in_use = [];\n        var in_use_ids = Object.create(null); // avoid expensive linear scans of in_use\n        var value_read = Object.create(null);\n        var value_modified = Object.create(null);\n        var var_defs = Object.create(null);\n        if (self instanceof AST_Toplevel && compressor.top_retain) {\n            self.variables.each(function(def) {\n                if (compressor.top_retain(def) && !(def.id in in_use_ids)) {\n                    in_use_ids[def.id] = true;\n                    in_use.push(def);\n                }\n            });\n        }\n        var assignments = new Dictionary();\n        var initializations = new Dictionary();\n        // pass 1: find out which symbols are directly used in\n        // this scope (not in nested scopes).\n        var scope = this;\n        var tw = new TreeWalker(function(node, descend) {\n            if (node instanceof AST_Lambda && node.uses_arguments && !tw.has_directive(\"use strict\")) {\n                node.each_argname(function(argname) {\n                    var def = argname.definition();\n                    if (!(def.id in in_use_ids)) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                });\n            }\n            if (node === self) return;\n            if (scope === self) {\n                if (node instanceof AST_DefClass) {\n                    var def = node.name.definition();\n                    if ((!drop_funcs || def.exported) && !(def.id in in_use_ids)) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                    if (node.extends) node.extends.walk(tw);\n                    var is_export = false;\n                    if (tw.parent() instanceof AST_ExportDefault) {\n                        is_export = true;\n                        export_defaults[def.id] = true;\n                    }\n                    node.properties.forEach(function(prop) {\n                        if (prop.key instanceof AST_Node) prop.key.walk(tw);\n                        if (!prop.value) return;\n                        if (is_export || prop instanceof AST_ClassField && prop.static) {\n                            var save_scope = scope;\n                            scope = node;\n                            prop.value.walk(tw);\n                            scope = save_scope;\n                        } else {\n                            initializations.add(def.id, prop.value);\n                        }\n                    });\n                    return true;\n                }\n                if (node instanceof AST_LambdaDefinition) {\n                    var def = node.name.definition();\n                    if ((!drop_funcs || def.exported) && !(def.id in in_use_ids)) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                    initializations.add(def.id, node);\n                    if (tw.parent() instanceof AST_ExportDefault) {\n                        export_defaults[def.id] = true;\n                    } else {\n                        return true;\n                    }\n                }\n                if (node instanceof AST_Definitions) {\n                    node.definitions.forEach(function(defn) {\n                        var value = defn.value;\n                        var side_effects = value\n                            && (defn.name instanceof AST_Destructured || value.has_side_effects(compressor));\n                        var shared = side_effects && value.tail_node().operator == \"=\";\n                        defn.name.mark_symbol(function(name) {\n                            if (!(name instanceof AST_SymbolDeclaration)) return;\n                            var def = name.definition();\n                            var_defs[def.id] = (var_defs[def.id] || 0) + 1;\n                            if (node instanceof AST_Var && def.orig[0] instanceof AST_SymbolCatch) {\n                                var redef = def.redefined();\n                                if (redef) var_defs[redef.id] = (var_defs[redef.id] || 0) + 1;\n                            }\n                            if (!(def.id in in_use_ids) && (!drop_vars || def.exported\n                                || (node instanceof AST_Const ? def.redefined() : def.const_redefs)\n                                || !(node instanceof AST_Var || is_safe_lexical(def)))) {\n                                in_use_ids[def.id] = true;\n                                in_use.push(def);\n                            }\n                            if (value) {\n                                if (!side_effects) {\n                                    initializations.add(def.id, value);\n                                } else if (shared) {\n                                    verify_safe_usage(def, name, value_modified[def.id]);\n                                }\n                                assignments.add(def.id, defn);\n                            }\n                            return true;\n                        }, tw);\n                        if (side_effects) value.walk(tw);\n                    });\n                    return true;\n                }\n                if (node instanceof AST_SymbolFunarg) {\n                    var def = node.definition();\n                    var_defs[def.id] = (var_defs[def.id] || 0) + 1;\n                    assignments.add(def.id, node);\n                    return true;\n                }\n                if (node instanceof AST_SymbolImport) {\n                    var def = node.definition();\n                    if (!(def.id in in_use_ids) && (!drop_vars || !is_safe_lexical(def))) {\n                        in_use_ids[def.id] = true;\n                        in_use.push(def);\n                    }\n                    return true;\n                }\n            }\n            return scan_ref_scoped(node, descend, true);\n        });\n        tw.directives = Object.create(compressor.directives);\n        self.walk(tw);\n        var drop_fn_name = compressor.option(\"keep_fnames\") ? return_false : compressor.option(\"ie\") ? function(def) {\n            return !compressor.exposed(def) && def.references.length == def.replaced;\n        } : function(def) {\n            if (!(def.id in in_use_ids)) return true;\n            if (def.orig.length - def.eliminated < 2) return false;\n            // function argument will always overshadow its name\n            if (def.orig[1] instanceof AST_SymbolFunarg) return true;\n            // retain if referenced within destructured object of argument\n            return all(def.references, function(ref) {\n                return !ref.in_arg;\n            });\n        };\n        if (compressor.option(\"ie\")) initializations.each(function(init, id) {\n            if (id in in_use_ids) return;\n            init.forEach(function(init) {\n                init.walk(new TreeWalker(function(node) {\n                    if (node instanceof AST_Function && node.name && !drop_fn_name(node.name.definition())) {\n                        node.walk(tw);\n                        return true;\n                    }\n                    if (node instanceof AST_Scope) return true;\n                }));\n            });\n        });\n        // pass 2: for every used symbol we need to walk its\n        // initialization code to figure out if it uses other\n        // symbols (that may not be in_use).\n        tw = new TreeWalker(scan_ref_scoped);\n        for (var i = 0; i < in_use.length; i++) {\n            var init = initializations.get(in_use[i].id);\n            if (init) init.forEach(function(init) {\n                init.walk(tw);\n            });\n        }\n        Object.keys(assign_in_use).forEach(function(id) {\n            var assigns = assign_in_use[id];\n            if (!assigns) {\n                delete assign_in_use[id];\n                return;\n            }\n            assigns = assigns.reduce(function(in_use, assigns) {\n                assigns.forEach(function(assign) {\n                    push_uniq(in_use, assign);\n                });\n                return in_use;\n            }, []);\n            var in_use = (assignments.get(id) || []).filter(function(node) {\n                return find_if(node instanceof AST_Unary ? function(assign) {\n                    return assign === node;\n                } : function(assign) {\n                    if (assign === node) return true;\n                    if (assign instanceof AST_Unary) return false;\n                    return get_rvalue(assign) === get_rvalue(node);\n                }, assigns);\n            });\n            if (assigns.length == in_use.length) {\n                assign_in_use[id] = in_use;\n            } else {\n                delete assign_in_use[id];\n            }\n        });\n        // pass 3: we should drop declarations not in_use\n        var trim_defns = [];\n        var unused_fn_names = [];\n        var calls_to_drop_args = [];\n        var fns_with_marked_args = [];\n        var trimmer = new TreeTransformer(function(node) {\n            if (node instanceof AST_DefaultValue) return trim_default(trimmer, node);\n            if (node instanceof AST_Destructured && node.rest) node.rest = node.rest.transform(trimmer);\n            if (node instanceof AST_DestructuredArray) {\n                var trim = !node.rest;\n                for (var i = node.elements.length; --i >= 0;) {\n                    var element = node.elements[i].transform(trimmer);\n                    if (element) {\n                        node.elements[i] = element;\n                        trim = false;\n                    } else if (trim) {\n                        node.elements.pop();\n                    } else {\n                        node.elements[i] = make_node(AST_Hole, node.elements[i]);\n                    }\n                }\n                return node;\n            }\n            if (node instanceof AST_DestructuredObject) {\n                var properties = [];\n                node.properties.forEach(function(prop) {\n                    var retain = false;\n                    if (prop.key instanceof AST_Node) {\n                        prop.key = prop.key.transform(tt);\n                        retain = prop.key.has_side_effects(compressor);\n                    }\n                    if ((retain || node.rest) && is_decl(prop.value)) {\n                        prop.value = prop.value.transform(tt);\n                        properties.push(prop);\n                    } else {\n                        var value = prop.value.transform(trimmer);\n                        if (!value && node.rest) {\n                            if (prop.value instanceof AST_DestructuredArray) {\n                                value = make_node(AST_DestructuredArray, prop.value, { elements: [] });\n                            } else {\n                                value = make_node(AST_DestructuredObject, prop.value, { properties: [] });\n                            }\n                        }\n                        if (value) {\n                            prop.value = value;\n                            properties.push(prop);\n                        }\n                    }\n                });\n                node.properties = properties;\n                return node;\n            }\n            if (node instanceof AST_SymbolDeclaration) return node.definition().id in in_use_ids ? node : null;\n        });\n        var tt = new TreeTransformer(function(node, descend, in_list) {\n            var parent = tt.parent();\n            if (drop_vars) {\n                var props = [], sym = assign_as_unused(node, props);\n                if (sym) {\n                    var value;\n                    if (can_drop_lhs(sym, node)) {\n                        if (node instanceof AST_Assign) {\n                            value = get_rhs(node);\n                            if (node.write_only === true) value = value.drop_side_effect_free(compressor);\n                        }\n                        if (!value) value = make_node(AST_Number, node, { value: 0 });\n                    }\n                    if (value) {\n                        if (props.assign) {\n                            var assign = props.assign.drop_side_effect_free(compressor);\n                            if (assign) {\n                                assign.write_only = true;\n                                props.unshift(assign);\n                            }\n                        }\n                        if (!(parent instanceof AST_Sequence)\n                            || parent.tail_node() === node\n                            || value.has_side_effects(compressor)) {\n                            props.push(value);\n                        }\n                        switch (props.length) {\n                          case 0:\n                            return List.skip;\n                          case 1:\n                            return maintain_this_binding(compressor, parent, node, props[0].transform(tt));\n                          default:\n                            return make_sequence(node, props.map(function(prop) {\n                                return prop.transform(tt);\n                            }));\n                        }\n                    }\n                } else if (node instanceof AST_UnaryPostfix\n                    && node.expression instanceof AST_SymbolRef\n                    && indexOf_assign(node.expression.definition(), node) < 0) {\n                    return make_node(AST_UnaryPrefix, node, {\n                        operator: \"+\",\n                        expression: node.expression\n                    });\n                }\n            }\n            if (node instanceof AST_Call) calls_to_drop_args.push(node);\n            if (scope !== self) return;\n            if (drop_funcs && node !== self && node instanceof AST_DefClass) {\n                var def = node.name.definition();\n                if (!(def.id in in_use_ids)) {\n                    log(node.name, \"Dropping unused class {name}\");\n                    def.eliminated++;\n                    descend(node, tt);\n                    if (parent instanceof AST_ExportDefault) return to_class_expr(node, true);\n                    var trimmed = node.drop_side_effect_free(compressor, true);\n                    if (trimmed === node) trimmed = to_class_expr(node, true);\n                    if (trimmed) return make_node(AST_SimpleStatement, node, { body: trimmed });\n                    return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                }\n            }\n            if (node instanceof AST_ClassExpression && node.name && drop_fn_name(node.name.definition())) {\n                unused_fn_names.push(node);\n            }\n            if (node instanceof AST_Lambda) {\n                if (drop_funcs && node !== self && node instanceof AST_LambdaDefinition) {\n                    var def = node.name.definition();\n                    if (!(def.id in in_use_ids)) {\n                        log(node.name, \"Dropping unused function {name}\");\n                        def.eliminated++;\n                        if (parent instanceof AST_ExportDefault) {\n                            descend_scope();\n                            return to_func_expr(node, true);\n                        }\n                        return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                    }\n                }\n                if (node instanceof AST_LambdaExpression && node.name && drop_fn_name(node.name.definition())) {\n                    unused_fn_names.push(node);\n                }\n                if (!(node instanceof AST_Accessor)) {\n                    if (node.rest) {\n                        var rest = node.rest.transform(trimmer);\n                        if (rest instanceof AST_Destructured && !rest.rest\n                            && (!node.uses_arguments || tt.has_directive(\"use strict\"))) {\n                            if (rest instanceof AST_DestructuredArray) {\n                                if (rest.elements.length == 0) rest = null;\n                            } else if (rest.properties.length == 0) {\n                                rest = null;\n                            }\n                        }\n                        node.rest = rest;\n                    }\n                    var argnames = node.argnames;\n                    var trim = compressor.drop_fargs(node, parent) && !node.rest;\n                    var default_length = trim ? -1 : node.length();\n                    for (var i = argnames.length; --i >= 0;) {\n                        var sym = argnames[i];\n                        if (!(sym instanceof AST_SymbolFunarg)) {\n                            var arg = sym.transform(trimmer);\n                            if (arg) {\n                                trim = false;\n                            } else if (trim) {\n                                log(sym.name, \"Dropping unused default argument {name}\");\n                                argnames.pop();\n                            } else if (i > default_length) {\n                                log(sym.name, \"Dropping unused default argument assignment {name}\");\n                                sym.name.unused = true;\n                                argnames[i] = sym.name;\n                            } else {\n                                log(sym.name, \"Dropping unused default argument value {name}\");\n                                sym.value = make_node(AST_Number, sym, { value: 0 });\n                            }\n                            continue;\n                        }\n                        var def = sym.definition();\n                        if (def.id in in_use_ids) {\n                            trim = false;\n                            if (indexOf_assign(def, sym) < 0) sym.unused = null;\n                        } else if (trim) {\n                            log(sym, \"Dropping unused function argument {name}\");\n                            argnames.pop();\n                        } else {\n                            sym.unused = true;\n                        }\n                    }\n                    fns_with_marked_args.push(node);\n                }\n            }\n            if (node instanceof AST_Catch && node.argname instanceof AST_Destructured) {\n                node.argname.transform(trimmer);\n            }\n            if (node instanceof AST_Definitions && !(parent instanceof AST_ForEnumeration && parent.init === node)) {\n                // place uninitialized names at the start\n                var body = [], head = [], tail = [];\n                // for unused names whose initialization has\n                // side effects, we can cascade the init. code\n                // into the next one, or next statement.\n                var side_effects = [];\n                var duplicated = 0;\n                var is_var = node instanceof AST_Var;\n                node.definitions.forEach(function(def) {\n                    if (def.value) def.value = def.value.transform(tt);\n                    var value = def.value;\n                    if (def.name instanceof AST_Destructured) {\n                        var trimmed = trim_destructured(def.name, value, function(node) {\n                            if (!drop_vars) return node;\n                            if (node.definition().id in in_use_ids) return node;\n                            if (is_catch(node)) return node;\n                            if (is_var && !can_drop_symbol(node)) return node;\n                            return null;\n                        }, true);\n                        if (trimmed.name) {\n                            def = make_node(AST_VarDef, def, {\n                                name: trimmed.name,\n                                value: value = trimmed.value,\n                            });\n                            flush();\n                        } else if (trimmed.value) {\n                            side_effects.push(trimmed.value);\n                        }\n                        return;\n                    }\n                    var sym = def.name.definition();\n                    var drop_sym = is_var ? can_drop_symbol(def.name) : is_safe_lexical(sym);\n                    if (!drop_sym || !drop_vars || sym.id in in_use_ids) {\n                        if (value && indexOf_assign(sym, def) < 0) {\n                            value = value.drop_side_effect_free(compressor);\n                            if (value) {\n                                AST_Node.warn(\"Side effects in definition of variable {name} [{file}:{line},{col}]\", template(def.name));\n                                side_effects.push(value);\n                            }\n                            value = null;\n                            trim_defns.push(def);\n                        }\n                        var old_def;\n                        if (!value && !(node instanceof AST_Let)) {\n                            if (parent instanceof AST_ExportDeclaration) {\n                                flush();\n                            } else if (drop_sym && var_defs[sym.id] > 1) {\n                                AST_Node.info(\"Dropping declaration of variable {name} [{file}:{line},{col}]\", template(def.name));\n                                var_defs[sym.id]--;\n                                sym.eliminated++;\n                            } else {\n                                head.push(def);\n                            }\n                        } else if (compressor.option(\"functions\")\n                            && !compressor.option(\"ie\")\n                            && drop_sym\n                            && var_defs[sym.id] == 1\n                            && sym.assignments == 0\n                            && value instanceof AST_LambdaExpression\n                            && !is_arguments(sym)\n                            && !is_arrow(value)\n                            && assigned_once(value, sym.references)\n                            && can_declare_defun(value)\n                            && (old_def = rename_def(value, def.name.name)) !== false) {\n                            AST_Node.warn(\"Declaring {name} as function [{file}:{line},{col}]\", template(def.name));\n                            var ctor;\n                            switch (value.CTOR) {\n                              case AST_AsyncFunction:\n                                ctor = AST_AsyncDefun;\n                                break;\n                              case AST_AsyncGeneratorFunction:\n                                ctor = AST_AsyncGeneratorDefun;\n                                break;\n                              case AST_Function:\n                                ctor = AST_Defun;\n                                break;\n                              case AST_GeneratorFunction:\n                                ctor = AST_GeneratorDefun;\n                                break;\n                            }\n                            var defun = make_node(ctor, def, value);\n                            defun.name = make_node(AST_SymbolDefun, def.name, def.name);\n                            var name_def = def.name.scope.resolve().def_function(defun.name);\n                            if (old_def) old_def.forEach(function(node) {\n                                node.name = name_def.name;\n                                node.thedef = name_def;\n                                node.reference();\n                            });\n                            body.push(defun);\n                        } else {\n                            if (drop_sym\n                                && var_defs[sym.id] > 1\n                                && !(parent instanceof AST_ExportDeclaration)\n                                && sym.orig.indexOf(def.name) > sym.eliminated) {\n                                var_defs[sym.id]--;\n                                duplicated++;\n                            }\n                            flush();\n                        }\n                    } else if (is_catch(def.name)) {\n                        value = value && value.drop_side_effect_free(compressor);\n                        if (value) side_effects.push(value);\n                        if (var_defs[sym.id] > 1) {\n                            AST_Node.warn(\"Dropping duplicated declaration of variable {name} [{file}:{line},{col}]\", template(def.name));\n                            var_defs[sym.id]--;\n                            sym.eliminated++;\n                        } else {\n                            def.value = null;\n                            head.push(def);\n                        }\n                    } else {\n                        value = value && !value.single_use && value.drop_side_effect_free(compressor);\n                        if (value) {\n                            AST_Node.warn(\"Side effects in initialization of unused variable {name} [{file}:{line},{col}]\", template(def.name));\n                            side_effects.push(value);\n                        } else {\n                            log(def.name, \"Dropping unused variable {name}\");\n                        }\n                        sym.eliminated++;\n                    }\n\n                    function assigned_once(fn, refs) {\n                        if (refs.length == 0) return fn === def.name.fixed_value();\n                        return all(refs, function(ref) {\n                            return fn === ref.fixed_value();\n                        });\n                    }\n\n                    function can_declare_defun(fn) {\n                        if (!is_var || compressor.has_directive(\"use strict\") || !(fn instanceof AST_Function)) {\n                            return parent instanceof AST_Scope;\n                        }\n                        return parent instanceof AST_Block\n                            || parent instanceof AST_For && parent.init === node\n                            || parent instanceof AST_If;\n                    }\n\n                    function rename_def(fn, name) {\n                        if (!fn.name) return null;\n                        var def = fn.name.definition();\n                        if (def.orig.length > 1) return null;\n                        if (def.assignments > 0) return false;\n                        if (def.name == name) return def;\n                        var forbidden;\n                        switch (name) {\n                          case \"await\":\n                            forbidden = is_async;\n                            break;\n                          case \"yield\":\n                            forbidden = is_generator;\n                            break;\n                        }\n                        return all(def.references, function(ref) {\n                            var scope = ref.scope;\n                            if (scope.find_variable(name) !== sym) return false;\n                            if (forbidden) do {\n                                scope = scope.resolve();\n                                if (forbidden(scope)) return false;\n                            } while (scope !== fn && (scope = scope.parent_scope));\n                            return true;\n                        }) && def;\n                    }\n\n                    function is_catch(node) {\n                        var sym = node.definition();\n                        return sym.orig[0] instanceof AST_SymbolCatch && sym.scope.resolve() === node.scope.resolve();\n                    }\n\n                    function flush() {\n                        if (side_effects.length > 0) {\n                            if (tail.length == 0) {\n                                body.push(make_node(AST_SimpleStatement, node, {\n                                    body: make_sequence(node, side_effects),\n                                }));\n                            } else if (value) {\n                                side_effects.push(value);\n                                def.value = make_sequence(value, side_effects);\n                            } else {\n                                def.value = make_node(AST_UnaryPrefix, def, {\n                                    operator: \"void\",\n                                    expression: make_sequence(def, side_effects),\n                                });\n                            }\n                            side_effects = [];\n                        }\n                        tail.push(def);\n                    }\n                });\n                switch (head.length) {\n                  case 0:\n                    if (tail.length == 0) break;\n                    if (tail.length == duplicated) {\n                        [].unshift.apply(side_effects, tail.map(function(def) {\n                            AST_Node.info(\"Dropping duplicated definition of variable {name} [{file}:{line},{col}]\", template(def.name));\n                            var sym = def.name.definition();\n                            var ref = make_node(AST_SymbolRef, def.name, def.name);\n                            sym.references.push(ref);\n                            var assign = make_node(AST_Assign, def, {\n                                operator: \"=\",\n                                left: ref,\n                                right: def.value,\n                            });\n                            var index = indexOf_assign(sym, def);\n                            if (index >= 0) assign_in_use[sym.id][index] = assign;\n                            sym.eliminated++;\n                            return assign;\n                        }));\n                        break;\n                    }\n                  case 1:\n                    if (tail.length == 0) {\n                        var id = head[0].name.definition().id;\n                        if (id in for_ins) {\n                            node.definitions = head;\n                            for_ins[id].init = node;\n                            break;\n                        }\n                    }\n                  default:\n                    node.definitions = head.concat(tail);\n                    body.push(node);\n                }\n                if (side_effects.length > 0) {\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: make_sequence(node, side_effects)\n                    }));\n                }\n                return insert_statements(body, node, in_list);\n            }\n            if (node instanceof AST_Assign) {\n                descend(node, tt);\n                if (!(node.left instanceof AST_Destructured)) return node;\n                var trimmed = trim_destructured(node.left, node.right, function(node) {\n                    return node;\n                }, node.write_only === true);\n                if (trimmed.name) return make_node(AST_Assign, node, {\n                    operator: node.operator,\n                    left: trimmed.name,\n                    right: trimmed.value,\n                });\n                if (trimmed.value) return trimmed.value;\n                if (parent instanceof AST_Sequence && parent.tail_node() !== node) return List.skip;\n                return make_node(AST_Number, node, { value: 0 });\n            }\n            if (node instanceof AST_LabeledStatement && node.body instanceof AST_For) {\n                // Certain combination of unused name + side effect leads to invalid AST:\n                //    https://github.com/mishoo/UglifyJS/issues/1830\n                // We fix it at this stage by moving the label inwards, back to the `for`.\n                descend(node, tt);\n                if (node.body instanceof AST_BlockStatement) {\n                    var block = node.body;\n                    node.body = block.body.pop();\n                    block.body.push(node);\n                    return in_list ? List.splice(block.body) : block;\n                }\n                return node;\n            }\n            if (node instanceof AST_Scope) {\n                descend_scope();\n                return node;\n            }\n            if (node instanceof AST_SymbolImport) {\n                if (!compressor.option(\"imports\") || node.definition().id in in_use_ids) return node;\n                return in_list ? List.skip : null;\n            }\n\n            function descend_scope() {\n                var save_scope = scope;\n                scope = node;\n                descend(node, tt);\n                scope = save_scope;\n            }\n        }, function(node, in_list) {\n            if (node instanceof AST_BlockStatement) return trim_block(node, tt.parent(), in_list);\n            // Certain combination of unused name + side effect leads to invalid AST:\n            //    https://github.com/mishoo/UglifyJS/issues/44\n            //    https://github.com/mishoo/UglifyJS/issues/1838\n            //    https://github.com/mishoo/UglifyJS/issues/3371\n            // We fix it at this stage by moving the `var` outside the `for`.\n            if (node instanceof AST_For) {\n                var block;\n                if (node.init instanceof AST_BlockStatement) {\n                    block = node.init;\n                    node.init = block.body.pop();\n                    block.body.push(node);\n                }\n                if (node.init instanceof AST_Defun) {\n                    if (!block) {\n                        block = make_node(AST_BlockStatement, node, {\n                            body: [ node ]\n                        });\n                    }\n                    block.body.splice(-1, 0, node.init);\n                    node.init = null;\n                } else if (node.init instanceof AST_SimpleStatement) {\n                    node.init = node.init.body;\n                } else if (is_empty(node.init)) {\n                    node.init = null;\n                }\n                return !block ? node : in_list ? List.splice(block.body) : block;\n            }\n            if (node instanceof AST_ForIn) {\n                if (!drop_vars || !compressor.option(\"loops\")) return;\n                if (!is_empty(node.body)) return;\n                var sym = get_init_symbol(node);\n                if (!sym) return;\n                var def = sym.definition();\n                if (def.id in in_use_ids) return;\n                log(sym, \"Dropping unused loop variable {name}\");\n                if (for_ins[def.id] === node) delete for_ins[def.id];\n                var body = [];\n                var value = node.object.drop_side_effect_free(compressor);\n                if (value) {\n                    AST_Node.warn(\"Side effects in object of for-in loop [{file}:{line},{col}]\", value.start);\n                    body.push(make_node(AST_SimpleStatement, node, {\n                        body: value\n                    }));\n                }\n                if (node.init instanceof AST_Definitions && def.orig[0] instanceof AST_SymbolCatch) {\n                    body.push(node.init);\n                }\n                return insert_statements(body, node, in_list);\n            }\n            if (node instanceof AST_Import) {\n                if (node.properties && node.properties.length == 0) node.properties = null;\n                return node;\n            }\n            if (node instanceof AST_Sequence) {\n                if (node.expressions.length > 1) return;\n                return maintain_this_binding(compressor, tt.parent(), node, node.expressions[0]);\n            }\n        });\n        tt.push(compressor.parent());\n        self.transform(tt);\n        if (self instanceof AST_Lambda\n            && self.body.length == 1\n            && self.body[0] instanceof AST_Directive\n            && self.body[0].value == \"use strict\") {\n            self.body.length = 0;\n        }\n        trim_defns.forEach(function(def) {\n            def.value = null;\n        });\n        unused_fn_names.forEach(function(fn) {\n            fn.name = null;\n        });\n        calls_to_drop_args.forEach(function(call) {\n            drop_unused_call_args(call, compressor, fns_with_marked_args);\n        });\n\n        function log(sym, text) {\n            AST_Node[sym.definition().references.length > 0 ? \"info\" : \"warn\"](text + \" [{file}:{line},{col}]\", template(sym));\n        }\n\n        function template(sym) {\n            return {\n                name: sym.name,\n                file: sym.start.file,\n                line: sym.start.line,\n                col : sym.start.col,\n            };\n        }\n\n        function get_rvalue(expr) {\n            return expr[expr instanceof AST_Assign ? \"right\" : \"value\"];\n        }\n\n        function insert_statements(body, orig, in_list) {\n            switch (body.length) {\n              case 0:\n                return in_list ? List.skip : make_node(AST_EmptyStatement, orig);\n              case 1:\n                return body[0];\n              default:\n                return in_list ? List.splice(body) : make_node(AST_BlockStatement, orig, {\n                    body: body\n                });\n            }\n        }\n\n        function track_assigns(def, node) {\n            if (def.scope.resolve() !== self) return false;\n            if (!def.fixed || !node.fixed) assign_in_use[def.id] = false;\n            return assign_in_use[def.id] !== false;\n        }\n\n        function add_assigns(def, node) {\n            if (!assign_in_use[def.id]) assign_in_use[def.id] = [];\n            if (node.fixed.assigns) push_uniq(assign_in_use[def.id], node.fixed.assigns);\n        }\n\n        function indexOf_assign(def, node) {\n            var nodes = assign_in_use[def.id];\n            return nodes && nodes.indexOf(node);\n        }\n\n        function verify_safe_usage(def, read, modified) {\n            if (def.id in in_use_ids) return;\n            if (read && modified) {\n                in_use_ids[def.id] = read;\n                in_use.push(def);\n            } else {\n                value_read[def.id] = read;\n                value_modified[def.id] = modified;\n            }\n        }\n\n        function can_drop_lhs(sym, node) {\n            var def = sym.definition();\n            var in_use = in_use_ids[def.id];\n            if (!in_use) return true;\n            if (node[node instanceof AST_Assign ? \"left\" : \"expression\"] !== sym) return false;\n            return in_use === sym && def.references.length - def.replaced == 1 || indexOf_assign(def, node) < 0;\n        }\n\n        function get_rhs(assign) {\n            var rhs = assign.right;\n            if (!assign.write_only) return rhs;\n            if (!(rhs instanceof AST_Binary && lazy_op[rhs.operator])) return rhs;\n            if (!(rhs.left instanceof AST_SymbolRef)) return rhs;\n            if (!(assign.left instanceof AST_SymbolRef)) return rhs;\n            var def = assign.left.definition();\n            if (rhs.left.definition() !== def) return rhs;\n            if (rhs.right.has_side_effects(compressor)) return rhs;\n            if (track_assigns(def, rhs.left)) add_assigns(def, rhs.left);\n            return rhs.right;\n        }\n\n        function get_init_symbol(for_in) {\n            var init = for_in.init;\n            if (init instanceof AST_Definitions) {\n                init = init.definitions[0].name;\n                return init instanceof AST_SymbolDeclaration && init;\n            }\n            while (init instanceof AST_PropAccess) init = init.expression.tail_node();\n            if (init instanceof AST_SymbolRef) return init;\n        }\n\n        function scan_ref_scoped(node, descend, init) {\n            if (node instanceof AST_Assign && node.left instanceof AST_SymbolRef) {\n                var def = node.left.definition();\n                if (def.scope.resolve() === self) assignments.add(def.id, node);\n            }\n            if (node instanceof AST_Unary && node.expression instanceof AST_SymbolRef) {\n                var def = node.expression.definition();\n                if (def.scope.resolve() === self) assignments.add(def.id, node);\n            }\n            var node_def, props = [], sym = assign_as_unused(node, props);\n            if (sym && ((node_def = sym.definition()).scope.resolve() === self\n                    || self.variables.get(sym.name) === node_def)\n                && !(is_arguments(node_def) && !all(self.argnames, function(argname) {\n                    return !argname.match_symbol(function(node) {\n                        if (node instanceof AST_SymbolFunarg) {\n                            var def = node.definition();\n                            return def.references.length > def.replaced;\n                        }\n                    }, true);\n                }))) {\n                if (node.write_only === \"p\" && node.right.may_throw_on_access(compressor, true)) return;\n                var assign = props.assign;\n                if (assign) {\n                    assign.write_only = true;\n                    assign.walk(tw);\n                }\n                props.forEach(function(prop) {\n                    prop.walk(tw);\n                });\n                if (node instanceof AST_Assign) {\n                    var right = get_rhs(node), shared = false;\n                    if (init && node.write_only === true && !right.has_side_effects(compressor)) {\n                        initializations.add(node_def.id, right);\n                    } else {\n                        right.walk(tw);\n                        shared = right.tail_node().operator == \"=\";\n                    }\n                    if (node.left === sym) {\n                        if (!node.write_only || shared) {\n                            verify_safe_usage(node_def, sym, value_modified[node_def.id]);\n                        }\n                    } else {\n                        var fixed = sym.fixed_value();\n                        if (!fixed || !fixed.is_constant()) {\n                            verify_safe_usage(node_def, value_read[node_def.id], true);\n                        }\n                    }\n                }\n                if (track_assigns(node_def, sym) && is_lhs(sym, node) !== sym) add_assigns(node_def, sym);\n                return true;\n            }\n            if (node instanceof AST_ForIn) {\n                if (node.init instanceof AST_SymbolRef && scope === self) {\n                    var id = node.init.definition().id;\n                    if (!(id in for_ins)) for_ins[id] = node;\n                }\n                if (!drop_vars || !compressor.option(\"loops\")) return;\n                if (!is_empty(node.body)) return;\n                if (node.init.has_side_effects(compressor)) return;\n                var sym = get_init_symbol(node);\n                if (!sym) return;\n                var def = sym.definition();\n                if (def.scope.resolve() !== self) {\n                    var d = find_variable(sym.name);\n                    if (d === def || d && d.redefined() === def) return;\n                }\n                node.object.walk(tw);\n                return true;\n            }\n            if (node instanceof AST_SymbolRef) {\n                node_def = node.definition();\n                if (!(node_def.id in in_use_ids)) {\n                    in_use_ids[node_def.id] = true;\n                    in_use.push(node_def);\n                }\n                if (cross_scope(node_def.scope, node.scope)) {\n                    var redef = node_def.redefined();\n                    if (redef && !(redef.id in in_use_ids)) {\n                        in_use_ids[redef.id] = true;\n                        in_use.push(redef);\n                    }\n                }\n                if (track_assigns(node_def, node)) add_assigns(node_def, node);\n                return true;\n            }\n            if (node instanceof AST_Scope) {\n                var save_scope = scope;\n                scope = node;\n                descend();\n                scope = save_scope;\n                return true;\n            }\n        }\n\n        function is_decl(node) {\n            return (node instanceof AST_DefaultValue ? node.name : node) instanceof AST_SymbolDeclaration;\n        }\n\n        function trim_default(trimmer, node) {\n            node.value = node.value.transform(tt);\n            var name = node.name.transform(trimmer);\n            if (!name) {\n                if (node.name instanceof AST_Destructured) return null;\n                var value = node.value.drop_side_effect_free(compressor);\n                if (!value) return null;\n                log(node.name, \"Side effects in default value of unused variable {name}\");\n                node.name.unused = null;\n                node.value = value;\n            }\n            return node;\n        }\n\n        function trim_destructured(node, value, process, drop) {\n            var trimmer = new TreeTransformer(function(node) {\n                if (node instanceof AST_DefaultValue) {\n                    if (compressor.option(\"default_values\") && value && value.is_defined(compressor)) {\n                        node = node.name;\n                    } else {\n                        var save_drop = drop;\n                        drop = false;\n                        var trimmed = trim_default(trimmer, node);\n                        drop = save_drop;\n                        if (!trimmed && drop && value) value = value.drop_side_effect_free(compressor);\n                        return trimmed;\n                    }\n                }\n                if (node instanceof AST_DestructuredArray) {\n                    var save_drop = drop;\n                    var save_value = value;\n                    if (value instanceof AST_SymbolRef) {\n                        drop = false;\n                        value = value.fixed_value();\n                    }\n                    var values = value instanceof AST_Array && value.elements;\n                    var elements = [], newValues = drop && [], pos = 0;\n                    node.elements.forEach(function(element, index) {\n                        value = values && values[index];\n                        if (value instanceof AST_Hole) {\n                            value = null;\n                        } else if (value instanceof AST_Spread) {\n                            if (drop) {\n                                newValues.length = pos;\n                                fill_holes(save_value, newValues);\n                                [].push.apply(newValues, values.slice(index));\n                                save_value.elements = newValues;\n                            }\n                            value = values = false;\n                        }\n                        element = element.transform(trimmer);\n                        if (element) elements[pos] = element;\n                        if (drop && value) newValues[pos] = value;\n                        if (element || value || !drop || !values) pos++;\n                    });\n                    value = values && make_node(AST_Array, save_value, {\n                        elements: values.slice(node.elements.length),\n                    });\n                    if (node.rest) {\n                        var was_drop = drop;\n                        drop = false;\n                        node.rest = node.rest.transform(compressor.option(\"rests\") ? trimmer : tt);\n                        drop = was_drop;\n                        if (node.rest) elements.length = pos;\n                    }\n                    if (drop) {\n                        if (value && !node.rest) value = value.drop_side_effect_free(compressor);\n                        if (value instanceof AST_Array) {\n                            value = value.elements;\n                        } else if (value instanceof AST_Sequence) {\n                            value = value.expressions;\n                        } else if (value) {\n                            value = [ value ];\n                        }\n                        if (value && value.length) {\n                            newValues.length = pos;\n                            [].push.apply(newValues, value);\n                        }\n                    }\n                    value = save_value;\n                    drop = save_drop;\n                    if (values && newValues) {\n                        fill_holes(value, newValues);\n                        value.elements = newValues;\n                    }\n                    if (!node.rest && (value instanceof AST_Array\n                        || value && value.is_string(compressor))) switch (elements.length) {\n                      case 0:\n                        if (drop) value = value.drop_side_effect_free(compressor);\n                        return null;\n                      case 1:\n                        if (!drop) break;\n                        var sym = elements[0];\n                        if (sym.has_side_effects(compressor)) break;\n                        if (value.has_side_effects(compressor) && sym.match_symbol(function(node) {\n                            return node instanceof AST_PropAccess;\n                        })) break;\n                        value = make_node(AST_Sub, node, {\n                            expression: value,\n                            property: make_node(AST_Number, node, { value: 0 }),\n                        });\n                        return sym;\n                    }\n                    fill_holes(node, elements);\n                    node.elements = elements;\n                    return node;\n                }\n                if (node instanceof AST_DestructuredObject) {\n                    var save_drop = drop;\n                    var save_value = value;\n                    if (value instanceof AST_SymbolRef) {\n                        drop = false;\n                        value = value.fixed_value();\n                    }\n                    var prop_keys, prop_map;\n                    if (value instanceof AST_Object) {\n                        prop_keys = [];\n                        prop_map = new Dictionary();\n                        value.properties.forEach(function(prop, index) {\n                            if (prop instanceof AST_Spread) return prop_map = false;\n                            var key = prop.key;\n                            if (key instanceof AST_Node) key = key.evaluate(compressor, true);\n                            if (key instanceof AST_Node) {\n                                prop_map = false;\n                            } else if (prop_map && !(prop instanceof AST_ObjectSetter)) {\n                                prop_map.set(key, prop);\n                            }\n                            prop_keys[index] = key;\n                        });\n                    }\n                    if (node.rest) {\n                        value = false;\n                        node.rest = node.rest.transform(compressor.option(\"rests\") ? trimmer : tt);\n                    }\n                    var can_drop = new Dictionary();\n                    var drop_keys = drop && new Dictionary();\n                    var properties = [];\n                    node.properties.map(function(prop) {\n                        var key = prop.key;\n                        if (key instanceof AST_Node) {\n                            prop.key = key = key.transform(tt);\n                            key = key.evaluate(compressor, true);\n                        }\n                        if (key instanceof AST_Node) {\n                            drop_keys = false;\n                        } else {\n                            can_drop.set(key, !can_drop.has(key));\n                        }\n                        return key;\n                    }).forEach(function(key, index) {\n                        var prop = node.properties[index], trimmed;\n                        if (key instanceof AST_Node) {\n                            drop = false;\n                            value = false;\n                            trimmed = prop.value.transform(trimmer) || retain_lhs(prop.value);\n                        } else {\n                            drop = drop_keys && can_drop.get(key);\n                            var mapped = prop_map && prop_map.get(key);\n                            if (mapped) {\n                                value = mapped.value;\n                                if (value instanceof AST_Accessor) value = false;\n                            } else {\n                                value = false;\n                            }\n                            trimmed = prop.value.transform(trimmer);\n                            if (!trimmed) {\n                                if (node.rest || retain_key(prop)) trimmed = retain_lhs(prop.value);\n                                if (drop_keys && !drop_keys.has(key)) {\n                                    if (mapped) {\n                                        drop_keys.set(key, mapped);\n                                        if (value === null) {\n                                            prop_map.set(key, retain_key(mapped) && make_node(AST_ObjectKeyVal, mapped, {\n                                                key: mapped.key,\n                                                value: make_node(AST_Number, mapped, { value: 0 }),\n                                            }));\n                                        }\n                                    } else {\n                                        drop_keys.set(key, true);\n                                    }\n                                }\n                            } else if (drop_keys) {\n                                drop_keys.set(key, false);\n                            }\n                            if (value) mapped.value = value;\n                        }\n                        if (trimmed) {\n                            prop.value = trimmed;\n                            properties.push(prop);\n                        }\n                    });\n                    value = save_value;\n                    drop = save_drop;\n                    if (drop_keys && prop_keys) value.properties = List(value.properties, function(prop, index) {\n                        if (prop instanceof AST_Spread) return prop;\n                        var key = prop_keys[index];\n                        if (key instanceof AST_Node) return prop;\n                        if (drop_keys.has(key)) {\n                            var mapped = drop_keys.get(key);\n                            if (!mapped) return prop;\n                            if (mapped === prop) return prop_map.get(key) || List.skip;\n                        } else if (node.rest) {\n                            return prop;\n                        }\n                        var trimmed = prop.value.drop_side_effect_free(compressor);\n                        if (trimmed) {\n                            prop.value = trimmed;\n                            return prop;\n                        }\n                        return retain_key(prop) ? make_node(AST_ObjectKeyVal, prop, {\n                            key: prop.key,\n                            value: make_node(AST_Number, prop, { value: 0 }),\n                        }) : List.skip;\n                    });\n                    if (value && !node.rest) switch (properties.length) {\n                      case 0:\n                        if (value.may_throw_on_access(compressor, true)) break;\n                        if (drop) value = value.drop_side_effect_free(compressor);\n                        return null;\n                      case 1:\n                        if (!drop) break;\n                        var prop = properties[0];\n                        if (prop.key instanceof AST_Node) break;\n                        if (prop.value.has_side_effects(compressor)) break;\n                        if (value.has_side_effects(compressor) && prop.value.match_symbol(function(node) {\n                            return node instanceof AST_PropAccess;\n                        })) break;\n                        value = make_node(AST_Sub, node, {\n                            expression: value,\n                            property: make_node_from_constant(prop.key, prop),\n                        });\n                        return prop.value;\n                    }\n                    node.properties = properties;\n                    return node;\n                }\n                if (node instanceof AST_Hole) {\n                    node = null;\n                } else {\n                    node = process(node);\n                }\n                if (!node && drop && value) value = value.drop_side_effect_free(compressor);\n                return node;\n            });\n            return {\n                name: node.transform(trimmer),\n                value: value,\n            };\n\n            function retain_key(prop) {\n                return prop.key instanceof AST_Node && prop.key.has_side_effects(compressor);\n            }\n\n            function retain_lhs(node) {\n                if (node instanceof AST_DefaultValue) return retain_lhs(node.name);\n                if (node instanceof AST_Destructured) {\n                    if (value === null) {\n                        value = make_node(AST_Number, node, { value: 0 });\n                    } else if (value && (value.tail_node().write_only === true\n                        || value.may_throw_on_access(compressor, true))) {\n                        value = make_node(AST_Array, node, {\n                            elements: value instanceof AST_Sequence ? value.expressions : [ value ],\n                        });\n                    }\n                    return make_node(AST_DestructuredObject, node, { properties: [] });\n                }\n                node.unused = null;\n                return node;\n            }\n        }\n    });\n\n    AST_Scope.DEFMETHOD(\"hoist_declarations\", function(compressor) {\n        if (compressor.has_directive(\"use asm\")) return;\n        var hoist_funs = compressor.option(\"hoist_funs\");\n        var hoist_vars = compressor.option(\"hoist_vars\");\n        var self = this;\n        if (hoist_vars) {\n            // let's count var_decl first, we seem to waste a lot of\n            // space if we hoist `var` when there's only one.\n            var var_decl = 0;\n            self.walk(new TreeWalker(function(node) {\n                if (var_decl > 1) return true;\n                if (node instanceof AST_ExportDeclaration) return true;\n                if (node instanceof AST_Scope && node !== self) return true;\n                if (node instanceof AST_Var) {\n                    var_decl++;\n                    return true;\n                }\n            }));\n            if (var_decl <= 1) hoist_vars = false;\n        }\n        if (!hoist_funs && !hoist_vars) return;\n        var consts = new Dictionary();\n        var dirs = [];\n        var hoisted = [];\n        var vars = new Dictionary(), vars_found = 0;\n        var tt = new TreeTransformer(function(node, descend, in_list) {\n            if (node === self) return;\n            if (node instanceof AST_Directive) {\n                dirs.push(node);\n                return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n            }\n            if (node instanceof AST_LambdaDefinition) {\n                if (!hoist_funs) return node;\n                var p = tt.parent();\n                if (p instanceof AST_ExportDeclaration) return node;\n                if (p instanceof AST_ExportDefault) return node;\n                if (p !== self && compressor.has_directive(\"use strict\")) return node;\n                hoisted.push(node);\n                return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n            }\n            if (node instanceof AST_Var) {\n                if (!hoist_vars) return node;\n                var p = tt.parent();\n                if (p instanceof AST_ExportDeclaration) return node;\n                if (!all(node.definitions, function(defn) {\n                    var sym = defn.name;\n                    return sym instanceof AST_SymbolVar\n                        && !consts.has(sym.name)\n                        && self.find_variable(sym.name) === sym.definition();\n                })) return node;\n                node.definitions.forEach(function(def) {\n                    vars.set(def.name.name, def);\n                    ++vars_found;\n                });\n                var seq = node.to_assignments();\n                if (p instanceof AST_ForEnumeration && p.init === node) {\n                    if (seq) return seq;\n                    var def = node.definitions[0].name;\n                    return make_node(AST_SymbolRef, def, def);\n                }\n                if (p instanceof AST_For && p.init === node) return seq;\n                if (!seq) return in_list ? List.skip : make_node(AST_EmptyStatement, node);\n                return make_node(AST_SimpleStatement, node, { body: seq });\n            }\n            if (node instanceof AST_Scope) return node;\n            if (node instanceof AST_SymbolConst) {\n                consts.set(node.name, true);\n                return node;\n            }\n        });\n        self.transform(tt);\n        if (vars_found > 0) {\n            // collect only vars which don't show up in self's arguments list\n            var defs = [];\n            if (self instanceof AST_Lambda) self.each_argname(function(argname) {\n                vars.del(argname.name);\n            });\n            vars.each(function(def, name) {\n                def = def.clone();\n                def.value = null;\n                defs.push(def);\n                vars.set(name, def);\n            });\n            if (defs.length > 0) {\n                // try to merge in assignments\n                insert_vars(self.body);\n                defs = make_node(AST_Var, self, { definitions: defs });\n                hoisted.push(defs);\n            }\n        }\n        self.body = dirs.concat(hoisted, self.body);\n\n        function insert_vars(body) {\n            while (body.length) {\n                var stat = body[0];\n                if (stat instanceof AST_SimpleStatement) {\n                    var expr = stat.body, sym, assign;\n                    if (expr instanceof AST_Assign\n                        && expr.operator == \"=\"\n                        && (sym = expr.left) instanceof AST_Symbol\n                        && vars.has(sym.name)) {\n                        var def = vars.get(sym.name);\n                        if (def.value) break;\n                        var value = expr.right;\n                        if (value instanceof AST_Sequence) value = value.clone();\n                        def.value = value;\n                        remove(defs, def);\n                        defs.push(def);\n                        body.shift();\n                        continue;\n                    }\n                    if (expr instanceof AST_Sequence\n                        && (assign = expr.expressions[0]) instanceof AST_Assign\n                        && assign.operator == \"=\"\n                        && (sym = assign.left) instanceof AST_Symbol\n                        && vars.has(sym.name)) {\n                        var def = vars.get(sym.name);\n                        if (def.value) break;\n                        def.value = assign.right;\n                        remove(defs, def);\n                        defs.push(def);\n                        stat.body = make_sequence(expr, expr.expressions.slice(1));\n                        continue;\n                    }\n                }\n                if (stat instanceof AST_EmptyStatement) {\n                    body.shift();\n                    continue;\n                }\n                if (stat instanceof AST_BlockStatement && !insert_vars(stat.body)) {\n                    body.shift();\n                    continue;\n                }\n                break;\n            }\n            return body.length;\n        }\n    });\n\n    function scan_local_returns(fn, transform) {\n        fn.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_Return) {\n                transform(node);\n                return true;\n            }\n            if (node instanceof AST_Scope && node !== fn) return true;\n        }));\n    }\n\n    function map_bool_returns(fn) {\n        var map = Object.create(null);\n        scan_local_returns(fn, function(node) {\n            var value = node.value;\n            if (value) value = value.tail_node();\n            if (value instanceof AST_SymbolRef) {\n                var id = value.definition().id;\n                map[id] = (map[id] || 0) + 1;\n            }\n        });\n        return map;\n    }\n\n    function all_bool(def, bool_returns, compressor) {\n        return def.bool_fn + (bool_returns[def.id] || 0) === def.references.length - def.replaced\n            && !compressor.exposed(def);\n    }\n\n    function process_boolean_returns(fn, compressor) {\n        scan_local_returns(fn, function(node) {\n            node.in_bool = true;\n            var value = node.value;\n            if (value) {\n                var ev = fuzzy_eval(compressor, value);\n                if (!ev) {\n                    value = value.drop_side_effect_free(compressor);\n                    node.value = value ? make_sequence(node.value, [\n                        value,\n                        make_node(AST_Number, node.value, { value: 0 }),\n                    ]) : null;\n                } else if (!(ev instanceof AST_Node)) {\n                    value = value.drop_side_effect_free(compressor);\n                    node.value = value ? make_sequence(node.value, [\n                        value,\n                        make_node(AST_Number, node.value, { value: 1 }),\n                    ]) : make_node(AST_Number, node.value, { value: 1 });\n                }\n            }\n        });\n    }\n\n    AST_Scope.DEFMETHOD(\"process_boolean_returns\", noop);\n    AST_Defun.DEFMETHOD(\"process_boolean_returns\", function(compressor) {\n        if (!compressor.option(\"booleans\")) return;\n        var bool_returns = map_bool_returns(this);\n        if (!all_bool(this.name.definition(), bool_returns, compressor)) return;\n        if (compressor.parent() instanceof AST_ExportDefault) return;\n        process_boolean_returns(this, compressor);\n    });\n    AST_Function.DEFMETHOD(\"process_boolean_returns\", function(compressor) {\n        if (!compressor.option(\"booleans\")) return;\n        var bool_returns = map_bool_returns(this);\n        if (this.name && !all_bool(this.name.definition(), bool_returns, compressor)) return;\n        var parent = compressor.parent();\n        if (parent instanceof AST_Assign) {\n            if (parent.operator != \"=\") return;\n            var sym = parent.left;\n            if (!(sym instanceof AST_SymbolRef)) return;\n            if (!all_bool(sym.definition(), bool_returns, compressor)) return;\n        } else if (parent instanceof AST_Call && parent.expression !== this) {\n            var exp = parent.expression;\n            if (exp instanceof AST_SymbolRef) exp = exp.fixed_value();\n            if (!(exp instanceof AST_Lambda)) return;\n            if (exp.uses_arguments || exp.pinned()) return;\n            var sym = exp.argnames[parent.args.indexOf(this)];\n            if (sym instanceof AST_DefaultValue) sym = sym.name;\n            if (sym instanceof AST_SymbolFunarg && !all_bool(sym.definition(), bool_returns, compressor)) return;\n        } else if (parent.TYPE == \"Call\") {\n            compressor.pop();\n            var in_bool = compressor.in_boolean_context();\n            compressor.push(this);\n            if (!in_bool) return;\n        } else return;\n        process_boolean_returns(this, compressor);\n    });\n\n    AST_BlockScope.DEFMETHOD(\"var_names\", function() {\n        var var_names = this._var_names;\n        if (!var_names) {\n            this._var_names = var_names = new Dictionary();\n            this.enclosed.forEach(function(def) {\n                var_names.set(def.name, true);\n            });\n            this.variables.each(function(def, name) {\n                var_names.set(name, true);\n            });\n        }\n        return var_names;\n    });\n\n    AST_Scope.DEFMETHOD(\"make_var\", function(type, orig, prefix) {\n        var scopes = [ this ];\n        if (orig instanceof AST_SymbolDeclaration) orig.definition().references.forEach(function(ref) {\n            var s = ref.scope;\n            if (member(s, scopes)) return;\n            do {\n                push_uniq(scopes, s);\n                s = s.parent_scope;\n            } while (s && s !== this);\n        });\n        prefix = prefix.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/ig, \"_\");\n        var name = prefix;\n        for (var i = 0; !all(scopes, function(scope) {\n            return !scope.var_names().has(name);\n        }); i++) name = prefix + \"$\" + i;\n        var sym = make_node(type, orig, {\n            name: name,\n            scope: this,\n        });\n        var def = this.def_variable(sym);\n        scopes.forEach(function(scope) {\n            scope.enclosed.push(def);\n            scope.var_names().set(name, true);\n        });\n        return sym;\n    });\n\n    AST_Scope.DEFMETHOD(\"hoist_properties\", function(compressor) {\n        if (!compressor.option(\"hoist_props\") || compressor.has_directive(\"use asm\")) return;\n        var self = this;\n        var top_retain = self instanceof AST_Toplevel && compressor.top_retain || return_false;\n        var defs_by_id = Object.create(null);\n        self.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_Assign) {\n                if (node.operator != \"=\") return;\n                if (!node.write_only) return;\n                if (!can_hoist(node.left, node.right, 1)) return;\n                descend(node, this);\n                var defs = new Dictionary();\n                var assignments = [];\n                var decls = [];\n                node.right.properties.forEach(function(prop) {\n                    var decl = make_sym(AST_SymbolVar, node.left, prop.key);\n                    decls.push(make_node(AST_VarDef, node, {\n                        name: decl,\n                        value: null,\n                    }));\n                    var sym = make_node(AST_SymbolRef, node, {\n                        name: decl.name,\n                        scope: self,\n                        thedef: decl.definition(),\n                    });\n                    sym.reference();\n                    assignments.push(make_node(AST_Assign, node, {\n                        operator: \"=\",\n                        left: sym,\n                        right: prop.value,\n                    }));\n                });\n                defs.value = node.right;\n                defs_by_id[node.left.definition().id] = defs;\n                self.body.splice(self.body.indexOf(this.stack[1]) + 1, 0, make_node(AST_Var, node, {\n                    definitions: decls,\n                }));\n                return make_sequence(node, assignments);\n            }\n            if (node instanceof AST_Scope) return node === self ? undefined : node;\n            if (node instanceof AST_VarDef) {\n                if (!can_hoist(node.name, node.value, 0)) return;\n                descend(node, this);\n                var defs = new Dictionary();\n                var var_defs = [];\n                var decl = node.clone();\n                decl.value = node.name instanceof AST_SymbolConst ? make_node(AST_Number, node, { value: 0 }) : null;\n                var_defs.push(decl);\n                node.value.properties.forEach(function(prop) {\n                    var_defs.push(make_node(AST_VarDef, node, {\n                        name: make_sym(node.name.CTOR, node.name, prop.key),\n                        value: prop.value,\n                    }));\n                });\n                defs.value = node.value;\n                defs_by_id[node.name.definition().id] = defs;\n                return List.splice(var_defs);\n            }\n\n            function make_sym(type, sym, key) {\n                var new_var = self.make_var(type, sym, sym.name + \"_\" + key);\n                defs.set(key, new_var.definition());\n                return new_var;\n            }\n        }));\n        self.transform(new TreeTransformer(function(node, descend) {\n            if (node instanceof AST_PropAccess) {\n                if (!(node.expression instanceof AST_SymbolRef)) return;\n                var defs = defs_by_id[node.expression.definition().id];\n                if (!defs) return;\n                if (node.expression.fixed_value() !== defs.value) return;\n                var def = defs.get(node.get_property());\n                var sym = make_node(AST_SymbolRef, node, {\n                    name: def.name,\n                    scope: node.expression.scope,\n                    thedef: def,\n                });\n                sym.reference();\n                return sym;\n            }\n            if (node instanceof AST_SymbolRef) {\n                var defs = defs_by_id[node.definition().id];\n                if (!defs) return;\n                if (node.fixed_value() !== defs.value) return;\n                return make_node(AST_Object, node, { properties: [] });\n            }\n        }));\n\n        function can_hoist(sym, right, count) {\n            if (!(sym instanceof AST_Symbol)) return;\n            var def = sym.definition();\n            if (def.assignments != count) return;\n            if (def.references.length - def.replaced == count) return;\n            if (def.single_use) return;\n            if (top_retain(def)) return;\n            if (sym.fixed_value() !== right) return;\n            var fixed = sym.fixed || def.fixed;\n            if (fixed.direct_access) return;\n            if (fixed.escaped && fixed.escaped.depth == 1) return;\n            return right instanceof AST_Object\n                && right.properties.length > 0\n                && all(right.properties, can_hoist_property)\n                && can_drop_symbol(sym, compressor);\n        }\n    });\n\n    function fn_name_unused(fn, compressor) {\n        if (!fn.name || !compressor.option(\"ie\")) return true;\n        var def = fn.name.definition();\n        if (compressor.exposed(def)) return false;\n        return all(def.references, function(sym) {\n            return !(sym instanceof AST_SymbolRef);\n        });\n    }\n\n    // drop_side_effect_free()\n    // remove side-effect-free parts which only affects return value\n    (function(def) {\n        // Drop side-effect-free elements from an array of expressions.\n        // Returns an array of expressions with side-effects or null\n        // if all elements were dropped. Note: original array may be\n        // returned if nothing changed.\n        function trim(nodes, compressor, first_in_statement, spread) {\n            var len = nodes.length;\n            var ret = [], changed = false;\n            for (var i = 0; i < len; i++) {\n                var node = nodes[i];\n                var trimmed;\n                if (spread && node instanceof AST_Spread) {\n                    trimmed = spread(node, compressor, first_in_statement);\n                } else {\n                    trimmed = node.drop_side_effect_free(compressor, first_in_statement);\n                }\n                if (trimmed !== node) changed = true;\n                if (trimmed) {\n                    ret.push(trimmed);\n                    first_in_statement = false;\n                }\n            }\n            return ret.length ? changed ? ret : nodes : null;\n        }\n        function array_spread(node, compressor, first_in_statement) {\n            var exp = node.expression;\n            if (!exp.is_string(compressor)) return node;\n            return exp.drop_side_effect_free(compressor, first_in_statement);\n        }\n        function convert_spread(node) {\n            return node instanceof AST_Spread ? make_node(AST_Array, node, {\n                elements: [ node ]\n            }) : node;\n        }\n        def(AST_Node, return_this);\n        def(AST_Accessor, return_null);\n        def(AST_Array, function(compressor, first_in_statement) {\n            var values = trim(this.elements, compressor, first_in_statement, array_spread);\n            if (!values) return null;\n            if (values === this.elements && all(values, function(node) {\n                return node instanceof AST_Spread;\n            })) return this;\n            return make_sequence(this, values.map(convert_spread));\n        });\n        def(AST_Assign, function(compressor) {\n            var left = this.left;\n            if (left instanceof AST_PropAccess) {\n                var expr = left.expression;\n                if (expr.may_throw_on_access(compressor, true)) return this;\n                if (compressor.has_directive(\"use strict\") && expr.is_constant()) return this;\n            }\n            if (left.has_side_effects(compressor)) return this;\n            if (lazy_op[this.operator.slice(0, -1)]) return this;\n            this.write_only = true;\n            if (!root_expr(left).is_constant_expression(compressor.find_parent(AST_Scope))) return this;\n            return this.right.drop_side_effect_free(compressor);\n        });\n        def(AST_Await, function(compressor) {\n            if (!compressor.option(\"awaits\")) return this;\n            var exp = this.expression;\n            if (!is_primitive(compressor, exp)) return this;\n            var node = this.clone();\n            node.expression = exp.drop_side_effect_free(compressor) || make_node(AST_Number, this, { value: 0 });\n            return node;\n        });\n        def(AST_Binary, function(compressor, first_in_statement) {\n            var left = this.left;\n            var right = this.right;\n            var op = this.operator;\n            if (op == \"in\" && !is_object(right)) {\n                var lhs = left.drop_side_effect_free(compressor, first_in_statement);\n                if (lhs === left) return this;\n                var node = this.clone();\n                node.left = lhs || make_node(AST_Number, left, { value: 0 });\n                return node;\n            }\n            var rhs = right.drop_side_effect_free(compressor, first_in_statement);\n            if (!rhs) return left.drop_side_effect_free(compressor, first_in_statement);\n            if (lazy_op[op] && rhs.has_side_effects(compressor)) {\n                var node = this;\n                if (rhs !== right) {\n                    node = node.clone();\n                    node.right = rhs.drop_side_effect_free(compressor);\n                }\n                if (op == \"??\") return node;\n                var negated = make_node(AST_Binary, this, {\n                    operator: op == \"&&\" ? \"||\" : \"&&\",\n                    left: left.negate(compressor, first_in_statement),\n                    right: node.right,\n                });\n                return first_in_statement ? best_of_statement(node, negated) : best_of_expression(node, negated);\n            }\n            var lhs = left.drop_side_effect_free(compressor, first_in_statement);\n            if (!lhs) return rhs;\n            rhs = rhs.drop_side_effect_free(compressor);\n            if (!rhs) return lhs;\n            return make_sequence(this, [ lhs, rhs ]);\n        });\n        function drop_returns(compressor, exp) {\n            var arrow = is_arrow(exp);\n            var async = is_async(exp);\n            var drop_body = false;\n            if (arrow && compressor.option(\"arrows\")) {\n                if (!exp.value) {\n                    drop_body = true;\n                } else if (!async || is_primitive(compressor, exp.value)) {\n                    exp.value = exp.value.drop_side_effect_free(compressor);\n                }\n            } else if (exp instanceof AST_AsyncFunction || exp instanceof AST_Function) {\n                if (exp.name) {\n                    var def = exp.name.definition();\n                    drop_body = def.references.length == def.replaced;\n                } else {\n                    drop_body = true;\n                }\n            }\n            if (drop_body) {\n                exp.process_expression(false, function(node) {\n                    var value = node.value;\n                    if (value) {\n                        if (async && !is_primitive(compressor, value)) return node;\n                        value = value.drop_side_effect_free(compressor, true);\n                    }\n                    if (!value) return make_node(AST_EmptyStatement, node);\n                    return make_node(AST_SimpleStatement, node, { body: value });\n                });\n                scan_local_returns(exp, function(node) {\n                    var value = node.value;\n                    if (value) {\n                        if (async && !is_primitive(compressor, value)) return;\n                        node.value = value.drop_side_effect_free(compressor);\n                    }\n                });\n            }\n            if (async && compressor.option(\"awaits\")) {\n                if (drop_body) exp.process_expression(\"awaits\", function(node) {\n                    var body = node.body;\n                    if (body instanceof AST_Await) {\n                        if (is_primitive(compressor, body.expression)) {\n                            body = body.expression.drop_side_effect_free(compressor, true);\n                            if (!body) return make_node(AST_EmptyStatement, node);\n                            node.body = body;\n                        }\n                    } else if (body instanceof AST_Sequence) {\n                        var exprs = body.expressions;\n                        for (var i = exprs.length; --i >= 0;) {\n                            var tail = exprs[i];\n                            if (!(tail instanceof AST_Await)) break;\n                            if (!is_primitive(compressor, tail.expression)) break;\n                            if (exprs[i] = tail.expression.drop_side_effect_free(compressor)) break;\n                        }\n                        switch (i) {\n                          case -1:\n                            return make_node(AST_EmptyStatement, node);\n                          case 0:\n                            node.body = exprs[0];\n                            break;\n                          default:\n                            exprs.length = i + 1;\n                            break;\n                        }\n                    }\n                    return node;\n                });\n                var abort = !drop_body && exp.name || arrow && exp.value && !is_primitive(compressor, exp.value);\n                var tw = new TreeWalker(function(node) {\n                    if (abort) return true;\n                    if (tw.parent() === exp && node.may_throw(compressor)) return abort = true;\n                    if (node instanceof AST_Await) return abort = true;\n                    if (node instanceof AST_ForAwaitOf) return abort = true;\n                    if (node instanceof AST_Return) {\n                        if (node.value && !is_primitive(compressor, node.value)) return abort = true;\n                        return;\n                    }\n                    if (node instanceof AST_Scope && node !== exp) return true;\n                });\n                exp.walk(tw);\n                if (!abort) {\n                    var ctor;\n                    switch (exp.CTOR) {\n                      case AST_AsyncArrow:\n                        ctor = AST_Arrow;\n                        break;\n                      case AST_AsyncFunction:\n                        ctor = AST_Function;\n                        break;\n                      case AST_AsyncGeneratorFunction:\n                        ctor = AST_GeneratorFunction;\n                        break;\n                    }\n                    return make_node(ctor, exp, exp);\n                }\n            }\n            return drop_body && exp.clone();\n        }\n        def(AST_Call, function(compressor, first_in_statement) {\n            var self = this;\n            if (self.is_expr_pure(compressor)) {\n                if (self.pure) AST_Node.warn(\"Dropping __PURE__ call [{file}:{line},{col}]\", self.start);\n                var args = trim(self.args, compressor, first_in_statement, array_spread);\n                return args && make_sequence(self, args.map(convert_spread));\n            }\n            var exp = self.expression;\n            if (self.is_call_pure(compressor)) {\n                var exprs = self.args.slice();\n                exprs.unshift(exp.expression);\n                exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                return exprs && make_sequence(self, exprs.map(convert_spread));\n            }\n            if (compressor.option(\"yields\") && is_generator(exp)) {\n                var call = self.clone();\n                call.expression = make_node(AST_Function, exp, exp);\n                call.expression.body = [];\n                var opt = call.transform(compressor);\n                if (opt !== call) return opt.drop_side_effect_free(compressor, first_in_statement);\n            }\n            var dropped = drop_returns(compressor, exp);\n            if (dropped) {\n                // always shallow clone to ensure stripping of negated IIFEs\n                self = self.clone();\n                self.expression = dropped;\n                // avoid extraneous traversal\n                if (exp._squeezed) self.expression._squeezed = true;\n            }\n            if (self instanceof AST_New) {\n                var fn = exp;\n                if (fn instanceof AST_SymbolRef) fn = fn.fixed_value();\n                if (fn instanceof AST_Lambda) {\n                    if (assign_this_only(fn, compressor)) {\n                        var exprs = self.args.slice();\n                        exprs.unshift(exp);\n                        exprs = trim(exprs, compressor, first_in_statement, array_spread);\n                        return exprs && make_sequence(self, exprs.map(convert_spread));\n                    }\n                    if (!fn.contains_this()) self = make_node(AST_Call, self, self);\n                }\n            }\n            self.call_only = true;\n            return self;\n        });\n        function assign_this_only(fn, compressor) {\n            fn.new = true;\n            var result = all(fn.body, function(stat) {\n                return !stat.has_side_effects(compressor);\n            }) && all(fn.argnames, function(argname) {\n                return !argname.match_symbol(return_false);\n            }) && !(fn.rest && fn.rest.match_symbol(return_false));\n            fn.new = false;\n            return result;\n        }\n        function drop_class(self, compressor, first_in_statement) {\n            var exprs = [], values = [];\n            var props = self.properties;\n            for (var i = 0; i < props.length; i++) {\n                var prop = props[i];\n                if (prop.key instanceof AST_Node) exprs.push(prop.key);\n                if (prop.static && prop.value\n                    && prop instanceof AST_ClassField\n                    && prop.value.has_side_effects(compressor)) {\n                    if (prop.value.contains_this()) return self;\n                    values.push(prop.value);\n                }\n            }\n            var base = self.extends;\n            if (base) {\n                if (base instanceof AST_SymbolRef) base = base.fixed_value();\n                base = !safe_for_extends(base);\n                if (!base) exprs.unshift(self.extends);\n            }\n            exprs = trim(exprs, compressor, first_in_statement);\n            if (exprs) first_in_statement = false;\n            values = trim(values, compressor, first_in_statement);\n            if (!exprs) {\n                if (!base && !values) return null;\n                exprs = [];\n            }\n            if (base) {\n                var node = to_class_expr(self, true);\n                node.properties = [];\n                if (exprs.length) node.properties.push(make_node(AST_ClassMethod, self, {\n                    key: make_sequence(self, exprs),\n                    value: make_node(AST_Function, self, {\n                        argnames: [],\n                        body: [],\n                    }).init_vars(node),\n                }));\n                exprs = [ node ];\n            }\n            if (values) exprs.push(make_node(AST_Call, self, {\n                expression: make_node(AST_Arrow, self, {\n                    argnames: [],\n                    body: [],\n                    value: make_sequence(self, values),\n                }).init_vars(self.parent_scope),\n                args: [],\n            }));\n            return make_sequence(self, exprs);\n        }\n        def(AST_ClassExpression, function(compressor, first_in_statement) {\n            var self = this;\n            var name = self.name;\n            if (name && name.fixed_value() !== self && name.definition().references.length > 0) return self;\n            return drop_class(self, compressor, first_in_statement);\n        });\n        def(AST_Conditional, function(compressor) {\n            var consequent = this.consequent.drop_side_effect_free(compressor);\n            var alternative = this.alternative.drop_side_effect_free(compressor);\n            if (consequent === this.consequent && alternative === this.alternative) return this;\n            var exprs;\n            if (compressor.option(\"ie\")) {\n                exprs = [];\n                if (consequent instanceof AST_Function) {\n                    exprs.push(consequent);\n                    consequent = null;\n                }\n                if (alternative instanceof AST_Function) {\n                    exprs.push(alternative);\n                    alternative = null;\n                }\n            }\n            var node;\n            if (!consequent) {\n                node = alternative ? make_node(AST_Binary, this, {\n                    operator: \"||\",\n                    left: this.condition,\n                    right: alternative\n                }) : this.condition.drop_side_effect_free(compressor);\n            } else if (!alternative) {\n                node = make_node(AST_Binary, this, {\n                    operator: \"&&\",\n                    left: this.condition,\n                    right: consequent\n                });\n            } else {\n                node = this.clone();\n                node.consequent = consequent;\n                node.alternative = alternative;\n            }\n            if (!compressor.option(\"ie\")) return node;\n            if (node) exprs.push(node);\n            return exprs.length == 0 ? null : make_sequence(this, exprs);\n        });\n        def(AST_Constant, return_null);\n        def(AST_DefClass, function(compressor, first_in_statement) {\n            return drop_class(this, compressor, first_in_statement);\n        });\n        def(AST_Dot, function(compressor, first_in_statement) {\n            var expr = this.expression;\n            if (!this.optional && expr.may_throw_on_access(compressor)) return this;\n            return expr.drop_side_effect_free(compressor, first_in_statement);\n        });\n        def(AST_Function, function(compressor) {\n            return fn_name_unused(this, compressor) ? null : this;\n        });\n        def(AST_LambdaExpression, return_null);\n        def(AST_Object, function(compressor, first_in_statement) {\n            var exprs = [];\n            this.properties.forEach(function(prop) {\n                if (prop instanceof AST_Spread) {\n                    exprs.push(prop);\n                } else {\n                    if (prop.key instanceof AST_Node) exprs.push(prop.key);\n                    exprs.push(prop.value);\n                }\n            });\n            var values = trim(exprs, compressor, first_in_statement, function(node, compressor, first_in_statement) {\n                var exp = node.expression;\n                return spread_side_effects(exp) ? node : exp.drop_side_effect_free(compressor, first_in_statement);\n            });\n            if (!values) return null;\n            if (values === exprs && !all(values, function(node) {\n                return !(node instanceof AST_Spread);\n            })) return this;\n            return make_sequence(this, values.map(function(node) {\n                return node instanceof AST_Spread ? make_node(AST_Object, node, {\n                    properties: [ node ],\n                }) : node;\n            }));\n        });\n        def(AST_ObjectIdentity, return_null);\n        def(AST_Sequence, function(compressor, first_in_statement) {\n            var expressions = trim(this.expressions, compressor, first_in_statement);\n            if (!expressions) return null;\n            var end = expressions.length - 1;\n            var last = expressions[end];\n            if (compressor.option(\"awaits\") && end > 0 && last instanceof AST_Await && last.expression.is_constant()) {\n                expressions = expressions.slice(0, -1);\n                end--;\n                last.expression = expressions[end];\n                expressions[end] = last;\n            }\n            var assign, cond, lhs;\n            if (compressor.option(\"conditionals\")\n                && end > 0\n                && (assign = expressions[end - 1]) instanceof AST_Assign\n                && assign.operator == \"=\"\n                && (lhs = assign.left) instanceof AST_SymbolRef\n                && (cond = to_conditional_assignment(compressor, lhs.definition(), assign.right, last))) {\n                assign = assign.clone();\n                assign.right = cond;\n                expressions = expressions.slice(0, -2);\n                expressions.push(assign.drop_side_effect_free(compressor, first_in_statement));\n            }\n            return expressions === this.expressions ? this : make_sequence(this, expressions);\n        });\n        def(AST_Sub, function(compressor, first_in_statement) {\n            var expr = this.expression;\n            var prop = this.property;\n            if (expr.may_throw_on_access(compressor)) {\n                if (!this.optional) return this;\n                if (prop.has_side_effects(compressor)) {\n                    prop = prop.drop_side_effect_free(compressor);\n                    if (!prop) return expr.drop_side_effect_free(compressor, first_in_statement);\n                    var node = this.clone();\n                    node.property = prop;\n                    return node;\n                }\n            }\n            expr = expr.drop_side_effect_free(compressor, first_in_statement);\n            if (!expr) return prop.drop_side_effect_free(compressor, first_in_statement);\n            prop = prop.drop_side_effect_free(compressor);\n            if (!prop) return expr;\n            return make_sequence(this, [ expr, prop ]);\n        });\n        def(AST_SymbolRef, function(compressor) {\n            return this.is_declared(compressor) && can_drop_symbol(this, compressor) ? null : this;\n        });\n        def(AST_Template, function(compressor, first_in_statement) {\n            var self = this;\n            if (self.is_expr_pure(compressor)) {\n                var expressions = self.expressions;\n                if (expressions.length == 0) return null;\n                return make_sequence(self, expressions).drop_side_effect_free(compressor, first_in_statement);\n            }\n            var tag = self.tag;\n            var dropped = drop_returns(compressor, tag);\n            if (dropped) {\n                // always shallow clone to signal internal changes\n                self = self.clone();\n                self.tag = dropped;\n                // avoid extraneous traversal\n                if (tag._squeezed) self.tag._squeezed = true;\n            }\n            return self;\n        });\n        def(AST_Unary, function(compressor, first_in_statement) {\n            var exp = this.expression;\n            if (unary_side_effects[this.operator]) {\n                this.write_only = !exp.has_side_effects(compressor);\n                return this;\n            }\n            if (this.operator == \"typeof\" && exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor)) {\n                return null;\n            }\n            var node = exp.drop_side_effect_free(compressor, first_in_statement);\n            if (first_in_statement && node && is_iife_call(node)) {\n                if (node === exp && this.operator == \"!\") return this;\n                return node.negate(compressor, first_in_statement);\n            }\n            return node;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"drop_side_effect_free\", func);\n    });\n\n    OPT(AST_SimpleStatement, function(self, compressor) {\n        if (compressor.option(\"side_effects\")) {\n            var body = self.body;\n            var node = body.drop_side_effect_free(compressor, true);\n            if (!node) {\n                AST_Node.warn(\"Dropping side-effect-free statement [{file}:{line},{col}]\", self.start);\n                return make_node(AST_EmptyStatement, self);\n            }\n            if (node !== body) {\n                return make_node(AST_SimpleStatement, self, { body: node });\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_While, function(self, compressor) {\n        return compressor.option(\"loops\") ? make_node(AST_For, self, self).optimize(compressor) : self;\n    });\n\n    function has_loop_control(loop, parent, type) {\n        if (!type) type = AST_LoopControl;\n        var found = false;\n        var tw = new TreeWalker(function(node) {\n            if (found || node instanceof AST_Scope) return true;\n            if (node instanceof type && tw.loopcontrol_target(node) === loop) {\n                return found = true;\n            }\n        });\n        if (parent instanceof AST_LabeledStatement) tw.push(parent);\n        tw.push(loop);\n        loop.body.walk(tw);\n        return found;\n    }\n\n    OPT(AST_Do, function(self, compressor) {\n        if (!compressor.option(\"loops\")) return self;\n        var cond = fuzzy_eval(compressor, self.condition);\n        if (!(cond instanceof AST_Node)) {\n            if (cond && !has_loop_control(self, compressor.parent(), AST_Continue)) return make_node(AST_For, self, {\n                body: make_node(AST_BlockStatement, self.body, {\n                    body: [\n                        self.body,\n                        make_node(AST_SimpleStatement, self.condition, {\n                            body: self.condition\n                        }),\n                    ]\n                })\n            }).optimize(compressor);\n            if (!has_loop_control(self, compressor.parent())) return make_node(AST_BlockStatement, self.body, {\n                body: [\n                    self.body,\n                    make_node(AST_SimpleStatement, self.condition, {\n                        body: self.condition\n                    }),\n                ]\n            }).optimize(compressor);\n        }\n        if (self.body instanceof AST_BlockStatement && !has_loop_control(self, compressor.parent(), AST_Continue)) {\n            var body = self.body.body;\n            for (var i = body.length; --i >= 0;) {\n                var stat = body[i];\n                if (stat instanceof AST_If\n                    && !stat.alternative\n                    && stat.body instanceof AST_Break\n                    && compressor.loopcontrol_target(stat.body) === self) {\n                    if (has_block_scope_refs(stat.condition)) break;\n                    self.condition = make_node(AST_Binary, self, {\n                        operator: \"&&\",\n                        left: stat.condition.negate(compressor),\n                        right: self.condition,\n                    });\n                    body.splice(i, 1);\n                } else if (stat instanceof AST_SimpleStatement) {\n                    if (has_block_scope_refs(stat.body)) break;\n                    self.condition = make_sequence(self, [\n                        stat.body,\n                        self.condition,\n                    ]);\n                    body.splice(i, 1);\n                } else if (!is_declaration(stat, true)) {\n                    break;\n                }\n            }\n            self.body = trim_block(self.body, compressor.parent());\n        }\n        if (self.body instanceof AST_EmptyStatement) return make_node(AST_For, self, self).optimize(compressor);\n        if (self.body instanceof AST_SimpleStatement) return make_node(AST_For, self, {\n            condition: make_sequence(self.condition, [\n                self.body.body,\n                self.condition\n            ]),\n            body: make_node(AST_EmptyStatement, self)\n        }).optimize(compressor);\n        return self;\n\n        function has_block_scope_refs(node) {\n            var found = false;\n            node.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_SymbolRef) {\n                    if (!member(node.definition(), self.enclosed)) found = true;\n                    return true;\n                }\n            }));\n            return found;\n        }\n    });\n\n    function if_break_in_loop(self, compressor) {\n        var first = first_statement(self.body);\n        if (compressor.option(\"dead_code\")\n            && (first instanceof AST_Break\n                || first instanceof AST_Continue && external_target(first)\n                || first instanceof AST_Exit)) {\n            var body = [];\n            if (is_statement(self.init)) {\n                body.push(self.init);\n            } else if (self.init) {\n                body.push(make_node(AST_SimpleStatement, self.init, {\n                    body: self.init\n                }));\n            }\n            var retain = external_target(first) || first instanceof AST_Exit;\n            if (self.condition && retain) {\n                body.push(make_node(AST_If, self, {\n                    condition: self.condition,\n                    body: first,\n                    alternative: null\n                }));\n            } else if (self.condition) {\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: self.condition\n                }));\n            } else if (retain) {\n                body.push(first);\n            }\n            extract_declarations_from_unreachable_code(compressor, self.body, body);\n            return make_node(AST_BlockStatement, self, {\n                body: body\n            });\n        }\n        if (first instanceof AST_If) {\n            var ab = first_statement(first.body);\n            if (ab instanceof AST_Break && !external_target(ab)) {\n                if (self.condition) {\n                    self.condition = make_node(AST_Binary, self.condition, {\n                        left: self.condition,\n                        operator: \"&&\",\n                        right: first.condition.negate(compressor),\n                    });\n                } else {\n                    self.condition = first.condition.negate(compressor);\n                }\n                var body = as_statement_array(first.alternative);\n                extract_declarations_from_unreachable_code(compressor, first.body, body);\n                return drop_it(body);\n            }\n            ab = first_statement(first.alternative);\n            if (ab instanceof AST_Break && !external_target(ab)) {\n                if (self.condition) {\n                    self.condition = make_node(AST_Binary, self.condition, {\n                        left: self.condition,\n                        operator: \"&&\",\n                        right: first.condition,\n                    });\n                } else {\n                    self.condition = first.condition;\n                }\n                var body = as_statement_array(first.body);\n                extract_declarations_from_unreachable_code(compressor, first.alternative, body);\n                return drop_it(body);\n            }\n        }\n        return self;\n\n        function first_statement(body) {\n            return body instanceof AST_BlockStatement ? body.body[0] : body;\n        }\n\n        function external_target(node) {\n            return compressor.loopcontrol_target(node) !== compressor.self();\n        }\n\n        function drop_it(rest) {\n            if (self.body instanceof AST_BlockStatement) {\n                self.body = self.body.clone();\n                self.body.body = rest.concat(self.body.body.slice(1));\n                self.body = self.body.transform(compressor);\n            } else {\n                self.body = make_node(AST_BlockStatement, self.body, {\n                    body: rest\n                }).transform(compressor);\n            }\n            return if_break_in_loop(self, compressor);\n        }\n    }\n\n    OPT(AST_For, function(self, compressor) {\n        if (!compressor.option(\"loops\")) return self;\n        if (compressor.option(\"side_effects\")) {\n            if (self.init) self.init = self.init.drop_side_effect_free(compressor);\n            if (self.step) self.step = self.step.drop_side_effect_free(compressor);\n        }\n        if (self.condition) {\n            var cond = fuzzy_eval(compressor, self.condition);\n            if (!cond) {\n                if (compressor.option(\"dead_code\")) {\n                    var body = [];\n                    if (is_statement(self.init)) {\n                        body.push(self.init);\n                    } else if (self.init) {\n                        body.push(make_node(AST_SimpleStatement, self.init, { body: self.init }));\n                    }\n                    body.push(make_node(AST_SimpleStatement, self.condition, { body: self.condition }));\n                    extract_declarations_from_unreachable_code(compressor, self.body, body);\n                    return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n                }\n            } else if (!(cond instanceof AST_Node)) {\n                self.body = make_node(AST_BlockStatement, self.body, {\n                    body: [\n                        make_node(AST_SimpleStatement, self.condition, { body: self.condition }),\n                        self.body,\n                    ],\n                });\n                self.condition = null;\n            }\n        }\n        return if_break_in_loop(self, compressor);\n    });\n\n    OPT(AST_ForEnumeration, function(self, compressor) {\n        if (compressor.option(\"varify\") && is_lexical_definition(self.init)) {\n            var name = self.init.definitions[0].name;\n            if ((name instanceof AST_Destructured || name instanceof AST_SymbolLet)\n                && !name.match_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) {\n                        var def = node.definition();\n                        return !same_scope(def) || may_overlap(compressor, def);\n                    }\n                }, true)) {\n                self.init = to_var(self.init);\n            }\n        }\n        return self;\n    });\n\n    function mark_locally_defined(condition, consequent, alternative) {\n        if (!(condition instanceof AST_Binary)) return;\n        if (!(condition.left instanceof AST_String)) {\n            switch (condition.operator) {\n              case \"&&\":\n                mark_locally_defined(condition.left, consequent);\n                mark_locally_defined(condition.right, consequent);\n                break;\n              case \"||\":\n                mark_locally_defined(negate(condition.left), alternative);\n                mark_locally_defined(negate(condition.right), alternative);\n                break;\n            }\n            return;\n        }\n        if (!(condition.right instanceof AST_UnaryPrefix)) return;\n        if (condition.right.operator != \"typeof\") return;\n        var sym = condition.right.expression;\n        if (!is_undeclared_ref(sym)) return;\n        var body;\n        var undef = condition.left.value == \"undefined\";\n        switch (condition.operator) {\n          case \"==\":\n            body = undef ? alternative : consequent;\n            break;\n          case \"!=\":\n            body = undef ? consequent : alternative;\n            break;\n          default:\n            return;\n        }\n        if (!body) return;\n        var def = sym.definition();\n        var tw = new TreeWalker(function(node) {\n            if (node instanceof AST_Scope) {\n                var parent = tw.parent();\n                if (parent instanceof AST_Call && parent.expression === node) return;\n                return true;\n            }\n            if (node instanceof AST_SymbolRef && node.definition() === def) node.defined = true;\n        });\n        body.walk(tw);\n\n        function negate(node) {\n            if (!(node instanceof AST_Binary)) return;\n            switch (node.operator) {\n              case \"==\":\n                node = node.clone();\n                node.operator = \"!=\";\n                return node;\n              case \"!=\":\n                node = node.clone();\n                node.operator = \"==\";\n                return node;\n            }\n        }\n    }\n\n    function fuzzy_eval(compressor, node, nullish) {\n        if (node.truthy) return true;\n        if (node.falsy && !nullish) return false;\n        if (node.is_truthy()) return true;\n        return node.evaluate(compressor, true);\n    }\n\n    function mark_duplicate_condition(compressor, node) {\n        var child;\n        var level = 0;\n        var negated = false;\n        var parent = compressor.self();\n        if (!is_statement(parent)) while (true) {\n            child = parent;\n            parent = compressor.parent(level++);\n            if (parent instanceof AST_Binary) {\n                var op = parent.operator;\n                if (!lazy_op[op]) return;\n                var left = parent.left;\n                if (left === child) continue;\n                if (match(left)) switch (op) {\n                  case \"&&\":\n                    node[negated ? \"falsy\" : \"truthy\"] = true;\n                    break;\n                  case \"||\":\n                  case \"??\":\n                    node[negated ? \"truthy\" : \"falsy\"] = true;\n                    break;\n                }\n            } else if (parent instanceof AST_Conditional) {\n                var cond = parent.condition;\n                if (cond === child) continue;\n                if (match(cond)) switch (child) {\n                  case parent.consequent:\n                    node[negated ? \"falsy\" : \"truthy\"] = true;\n                    break;\n                  case parent.alternative:\n                    node[negated ? \"truthy\" : \"falsy\"] = true;\n                    break;\n                }\n            } else if (parent instanceof AST_Exit) {\n                break;\n            } else if (parent instanceof AST_If) {\n                break;\n            } else if (parent instanceof AST_Sequence) {\n                if (parent.expressions[0] === child) continue;\n            } else if (parent instanceof AST_SimpleStatement) {\n                break;\n            }\n            return;\n        }\n        while (true) {\n            child = parent;\n            parent = compressor.parent(level++);\n            if (parent instanceof AST_BlockStatement) {\n                if (parent.body[0] === child) continue;\n            } else if (parent instanceof AST_If) {\n                if (match(parent.condition)) switch (child) {\n                  case parent.body:\n                    node[negated ? \"falsy\" : \"truthy\"] = true;\n                    break;\n                  case parent.alternative:\n                    node[negated ? \"truthy\" : \"falsy\"] = true;\n                    break;\n                }\n            }\n            return;\n        }\n\n        function match(cond) {\n            if (node.equivalent_to(cond)) return true;\n            if (!(cond instanceof AST_UnaryPrefix)) return false;\n            if (cond.operator != \"!\") return false;\n            if (!node.equivalent_to(cond.expression)) return false;\n            negated = true;\n            return true;\n        }\n    }\n\n    OPT(AST_If, function(self, compressor) {\n        if (is_empty(self.alternative)) self.alternative = null;\n\n        if (!compressor.option(\"conditionals\")) return self;\n        if (compressor.option(\"booleans\") && !self.condition.has_side_effects(compressor)) {\n            mark_duplicate_condition(compressor, self.condition);\n        }\n        // if condition can be statically determined, warn and drop\n        // one of the blocks.  note, statically determined implies\n        // has no side effects; also it doesn't work for cases like\n        // `x && true`, though it probably should.\n        if (compressor.option(\"dead_code\")) {\n            var cond = fuzzy_eval(compressor, self.condition);\n            if (!cond) {\n                AST_Node.warn(\"Condition always false [{file}:{line},{col}]\", self.condition.start);\n                var body = [ make_node(AST_SimpleStatement, self.condition, { body: self.condition }) ];\n                extract_declarations_from_unreachable_code(compressor, self.body, body);\n                if (self.alternative) body.push(self.alternative);\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            } else if (!(cond instanceof AST_Node)) {\n                AST_Node.warn(\"Condition always true [{file}:{line},{col}]\", self.condition.start);\n                var body = [\n                    make_node(AST_SimpleStatement, self.condition, { body: self.condition }),\n                    self.body,\n                ];\n                if (self.alternative) extract_declarations_from_unreachable_code(compressor, self.alternative, body);\n                return make_node(AST_BlockStatement, self, { body: body }).optimize(compressor);\n            }\n        }\n        var negated = self.condition.negate(compressor);\n        var self_condition_length = self.condition.print_to_string().length;\n        var negated_length = negated.print_to_string().length;\n        var negated_is_best = negated_length < self_condition_length;\n        if (self.alternative && negated_is_best) {\n            negated_is_best = false; // because we already do the switch here.\n            // no need to swap values of self_condition_length and negated_length\n            // here because they are only used in an equality comparison later on.\n            self.condition = negated;\n            var tmp = self.body;\n            self.body = self.alternative || make_node(AST_EmptyStatement, self);\n            self.alternative = tmp;\n        }\n        var body = [], var_defs = [], refs = [];\n        var body_exprs = sequencesize(self.body, body, var_defs, refs);\n        var alt_exprs = sequencesize(self.alternative, body, var_defs, refs);\n        if (body_exprs && alt_exprs) {\n            if (var_defs.length > 0) body.push(make_node(AST_Var, self, { definitions: var_defs }));\n            if (body_exprs.length == 0) {\n                body.push(make_node(AST_SimpleStatement, self.condition, {\n                    body: alt_exprs.length > 0 ? make_node(AST_Binary, self, {\n                        operator : \"||\",\n                        left     : self.condition,\n                        right    : make_sequence(self.alternative, alt_exprs)\n                    }).transform(compressor) : self.condition.clone()\n                }).optimize(compressor));\n            } else if (alt_exprs.length == 0) {\n                if (self_condition_length === negated_length && !negated_is_best\n                    && self.condition instanceof AST_Binary && self.condition.operator == \"||\") {\n                    // although the code length of self.condition and negated are the same,\n                    // negated does not require additional surrounding parentheses.\n                    // see https://github.com/mishoo/UglifyJS/issues/979\n                    negated_is_best = true;\n                }\n                body.push(make_node(AST_SimpleStatement, self, {\n                    body: make_node(AST_Binary, self, {\n                        operator : negated_is_best ? \"||\" : \"&&\",\n                        left     : negated_is_best ? negated : self.condition,\n                        right    : make_sequence(self.body, body_exprs)\n                    }).transform(compressor)\n                }).optimize(compressor));\n            } else {\n                body.push(make_node(AST_SimpleStatement, self, {\n                    body: make_node(AST_Conditional, self, {\n                        condition   : self.condition,\n                        consequent  : make_sequence(self.body, body_exprs),\n                        alternative : make_sequence(self.alternative, alt_exprs)\n                    })\n                }).optimize(compressor));\n            }\n            refs.forEach(function(ref) {\n                ref.definition().references.push(ref);\n            });\n            return make_node(AST_BlockStatement, self, {\n                body: body\n            }).optimize(compressor);\n        }\n        if (is_empty(self.body)) {\n            self = make_node(AST_If, self, {\n                condition: negated,\n                body: self.alternative,\n                alternative: null\n            });\n        }\n        if (self.body instanceof AST_Exit\n            && self.alternative instanceof AST_Exit\n            && self.body.TYPE == self.alternative.TYPE) {\n            var exit = make_node(self.body.CTOR, self, {\n                value: make_node(AST_Conditional, self, {\n                    condition   : self.condition,\n                    consequent  : self.body.value || make_node(AST_Undefined, self.body).transform(compressor),\n                    alternative : self.alternative.value || make_node(AST_Undefined, self.alternative).transform(compressor)\n                })\n            });\n            if (exit instanceof AST_Return) {\n                exit.in_bool = self.body.in_bool || self.alternative.in_bool;\n            }\n            return exit;\n        }\n        if (self.body instanceof AST_If\n            && !self.body.alternative\n            && !self.alternative) {\n            self = make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self.condition, {\n                    operator: \"&&\",\n                    left: self.condition,\n                    right: self.body.condition\n                }),\n                body: self.body.body,\n                alternative: null\n            });\n        }\n        if (aborts(self.body)) {\n            if (self.alternative) {\n                var alt = self.alternative;\n                self.alternative = null;\n                return make_node(AST_BlockStatement, self, {\n                    body: [ self, alt ]\n                }).optimize(compressor);\n            }\n        }\n        if (aborts(self.alternative)) {\n            var body = self.body;\n            self.body = self.alternative;\n            self.condition = negated_is_best ? negated : self.condition.negate(compressor);\n            self.alternative = null;\n            return make_node(AST_BlockStatement, self, {\n                body: [ self, body ]\n            }).optimize(compressor);\n        }\n        if (compressor.option(\"typeofs\")) mark_locally_defined(self.condition, self.body, self.alternative);\n        return self;\n\n        function sequencesize(stat, defuns, var_defs, refs) {\n            if (stat == null) return [];\n            if (stat instanceof AST_BlockStatement) {\n                var exprs = [];\n                for (var i = 0; i < stat.body.length; i++) {\n                    var line = stat.body[i];\n                    if (line instanceof AST_LambdaDefinition) {\n                        defuns.push(line);\n                    } else if (line instanceof AST_EmptyStatement) {\n                        continue;\n                    } else if (line instanceof AST_SimpleStatement) {\n                        if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                        exprs.push(line.body);\n                    } else if (line instanceof AST_Var) {\n                        if (!compressor.option(\"sequences\") && exprs.length > 0) return;\n                        line.remove_initializers(compressor, var_defs);\n                        line.definitions.forEach(process_var_def);\n                    } else {\n                        return;\n                    }\n                }\n                return exprs;\n            }\n            if (stat instanceof AST_LambdaDefinition) {\n                defuns.push(stat);\n                return [];\n            }\n            if (stat instanceof AST_EmptyStatement) return [];\n            if (stat instanceof AST_SimpleStatement) return [ stat.body ];\n            if (stat instanceof AST_Var) {\n                var exprs = [];\n                stat.remove_initializers(compressor, var_defs);\n                stat.definitions.forEach(process_var_def);\n                return exprs;\n            }\n\n            function process_var_def(var_def) {\n                if (!var_def.value) return;\n                exprs.push(make_node(AST_Assign, var_def, {\n                    operator: \"=\",\n                    left: var_def.name.convert_symbol(AST_SymbolRef, function(ref) {\n                        refs.push(ref);\n                    }),\n                    right: var_def.value\n                }));\n            }\n        }\n    });\n\n    OPT(AST_Switch, function(self, compressor) {\n        if (!compressor.option(\"switches\")) return self;\n        if (!compressor.option(\"dead_code\")) return self;\n        var body = [];\n        var branch;\n        var decl = [];\n        var default_branch;\n        var exact_match;\n        var side_effects = [];\n        for (var i = 0, len = self.body.length; i < len; i++) {\n            branch = self.body[i];\n            if (branch instanceof AST_Default) {\n                var prev = body[body.length - 1];\n                if (default_branch || is_break(branch.body[0], compressor) && (!prev || aborts(prev))) {\n                    eliminate_branch(branch, prev);\n                    continue;\n                } else {\n                    default_branch = branch;\n                }\n            } else {\n                var exp = branch.expression;\n                var equals = make_node(AST_Binary, self, {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: exp,\n                }).evaluate(compressor, true);\n                if (!equals) {\n                    if (exp.has_side_effects(compressor)) side_effects.push(exp);\n                    eliminate_branch(branch, body[body.length - 1]);\n                    continue;\n                }\n                if (!(equals instanceof AST_Node)) {\n                    if (default_branch) {\n                        var default_index = body.indexOf(default_branch);\n                        body.splice(default_index, 1);\n                        eliminate_branch(default_branch, body[default_index - 1]);\n                        default_branch = null;\n                    }\n                    if (exp.has_side_effects(compressor)) {\n                        exact_match = branch;\n                    } else {\n                        default_branch = branch = make_node(AST_Default, branch, branch);\n                    }\n                    while (++i < len) eliminate_branch(self.body[i], branch);\n                }\n            }\n            if (i + 1 >= len || aborts(branch)) {\n                var prev = body[body.length - 1];\n                var statements = branch.body;\n                if (aborts(prev)) switch (prev.body.length - statements.length) {\n                  case 1:\n                    var stat = prev.body[prev.body.length - 1];\n                    if (!is_break(stat, compressor)) break;\n                    statements = statements.concat(stat);\n                  case 0:\n                    var prev_block = make_node(AST_BlockStatement, prev, prev);\n                    var next_block = make_node(AST_BlockStatement, branch, { body: statements });\n                    if (prev_block.equivalent_to(next_block)) prev.body = [];\n                }\n            }\n            if (side_effects.length) {\n                if (branch instanceof AST_Default) {\n                    body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));\n                } else {\n                    side_effects.push(branch.expression);\n                    branch.expression = make_sequence(self, side_effects);\n                }\n                side_effects = [];\n            }\n            body.push(branch);\n        }\n        if (side_effects.length && !exact_match) {\n            body.push(make_node(AST_Case, self, { expression: make_sequence(self, side_effects), body: [] }));\n        }\n        while (branch = body[body.length - 1]) {\n            var stat = branch.body[branch.body.length - 1];\n            if (is_break(stat, compressor)) branch.body.pop();\n            if (branch === default_branch) {\n                if (!has_declarations_only(branch)) break;\n            } else if (branch.expression.has_side_effects(compressor)) {\n                break;\n            } else if (default_branch) {\n                if (!has_declarations_only(default_branch)) break;\n                if (body[body.length - 2] !== default_branch) break;\n                default_branch.body = default_branch.body.concat(branch.body);\n                branch.body = [];\n            } else if (!has_declarations_only(branch)) break;\n            eliminate_branch(branch);\n            if (body.pop() === default_branch) default_branch = null;\n        }\n        if (!branch) {\n            decl.push(make_node(AST_SimpleStatement, self.expression, { body: self.expression }));\n            if (side_effects.length) decl.push(make_node(AST_SimpleStatement, self, {\n                body: make_sequence(self, side_effects),\n            }));\n            return make_node(AST_BlockStatement, self, { body: decl }).optimize(compressor);\n        }\n        if (branch === default_branch) while (branch = body[body.length - 2]) {\n            if (branch instanceof AST_Default) break;\n            if (!has_declarations_only(branch)) break;\n            var exp = branch.expression;\n            if (exp.has_side_effects(compressor)) {\n                var prev = body[body.length - 3];\n                if (prev && !aborts(prev)) break;\n                default_branch.body.unshift(make_node(AST_SimpleStatement, self, { body: exp }));\n            }\n            eliminate_branch(branch);\n            body.splice(-2, 1);\n        }\n        body[0].body = decl.concat(body[0].body);\n        self.body = body;\n        if (compressor.option(\"conditionals\")) switch (body.length) {\n          case 1:\n            if (!no_break(body[0])) break;\n            var exp = body[0].expression;\n            var statements = body[0].body.slice();\n            if (body[0] !== default_branch && body[0] !== exact_match) return make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self, {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: exp,\n                }),\n                body: make_node(AST_BlockStatement, self, {\n                    body: statements,\n                }),\n                alternative: null,\n            }).optimize(compressor);\n            if (exp) statements.unshift(make_node(AST_SimpleStatement, exp, {\n                body: exp,\n            }));\n            statements.unshift(make_node(AST_SimpleStatement, self.expression, {\n                body:self.expression,\n            }));\n            return make_node(AST_BlockStatement, self, {\n                body: statements,\n            }).optimize(compressor);\n          case 2:\n            if (!member(default_branch, body) || !no_break(body[1])) break;\n            var statements = body[0].body.slice();\n            var exclusive = statements.length && is_break(statements[statements.length - 1], compressor);\n            if (exclusive) statements.pop();\n            if (!all(statements, no_break)) break;\n            var alternative = body[1].body.length && make_node(AST_BlockStatement, body[1], body[1]);\n            var node = make_node(AST_If, self, {\n                condition: make_node(AST_Binary, self, body[0] === default_branch ? {\n                    operator: \"!==\",\n                    left: self.expression,\n                    right: body[1].expression,\n                } : {\n                    operator: \"===\",\n                    left: self.expression,\n                    right: body[0].expression,\n                }),\n                body: make_node(AST_BlockStatement, body[0], {\n                    body: statements,\n                }),\n                alternative: exclusive && alternative || null,\n            });\n            if (!exclusive && alternative) node = make_node(AST_BlockStatement, self, {\n                body: [ node, alternative ],\n            });\n            return node.optimize(compressor);\n        }\n        return self;\n\n        function is_break(node, tw) {\n            return node instanceof AST_Break && tw.loopcontrol_target(node) === self;\n        }\n\n        function no_break(node) {\n            var found = false;\n            var tw = new TreeWalker(function(node) {\n                if (found\n                    || node instanceof AST_Lambda\n                    || node instanceof AST_SimpleStatement) return true;\n                if (is_break(node, tw)) found = true;\n            });\n            tw.push(self);\n            node.walk(tw);\n            return !found;\n        }\n\n        function eliminate_branch(branch, prev) {\n            if (prev && !aborts(prev)) {\n                prev.body = prev.body.concat(branch.body);\n            } else {\n                extract_declarations_from_unreachable_code(compressor, branch, decl);\n            }\n        }\n    });\n\n    OPT(AST_Try, function(self, compressor) {\n        self.body = tighten_body(self.body, compressor);\n        if (compressor.option(\"dead_code\")) {\n            if (has_declarations_only(self)\n                && !(self.bcatch && self.bcatch.argname && self.bcatch.argname.match_symbol(function(node) {\n                    return node instanceof AST_SymbolCatch && !can_drop_symbol(node);\n                }, true))) {\n                var body = [];\n                if (self.bcatch) {\n                    extract_declarations_from_unreachable_code(compressor, self.bcatch, body);\n                    body.forEach(function(stat) {\n                        if (!(stat instanceof AST_Var)) return;\n                        stat.definitions.forEach(function(var_def) {\n                            var def = var_def.name.definition().redefined();\n                            if (!def) return;\n                            var_def.name = var_def.name.clone();\n                            var_def.name.thedef = def;\n                        });\n                    });\n                }\n                body.unshift(make_node(AST_BlockStatement, self, self).optimize(compressor));\n                if (self.bfinally) {\n                    body.push(make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor));\n                }\n                return make_node(AST_BlockStatement, self, {\n                    body: body\n                }).optimize(compressor);\n            }\n            if (self.bfinally && has_declarations_only(self.bfinally)) {\n                var body = make_node(AST_BlockStatement, self.bfinally, self.bfinally).optimize(compressor);\n                body = self.body.concat(body);\n                if (!self.bcatch) return make_node(AST_BlockStatement, self, {\n                    body: body\n                }).optimize(compressor);\n                self.body = body;\n                self.bfinally = null;\n            }\n        }\n        return self;\n    });\n\n    function remove_initializers(make_value) {\n        return function(compressor, defns) {\n            var dropped = false;\n            this.definitions.forEach(function(defn) {\n                if (defn.value) dropped = true;\n                defn.name.match_symbol(function(node) {\n                    if (node instanceof AST_SymbolDeclaration) defns.push(make_node(AST_VarDef, node, {\n                        name: node,\n                        value: make_value(compressor, node)\n                    }));\n                }, true);\n            });\n            return dropped;\n        };\n    }\n\n    AST_Const.DEFMETHOD(\"remove_initializers\", remove_initializers(function(compressor, node) {\n        return make_node(AST_Undefined, node).optimize(compressor);\n    }));\n    AST_Let.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n    AST_Var.DEFMETHOD(\"remove_initializers\", remove_initializers(return_null));\n\n    AST_Definitions.DEFMETHOD(\"to_assignments\", function() {\n        var assignments = this.definitions.reduce(function(a, defn) {\n            var def = defn.name.definition();\n            var value = defn.value;\n            if (value) {\n                if (value instanceof AST_Sequence) value = value.clone();\n                var name = make_node(AST_SymbolRef, defn.name, defn.name);\n                var assign = make_node(AST_Assign, defn, {\n                    operator: \"=\",\n                    left: name,\n                    right: value,\n                });\n                a.push(assign);\n                var fixed = function() {\n                    return assign.right;\n                };\n                fixed.assigns = [ assign ];\n                fixed.direct_access = def.direct_access;\n                fixed.escaped = def.escaped;\n                name.fixed = fixed;\n                def.references.forEach(function(ref) {\n                    var assigns = ref.fixed && ref.fixed.assigns;\n                    if (assigns && assigns[0] === defn) assigns[0] = assign;\n                });\n                def.references.push(name);\n            }\n            def.assignments++;\n            def.eliminated++;\n            def.single_use = false;\n            return a;\n        }, []);\n        if (assignments.length == 0) return null;\n        return make_sequence(this, assignments);\n    });\n\n    function is_safe_lexical(def) {\n        return def.name != \"arguments\" && def.orig.length < (def.orig[0] instanceof AST_SymbolLambda ? 3 : 2);\n    }\n\n    function may_overlap(compressor, def) {\n        if (compressor.exposed(def)) return true;\n        var scope = def.scope.resolve();\n        for (var s = def.scope; s !== scope;) {\n            s = s.parent_scope;\n            if (s.var_names().has(def.name)) return true;\n        }\n    }\n\n    function to_var(stat) {\n        return make_node(AST_Var, stat, {\n            definitions: stat.definitions.map(function(defn) {\n                return make_node(AST_VarDef, defn, {\n                    name: defn.name.convert_symbol(AST_SymbolVar, function(name, node) {\n                        var def = name.definition();\n                        def.orig[def.orig.indexOf(node)] = name;\n                        var scope = def.scope.resolve();\n                        if (def.scope === scope) return;\n                        def.scope = scope;\n                        scope.variables.set(def.name, def);\n                        scope.enclosed.push(def);\n                        scope.var_names().set(def.name, true);\n                    }),\n                    value: defn.value,\n                });\n            })\n        });\n    }\n\n    function can_varify(compressor, sym) {\n        if (!sym.fixed_value()) return false;\n        var def = sym.definition();\n        return is_safe_lexical(def) && same_scope(def) && !may_overlap(compressor, def);\n    }\n\n    function varify(self, compressor) {\n        return compressor.option(\"varify\") && all(self.definitions, function(defn) {\n            return !defn.name.match_symbol(function(node) {\n                if (node instanceof AST_SymbolDeclaration) return !can_varify(compressor, node);\n            }, true);\n        }) ? to_var(self) : self;\n    }\n\n    OPT(AST_Const, varify);\n    OPT(AST_Let, varify);\n\n    function trim_optional_chain(node, compressor) {\n        if (!compressor.option(\"optional_chains\")) return;\n        if (node.terminal) do {\n            var expr = node.expression;\n            if (node.optional) {\n                var ev = fuzzy_eval(compressor, expr, true);\n                if (ev == null) return make_node(AST_UnaryPrefix, node, {\n                    operator: \"void\",\n                    expression: expr,\n                }).optimize(compressor);\n                if (!(ev instanceof AST_Node)) node.optional = false;\n            }\n            node = expr;\n        } while ((node.TYPE == \"Call\" || node instanceof AST_PropAccess) && !node.terminal);\n    }\n\n    function lift_sequence_in_expression(node, compressor) {\n        var exp = node.expression;\n        if (!(exp instanceof AST_Sequence)) return node;\n        var x = exp.expressions.slice();\n        var e = node.clone();\n        e.expression = x.pop();\n        x.push(e);\n        return make_sequence(node, x);\n    }\n\n    function drop_unused_call_args(call, compressor, fns_with_marked_args) {\n        var exp = call.expression;\n        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n        if (!(fn instanceof AST_Lambda)) return;\n        if (fn.uses_arguments) return;\n        if (fn.pinned()) return;\n        if (fns_with_marked_args && fns_with_marked_args.indexOf(fn) < 0) return;\n        var args = call.args;\n        if (!all(args, function(arg) {\n            return !(arg instanceof AST_Spread);\n        })) return;\n        var argnames = fn.argnames;\n        var is_iife = fn === exp && !fn.name;\n        if (fn.rest) {\n            if (!(is_iife && compressor.option(\"rests\"))) return;\n            var insert = argnames.length;\n            args = args.slice(0, insert);\n            while (args.length < insert) args.push(make_node(AST_Undefined, call).optimize(compressor));\n            args.push(make_node(AST_Array, call, { elements: call.args.slice(insert) }));\n            argnames = argnames.concat(fn.rest);\n            fn.rest = null;\n        } else {\n            args = args.slice();\n            argnames = argnames.slice();\n        }\n        var pos = 0, last = 0;\n        var drop_defaults = is_iife && compressor.option(\"default_values\");\n        var drop_fargs = is_iife && compressor.drop_fargs(fn, call) ? function(argname, arg) {\n            if (!argname) return true;\n            if (argname instanceof AST_DestructuredArray) {\n                return argname.elements.length == 0 && !argname.rest && arg instanceof AST_Array;\n            }\n            if (argname instanceof AST_DestructuredObject) {\n                return argname.properties.length == 0 && !argname.rest && arg && !arg.may_throw_on_access(compressor);\n            }\n            return argname.unused;\n        } : return_false;\n        var side_effects = [];\n        for (var i = 0; i < args.length; i++) {\n            var argname = argnames[i];\n            if (drop_defaults && argname instanceof AST_DefaultValue && args[i].is_defined(compressor)) {\n                argnames[i] = argname = argname.name;\n            }\n            if (!argname || argname.unused !== undefined) {\n                var node = args[i].drop_side_effect_free(compressor);\n                if (drop_fargs(argname)) {\n                    if (argname) argnames.splice(i, 1);\n                    args.splice(i, 1);\n                    if (node) side_effects.push(node);\n                    i--;\n                    continue;\n                } else if (node) {\n                    side_effects.push(node);\n                    args[pos++] = make_sequence(call, side_effects);\n                    side_effects = [];\n                } else if (argname) {\n                    if (side_effects.length) {\n                        args[pos++] = make_sequence(call, side_effects);\n                        side_effects = [];\n                    } else {\n                        args[pos++] = make_node(AST_Number, args[i], {\n                            value: 0\n                        });\n                        continue;\n                    }\n                }\n            } else if (drop_fargs(argname, args[i])) {\n                var node = args[i].drop_side_effect_free(compressor);\n                argnames.splice(i, 1);\n                args.splice(i, 1);\n                if (node) side_effects.push(node);\n                i--;\n                continue;\n            } else {\n                side_effects.push(args[i]);\n                args[pos++] = make_sequence(call, side_effects);\n                side_effects = [];\n            }\n            last = pos;\n        }\n        for (; i < argnames.length; i++) {\n            if (drop_fargs(argnames[i])) argnames.splice(i--, 1);\n        }\n        fn.argnames = argnames;\n        args.length = last;\n        call.args = args;\n        if (!side_effects.length) return;\n        var arg = make_sequence(call, side_effects);\n        args.push(args.length < argnames.length ? make_node(AST_UnaryPrefix, call, {\n            operator: \"void\",\n            expression: arg,\n        }) : arg);\n    }\n\n    function avoid_await_yield(parent_scope) {\n        var avoid = [];\n        if (is_async(parent_scope)) avoid.push(\"await\");\n        if (is_generator(parent_scope)) avoid.push(\"yield\");\n        return avoid.length && makePredicate(avoid);\n    }\n\n    OPT(AST_Call, function(self, compressor) {\n        var exp = self.expression;\n        var terminated = trim_optional_chain(self, compressor);\n        if (terminated) return terminated;\n        if (compressor.option(\"sequences\")) {\n            if (exp instanceof AST_PropAccess) {\n                var seq = lift_sequence_in_expression(exp, compressor);\n                if (seq !== exp) {\n                    var call = self.clone();\n                    call.expression = seq.expressions.pop();\n                    seq.expressions.push(call);\n                    return seq.optimize(compressor);\n                }\n            } else if (!needs_unbinding(compressor, exp.tail_node())) {\n                var seq = lift_sequence_in_expression(self, compressor);\n                if (seq !== self) return seq.optimize(compressor);\n            }\n        }\n        if (compressor.option(\"unused\")) drop_unused_call_args(self, compressor);\n        if (compressor.option(\"unsafe\")) {\n            if (is_undeclared_ref(exp)) switch (exp.name) {\n              case \"Array\":\n                // Array(n) ---> [ , , ... , ]\n                if (self.args.length == 1) {\n                    var first = self.args[0];\n                    if (first instanceof AST_Number) try {\n                        var length = first.value;\n                        if (length > 6) break;\n                        var elements = Array(length);\n                        for (var i = 0; i < length; i++) elements[i] = make_node(AST_Hole, self);\n                        return make_node(AST_Array, self, { elements: elements });\n                    } catch (ex) {\n                        AST_Node.warn(\"Invalid array length: {length} [{file}:{line},{col}]\", {\n                            length: length,\n                            file: self.start.file,\n                            line: self.start.line,\n                            col: self.start.col,\n                        });\n                        break;\n                    }\n                    if (!first.is_boolean(compressor) && !first.is_string(compressor)) break;\n                }\n                // Array(...) ---> [ ... ]\n                return make_node(AST_Array, self, { elements: self.args });\n              case \"Object\":\n                // Object() ---> {}\n                if (self.args.length == 0) return make_node(AST_Object, self, { properties: [] });\n                break;\n              case \"String\":\n                // String() ---> \"\"\n                if (self.args.length == 0) return make_node(AST_String, self, { value: \"\" });\n                // String(x) ---> \"\" + x\n                if (self.args.length == 1) return make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: make_node(AST_String, self, { value: \"\" }),\n                    right: self.args[0],\n                }).optimize(compressor);\n                break;\n              case \"Number\":\n                // Number() ---> 0\n                if (self.args.length == 0) return make_node(AST_Number, self, { value: 0 });\n                // Number(x) ---> +(\"\" + x)\n                if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                    operator: \"+\",\n                    expression: make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self, { value: \"\" }),\n                        right: self.args[0],\n                    }),\n                }).optimize(compressor);\n                break;\n              case \"Boolean\":\n                // Boolean() ---> false\n                if (self.args.length == 0) return make_node(AST_False, self).optimize(compressor);\n                // Boolean(x) ---> !!x\n                if (self.args.length == 1) return make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: self.args[0],\n                    }),\n                }).optimize(compressor);\n                break;\n              case \"RegExp\":\n                // attempt to convert RegExp(...) to literal\n                var params = [];\n                if (all(self.args, function(arg) {\n                    var value = arg.evaluate(compressor);\n                    params.unshift(value);\n                    return arg !== value;\n                })) try {\n                    return best_of(compressor, self, make_node(AST_RegExp, self, {\n                        value: RegExp.apply(RegExp, params),\n                    }));\n                } catch (ex) {\n                    AST_Node.warn(\"Error converting {expr} [{file}:{line},{col}]\", {\n                        expr: self,\n                        file: self.start.file,\n                        line: self.start.line,\n                        col: self.start.col,\n                    });\n                }\n                break;\n            } else if (exp instanceof AST_Dot) switch (exp.property) {\n              case \"toString\":\n                // x.toString() ---> \"\" + x\n                var expr = exp.expression;\n                if (self.args.length == 0 && !(expr.may_throw_on_access(compressor) || expr instanceof AST_Super)) {\n                    return make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self, { value: \"\" }),\n                        right: expr,\n                    }).optimize(compressor);\n                }\n                break;\n              case \"join\":\n                if (exp.expression instanceof AST_Array && self.args.length < 2) EXIT: {\n                    var separator = self.args[0];\n                    // [].join() ---> \"\"\n                    // [].join(x) ---> (x, \"\")\n                    if (exp.expression.elements.length == 0 && !(separator instanceof AST_Spread)) {\n                        return separator ? make_sequence(self, [\n                            separator,\n                            make_node(AST_String, self, { value: \"\" }),\n                        ]).optimize(compressor) : make_node(AST_String, self, { value: \"\" });\n                    }\n                    if (separator) {\n                        separator = separator.evaluate(compressor);\n                        if (separator instanceof AST_Node) break EXIT; // not a constant\n                    }\n                    var elements = [];\n                    var consts = [];\n                    for (var i = 0; i < exp.expression.elements.length; i++) {\n                        var el = exp.expression.elements[i];\n                        var value = el.evaluate(compressor);\n                        if (value !== el) {\n                            consts.push(value);\n                        } else if (el instanceof AST_Spread) {\n                            break EXIT;\n                        } else {\n                            if (consts.length > 0) {\n                                elements.push(make_node(AST_String, self, {\n                                    value: consts.join(separator),\n                                }));\n                                consts.length = 0;\n                            }\n                            elements.push(el);\n                        }\n                    }\n                    if (consts.length > 0) elements.push(make_node(AST_String, self, {\n                        value: consts.join(separator),\n                    }));\n                    // [ x ].join() ---> \"\" + x\n                    // [ x ].join(\".\") ---> \"\" + x\n                    // [ 1, 2, 3 ].join() ---> \"1,2,3\"\n                    // [ 1, 2, 3 ].join(\".\") ---> \"1.2.3\"\n                    if (elements.length == 1) {\n                        if (elements[0].is_string(compressor)) return elements[0];\n                        return make_node(AST_Binary, elements[0], {\n                            operator: \"+\",\n                            left: make_node(AST_String, self, { value: \"\" }),\n                            right: elements[0],\n                        });\n                    }\n                    // [ 1, 2, a, 3 ].join(\"\") ---> \"12\" + a + \"3\"\n                    if (separator == \"\") {\n                        var first;\n                        if (elements[0].is_string(compressor) || elements[1].is_string(compressor)) {\n                            first = elements.shift();\n                        } else {\n                            first = make_node(AST_String, self, { value: \"\" });\n                        }\n                        return elements.reduce(function(prev, el) {\n                            return make_node(AST_Binary, el, {\n                                operator: \"+\",\n                                left: prev,\n                                right: el,\n                            });\n                        }, first).optimize(compressor);\n                    }\n                    // [ x, \"foo\", \"bar\", y ].join() ---> [ x, \"foo,bar\", y ].join()\n                    // [ x, \"foo\", \"bar\", y ].join(\"-\") ---> [ x, \"foo-bar\", y ].join(\"-\")\n                    // need this awkward cloning to not affect original element\n                    // best_of will decide which one to get through.\n                    var node = self.clone();\n                    node.expression = node.expression.clone();\n                    node.expression.expression = node.expression.expression.clone();\n                    node.expression.expression.elements = elements;\n                    return best_of(compressor, self, node);\n                }\n                break;\n              case \"charAt\":\n                if (self.args.length < 2) {\n                    var node = make_node(AST_Binary, self, {\n                        operator: \"||\",\n                        left: make_node(AST_Sub, self, {\n                            expression: exp.expression,\n                            property: self.args.length ? make_node(AST_Binary, self.args[0], {\n                                operator: \"|\",\n                                left: make_node(AST_Number, self, { value: 0 }),\n                                right: self.args[0],\n                            }) : make_node(AST_Number, self, { value: 0 }),\n                        }).optimize(compressor),\n                        right: make_node(AST_String, self, { value: \"\" }),\n                    });\n                    node.is_string = return_true;\n                    return node.optimize(compressor);\n                }\n                break;\n              case \"apply\":\n                if (self.args.length == 2 && self.args[1] instanceof AST_Array) {\n                    var args = self.args[1].elements.slice();\n                    args.unshift(self.args[0]);\n                    return make_node(AST_Call, self, {\n                        expression: make_node(AST_Dot, exp, {\n                            expression: exp.expression,\n                            property: \"call\",\n                        }),\n                        args: args\n                    }).optimize(compressor);\n                }\n                break;\n              case \"call\":\n                var func = exp.expression;\n                if (func instanceof AST_SymbolRef) {\n                    func = func.fixed_value();\n                }\n                if (func instanceof AST_Lambda && !func.contains_this()) {\n                    return (self.args.length ? make_sequence(this, [\n                        self.args[0],\n                        make_node(AST_Call, self, {\n                            expression: exp.expression,\n                            args: self.args.slice(1)\n                        })\n                    ]) : make_node(AST_Call, self, {\n                        expression: exp.expression,\n                        args: []\n                    })).optimize(compressor);\n                }\n                break;\n            }\n        }\n        if (compressor.option(\"unsafe_Function\")\n            && is_undeclared_ref(exp)\n            && exp.name == \"Function\") {\n            // new Function() ---> function(){}\n            if (self.args.length == 0) return make_node(AST_Function, self, {\n                argnames: [],\n                body: []\n            }).init_vars(exp.scope);\n            if (all(self.args, function(x) {\n                return x instanceof AST_String;\n            })) {\n                // quite a corner-case, but we can handle it:\n                //   https://github.com/mishoo/UglifyJS/issues/203\n                // if the code argument is a constant, then we can minify it.\n                try {\n                    var code = \"n(function(\" + self.args.slice(0, -1).map(function(arg) {\n                        return arg.value;\n                    }).join() + \"){\" + self.args[self.args.length - 1].value + \"})\";\n                    var ast = parse(code);\n                    var mangle = { ie: compressor.option(\"ie\") };\n                    ast.figure_out_scope(mangle);\n                    var comp = new Compressor(compressor.options);\n                    ast = ast.transform(comp);\n                    ast.figure_out_scope(mangle);\n                    ast.compute_char_frequency(mangle);\n                    ast.mangle_names(mangle);\n                    var fun;\n                    ast.walk(new TreeWalker(function(node) {\n                        if (fun) return true;\n                        if (node instanceof AST_Lambda) {\n                            fun = node;\n                            return true;\n                        }\n                    }));\n                    var code = OutputStream();\n                    AST_BlockStatement.prototype._codegen.call(fun, code);\n                    self.args = [\n                        make_node(AST_String, self, {\n                            value: fun.argnames.map(function(arg) {\n                                return arg.print_to_string();\n                            }).join(),\n                        }),\n                        make_node(AST_String, self.args[self.args.length - 1], {\n                            value: code.get().replace(/^\\{|\\}$/g, \"\")\n                        })\n                    ];\n                    return self;\n                } catch (ex) {\n                    if (ex instanceof JS_Parse_Error) {\n                        AST_Node.warn(\"Error parsing code passed to new Function [{file}:{line},{col}]\", self.args[self.args.length - 1].start);\n                        AST_Node.warn(ex.toString());\n                    } else {\n                        throw ex;\n                    }\n                }\n            }\n        }\n        var fn = exp instanceof AST_SymbolRef ? exp.fixed_value() : exp;\n        var parent = compressor.parent(), current = compressor.self();\n        var is_func = fn instanceof AST_Lambda\n            && (!is_async(fn) || compressor.option(\"awaits\") && parent instanceof AST_Await)\n            && (!is_generator(fn) || compressor.option(\"yields\") && current instanceof AST_Yield && current.nested);\n        var stat = is_func && fn.first_statement();\n        var has_default = 0, has_destructured = false;\n        var has_spread = !all(self.args, function(arg) {\n            return !(arg instanceof AST_Spread);\n        });\n        var can_drop = is_func && all(fn.argnames, function(argname, index) {\n            if (has_default == 1 && self.args[index] instanceof AST_Spread) has_default = 2;\n            if (argname instanceof AST_DefaultValue) {\n                if (!has_default) has_default = 1;\n                var arg = has_default == 1 && self.args[index];\n                if (arg && !is_undefined(arg)) has_default = 2;\n                if (has_arg_refs(argname.value)) return false;\n                argname = argname.name;\n            }\n            if (argname instanceof AST_Destructured) {\n                has_destructured = true;\n                if (has_arg_refs(argname)) return false;\n            }\n            return true;\n        }) && !(fn.rest instanceof AST_Destructured && has_arg_refs(fn.rest));\n        var can_inline = can_drop && compressor.option(\"inline\") && !self.is_expr_pure(compressor);\n        if (can_inline && stat instanceof AST_Return) {\n            var value = stat.value;\n            if (exp === fn\n                && !fn.name\n                && (!value || value.is_constant_expression())\n                && safe_from_await_yield(fn, compressor.find_parent(AST_Scope))) {\n                return make_sequence(self, convert_args(value)).optimize(compressor);\n            }\n        }\n        if (is_func) {\n            var def, value, var_assigned = false;\n            if (can_inline\n                && !fn.uses_arguments\n                && !fn.pinned()\n                && !(fn.name && fn instanceof AST_LambdaExpression)\n                && (exp === fn || !recursive_ref(compressor, def = exp.definition(), fn)\n                    && fn.is_constant_expression(find_scope(compressor)))\n                && !has_spread\n                && (value = can_flatten_body(stat))\n                && !fn.contains_this()) {\n                var replacing = exp === fn || def.single_use && def.references.length - def.replaced == 1;\n                if (can_substitute_directly()) {\n                    var args = self.args.slice();\n                    var refs = [];\n                    var retValue = value.clone(true).transform(new TreeTransformer(function(node) {\n                        if (node instanceof AST_SymbolRef) {\n                            var def = node.definition();\n                            if (fn.variables.get(node.name) !== def) {\n                                refs.push(node);\n                                return node;\n                            }\n                            var index = resolve_index(def);\n                            var arg = args[index];\n                            if (!arg) return make_node(AST_Undefined, self);\n                            args[index] = null;\n                            var parent = this.parent();\n                            return parent ? maintain_this_binding(compressor, parent, node, arg) : arg;\n                        }\n                    }));\n                    var save_inlined = fn.inlined;\n                    if (exp !== fn) fn.inlined = true;\n                    var exprs = [];\n                    args.forEach(function(arg) {\n                        if (!arg) return;\n                        arg = arg.clone(true);\n                        arg.walk(new TreeWalker(function(node) {\n                            if (node instanceof AST_SymbolRef) refs.push(node);\n                        }));\n                        exprs.push(arg);\n                    }, []);\n                    exprs.push(retValue);\n                    var node = make_sequence(self, exprs).optimize(compressor);\n                    fn.inlined = save_inlined;\n                    node = maintain_this_binding(compressor, parent, current, node);\n                    if (replacing || best_of_expression(node, self) === node) {\n                        refs.forEach(function(ref) {\n                            ref.scope = exp === fn ? fn.parent_scope : exp.scope;\n                            ref.reference();\n                            var def = ref.definition();\n                            if (replacing) def.replaced++;\n                            def.single_use = false;\n                        });\n                        return node;\n                    } else if (!node.has_side_effects(compressor)) {\n                        self.drop_side_effect_free = function(compressor, first_in_statement) {\n                            var self = this;\n                            var exprs = self.args.slice();\n                            exprs.unshift(self.expression);\n                            return make_sequence(self, exprs).drop_side_effect_free(compressor, first_in_statement);\n                        };\n                    }\n                }\n                var arg_used, insert, in_loop, scope;\n                if (replacing && can_inject_symbols()) {\n                    fn._squeezed = true;\n                    if (exp !== fn) fn.parent_scope = exp.scope;\n                    var node = make_sequence(self, flatten_fn()).optimize(compressor);\n                    return maintain_this_binding(compressor, parent, current, node);\n                }\n            }\n            if (compressor.option(\"side_effects\")\n                && can_drop\n                && all(fn.body, is_empty)\n                && (fn === exp ? fn_name_unused(fn, compressor) : !has_default && !has_destructured && !fn.rest)\n                && !(is_arrow(fn) && fn.value)\n                && safe_from_await_yield(fn, compressor.find_parent(AST_Scope))) {\n                return make_sequence(self, convert_args()).optimize(compressor);\n            }\n        }\n        if (compressor.option(\"drop_console\")) {\n            if (exp instanceof AST_PropAccess) {\n                var name = exp.expression;\n                while (name.expression) {\n                    name = name.expression;\n                }\n                if (is_undeclared_ref(name) && name.name == \"console\") {\n                    return make_node(AST_Undefined, self).optimize(compressor);\n                }\n            }\n        }\n        if (compressor.option(\"negate_iife\") && parent instanceof AST_SimpleStatement && is_iife_call(current)) {\n            return self.negate(compressor, true);\n        }\n        return try_evaluate(compressor, self);\n\n        function has_arg_refs(node) {\n            var found = false;\n            node.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_SymbolRef && fn.variables.get(node.name) === node.definition()) {\n                    return found = true;\n                }\n            }));\n            return found;\n        }\n\n        function make_void_lhs(orig) {\n            return make_node(AST_Dot, orig, {\n                expression: make_node(AST_Array, orig, { elements: [] }),\n                property: \"e\",\n            });\n        }\n\n        function convert_args(value) {\n            var args = self.args.slice();\n            var destructured = has_default > 1 || has_destructured || fn.rest;\n            if (destructured || has_spread) args = [ make_node(AST_Array, self, { elements: args }) ];\n            if (destructured) {\n                var tt = new TreeTransformer(function(node, descend) {\n                    if (node instanceof AST_DefaultValue) return make_node(AST_DefaultValue, node, {\n                        name: node.name.transform(tt) || make_void_lhs(node),\n                        value: node.value,\n                    });\n                    if (node instanceof AST_DestructuredArray) {\n                        var elements = [];\n                        node.elements.forEach(function(node, index) {\n                            node = node.transform(tt);\n                            if (node) elements[index] = node;\n                        });\n                        fill_holes(node, elements);\n                        return make_node(AST_DestructuredArray, node, { elements: elements });\n                    }\n                    if (node instanceof AST_DestructuredObject) {\n                        var properties = [], side_effects = [];\n                        node.properties.forEach(function(prop) {\n                            var key = prop.key;\n                            var value = prop.value.transform(tt);\n                            if (value) {\n                                if (side_effects.length) {\n                                    if (!(key instanceof AST_Node)) key = make_node_from_constant(key, prop);\n                                    side_effects.push(key);\n                                    key = make_sequence(node, side_effects);\n                                    side_effects = [];\n                                }\n                                properties.push(make_node(AST_DestructuredKeyVal, prop, {\n                                    key: key,\n                                    value: value,\n                                }));\n                            } else if (key instanceof AST_Node) {\n                                side_effects.push(key);\n                            }\n                        });\n                        if (side_effects.length) properties.push(make_node(AST_DestructuredKeyVal, node, {\n                            key: make_sequence(node, side_effects),\n                            value: make_void_lhs(node),\n                        }));\n                        return make_node(AST_DestructuredObject, node, { properties: properties });\n                    }\n                    if (node instanceof AST_SymbolFunarg) return null;\n                });\n                var lhs = [];\n                fn.argnames.forEach(function(argname, index) {\n                    argname = argname.transform(tt);\n                    if (argname) lhs[index] = argname;\n                });\n                var rest = fn.rest && fn.rest.transform(tt);\n                if (rest) lhs.length = fn.argnames.length;\n                fill_holes(fn, lhs);\n                args[0] = make_node(AST_Assign, self, {\n                    operator: \"=\",\n                    left: make_node(AST_DestructuredArray, fn, {\n                        elements: lhs,\n                        rest: rest,\n                    }),\n                    right: args[0],\n                });\n            } else fn.argnames.forEach(function(argname) {\n                if (argname instanceof AST_DefaultValue) args.push(argname.value);\n            });\n            args.push(value || make_node(AST_Undefined, self));\n            return args;\n        }\n\n        function safe_from_await_yield(node, scope) {\n            var avoid = avoid_await_yield(scope);\n            if (!avoid) return true;\n            var safe = true;\n            var tw = new TreeWalker(function(node) {\n                if (!safe) return true;\n                if (node instanceof AST_Scope) {\n                    if (node === fn) return;\n                    if (is_arrow(node)) {\n                        for (var i = 0; safe && i < node.argnames.length; i++) node.argnames[i].walk(tw);\n                    } else if (node instanceof AST_LambdaDefinition && avoid[node.name.name]) {\n                        safe = false;\n                    }\n                    return true;\n                }\n                if (node instanceof AST_Symbol && avoid[node.name] && node !== fn.name) safe = false;\n            });\n            node.walk(tw);\n            return safe;\n        }\n\n        function noop_value() {\n            return self.call_only ? make_node(AST_Number, self, { value: 0 }) : make_node(AST_Undefined, self);\n        }\n\n        function return_value(stat) {\n            if (!stat) return noop_value();\n            if (stat instanceof AST_Return) return stat.value || noop_value();\n            if (stat instanceof AST_SimpleStatement) {\n                return self.call_only ? stat.body : make_node(AST_UnaryPrefix, stat, {\n                    operator: \"void\",\n                    expression: stat.body,\n                });\n            }\n        }\n\n        function can_flatten_body(stat) {\n            var len = fn.body.length;\n            if (len < 2) {\n                stat = return_value(stat);\n                if (stat) return stat;\n            }\n            if (compressor.option(\"inline\") < 3) return false;\n            stat = null;\n            for (var i = 0; i < len; i++) {\n                var line = fn.body[i];\n                if (line instanceof AST_Var) {\n                    var assigned = var_assigned || !declarations_only(line);\n                    if (assigned) {\n                        var_assigned = true;\n                        if (stat) return false;\n                    }\n                } else if (line instanceof AST_AsyncDefun\n                    || line instanceof AST_Defun\n                    || line instanceof AST_EmptyStatement) {\n                    continue;\n                } else if (stat) {\n                    return false;\n                } else {\n                    stat = line;\n                }\n            }\n            return return_value(stat);\n        }\n\n        function resolve_index(def) {\n            for (var i = fn.argnames.length; --i >= 0;) {\n                if (fn.argnames[i].definition() === def) return i;\n            }\n        }\n\n        function can_substitute_directly() {\n            if (has_default || has_destructured || var_assigned || fn.rest) return;\n            if (compressor.option(\"inline\") < 2 && fn.argnames.length) return;\n            if (!fn.variables.all(function(def) {\n                return def.references.length - def.replaced < 2 && def.orig[0] instanceof AST_SymbolFunarg;\n            })) return;\n            var scope = compressor.find_parent(AST_Scope);\n            var abort = false;\n            var avoid = avoid_await_yield(scope);\n            var begin;\n            var in_order = [];\n            var side_effects = false;\n            value.walk(new TreeWalker(function(node, descend) {\n                if (abort) return true;\n                if (node instanceof AST_Binary && lazy_op[node.operator]\n                    || node instanceof AST_Conditional) {\n                    in_order = null;\n                    return;\n                }\n                if (node instanceof AST_Scope) return abort = true;\n                if (avoid && node instanceof AST_Symbol && avoid[node.name]) return abort = true;\n                if (node instanceof AST_SymbolRef) {\n                    var def = node.definition();\n                    if (fn.variables.get(node.name) !== def) {\n                        in_order = null;\n                        return;\n                    }\n                    if (def.init instanceof AST_LambdaDefinition) return abort = true;\n                    if (is_lhs(node, this.parent())) return abort = true;\n                    var index = resolve_index(def);\n                    if (!(begin < index)) begin = index;\n                    if (!in_order) return;\n                    if (side_effects) {\n                        in_order = null;\n                    } else {\n                        in_order.push(fn.argnames[index]);\n                    }\n                    return;\n                }\n                if (node.has_side_effects(compressor)) {\n                    descend();\n                    side_effects = true;\n                    return true;\n                }\n            }));\n            if (abort) return;\n            var end = self.args.length;\n            if (in_order && fn.argnames.length >= end) {\n                end = fn.argnames.length;\n                while (end-- > begin && fn.argnames[end] === in_order.pop());\n                end++;\n            }\n            return end <= begin || all(self.args.slice(begin, end), side_effects && !in_order ? function(funarg) {\n                return funarg.is_constant_expression(scope);\n            } : function(funarg) {\n                return !funarg.has_side_effects(compressor);\n            });\n        }\n\n        function var_exists(defined, name) {\n            return defined.has(name) || identifier_atom[name] || scope.var_names().has(name);\n        }\n\n        function can_inject_args(defined, safe_to_inject) {\n            var abort = false;\n            fn.each_argname(function(arg) {\n                if (abort) return;\n                if (arg.unused) return;\n                if (!safe_to_inject || var_exists(defined, arg.name)) return abort = true;\n                arg_used.set(arg.name, true);\n                if (in_loop) in_loop.push(arg.definition());\n            });\n            return !abort;\n        }\n\n        function can_inject_vars(defined, safe_to_inject) {\n            for (var i = 0; i < fn.body.length; i++) {\n                var stat = fn.body[i];\n                if (stat instanceof AST_LambdaDefinition) {\n                    var name = stat.name;\n                    if (!safe_to_inject) return false;\n                    if (arg_used.has(name.name)) return false;\n                    if (var_exists(defined, name.name)) return false;\n                    if (!all(stat.enclosed, function(def) {\n                        return def.scope === stat || !defined.has(def.name);\n                    })) return false;\n                    if (in_loop) in_loop.push(name.definition());\n                    continue;\n                }\n                if (!(stat instanceof AST_Var)) continue;\n                if (!safe_to_inject) return false;\n                for (var j = stat.definitions.length; --j >= 0;) {\n                    var name = stat.definitions[j].name;\n                    if (var_exists(defined, name.name)) return false;\n                    if (in_loop) in_loop.push(name.definition());\n                }\n            }\n            return true;\n        }\n\n        function can_inject_symbols() {\n            var defined = new Dictionary();\n            var level = 0, child;\n            scope = current;\n            do {\n                if (scope.variables) scope.variables.each(function(def) {\n                    defined.set(def.name, true);\n                });\n                child = scope;\n                scope = compressor.parent(level++);\n                if (scope instanceof AST_DWLoop) {\n                    in_loop = [];\n                } else if (scope instanceof AST_For) {\n                    if (scope.init === child) continue;\n                    in_loop = [];\n                } else if (scope instanceof AST_ForEnumeration) {\n                    if (scope.init === child) continue;\n                    if (scope.object === child) continue;\n                    in_loop = [];\n                } else if (scope instanceof AST_SymbolRef) {\n                    if (scope.fixed_value() instanceof AST_Scope) return false;\n                }\n            } while (!(scope instanceof AST_Scope));\n            insert = scope.body.indexOf(child) + 1;\n            if (!insert) return false;\n            if (!safe_from_await_yield(fn, scope)) return false;\n            var safe_to_inject = exp !== fn || fn.parent_scope.resolve() === scope;\n            if (scope instanceof AST_Toplevel) {\n                if (compressor.toplevel.vars) {\n                    defined.set(\"arguments\", true);\n                } else {\n                    safe_to_inject = false;\n                }\n            }\n            arg_used = new Dictionary();\n            var inline = compressor.option(\"inline\");\n            if (!can_inject_args(defined, inline >= 2 && safe_to_inject)) return false;\n            if (!can_inject_vars(defined, inline >= 3 && safe_to_inject)) return false;\n            return !in_loop || in_loop.length == 0 || !is_reachable(fn, in_loop);\n        }\n\n        function append_var(decls, expressions, name, value) {\n            var def = name.definition();\n            if (!scope.var_names().has(name.name)) {\n                scope.var_names().set(name.name, true);\n                decls.push(make_node(AST_VarDef, name, {\n                    name: name,\n                    value: null,\n                }));\n            }\n            scope.variables.set(name.name, def);\n            scope.enclosed.push(def);\n            if (!value) return;\n            var sym = make_node(AST_SymbolRef, name, name);\n            def.references.push(sym);\n            expressions.push(make_node(AST_Assign, self, {\n                operator: \"=\",\n                left: sym,\n                right: value,\n            }));\n        }\n\n        function flatten_args(decls, expressions) {\n            var len = fn.argnames.length;\n            for (var i = self.args.length; --i >= len;) {\n                expressions.push(self.args[i]);\n            }\n            var default_args = [];\n            for (i = len; --i >= 0;) {\n                var argname = fn.argnames[i];\n                var name;\n                if (argname instanceof AST_DefaultValue) {\n                    default_args.push(argname);\n                    name = argname.name;\n                } else {\n                    name = argname;\n                }\n                var value = self.args[i];\n                if (name.unused || scope.var_names().has(name.name)) {\n                    if (value) expressions.push(value);\n                } else {\n                    var symbol = make_node(AST_SymbolVar, name, name);\n                    name.definition().orig.push(symbol);\n                    if (name.unused !== undefined) {\n                        append_var(decls, expressions, symbol);\n                        if (value) expressions.push(value);\n                    } else {\n                        if (!value && in_loop && argname === name) value = make_node(AST_Undefined, self);\n                        append_var(decls, expressions, symbol, value);\n                    }\n                }\n            }\n            decls.reverse();\n            expressions.reverse();\n            for (i = default_args.length; --i >= 0;) {\n                var node = default_args[i];\n                if (node.name.unused !== undefined) {\n                    expressions.push(node.value);\n                } else {\n                    var sym = make_node(AST_SymbolRef, node.name, node.name);\n                    node.name.definition().references.push(sym);\n                    expressions.push(make_node(AST_Assign, node, {\n                        operator: \"=\",\n                        left: sym,\n                        right: node.value,\n                    }));\n                }\n            }\n        }\n\n        function flatten_destructured(decls, expressions) {\n            expressions.push(make_node(AST_Assign, self, {\n                operator: \"=\",\n                left: make_node(AST_DestructuredArray, self, {\n                    elements: fn.argnames.map(function(argname) {\n                        if (argname.unused) return make_node(AST_Hole, argname);\n                        return argname.convert_symbol(AST_SymbolRef, process);\n                    }),\n                    rest: fn.rest && fn.rest.convert_symbol(AST_SymbolRef, process),\n                }),\n                right: make_node(AST_Array, self, { elements: self.args.slice() }),\n            }));\n\n            function process(ref, name) {\n                var def = name.definition();\n                def.references.push(ref);\n                var symbol = make_node(AST_SymbolVar, name, name);\n                def.orig.push(symbol);\n                append_var(decls, expressions, symbol);\n            }\n        }\n\n        function flatten_var(name) {\n            var redef = name.definition().redefined();\n            if (redef) {\n                name = name.clone();\n                name.thedef = redef;\n            }\n            return name;\n        }\n\n        function flatten_vars(decls, expressions) {\n            var args = [ insert, 0 ];\n            var decl_var = [], expr_var = [], expr_loop = [];\n            for (var i = 0; i < fn.body.length; i++) {\n                var stat = fn.body[i];\n                if (stat instanceof AST_LambdaDefinition) {\n                    if (in_loop) {\n                        var name = make_node(AST_SymbolVar, stat.name, flatten_var(stat.name));\n                        name.definition().orig.push(name);\n                        append_var(decls, expressions, name, to_func_expr(stat, true));\n                    } else {\n                        var def = stat.name.definition();\n                        scope.functions.set(def.name, def);\n                        scope.variables.set(def.name, def);\n                        scope.enclosed.push(def);\n                        scope.var_names().set(def.name, true);\n                        args.push(stat);\n                    }\n                    continue;\n                }\n                if (!(stat instanceof AST_Var)) continue;\n                for (var j = 0; j < stat.definitions.length; j++) {\n                    var var_def = stat.definitions[j];\n                    var name = flatten_var(var_def.name);\n                    append_var(decl_var, expr_var, name, var_def.value);\n                    if (in_loop && !arg_used.has(name.name)) {\n                        var def = fn.variables.get(name.name);\n                        var sym = make_node(AST_SymbolRef, name, name);\n                        def.references.push(sym);\n                        expr_loop.push(make_node(AST_Assign, var_def, {\n                            operator: \"=\",\n                            left: sym,\n                            right: make_node(AST_Undefined, name),\n                        }));\n                    }\n                }\n            }\n            [].push.apply(decls, decl_var);\n            [].push.apply(expressions, expr_loop);\n            [].push.apply(expressions, expr_var);\n            return args;\n        }\n\n        function flatten_fn() {\n            var decls = [];\n            var expressions = [];\n            if (has_default > 1 || has_destructured || fn.rest) {\n                flatten_destructured(decls, expressions);\n            } else {\n                flatten_args(decls, expressions);\n            }\n            var args = flatten_vars(decls, expressions);\n            expressions.push(value);\n            if (decls.length) args.push(make_node(AST_Var, fn, {\n                definitions: decls\n            }));\n            [].splice.apply(scope.body, args);\n            fn.enclosed.forEach(function(def) {\n                if (scope.var_names().has(def.name)) return;\n                scope.enclosed.push(def);\n                scope.var_names().set(def.name, true);\n            });\n            return expressions;\n        }\n    });\n\n    OPT(AST_New, function(self, compressor) {\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"unused\")) drop_unused_call_args(self, compressor);\n        if (compressor.option(\"unsafe\")) {\n            var exp = self.expression;\n            if (is_undeclared_ref(exp)) {\n                switch (exp.name) {\n                  case \"Object\":\n                  case \"RegExp\":\n                  case \"Function\":\n                  case \"Error\":\n                  case \"Array\":\n                    return make_node(AST_Call, self, self).transform(compressor);\n                }\n            }\n        }\n        return self;\n    });\n\n    // (a = b, x && a = c) ---> a = x ? c : b\n    // (a = b, x || a = c) ---> a = x ? b : c\n    function to_conditional_assignment(compressor, def, value, node) {\n        if (!(node instanceof AST_Binary)) return;\n        if (!(node.operator == \"&&\" || node.operator == \"||\")) return;\n        if (!(node.right instanceof AST_Assign)) return;\n        if (node.right.operator != \"=\") return;\n        if (!(node.right.left instanceof AST_SymbolRef)) return;\n        if (node.right.left.definition() !== def) return;\n        if (value.has_side_effects(compressor)) return;\n        if (!safe_from_assignment(node.left)) return;\n        if (!safe_from_assignment(node.right.right)) return;\n        def.replaced++;\n        return node.operator == \"&&\" ? make_node(AST_Conditional, node, {\n            condition: node.left,\n            consequent: node.right.right,\n            alternative: value\n        }) : make_node(AST_Conditional, node, {\n            condition: node.left,\n            consequent: value,\n            alternative: node.right.right\n        });\n\n        function safe_from_assignment(node) {\n            if (node.has_side_effects(compressor)) return;\n            var hit = false;\n            node.walk(new TreeWalker(function(node) {\n                if (hit) return true;\n                if (node instanceof AST_SymbolRef && node.definition() === def) return hit = true;\n            }));\n            return !hit;\n        }\n    }\n\n    OPT(AST_Sequence, function(self, compressor) {\n        var expressions = filter_for_side_effects();\n        var end = expressions.length - 1;\n        merge_assignments();\n        trim_right_for_undefined();\n        if (end == 0) {\n            self = maintain_this_binding(compressor, compressor.parent(), compressor.self(), expressions[0]);\n            if (!(self instanceof AST_Sequence)) self = self.optimize(compressor);\n            return self;\n        }\n        self.expressions = expressions;\n        return self;\n\n        function filter_for_side_effects() {\n            if (!compressor.option(\"side_effects\")) return self.expressions;\n            var expressions = [];\n            var first = first_in_statement(compressor);\n            var last = self.expressions.length - 1;\n            self.expressions.forEach(function(expr, index) {\n                if (index < last) expr = expr.drop_side_effect_free(compressor, first);\n                if (expr) {\n                    merge_sequence(expressions, expr);\n                    first = false;\n                }\n            });\n            return expressions;\n        }\n\n        function trim_right_for_undefined() {\n            if (!compressor.option(\"side_effects\")) return;\n            while (end > 0 && is_undefined(expressions[end], compressor)) end--;\n            if (end < expressions.length - 1) {\n                expressions[end] = make_node(AST_UnaryPrefix, self, {\n                    operator   : \"void\",\n                    expression : expressions[end]\n                });\n                expressions.length = end + 1;\n            }\n        }\n\n        function is_simple_assign(node) {\n            return node instanceof AST_Assign\n                && node.operator == \"=\"\n                && node.left instanceof AST_SymbolRef\n                && node.left.definition();\n        }\n\n        function merge_assignments() {\n            for (var i = 1; i < end; i++) {\n                var prev = expressions[i - 1];\n                var def = is_simple_assign(prev);\n                if (!def) continue;\n                var expr = expressions[i];\n                if (compressor.option(\"conditionals\")) {\n                    var cond = to_conditional_assignment(compressor, def, prev.right, expr);\n                    if (cond) {\n                        prev.right = cond;\n                        expressions.splice(i--, 1);\n                        end--;\n                        continue;\n                    }\n                }\n                if (compressor.option(\"dead_code\")\n                    && is_simple_assign(expr) === def\n                    && expr.right.is_constant_expression(def.scope.resolve())) {\n                    expressions[--i] = prev.right;\n                }\n            }\n        }\n    });\n\n    OPT(AST_UnaryPostfix, function(self, compressor) {\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        return try_evaluate(compressor, self);\n    });\n\n    var SIGN_OPS = makePredicate(\"+ -\");\n    var MULTIPLICATIVE_OPS = makePredicate(\"* / %\");\n    OPT(AST_UnaryPrefix, function(self, compressor) {\n        var op = self.operator;\n        var exp = self.expression;\n        if (compressor.option(\"evaluate\") && op == \"delete\" && !may_not_delete(exp)) {\n            return make_sequence(self, [ exp, make_node(AST_True, self) ]).optimize(compressor);\n        }\n        if (compressor.option(\"sequences\") && can_lift()) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"side_effects\") && op == \"void\") {\n            exp = exp.drop_side_effect_free(compressor);\n            if (!exp) return make_node(AST_Undefined, self).optimize(compressor);\n            self.expression = exp;\n            return self;\n        }\n        if (compressor.option(\"booleans\")) {\n            if (op == \"!\" && exp.is_truthy()) {\n                return make_sequence(self, [ exp, make_node(AST_False, self) ]).optimize(compressor);\n            } else if (compressor.in_boolean_context()) switch (op) {\n              case \"!\":\n                if (exp instanceof AST_UnaryPrefix && exp.operator == \"!\") {\n                    // !!foo ---> foo, if we're in boolean context\n                    return exp.expression;\n                }\n                if (exp instanceof AST_Binary) {\n                    self = best_of(compressor, self, exp.negate(compressor, first_in_statement(compressor)));\n                }\n                break;\n              case \"typeof\":\n                // typeof always returns a non-empty string, thus it's\n                // always true in booleans\n                AST_Node.warn(\"Boolean expression always true [{file}:{line},{col}]\", self.start);\n                var exprs = [ make_node(AST_True, self) ];\n                if (!(exp instanceof AST_SymbolRef && can_drop_symbol(exp, compressor))) exprs.unshift(exp);\n                return make_sequence(self, exprs).optimize(compressor);\n            }\n        }\n        if (op == \"-\" && exp instanceof AST_Infinity) exp = exp.transform(compressor);\n        if (compressor.option(\"evaluate\")\n            && exp instanceof AST_Binary\n            && SIGN_OPS[op]\n            && MULTIPLICATIVE_OPS[exp.operator]\n            && (exp.left.is_constant() || !exp.right.has_side_effects(compressor))) {\n            return make_node(AST_Binary, self, {\n                operator: exp.operator,\n                left: make_node(AST_UnaryPrefix, exp.left, {\n                    operator: op,\n                    expression: exp.left\n                }),\n                right: exp.right\n            });\n        }\n        // avoids infinite recursion of numerals\n        return op == \"-\" && (exp instanceof AST_Number || exp instanceof AST_Infinity)\n            ? self : try_evaluate(compressor, self);\n\n        function may_not_delete(node) {\n            return node instanceof AST_Infinity\n                || node instanceof AST_NaN\n                || node instanceof AST_NewTarget\n                || node instanceof AST_PropAccess\n                || node instanceof AST_SymbolRef\n                || node instanceof AST_Undefined;\n        }\n\n        function can_lift() {\n            switch (op) {\n              case \"delete\":\n                return !may_not_delete(exp.tail_node());\n              case \"typeof\":\n                return !is_undeclared_ref(exp.tail_node());\n              default:\n                return true;\n            }\n        }\n    });\n\n    OPT(AST_Await, function(self, compressor) {\n        if (!compressor.option(\"awaits\")) return self;\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"side_effects\")) {\n            var exp = self.expression;\n            if (exp instanceof AST_Await) return exp.optimize(compressor);\n            if (exp instanceof AST_UnaryPrefix) {\n                if (exp.expression instanceof AST_Await) return exp.optimize(compressor);\n                if (exp.operator == \"void\") return make_node(AST_UnaryPrefix, self, {\n                    operator: \"void\",\n                    expression: make_node(AST_Await, self, { expression: exp.expression }),\n                }).optimize(compressor);\n            }\n            for (var level = 0, node = self, parent; parent = compressor.parent(level++); node = parent) {\n                if (is_arrow(parent)) {\n                    if (parent.value === node) return exp.optimize(compressor);\n                } else if (parent instanceof AST_Return) {\n                    var drop = true;\n                    do {\n                        node = parent;\n                        parent = compressor.parent(level++);\n                        if (parent instanceof AST_Try && (parent.bfinally || parent.bcatch) !== node) {\n                            drop = false;\n                            break;\n                        }\n                    } while (parent && !(parent instanceof AST_Scope));\n                    if (drop) return exp.optimize(compressor);\n                } else if (parent instanceof AST_Sequence) {\n                    if (parent.tail_node() === node) continue;\n                }\n                break;\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_Yield, function(self, compressor) {\n        if (!compressor.option(\"yields\")) return self;\n        if (compressor.option(\"sequences\")) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        var exp = self.expression;\n        if (self.nested && exp.TYPE == \"Call\") {\n            var inlined = exp.clone().optimize(compressor);\n            if (inlined.TYPE != \"Call\") return inlined;\n        }\n        return self;\n    });\n\n    AST_Binary.DEFMETHOD(\"lift_sequences\", function(compressor) {\n        if (this.left instanceof AST_PropAccess) {\n            if (!(this.left.expression instanceof AST_Sequence)) return this;\n            var x = this.left.expression.expressions.slice();\n            var e = this.clone();\n            e.left = e.left.clone();\n            e.left.expression = x.pop();\n            x.push(e);\n            return make_sequence(this, x);\n        }\n        if (this.left instanceof AST_Sequence) {\n            var x = this.left.expressions.slice();\n            var e = this.clone();\n            e.left = x.pop();\n            x.push(e);\n            return make_sequence(this, x);\n        }\n        if (this.right instanceof AST_Sequence) {\n            if (this.left.has_side_effects(compressor)) return this;\n            var assign = this.operator == \"=\" && this.left instanceof AST_SymbolRef;\n            var x = this.right.expressions;\n            var last = x.length - 1;\n            for (var i = 0; i < last; i++) {\n                if (!assign && x[i].has_side_effects(compressor)) break;\n            }\n            if (i == last) {\n                x = x.slice();\n                var e = this.clone();\n                e.right = x.pop();\n                x.push(e);\n                return make_sequence(this, x);\n            }\n            if (i > 0) {\n                var e = this.clone();\n                e.right = make_sequence(this.right, x.slice(i));\n                x = x.slice(0, i);\n                x.push(e);\n                return make_sequence(this, x);\n            }\n        }\n        return this;\n    });\n\n    var indexFns = makePredicate(\"indexOf lastIndexOf\");\n    var commutativeOperators = makePredicate(\"== === != !== * & | ^\");\n    function is_object(node) {\n        if (node instanceof AST_Assign) return node.operator == \"=\" && is_object(node.right);\n        if (node instanceof AST_Sequence) return is_object(node.tail_node());\n        if (node instanceof AST_SymbolRef) return is_object(node.fixed_value());\n        return node instanceof AST_Array\n            || node instanceof AST_Class\n            || node instanceof AST_Lambda\n            || node instanceof AST_New\n            || node instanceof AST_Object;\n    }\n\n    function is_primitive(compressor, node) {\n        if (node.is_constant()) return true;\n        if (node instanceof AST_Assign) return node.operator != \"=\" || is_primitive(compressor, node.right);\n        if (node instanceof AST_Binary) {\n            return !lazy_op[node.operator]\n                || is_primitive(compressor, node.left) && is_primitive(compressor, node.right);\n        }\n        if (node instanceof AST_Conditional) {\n            return is_primitive(compressor, node.consequent) && is_primitive(compressor, node.alternative);\n        }\n        if (node instanceof AST_Sequence) return is_primitive(compressor, node.tail_node());\n        if (node instanceof AST_SymbolRef) {\n            var fixed = node.fixed_value();\n            return fixed && is_primitive(compressor, fixed);\n        }\n        if (node instanceof AST_Template) return !node.tag || is_raw_tag(compressor, node.tag);\n        if (node instanceof AST_Unary) return true;\n    }\n\n    function repeatable(compressor, node) {\n        if (node instanceof AST_Dot) return repeatable(compressor, node.expression);\n        if (node instanceof AST_Sub) {\n            return repeatable(compressor, node.expression) && repeatable(compressor, node.property);\n        }\n        if (node instanceof AST_Symbol) return true;\n        return !node.has_side_effects(compressor);\n    }\n\n    OPT(AST_Binary, function(self, compressor) {\n        function reversible() {\n            return self.left.is_constant()\n                || self.right.is_constant()\n                || !self.left.has_side_effects(compressor)\n                    && !self.right.has_side_effects(compressor);\n        }\n        function reverse(op) {\n            if (reversible()) {\n                if (op) self.operator = op;\n                var tmp = self.left;\n                self.left = self.right;\n                self.right = tmp;\n            }\n        }\n        function swap_chain() {\n            var rhs = self.right;\n            self.left = make_node(AST_Binary, self, {\n                operator: self.operator,\n                left: self.left,\n                right: rhs.left,\n                start: self.left.start,\n                end: rhs.left.end\n            });\n            self.right = rhs.right;\n            self.left = self.left.transform(compressor);\n        }\n        if (commutativeOperators[self.operator]\n            && self.right.is_constant()\n            && !self.left.is_constant()\n            && !(self.left instanceof AST_Binary\n                && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n            // if right is a constant, whatever side effects the\n            // left side might have could not influence the\n            // result.  hence, force switch.\n            reverse();\n        }\n        if (compressor.option(\"sequences\")) {\n            var seq = self.lift_sequences(compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"assignments\") && lazy_op[self.operator]) {\n            var assign = self.right;\n            // a || (a = x) ---> a = a || x\n            // a && (a = x) ---> a = a && x\n            if (self.left instanceof AST_SymbolRef\n                && assign instanceof AST_Assign\n                && assign.operator == \"=\"\n                && self.left.equivalent_to(assign.left)) {\n                self.right = assign.right;\n                assign.right = self;\n                return assign;\n            }\n        }\n        if (compressor.option(\"comparisons\")) switch (self.operator) {\n          case \"===\":\n          case \"!==\":\n            if (is_undefined(self.left, compressor) && self.right.is_defined(compressor)) {\n                AST_Node.warn(\"Expression always defined [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.right,\n                    make_node(self.operator == \"===\" ? AST_False : AST_True, self)\n                ]).optimize(compressor);\n            }\n            var is_strict_comparison = true;\n            if ((self.left.is_string(compressor) && self.right.is_string(compressor)) ||\n                (self.left.is_number(compressor) && self.right.is_number(compressor)) ||\n                (self.left.is_boolean(compressor) && self.right.is_boolean(compressor)) ||\n                repeatable(compressor, self.left) && self.left.equivalent_to(self.right)) {\n                self.operator = self.operator.slice(0, 2);\n            }\n            // XXX: intentionally falling down to the next case\n          case \"==\":\n          case \"!=\":\n            // void 0 == x ---> null == x\n            if (!is_strict_comparison && is_undefined(self.left, compressor)) {\n                self.left = make_node(AST_Null, self.left);\n            }\n            // \"undefined\" == typeof x ---> undefined === x\n            else if (compressor.option(\"typeofs\")\n                && self.left instanceof AST_String\n                && self.left.value == \"undefined\"\n                && self.right instanceof AST_UnaryPrefix\n                && self.right.operator == \"typeof\") {\n                var expr = self.right.expression;\n                if (expr instanceof AST_SymbolRef ? expr.is_declared(compressor)\n                    : !(expr instanceof AST_PropAccess && compressor.option(\"ie\"))) {\n                    self.right = expr;\n                    self.left = make_node(AST_Undefined, self.left).optimize(compressor);\n                    if (self.operator.length == 2) self.operator += \"=\";\n                }\n            }\n            // obj !== obj ---> false\n            else if (self.left instanceof AST_SymbolRef\n                && self.right instanceof AST_SymbolRef\n                && self.left.definition() === self.right.definition()\n                && is_object(self.left)) {\n                return make_node(self.operator[0] == \"=\" ? AST_True : AST_False, self).optimize(compressor);\n            }\n            break;\n          case \"&&\":\n          case \"||\":\n            // void 0 !== x && null !== x ---> null != x\n            // void 0 === x || null === x ---> null == x\n            var lhs = self.left;\n            if (lhs.operator == self.operator) {\n                lhs = lhs.right;\n            }\n            if (lhs instanceof AST_Binary\n                && lhs.operator == (self.operator == \"&&\" ? \"!==\" : \"===\")\n                && self.right instanceof AST_Binary\n                && lhs.operator == self.right.operator\n                && (is_undefined(lhs.left, compressor) && self.right.left instanceof AST_Null\n                    || lhs.left instanceof AST_Null && is_undefined(self.right.left, compressor))\n                && !lhs.right.has_side_effects(compressor)\n                && lhs.right.equivalent_to(self.right.right)) {\n                var combined = make_node(AST_Binary, self, {\n                    operator: lhs.operator.slice(0, -1),\n                    left: make_node(AST_Null, self),\n                    right: lhs.right\n                });\n                if (lhs !== self.left) {\n                    combined = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: self.left.left,\n                        right: combined\n                    });\n                }\n                return combined;\n            }\n            break;\n        }\n        var in_bool = false;\n        var parent = compressor.parent();\n        if (compressor.option(\"booleans\")) {\n            var lhs = self.left;\n            if (lazy_op[self.operator] && !lhs.has_side_effects(compressor)) {\n                if (lhs.equivalent_to(self.right)) {\n                    return maintain_this_binding(compressor, parent, compressor.self(), lhs).optimize(compressor);\n                }\n                mark_duplicate_condition(compressor, lhs);\n            }\n            in_bool = compressor.in_boolean_context();\n        }\n        if (in_bool) switch (self.operator) {\n          case \"+\":\n            var ll = self.left.evaluate(compressor);\n            var rr = self.right.evaluate(compressor);\n            if (ll && typeof ll == \"string\") {\n                AST_Node.warn(\"+ in boolean context always true [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.right,\n                    make_node(AST_True, self)\n                ]).optimize(compressor);\n            }\n            if (rr && typeof rr == \"string\") {\n                AST_Node.warn(\"+ in boolean context always true [{file}:{line},{col}]\", self.start);\n                return make_sequence(self, [\n                    self.left,\n                    make_node(AST_True, self)\n                ]).optimize(compressor);\n            }\n            break;\n          case \"==\":\n            if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                return make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.right\n                }).optimize(compressor);\n            }\n            break;\n          case \"!=\":\n            if (self.left instanceof AST_String && self.left.value == \"\" && self.right.is_string(compressor)) {\n                return self.right.optimize(compressor);\n            }\n            break;\n        }\n        if (compressor.option(\"comparisons\") && self.is_boolean(compressor)) {\n            if (!(parent instanceof AST_Binary) || parent instanceof AST_Assign) {\n                var negated = best_of(compressor, self, make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.negate(compressor, first_in_statement(compressor))\n                }));\n                if (negated !== self) return negated;\n            }\n            switch (self.operator) {\n              case \">\": reverse(\"<\"); break;\n              case \">=\": reverse(\"<=\"); break;\n            }\n        }\n        // x && (y && z) ---> x && y && z\n        // x || (y || z) ---> x || y || z\n        if (compressor.option(\"conditionals\")\n            && lazy_op[self.operator]\n            && self.right instanceof AST_Binary\n            && self.operator == self.right.operator) {\n            swap_chain();\n        }\n        if (compressor.option(\"strings\") && self.operator == \"+\") {\n            // \"foo\" + 42 + \"\" ---> \"foo\" + 42\n            if (self.right instanceof AST_String\n                && self.right.value == \"\"\n                && self.left.is_string(compressor)) {\n                return self.left.optimize(compressor);\n            }\n            // \"\" + (\"foo\" + 42) ---> \"foo\" + 42\n            if (self.left instanceof AST_String\n                && self.left.value == \"\"\n                && self.right.is_string(compressor)) {\n                return self.right.optimize(compressor);\n            }\n            // \"\" + 42 + \"foo\" ---> 42 + \"foo\"\n            if (self.left instanceof AST_Binary\n                && self.left.operator == \"+\"\n                && self.left.left instanceof AST_String\n                && self.left.left.value == \"\"\n                && self.right.is_string(compressor)\n                && (self.left.right.is_constant() || !self.right.has_side_effects(compressor))) {\n                self.left = self.left.right;\n                return self.optimize(compressor);\n            }\n            // \"x\" + (y + \"z\") ---> \"x\" + y + \"z\"\n            // x + (\"y\" + z) ---> x + \"y\" + z\n            if (self.right instanceof AST_Binary\n                && self.operator == self.right.operator\n                && (self.left.is_string(compressor) && self.right.is_string(compressor)\n                    || self.right.left.is_string(compressor)\n                        && (self.left.is_constant() || !self.right.right.has_side_effects(compressor)))) {\n                swap_chain();\n            }\n        }\n        if (compressor.option(\"evaluate\")) {\n            var associative = true;\n            switch (self.operator) {\n              case \"&&\":\n                var ll = fuzzy_eval(compressor, self.left);\n                if (!ll) {\n                    AST_Node.warn(\"Condition left of && always false [{file}:{line},{col}]\", self.start);\n                    return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);\n                } else if (!(ll instanceof AST_Node)) {\n                    AST_Node.warn(\"Condition left of && always true [{file}:{line},{col}]\", self.start);\n                    return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                }\n                var rr = self.right.evaluate(compressor);\n                if (!rr) {\n                    if (in_bool) {\n                        AST_Node.warn(\"Boolean && always false [{file}:{line},{col}]\", self.start);\n                        return make_sequence(self, [\n                            self.left,\n                            make_node(AST_False, self)\n                        ]).optimize(compressor);\n                    } else self.falsy = true;\n                } else if (!(rr instanceof AST_Node)) {\n                    if (in_bool || parent.operator == \"&&\" && parent.left === compressor.self()) {\n                        AST_Node.warn(\"Dropping side-effect-free && [{file}:{line},{col}]\", self.start);\n                        return self.left.optimize(compressor);\n                    }\n                }\n                // (x || false) && y ---> x ? y : false\n                if (self.left.operator == \"||\") {\n                    var lr = fuzzy_eval(compressor, self.left.right);\n                    if (!lr) return make_node(AST_Conditional, self, {\n                        condition: self.left.left,\n                        consequent: self.right,\n                        alternative: self.left.right\n                    }).optimize(compressor);\n                }\n                break;\n              case \"??\":\n                var nullish = true;\n              case \"||\":\n                var ll = fuzzy_eval(compressor, self.left, nullish);\n                if (nullish ? ll == null : !ll) {\n                    AST_Node.warn(\"Condition left of {operator} always {value} [{file}:{line},{col}]\", {\n                        operator: self.operator,\n                        value: nullish ? \"nulish\" : \"false\",\n                        file: self.start.file,\n                        line: self.start.line,\n                        col: self.start.col,\n                    });\n                    return make_sequence(self, [ self.left, self.right ]).optimize(compressor);\n                } else if (!(ll instanceof AST_Node)) {\n                    AST_Node.warn(\"Condition left of {operator} always {value} [{file}:{line},{col}]\", {\n                        operator: self.operator,\n                        value: nullish ? \"defined\" : \"true\",\n                        file: self.start.file,\n                        line: self.start.line,\n                        col: self.start.col,\n                    });\n                    return maintain_this_binding(compressor, parent, compressor.self(), self.left).optimize(compressor);\n                }\n                var rr = self.right.evaluate(compressor);\n                if (!rr) {\n                    if (in_bool || parent.operator == \"||\" && parent.left === compressor.self()) {\n                        AST_Node.warn(\"Dropping side-effect-free {operator} [{file}:{line},{col}]\", {\n                            operator: self.operator,\n                            file: self.start.file,\n                            line: self.start.line,\n                            col: self.start.col,\n                        });\n                        return self.left.optimize(compressor);\n                    }\n                } else if (!nullish && !(rr instanceof AST_Node)) {\n                    if (in_bool) {\n                        AST_Node.warn(\"Boolean || always true [{file}:{line},{col}]\", self.start);\n                        return make_sequence(self, [\n                            self.left,\n                            make_node(AST_True, self)\n                        ]).optimize(compressor);\n                    } else self.truthy = true;\n                }\n                // x && true || y ---> x ? true : y\n                if (!nullish && self.left.operator == \"&&\") {\n                    var lr = fuzzy_eval(compressor, self.left.right);\n                    if (lr && !(lr instanceof AST_Node)) return make_node(AST_Conditional, self, {\n                        condition: self.left.left,\n                        consequent: self.left.right,\n                        alternative: self.right\n                    }).optimize(compressor);\n                }\n                break;\n              case \"+\":\n                // \"foo\" + (\"bar\" + x) ---> \"foobar\" + x\n                if (self.left instanceof AST_Constant\n                    && self.right instanceof AST_Binary\n                    && self.right.operator == \"+\"\n                    && self.right.left instanceof AST_Constant\n                    && self.right.is_string(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self.left, {\n                            value: \"\" + self.left.value + self.right.left.value,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                }\n                // (x + \"foo\") + \"bar\" ---> x + \"foobar\"\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator == \"+\"\n                    && self.left.right instanceof AST_Constant\n                    && self.left.is_string(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left.left,\n                        right: make_node(AST_String, self.right, {\n                            value: \"\" + self.left.right.value + self.right.value,\n                            start: self.left.right.start,\n                            end: self.right.end\n                        })\n                    });\n                }\n                // a + -b ---> a - b\n                if (self.right instanceof AST_UnaryPrefix\n                    && self.right.operator == \"-\"\n                    && self.left.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"-\",\n                        left: self.left,\n                        right: self.right.expression\n                    });\n                    break;\n                }\n                // -a + b ---> b - a\n                if (self.left instanceof AST_UnaryPrefix\n                    && self.left.operator == \"-\"\n                    && reversible()\n                    && self.right.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"-\",\n                        left: self.right,\n                        right: self.left.expression\n                    });\n                    break;\n                }\n                // (a + b) + 3 ---> 3 + (a + b)\n                if (compressor.option(\"unsafe_math\")\n                    && self.left instanceof AST_Binary\n                    && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                    && self.right.is_constant()\n                    && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                    && self.left.is_number(compressor)\n                    && !self.left.right.is_constant()\n                    && (self.left.left.is_boolean(compressor) || self.left.left.is_number(compressor))) {\n                    self = make_node(AST_Binary, self, {\n                        operator: self.left.operator,\n                        left: make_node(AST_Binary, self, {\n                            operator: self.operator,\n                            left: self.right,\n                            right: self.left.left\n                        }),\n                        right: self.left.right\n                    });\n                    break;\n                }\n              case \"-\":\n                // a - -b ---> a + b\n                if (self.right instanceof AST_UnaryPrefix\n                    && self.right.operator == \"-\"\n                    && self.left.is_number(compressor)\n                    && self.right.expression.is_number(compressor)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: self.left,\n                        right: self.right.expression\n                    });\n                    break;\n                }\n              case \"*\":\n              case \"/\":\n                associative = compressor.option(\"unsafe_math\");\n                // +a - b ---> a - b\n                // a - +b ---> a - b\n                if (self.operator != \"+\") [ \"left\", \"right\" ].forEach(function(operand) {\n                    var node = self[operand];\n                    if (node instanceof AST_UnaryPrefix && node.operator == \"+\") {\n                        var exp = node.expression;\n                        if (exp.is_boolean(compressor) || exp.is_number(compressor) || exp.is_string(compressor)) {\n                            self[operand] = exp;\n                        }\n                    }\n                });\n              case \"&\":\n              case \"|\":\n              case \"^\":\n                // a + +b ---> +b + a\n                if (self.operator != \"-\"\n                    && self.operator != \"/\"\n                    && (self.left.is_boolean(compressor) || self.left.is_number(compressor))\n                    && (self.right.is_boolean(compressor) || self.right.is_number(compressor))\n                    && reversible()\n                    && !(self.left instanceof AST_Binary\n                        && self.left.operator != self.operator\n                        && PRECEDENCE[self.left.operator] >= PRECEDENCE[self.operator])) {\n                    var reversed = make_node(AST_Binary, self, {\n                        operator: self.operator,\n                        left: self.right,\n                        right: self.left\n                    });\n                    if (self.right instanceof AST_Constant\n                        && !(self.left instanceof AST_Constant)) {\n                        self = best_of(compressor, reversed, self);\n                    } else {\n                        self = best_of(compressor, self, reversed);\n                    }\n                }\n                if (!associative || !self.is_number(compressor)) break;\n                // a + (b + c) ---> (a + b) + c\n                if (self.right instanceof AST_Binary\n                    && self.right.operator != \"%\"\n                    && PRECEDENCE[self.right.operator] == PRECEDENCE[self.operator]\n                    && self.right.is_number(compressor)\n                    && (self.operator != \"+\"\n                        || self.right.left.is_boolean(compressor)\n                        || self.right.left.is_number(compressor))\n                    && (self.operator != \"-\" || !self.left.is_negative_zero())\n                    && (self.right.left.is_constant_expression()\n                        || !self.right.right.has_side_effects(compressor))\n                    && !is_modify_array(self.right.right)) {\n                    self = make_node(AST_Binary, self, {\n                        operator: align(self.operator, self.right.operator),\n                        left: make_node(AST_Binary, self.left, {\n                            operator: self.operator,\n                            left: self.left,\n                            right: self.right.left,\n                            start: self.left.start,\n                            end: self.right.left.end\n                        }),\n                        right: self.right.right\n                    });\n                    if (self.operator == \"+\"\n                        && !self.right.is_boolean(compressor)\n                        && !self.right.is_number(compressor)) {\n                        self.right = make_node(AST_UnaryPrefix, self.right, {\n                            operator: \"+\",\n                            expression: self.right\n                        });\n                    }\n                }\n                // (2 * n) * 3 ---> 6 * n\n                // (n + 2) + 3 ---> n + 5\n                if (self.right instanceof AST_Constant\n                    && self.left instanceof AST_Binary\n                    && self.left.operator != \"%\"\n                    && PRECEDENCE[self.left.operator] == PRECEDENCE[self.operator]\n                    && self.left.is_number(compressor)) {\n                    if (self.left.left instanceof AST_Constant) {\n                        var lhs = make_binary(self.left, self.operator, self.left.left, self.right, self.left.left.start, self.right.end);\n                        self = make_binary(self, self.left.operator, try_evaluate(compressor, lhs), self.left.right);\n                    } else if (self.left.right instanceof AST_Constant) {\n                        var op = align(self.left.operator, self.operator);\n                        var rhs = try_evaluate(compressor, make_binary(self.left, op, self.left.right, self.right));\n                        if (rhs.is_constant()\n                            && !(self.left.operator == \"-\"\n                                && self.right.value != 0\n                                && +rhs.value == 0\n                                && self.left.left.is_negative_zero())) {\n                            self = make_binary(self, self.left.operator, self.left.left, rhs);\n                        }\n                    }\n                }\n                break;\n            }\n            if (!(parent instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                if (self.left instanceof AST_Number && !self.right.is_constant()) switch (self.operator) {\n                  // 0 + n ---> n\n                  case \"+\":\n                    if (self.left.value == 0) {\n                        if (self.right.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.right\n                        }).optimize(compressor);\n                        if (self.right.is_number(compressor) && !self.right.is_negative_zero()) return self.right;\n                    }\n                    break;\n                  // 1 * n ---> n\n                  case \"*\":\n                    if (self.left.value == 1) {\n                        return self.right.is_number(compressor) ? self.right : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.right\n                        }).optimize(compressor);\n                    }\n                    break;\n                }\n                if (self.right instanceof AST_Number && !self.left.is_constant()) switch (self.operator) {\n                  // n + 0 ---> n\n                  case \"+\":\n                    if (self.right.value == 0) {\n                        if (self.left.is_boolean(compressor)) return make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                        if (self.left.is_number(compressor) && !self.left.is_negative_zero()) return self.left;\n                    }\n                    break;\n                  // n - 0 ---> n\n                  case \"-\":\n                    if (self.right.value == 0) {\n                        return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                    }\n                    break;\n                  // n / 1 ---> n\n                  case \"/\":\n                    if (self.right.value == 1) {\n                        return self.left.is_number(compressor) ? self.left : make_node(AST_UnaryPrefix, self, {\n                            operator: \"+\",\n                            expression: self.left\n                        }).optimize(compressor);\n                    }\n                    break;\n                }\n            }\n        }\n        if (compressor.option(\"typeofs\")) switch (self.operator) {\n          case \"&&\":\n            mark_locally_defined(self.left, self.right, null);\n            break;\n          case \"||\":\n            mark_locally_defined(self.left, null, self.right);\n            break;\n        }\n        if (compressor.option(\"unsafe\")) {\n            var indexRight = is_indexFn(self.right);\n            if (in_bool\n                && indexRight\n                && (self.operator == \"==\" || self.operator == \"!=\")\n                && self.left instanceof AST_Number\n                && self.left.value == 0) {\n                return (self.operator == \"==\" ? make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: self.right\n                }) : self.right).optimize(compressor);\n            }\n            var indexLeft = is_indexFn(self.left);\n            if (compressor.option(\"comparisons\") && is_indexOf_match_pattern()) {\n                var node = make_node(AST_UnaryPrefix, self, {\n                    operator: \"!\",\n                    expression: make_node(AST_UnaryPrefix, self, {\n                        operator: \"~\",\n                        expression: indexLeft ? self.left : self.right\n                    })\n                });\n                switch (self.operator) {\n                  case \"<\":\n                    if (indexLeft) break;\n                  case \"<=\":\n                  case \"!=\":\n                    node = make_node(AST_UnaryPrefix, self, {\n                        operator: \"!\",\n                        expression: node\n                    });\n                    break;\n                }\n                return node.optimize(compressor);\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function is_modify_array(node) {\n            var found = false;\n            node.walk(new TreeWalker(function(node) {\n                if (found) return true;\n                if (node instanceof AST_Assign) {\n                    if (node.left instanceof AST_PropAccess) return found = true;\n                } else if (node instanceof AST_Unary) {\n                    if (unary_side_effects[node.operator] && node.expression instanceof AST_PropAccess) {\n                        return found = true;\n                    }\n                }\n            }));\n            return found;\n        }\n\n        function align(ref, op) {\n            switch (ref) {\n              case \"-\":\n                return op == \"+\" ? \"-\" : \"+\";\n              case \"/\":\n                return op == \"*\" ? \"/\" : \"*\";\n              default:\n                return op;\n            }\n        }\n\n        function make_binary(orig, op, left, right, start, end) {\n            if (op == \"+\") {\n                if (!left.is_boolean(compressor) && !left.is_number(compressor)) {\n                    left = make_node(AST_UnaryPrefix, left, {\n                        operator: \"+\",\n                        expression: left\n                    });\n                }\n                if (!right.is_boolean(compressor) && !right.is_number(compressor)) {\n                    right = make_node(AST_UnaryPrefix, right, {\n                        operator: \"+\",\n                        expression: right\n                    });\n                }\n            }\n            return make_node(AST_Binary, orig, {\n                operator: op,\n                left: left,\n                right: right,\n                start: start,\n                end: end\n            });\n        }\n\n        function is_indexFn(node) {\n            return node.TYPE == \"Call\"\n                && node.expression instanceof AST_Dot\n                && indexFns[node.expression.property];\n        }\n\n        function is_indexOf_match_pattern() {\n            switch (self.operator) {\n              case \"<=\":\n                // 0 <= array.indexOf(string) ---> !!~array.indexOf(string)\n                return indexRight && self.left instanceof AST_Number && self.left.value == 0;\n              case \"<\":\n                // array.indexOf(string) < 0 ---> !~array.indexOf(string)\n                if (indexLeft && self.right instanceof AST_Number && self.right.value == 0) return true;\n                // -1 < array.indexOf(string) ---> !!~array.indexOf(string)\n              case \"==\":\n              case \"!=\":\n                // -1 == array.indexOf(string) ---> !~array.indexOf(string)\n                // -1 != array.indexOf(string) ---> !!~array.indexOf(string)\n                if (!indexRight) return false;\n                return self.left instanceof AST_Number && self.left.value == -1\n                    || self.left instanceof AST_UnaryPrefix && self.left.operator == \"-\"\n                        && self.left.expression instanceof AST_Number && self.left.expression.value == 1;\n            }\n        }\n    });\n\n    OPT(AST_SymbolExport, function(self) {\n        return self;\n    });\n\n    function recursive_ref(compressor, def, fn) {\n        var level = 0, node = compressor.self();\n        do {\n            if (node === fn) return node;\n            if (is_lambda(node) && node.name && node.name.definition() === def) return node;\n        } while (node = compressor.parent(level++));\n    }\n\n    function same_scope(def) {\n        var scope = def.scope.resolve();\n        return all(def.references, function(ref) {\n            return scope === ref.scope.resolve();\n        });\n    }\n\n    OPT(AST_SymbolRef, function(self, compressor) {\n        if (!compressor.option(\"ie\")\n            && is_undeclared_ref(self)\n            // testing against `self.scope.uses_with` is an optimization\n            && !(self.scope.resolve().uses_with && compressor.find_parent(AST_With))) {\n            switch (self.name) {\n              case \"undefined\":\n                return make_node(AST_Undefined, self).optimize(compressor);\n              case \"NaN\":\n                return make_node(AST_NaN, self).optimize(compressor);\n              case \"Infinity\":\n                return make_node(AST_Infinity, self).optimize(compressor);\n            }\n        }\n        var parent = compressor.parent();\n        if (compressor.option(\"reduce_vars\") && is_lhs(compressor.self(), parent) !== compressor.self()) {\n            var def = self.definition();\n            var fixed = self.fixed_value();\n            var single_use = def.single_use && !(parent instanceof AST_Call && parent.is_expr_pure(compressor));\n            if (single_use) {\n                if (is_lambda(fixed)) {\n                    if ((def.scope !== self.scope.resolve() || def.in_loop)\n                        && (!compressor.option(\"reduce_funcs\") || def.escaped.depth == 1 || fixed.inlined)) {\n                        single_use = false;\n                    } else if (recursive_ref(compressor, def, fixed)) {\n                        single_use = false;\n                    } else if (fixed.name && fixed.name.definition() !== def) {\n                        single_use = false;\n                    } else if (fixed.parent_scope !== self.scope || is_funarg(def)) {\n                        single_use = fixed.is_constant_expression(self.scope);\n                        if (single_use == \"f\") {\n                            var scope = self.scope;\n                            do {\n                                if (scope instanceof AST_LambdaDefinition || scope instanceof AST_LambdaExpression) {\n                                    scope.inlined = true;\n                                }\n                            } while (scope = scope.parent_scope);\n                        }\n                    } else if (fixed.name && (fixed.name.name == \"await\" && is_async(fixed)\n                        || fixed.name.name == \"yield\" && is_generator(fixed))) {\n                        single_use = false;\n                    } else if (fixed.has_side_effects(compressor)) {\n                        single_use = false;\n                    } else if (compressor.option(\"ie\") && fixed instanceof AST_Class) {\n                        single_use = false;\n                    }\n                    if (single_use) fixed.parent_scope = self.scope;\n                } else if (!fixed\n                    || def.recursive_refs > 0\n                    || !fixed.is_constant_expression()\n                    || fixed.drop_side_effect_free(compressor)) {\n                    single_use = false;\n                }\n            }\n            if (single_use) {\n                def.single_use = false;\n                fixed._squeezed = true;\n                fixed.single_use = true;\n                if (fixed instanceof AST_DefClass) fixed = to_class_expr(fixed);\n                if (fixed instanceof AST_LambdaDefinition) fixed = to_func_expr(fixed);\n                if (is_lambda(fixed)) {\n                    var scope = self.scope.resolve();\n                    fixed.enclosed.forEach(function(def) {\n                        if (fixed.variables.has(def.name)) return;\n                        if (scope.var_names().has(def.name)) return;\n                        scope.enclosed.push(def);\n                        scope.var_names().set(def.name, true);\n                    });\n                }\n                var value;\n                if (def.recursive_refs > 0) {\n                    value = fixed.clone(true);\n                    var defun_def = value.name.definition();\n                    var lambda_def = value.variables.get(value.name.name);\n                    var name = lambda_def && lambda_def.orig[0];\n                    var def_fn_name, symbol_type;\n                    if (value instanceof AST_Class) {\n                        def_fn_name = \"def_function\";\n                        symbol_type = AST_SymbolClass;\n                    } else {\n                        def_fn_name = \"def_variable\";\n                        symbol_type = AST_SymbolLambda;\n                    }\n                    if (!(name instanceof symbol_type)) {\n                        name = make_node(symbol_type, value.name, value.name);\n                        name.scope = value;\n                        value.name = name;\n                        lambda_def = value[def_fn_name](name);\n                        lambda_def.recursive_refs = def.recursive_refs;\n                    }\n                    value.walk(new TreeWalker(function(node) {\n                        if (node instanceof AST_SymbolDeclaration) {\n                            if (node !== name) {\n                                var def = node.definition();\n                                def.orig.push(node);\n                                def.eliminated++;\n                            }\n                            return;\n                        }\n                        if (!(node instanceof AST_SymbolRef)) return;\n                        var def = node.definition();\n                        if (def === defun_def) {\n                            node.thedef = def = lambda_def;\n                        } else {\n                            def.single_use = false;\n                            var fn = node.fixed_value();\n                            if (is_lambda(fn)\n                                && fn.name\n                                && fn.name.definition() === def\n                                && def.scope === fn.name.scope\n                                && fixed.variables.get(fn.name.name) === def) {\n                                fn.name = fn.name.clone();\n                                node.thedef = def = value.variables.get(fn.name.name) || value[def_fn_name](fn.name);\n                            }\n                        }\n                        def.references.push(node);\n                    }));\n                } else {\n                    if (fixed instanceof AST_Scope) {\n                        compressor.push(fixed);\n                        value = fixed.optimize(compressor);\n                        compressor.pop();\n                    } else {\n                        value = fixed.optimize(compressor);\n                    }\n                    value = value.transform(new TreeTransformer(function(node, descend) {\n                        if (node instanceof AST_Scope) return node;\n                        node = node.clone();\n                        descend(node, this);\n                        return node;\n                    }));\n                }\n                def.replaced++;\n                return value;\n            }\n            var local = self.fixed !== def.fixed;\n            if (fixed && (local || def.should_replace !== false)) {\n                var ev, init;\n                if (fixed instanceof AST_This) {\n                    if (!is_funarg(def) && same_scope(def)) init = fixed;\n                } else if ((ev = fixed.evaluate(compressor, true)) !== fixed\n                    && typeof ev != \"function\"\n                    && (ev === null\n                        || typeof ev != \"object\"\n                        || compressor.option(\"unsafe_regexp\")\n                            && ev instanceof RegExp && !def.cross_loop && same_scope(def))) {\n                    init = make_node_from_constant(ev, fixed);\n                }\n                if (init) {\n                    if (!local && def.should_replace === undefined) {\n                        var value_length = init.optimize(compressor).print_to_string().length;\n                        if (!has_symbol_ref(fixed)) {\n                            value_length = Math.min(value_length, fixed.print_to_string().length);\n                        }\n                        var name_length = def.name.length;\n                        if (compressor.option(\"unused\") && !compressor.exposed(def)) {\n                            var referenced = def.references.length - def.replaced;\n                            name_length += (name_length + 2 + value_length) / (referenced - def.assignments);\n                        }\n                        var delta = value_length - Math.floor(name_length);\n                        def.should_replace = delta < compressor.eval_threshold;\n                    }\n                    if (local || def.should_replace) {\n                        var value;\n                        if (has_symbol_ref(fixed)) {\n                            value = init.optimize(compressor);\n                            if (value === init) value = value.clone(true);\n                        } else {\n                            value = best_of_expression(init.optimize(compressor), fixed);\n                            if (value === init || value === fixed) value = value.clone(true);\n                        }\n                        def.replaced++;\n                        return value;\n                    }\n                }\n            }\n        }\n        return self;\n\n        function has_symbol_ref(value) {\n            var found;\n            value.walk(new TreeWalker(function(node) {\n                if (node instanceof AST_SymbolRef) found = true;\n                if (found) return true;\n            }));\n            return found;\n        }\n    });\n\n    function is_raw_tag(compressor, tag) {\n        return compressor.option(\"unsafe\")\n            && tag instanceof AST_Dot\n            && tag.property == \"raw\"\n            && is_undeclared_ref(tag.expression)\n            && tag.expression.name == \"String\";\n    }\n\n    function decode_template(str) {\n        var malformed = false;\n        str = str.replace(/\\\\(u\\{[^{}]*\\}?|u[\\s\\S]{0,4}|x[\\s\\S]{0,2}|[0-9]+|[\\s\\S])/g, function(match, seq) {\n            var ch = decode_escape_sequence(seq);\n            if (typeof ch == \"string\") return ch;\n            malformed = true;\n        });\n        if (!malformed) return str;\n    }\n\n    OPT(AST_Template, function(self, compressor) {\n        if (!compressor.option(\"templates\")) return self;\n        var tag = self.tag;\n        if (!tag || is_raw_tag(compressor, tag)) {\n            var exprs = [];\n            var strs = [];\n            for (var i = 0, status; i < self.strings.length; i++) {\n                var str = self.strings[i];\n                if (!tag) {\n                    var trimmed = decode_template(str);\n                    if (trimmed) str = escape_literal(trimmed);\n                }\n                if (i > 0) {\n                    var node = self.expressions[i - 1];\n                    var value = should_join(node);\n                    if (value) {\n                        var prev = strs[strs.length - 1];\n                        var joined = prev + value + str;\n                        var decoded;\n                        if (tag || typeof (decoded = decode_template(joined)) == status) {\n                            strs[strs.length - 1] = decoded ? escape_literal(decoded) : joined;\n                            continue;\n                        }\n                    }\n                    exprs.push(node);\n                }\n                strs.push(str);\n                if (!tag) status = typeof trimmed;\n            }\n            if (!tag && strs.length > 1) {\n                if (strs[strs.length - 1] == \"\") return make_node(AST_Binary, self, {\n                    operator: \"+\",\n                    left: make_node(AST_Template, self, {\n                        expressions: exprs.slice(0, -1),\n                        strings: strs.slice(0, -1),\n                        tag: tag,\n                    }).transform(compressor),\n                    right: exprs[exprs.length - 1],\n                }).optimize(compressor);\n                if (strs[0] == \"\") {\n                    var left = make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: make_node(AST_String, self, { value: \"\" }),\n                        right: exprs[0],\n                    });\n                    for (var i = 1; strs[i] == \"\" && i < exprs.length; i++) {\n                        left = make_node(AST_Binary, self, {\n                            operator: \"+\",\n                            left: left,\n                            right: exprs[i],\n                        });\n                    }\n                    return best_of(compressor, self, make_node(AST_Binary, self, {\n                        operator: \"+\",\n                        left: left.transform(compressor),\n                        right: make_node(AST_Template, self, {\n                            expressions: exprs.slice(i),\n                            strings: strs.slice(i),\n                            tag: tag,\n                        }).transform(compressor),\n                    }).optimize(compressor));\n                }\n            }\n            self.expressions = exprs;\n            self.strings = strs;\n        }\n        return try_evaluate(compressor, self);\n\n        function escape_literal(str) {\n            return str.replace(/\\r|\\\\|`|\\${/g, function(s) {\n                return \"\\\\\" + (s == \"\\r\" ? \"r\" : s);\n            });\n        }\n\n        function should_join(node) {\n            var ev = node.evaluate(compressor);\n            if (ev === node) return;\n            if (tag && /\\r|\\\\|`/.test(ev)) return;\n            ev = escape_literal(\"\" + ev);\n            if (ev.length > node.print_to_string().length + \"${}\".length) return;\n            return ev;\n        }\n    });\n\n    function is_atomic(lhs, self) {\n        return lhs instanceof AST_SymbolRef || lhs.TYPE === self.TYPE;\n    }\n\n    OPT(AST_Undefined, function(self, compressor) {\n        if (compressor.option(\"unsafe_undefined\")) {\n            var undef = find_scope(compressor).find_variable(\"undefined\");\n            if (undef) {\n                var ref = make_node(AST_SymbolRef, self, {\n                    name   : \"undefined\",\n                    scope  : undef.scope,\n                    thedef : undef\n                });\n                ref.is_undefined = true;\n                return ref;\n            }\n        }\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"void\",\n            expression: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    OPT(AST_Infinity, function(self, compressor) {\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        if (compressor.option(\"keep_infinity\") && !lhs && !find_scope(compressor).find_variable(\"Infinity\")) {\n            return self;\n        }\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 1\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    OPT(AST_NaN, function(self, compressor) {\n        var lhs = is_lhs(compressor.self(), compressor.parent());\n        if (lhs && is_atomic(lhs, self)) return self;\n        if (!lhs && !find_scope(compressor).find_variable(\"NaN\")) return self;\n        return make_node(AST_Binary, self, {\n            operator: \"/\",\n            left: make_node(AST_Number, self, {\n                value: 0\n            }),\n            right: make_node(AST_Number, self, {\n                value: 0\n            })\n        });\n    });\n\n    function is_reachable(self, defs) {\n        var reachable = false;\n        var find_ref = new TreeWalker(function(node) {\n            if (reachable) return true;\n            if (node instanceof AST_SymbolRef && member(node.definition(), defs)) {\n                return reachable = true;\n            }\n        });\n        var scan_scope = new TreeWalker(function(node) {\n            if (reachable) return true;\n            if (node instanceof AST_Lambda && node !== self) {\n                if (!(node.name || is_async(node) || is_generator(node))) {\n                    var parent = scan_scope.parent();\n                    if (parent instanceof AST_Call && parent.expression === node) return;\n                }\n                node.walk(find_ref);\n                return true;\n            }\n        });\n        self.walk(scan_scope);\n        return reachable;\n    }\n\n    var ASSIGN_OPS = makePredicate(\"+ - * / % >> << >>> | ^ &\");\n    var ASSIGN_OPS_COMMUTATIVE = makePredicate(\"* | ^ &\");\n    OPT(AST_Assign, function(self, compressor) {\n        if (compressor.option(\"dead_code\")) {\n            if (self.left instanceof AST_PropAccess) {\n                if (self.operator == \"=\") {\n                    if (self.redundant) {\n                        var exprs = [ self.left.expression ];\n                        if (self.left instanceof AST_Sub) exprs.push(self.left.property);\n                        exprs.push(self.right);\n                        return make_sequence(self, exprs).optimize(compressor);\n                    }\n                    if (self.left.equivalent_to(self.right) && !self.left.has_side_effects(compressor)) {\n                        return self.right;\n                    }\n                    var exp = self.left.expression;\n                    if (exp instanceof AST_Lambda\n                        || !compressor.has_directive(\"use strict\")\n                            && exp instanceof AST_Constant\n                            && !exp.may_throw_on_access(compressor)) {\n                        return self.left instanceof AST_Dot ? self.right : make_sequence(self, [\n                            self.left.property,\n                            self.right\n                        ]).optimize(compressor);\n                    }\n                }\n            } else if (self.left instanceof AST_SymbolRef && can_drop_symbol(self.left, compressor)) {\n                var parent;\n                if (self.operator == \"=\" && self.left.equivalent_to(self.right)\n                    && !((parent = compressor.parent()) instanceof AST_UnaryPrefix && parent.operator == \"delete\")) {\n                    return self.right;\n                }\n                if (self.left.is_immutable()) return strip_assignment();\n                var def = self.left.definition();\n                var scope = def.scope.resolve();\n                var local = scope === compressor.find_parent(AST_Lambda);\n                var level = 0, node;\n                parent = compressor.self();\n                if (!(scope.uses_arguments && is_funarg(def)) || compressor.has_directive(\"use strict\")) do {\n                    node = parent;\n                    parent = compressor.parent(level++);\n                    if (parent instanceof AST_Assign) {\n                        if (parent.left instanceof AST_SymbolRef && parent.left.definition() === def) {\n                            if (in_try(level, parent)) break;\n                            return strip_assignment(def);\n                        }\n                        if (parent.left.match_symbol(function(node) {\n                            if (node instanceof AST_PropAccess) return true;\n                        })) break;\n                        continue;\n                    }\n                    if (parent instanceof AST_Exit) {\n                        if (!local) break;\n                        if (in_try(level, parent)) break;\n                        if (is_reachable(scope, [ def ])) break;\n                        return strip_assignment(def);\n                    }\n                    if (parent instanceof AST_SimpleStatement) {\n                        if (!local) break;\n                        if (is_reachable(scope, [ def ])) break;\n                        var stat;\n                        do {\n                            stat = parent;\n                            parent = compressor.parent(level++);\n                            if (parent === scope && is_last_statement(parent.body, stat)) return strip_assignment(def);\n                        } while (is_tail_block(stat, parent));\n                        break;\n                    }\n                    if (parent instanceof AST_VarDef) {\n                        if (!(parent.name instanceof AST_SymbolDeclaration)) continue;\n                        if (parent.name.definition() !== def) continue;\n                        if (in_try(level, parent)) break;\n                        return strip_assignment(def);\n                    }\n                } while (is_tail(node, parent));\n            }\n        }\n        if (compressor.option(\"sequences\")) {\n            var seq = self.lift_sequences(compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"assignments\")) {\n            if (self.operator == \"=\" && self.left instanceof AST_SymbolRef && self.right instanceof AST_Binary) {\n                // x = expr1 OP expr2\n                if (self.right.left instanceof AST_SymbolRef\n                    && self.right.left.name == self.left.name\n                    && ASSIGN_OPS[self.right.operator]) {\n                    // x = x - 2 ---> x -= 2\n                    return make_node(AST_Assign, self, {\n                        operator: self.right.operator + \"=\",\n                        left: self.left,\n                        right: self.right.right,\n                    });\n                }\n                if (self.right.right instanceof AST_SymbolRef\n                    && self.right.right.name == self.left.name\n                    && ASSIGN_OPS_COMMUTATIVE[self.right.operator]\n                    && !self.right.left.has_side_effects(compressor)) {\n                    // x = 2 & x ---> x &= 2\n                    return make_node(AST_Assign, self, {\n                        operator: self.right.operator + \"=\",\n                        left: self.left,\n                        right: self.right.left,\n                    });\n                }\n            }\n            if ((self.operator == \"-=\" || self.operator == \"+=\"\n                    && (self.left.is_boolean(compressor) || self.left.is_number(compressor)))\n                && self.right instanceof AST_Number\n                && self.right.value == 1) {\n                var op = self.operator.slice(0, -1);\n                return make_node(AST_UnaryPrefix, self, {\n                    operator: op + op,\n                    expression: self.left\n                });\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function is_tail(node, parent) {\n            if (parent instanceof AST_Binary) {\n                return parent.right === node || parent.right.is_constant_expression(scope);\n            }\n            if (parent instanceof AST_Conditional) {\n                return parent.condition !== node\n                    || parent.consequent.is_constant_expression(scope)\n                        && parent.alternative.is_constant_expression(scope);\n            }\n            if (parent instanceof AST_Sequence) {\n                var exprs = parent.expressions;\n                var stop = exprs.indexOf(node);\n                if (stop < 0) return false;\n                for (var i = exprs.length; --i > stop;) {\n                    if (!exprs[i].is_constant_expression(scope)) return false;\n                }\n                return true;\n            }\n            if (parent instanceof AST_UnaryPrefix) return true;\n        }\n\n        function is_tail_block(stat, parent) {\n            if (parent instanceof AST_BlockStatement) return is_last_statement(parent.body, stat);\n            if (parent instanceof AST_Catch) return is_last_statement(parent.body, stat);\n            if (parent instanceof AST_Finally) return is_last_statement(parent.body, stat);\n            if (parent instanceof AST_If) return parent.body === stat || parent.alternative === stat;\n            if (parent instanceof AST_Try) return parent.bfinally ? parent.bfinally === stat : parent.bcatch === stat;\n        }\n\n        function in_try(level, node) {\n            var right = self.right;\n            self.right = make_node(AST_Null, right);\n            var may_throw = node.may_throw(compressor);\n            self.right = right;\n            for (var parent; parent = compressor.parent(level++); node = parent) {\n                if (parent === scope) return false;\n                if (parent instanceof AST_Try) {\n                    if (parent.bfinally && parent.bfinally !== node) return true;\n                    if (may_throw && parent.bcatch && parent.bcatch !== node) return true;\n                }\n            }\n        }\n\n        function strip_assignment(def) {\n            if (def) def.fixed = false;\n            return (self.operator != \"=\" ? make_node(AST_Binary, self, {\n                operator: self.operator.slice(0, -1),\n                left: self.left,\n                right: self.right,\n            }) : maintain_this_binding(compressor, compressor.parent(), self, self.right)).optimize(compressor);\n        }\n    });\n\n    OPT(AST_Conditional, function(self, compressor) {\n        if (compressor.option(\"sequences\") && self.condition instanceof AST_Sequence) {\n            var expressions = self.condition.expressions.slice();\n            self.condition = expressions.pop();\n            expressions.push(self);\n            return make_sequence(self, expressions);\n        }\n        if (!compressor.option(\"conditionals\")) return self;\n        var condition = self.condition;\n        if (compressor.option(\"booleans\") && !condition.has_side_effects(compressor)) {\n            mark_duplicate_condition(compressor, condition);\n        }\n        condition = fuzzy_eval(compressor, condition);\n        if (!condition) {\n            AST_Node.warn(\"Condition always false [{file}:{line},{col}]\", self.start);\n            return make_sequence(self, [ self.condition, self.alternative ]).optimize(compressor);\n        } else if (!(condition instanceof AST_Node)) {\n            AST_Node.warn(\"Condition always true [{file}:{line},{col}]\", self.start);\n            return make_sequence(self, [ self.condition, self.consequent ]).optimize(compressor);\n        }\n        var negated = condition.negate(compressor, first_in_statement(compressor));\n        if (best_of(compressor, condition, negated) === negated) {\n            self = make_node(AST_Conditional, self, {\n                condition: negated,\n                consequent: self.alternative,\n                alternative: self.consequent\n            });\n            negated = condition;\n            condition = self.condition;\n        }\n        var consequent = self.consequent;\n        var alternative = self.alternative;\n        if (repeatable(compressor, condition)) {\n            // x ? x : y ---> x || y\n            if (condition.equivalent_to(consequent)) return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: condition,\n                right: alternative,\n            }).optimize(compressor);\n            // x ? y : x ---> x && y\n            if (condition.equivalent_to(alternative)) return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: condition,\n                right: consequent,\n            }).optimize(compressor);\n        }\n        // if (foo) exp = something; else exp = something_else;\n        //                   |\n        //                   v\n        // exp = foo ? something : something_else;\n        var seq_tail = consequent.tail_node();\n        if (seq_tail instanceof AST_Assign) {\n            var is_eq = seq_tail.operator == \"=\";\n            var alt_tail = is_eq ? alternative.tail_node() : alternative;\n            if ((is_eq || consequent === seq_tail)\n                && alt_tail instanceof AST_Assign\n                && seq_tail.operator == alt_tail.operator\n                && seq_tail.left.equivalent_to(alt_tail.left)\n                && (is_eq && seq_tail.left instanceof AST_SymbolRef\n                    || !condition.has_side_effects(compressor)\n                        && can_shift_lhs_of_tail(consequent)\n                        && can_shift_lhs_of_tail(alternative))) {\n                return make_node(AST_Assign, self, {\n                    operator: seq_tail.operator,\n                    left: seq_tail.left,\n                    right: make_node(AST_Conditional, self, {\n                        condition: condition,\n                        consequent: pop_lhs(consequent),\n                        alternative: pop_lhs(alternative)\n                    })\n                });\n            }\n        }\n        // x ? y : y ---> x, y\n        if (consequent.equivalent_to(alternative)) return make_sequence(self, [\n            condition,\n            consequent\n        ]).optimize(compressor);\n        // x ? y.p : z.p ---> (x ? y : z).p\n        // x ? y(a) : z(a) ---> (x ? y : z)(a)\n        // x ? y.f(a) : z.f(a) ---> (x ? y : z).f(a)\n        var combined = combine_tail(consequent, alternative, true);\n        if (combined) return combined;\n        // x ? y(a) : y(b) ---> y(x ? a : b)\n        var arg_index;\n        if (consequent instanceof AST_Call\n            && alternative.TYPE == consequent.TYPE\n            && (arg_index = arg_diff(consequent, alternative)) >= 0\n            && consequent.expression.equivalent_to(alternative.expression)\n            && !condition.has_side_effects(compressor)\n            && !consequent.expression.has_side_effects(compressor)) {\n            var node = consequent.clone();\n            var arg = consequent.args[arg_index];\n            node.args[arg_index] = arg instanceof AST_Spread ? make_node(AST_Spread, self, {\n                expression: make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: arg.expression,\n                    alternative: alternative.args[arg_index].expression,\n                }),\n            }) : make_node(AST_Conditional, self, {\n                condition: condition,\n                consequent: arg,\n                alternative: alternative.args[arg_index],\n            });\n            return node;\n        }\n        // x ? (y ? a : b) : b ---> x && y ? a : b\n        if (consequent instanceof AST_Conditional\n            && consequent.alternative.equivalent_to(alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: condition,\n                    operator: \"&&\",\n                    right: consequent.condition\n                }),\n                consequent: consequent.consequent,\n                alternative: alternative\n            });\n        }\n        // x ? (y ? a : b) : a ---> !x || y ? a : b\n        if (consequent instanceof AST_Conditional\n            && consequent.consequent.equivalent_to(alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: negated,\n                    operator: \"||\",\n                    right: consequent.condition\n                }),\n                consequent: alternative,\n                alternative: consequent.alternative\n            });\n        }\n        // x ? a : (y ? a : b) ---> x || y ? a : b\n        if (alternative instanceof AST_Conditional\n            && consequent.equivalent_to(alternative.consequent)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: condition,\n                    operator: \"||\",\n                    right: alternative.condition\n                }),\n                consequent: consequent,\n                alternative: alternative.alternative\n            });\n        }\n        // x ? b : (y ? a : b) ---> !x && y ? a : b\n        if (alternative instanceof AST_Conditional\n            && consequent.equivalent_to(alternative.alternative)) {\n            return make_node(AST_Conditional, self, {\n                condition: make_node(AST_Binary, self, {\n                    left: negated,\n                    operator: \"&&\",\n                    right: alternative.condition\n                }),\n                consequent: alternative.consequent,\n                alternative: consequent\n            });\n        }\n        // x ? (a, c) : (b, c) ---> x ? a : b, c\n        if ((consequent instanceof AST_Sequence || alternative instanceof AST_Sequence)\n            && consequent.tail_node().equivalent_to(alternative.tail_node())) {\n            return make_sequence(self, [\n                make_node(AST_Conditional, self, {\n                    condition: condition,\n                    consequent: pop_seq(consequent),\n                    alternative: pop_seq(alternative)\n                }),\n                consequent.tail_node()\n            ]).optimize(compressor);\n        }\n        // x ? y && a : a ---> (!x || y) && a\n        if (consequent instanceof AST_Binary\n            && consequent.operator == \"&&\"\n            && consequent.right.equivalent_to(alternative)) {\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: negated,\n                    right: consequent.left\n                }),\n                right: alternative\n            }).optimize(compressor);\n        }\n        // x ? y || a : a ---> x && y || a\n        if (consequent instanceof AST_Binary\n            && consequent.operator == \"||\"\n            && consequent.right.equivalent_to(alternative)) {\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: condition,\n                    right: consequent.left\n                }),\n                right: alternative\n            }).optimize(compressor);\n        }\n        // x ? a : y && a ---> (x || y) && a\n        if (alternative instanceof AST_Binary\n            && alternative.operator == \"&&\"\n            && alternative.right.equivalent_to(consequent)) {\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"||\",\n                    left: condition,\n                    right: alternative.left\n                }),\n                right: consequent\n            }).optimize(compressor);\n        }\n        // x ? a : y || a ---> !x && y || a\n        if (alternative instanceof AST_Binary\n            && alternative.operator == \"||\"\n            && alternative.right.equivalent_to(consequent)) {\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: make_node(AST_Binary, self, {\n                    operator: \"&&\",\n                    left: negated,\n                    right: alternative.left\n                }),\n                right: consequent\n            }).optimize(compressor);\n        }\n        var in_bool = compressor.option(\"booleans\") && compressor.in_boolean_context();\n        if (is_true(consequent)) {\n            if (is_false(alternative)) {\n                // c ? true : false ---> !!c\n                return booleanize(condition);\n            }\n            // c ? true : x ---> !!c || x\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: booleanize(condition),\n                right: alternative\n            });\n        }\n        if (is_false(consequent)) {\n            if (is_true(alternative)) {\n                // c ? false : true ---> !c\n                return booleanize(condition.negate(compressor));\n            }\n            // c ? false : x ---> !c && x\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: booleanize(condition.negate(compressor)),\n                right: alternative\n            });\n        }\n        if (is_true(alternative)) {\n            // c ? x : true ---> !c || x\n            return make_node(AST_Binary, self, {\n                operator: \"||\",\n                left: booleanize(condition.negate(compressor)),\n                right: consequent\n            });\n        }\n        if (is_false(alternative)) {\n            // c ? x : false ---> !!c && x\n            return make_node(AST_Binary, self, {\n                operator: \"&&\",\n                left: booleanize(condition),\n                right: consequent\n            });\n        }\n        if (compressor.option(\"typeofs\")) mark_locally_defined(condition, consequent, alternative);\n        return self;\n\n        function booleanize(node) {\n            if (node.is_boolean(compressor)) return node;\n            // !!expression\n            return make_node(AST_UnaryPrefix, node, {\n                operator: \"!\",\n                expression: node.negate(compressor)\n            });\n        }\n\n        // AST_True or !0\n        function is_true(node) {\n            return node instanceof AST_True\n                || in_bool\n                    && node instanceof AST_Constant\n                    && node.value\n                || (node instanceof AST_UnaryPrefix\n                    && node.operator == \"!\"\n                    && node.expression instanceof AST_Constant\n                    && !node.expression.value);\n        }\n        // AST_False or !1 or void 0\n        function is_false(node) {\n            return node instanceof AST_False\n                || in_bool\n                    && (node instanceof AST_Constant\n                            && !node.value\n                        || node instanceof AST_UnaryPrefix\n                            && node.operator == \"void\"\n                            && !node.expression.has_side_effects(compressor))\n                || (node instanceof AST_UnaryPrefix\n                    && node.operator == \"!\"\n                    && node.expression instanceof AST_Constant\n                    && node.expression.value);\n        }\n\n        function arg_diff(consequent, alternative) {\n            var a = consequent.args;\n            var b = alternative.args;\n            var len = a.length;\n            if (len != b.length) return -2;\n            for (var i = 0; i < len; i++) {\n                if (!a[i].equivalent_to(b[i])) {\n                    if (a[i] instanceof AST_Spread !== b[i] instanceof AST_Spread) return -3;\n                    for (var j = i + 1; j < len; j++) {\n                        if (!a[j].equivalent_to(b[j])) return -2;\n                    }\n                    return i;\n                }\n            }\n            return -1;\n        }\n\n        function is_tail_equivalent(consequent, alternative) {\n            if (consequent.TYPE != alternative.TYPE) return;\n            if (consequent.optional != alternative.optional) return;\n            if (consequent instanceof AST_Call) {\n                if (arg_diff(consequent, alternative) != -1) return;\n                return consequent.TYPE != \"Call\"\n                    || !(consequent.expression instanceof AST_PropAccess\n                        || alternative.expression instanceof AST_PropAccess)\n                    || is_tail_equivalent(consequent.expression, alternative.expression);\n            }\n            if (!(consequent instanceof AST_PropAccess)) return;\n            var p = consequent.property;\n            var q = alternative.property;\n            return (p instanceof AST_Node ? p.equivalent_to(q) : p == q)\n                && !(consequent.expression instanceof AST_Super || alternative.expression instanceof AST_Super);\n        }\n\n        function combine_tail(consequent, alternative, top) {\n            if (!is_tail_equivalent(consequent, alternative)) return !top && make_node(AST_Conditional, self, {\n                condition: condition,\n                consequent: consequent,\n                alternative: alternative,\n            });\n            var node = consequent.clone();\n            node.expression = combine_tail(consequent.expression, alternative.expression);\n            return node;\n        }\n\n        function can_shift_lhs_of_tail(node) {\n            return node === node.tail_node() || all(node.expressions.slice(0, -1), function(expr) {\n                return !expr.has_side_effects(compressor);\n            });\n        }\n\n        function pop_lhs(node) {\n            if (!(node instanceof AST_Sequence)) return node.right;\n            var exprs = node.expressions.slice();\n            exprs.push(exprs.pop().right);\n            return make_sequence(node, exprs);\n        }\n\n        function pop_seq(node) {\n            if (!(node instanceof AST_Sequence)) return make_node(AST_Number, node, {\n                value: 0\n            });\n            return make_sequence(node, node.expressions.slice(0, -1));\n        }\n    });\n\n    OPT(AST_Boolean, function(self, compressor) {\n        if (!compressor.option(\"booleans\")) return self;\n        if (compressor.in_boolean_context()) return make_node(AST_Number, self, {\n            value: +self.value\n        });\n        var p = compressor.parent();\n        if (p instanceof AST_Binary && (p.operator == \"==\" || p.operator == \"!=\")) {\n            AST_Node.warn(\"Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]\", {\n                operator : p.operator,\n                value    : self.value,\n                file     : p.start.file,\n                line     : p.start.line,\n                col      : p.start.col,\n            });\n            return make_node(AST_Number, self, {\n                value: +self.value\n            });\n        }\n        return make_node(AST_UnaryPrefix, self, {\n            operator: \"!\",\n            expression: make_node(AST_Number, self, {\n                value: 1 - self.value\n            })\n        });\n    });\n\n    OPT(AST_Spread, function(self, compressor) {\n        var exp = self.expression;\n        if (compressor.option(\"spreads\") && exp instanceof AST_Array && !(compressor.parent() instanceof AST_Object)) {\n            return List.splice(exp.elements.map(function(node) {\n                return node instanceof AST_Hole ? make_node(AST_Undefined, node).optimize(compressor) : node;\n            }));\n        }\n        return self;\n    });\n\n    function safe_to_flatten(value, compressor) {\n        if (!value) return false;\n        var parent = compressor.parent();\n        if (parent.TYPE != \"Call\") return true;\n        if (parent.expression !== compressor.self()) return true;\n        if (value instanceof AST_SymbolRef) {\n            value = value.fixed_value();\n            if (!value) return false;\n        }\n        return value instanceof AST_Lambda && !value.contains_this();\n    }\n\n    OPT(AST_Sub, function(self, compressor) {\n        var expr = self.expression;\n        var prop = self.property;\n        var terminated = trim_optional_chain(self, compressor);\n        if (terminated) return terminated;\n        if (compressor.option(\"properties\")) {\n            var key = prop.evaluate(compressor);\n            if (key !== prop) {\n                if (typeof key == \"string\") {\n                    if (key == \"undefined\") {\n                        key = undefined;\n                    } else {\n                        var value = parseFloat(key);\n                        if (value.toString() == key) {\n                            key = value;\n                        }\n                    }\n                }\n                prop = self.property = best_of_expression(prop, make_node_from_constant(key, prop).transform(compressor));\n                var property = \"\" + key;\n                if (is_identifier_string(property)\n                    && property.length <= prop.print_to_string().length + 1) {\n                    return make_node(AST_Dot, self, {\n                        optional: self.optional,\n                        expression: expr,\n                        property: property,\n                    }).optimize(compressor);\n                }\n            }\n        }\n        var parent = compressor.parent();\n        var assigned = is_lhs(compressor.self(), parent);\n        var def, fn, fn_parent, index;\n        if (compressor.option(\"arguments\")\n            && expr instanceof AST_SymbolRef\n            && is_arguments(def = expr.definition())\n            && !expr.in_arg\n            && prop instanceof AST_Number\n            && Math.floor(index = prop.value) == index\n            && (fn = def.scope) === find_lambda()\n            && fn.uses_arguments < (assigned ? 2 : 3)) {\n            if (parent instanceof AST_UnaryPrefix && parent.operator == \"delete\") {\n                if (!def.deleted) def.deleted = [];\n                def.deleted[index] = true;\n            }\n            var argname = fn.argnames[index];\n            if (def.deleted && def.deleted[index]) {\n                argname = null;\n            } else if (argname) {\n                var arg_def;\n                if (!(argname instanceof AST_SymbolFunarg)\n                    || argname.name == \"await\"\n                    || expr.scope.find_variable(argname.name) !== (arg_def = argname.definition())) {\n                    argname = null;\n                } else if (compressor.has_directive(\"use strict\")\n                    || fn.name\n                    || fn.rest\n                    || !(fn_parent instanceof AST_Call\n                        && index < fn_parent.args.length\n                        && all(fn_parent.args.slice(0, index + 1), function(arg) {\n                            return !(arg instanceof AST_Spread);\n                        }))\n                    || !all(fn.argnames, function(argname) {\n                        return argname instanceof AST_SymbolFunarg;\n                    })) {\n                    if (has_reassigned() || arg_def.assignments || arg_def.orig.length > 1) argname = null;\n                }\n            } else if ((assigned || !has_reassigned())\n                && index < fn.argnames.length + 5\n                && compressor.drop_fargs(fn, fn_parent)\n                && !fn.rest) {\n                while (index >= fn.argnames.length) {\n                    argname = fn.make_var(AST_SymbolFunarg, fn, \"argument_\" + fn.argnames.length);\n                    fn.argnames.push(argname);\n                }\n            }\n            if (argname && find_if(function(node) {\n                return node.name === argname.name;\n            }, fn.argnames) === argname) {\n                if (assigned) def.reassigned--;\n                var sym = make_node(AST_SymbolRef, self, argname);\n                sym.reference();\n                argname.unused = undefined;\n                return sym;\n            }\n        }\n        if (assigned) return self;\n        if (compressor.option(\"sequences\")\n            && parent.TYPE != \"Call\"\n            && !(parent instanceof AST_ForEnumeration && parent.init === self)) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (key !== prop) {\n            var sub = self.flatten_object(property, compressor);\n            if (sub) {\n                expr = self.expression = sub.expression;\n                prop = self.property = sub.property;\n            }\n        }\n        var elements;\n        if (compressor.option(\"properties\")\n            && compressor.option(\"side_effects\")\n            && prop instanceof AST_Number\n            && expr instanceof AST_Array\n            && all(elements = expr.elements, function(value) {\n                return !(value instanceof AST_Spread);\n            })) {\n            var index = prop.value;\n            var retValue = elements[index];\n            if (safe_to_flatten(retValue, compressor)) {\n                var is_hole = retValue instanceof AST_Hole;\n                var flatten = !is_hole;\n                var values = [];\n                for (var i = elements.length; --i > index;) {\n                    var value = elements[i].drop_side_effect_free(compressor);\n                    if (value) {\n                        values.unshift(value);\n                        if (flatten && value.has_side_effects(compressor)) flatten = false;\n                    }\n                }\n                if (!flatten) values.unshift(retValue);\n                while (--i >= 0) {\n                    var value = elements[i].drop_side_effect_free(compressor);\n                    if (value) {\n                        values.unshift(value);\n                    } else if (is_hole) {\n                        values.unshift(make_node(AST_Hole, elements[i]));\n                    } else {\n                        index--;\n                    }\n                }\n                if (flatten) {\n                    values.push(retValue);\n                    return make_sequence(self, values).optimize(compressor);\n                } else return make_node(AST_Sub, self, {\n                    expression: make_node(AST_Array, expr, { elements: values }),\n                    property: make_node(AST_Number, prop, { value: index }),\n                });\n            }\n        }\n        return try_evaluate(compressor, self);\n\n        function find_lambda() {\n            var i = 0, p;\n            while (p = compressor.parent(i++)) {\n                if (p instanceof AST_Lambda) {\n                    if (p instanceof AST_Accessor) return;\n                    if (is_arrow(p)) continue;\n                    fn_parent = compressor.parent(i);\n                    return p;\n                }\n            }\n        }\n\n        function has_reassigned() {\n            return !compressor.option(\"reduce_vars\") || def.reassigned;\n        }\n    });\n\n    AST_LambdaExpression.DEFMETHOD(\"contains_super\", function() {\n        var result = false;\n        var self = this;\n        self.walk(new TreeWalker(function(node) {\n            if (result) return true;\n            if (node instanceof AST_Super) return result = true;\n            if (node !== self && node instanceof AST_Scope && !is_arrow(node)) return true;\n        }));\n        return result;\n    });\n\n    // contains_this()\n    // returns false only if context bound by the specified scope (or scope\n    // containing the specified expression) is not referenced by `this`\n    (function(def) {\n        // scope of arrow function cannot bind to any context\n        def(AST_Arrow, return_false);\n        def(AST_AsyncArrow, return_false);\n        def(AST_Node, function() {\n            var result = false;\n            var self = this;\n            self.walk(new TreeWalker(function(node) {\n                if (result) return true;\n                if (node instanceof AST_This) return result = true;\n                if (node !== self && node instanceof AST_Scope && !is_arrow(node)) return true;\n            }));\n            return result;\n        });\n    })(function(node, func) {\n        node.DEFMETHOD(\"contains_this\", func);\n    });\n\n    function can_hoist_property(prop) {\n        return prop instanceof AST_ObjectKeyVal\n            && typeof prop.key == \"string\"\n            && !(prop instanceof AST_ObjectMethod && prop.value.contains_super());\n    }\n\n    AST_PropAccess.DEFMETHOD(\"flatten_object\", function(key, compressor) {\n        if (!compressor.option(\"properties\")) return;\n        if (key === \"__proto__\") return;\n        var expr = this.expression;\n        if (expr instanceof AST_Object) {\n            var props = expr.properties;\n            for (var i = props.length; --i >= 0;) {\n                var prop = props[i];\n                if (prop.key !== key) continue;\n                if (!all(props, can_hoist_property)) return;\n                if (!safe_to_flatten(prop.value, compressor)) return;\n                var scope, values = [];\n                for (var j = 0; j < props.length; j++) {\n                    var value = props[j].value;\n                    if (props[j] instanceof AST_ObjectMethod) {\n                        var arrow = !(value.uses_arguments || is_generator(value) || value.contains_this());\n                        if (arrow) {\n                            if (!scope) scope = compressor.find_parent(AST_Scope);\n                            var avoid = avoid_await_yield(scope);\n                            value.each_argname(function(argname) {\n                                if (avoid[argname.name]) arrow = false;\n                            });\n                        }\n                        var ctor;\n                        if (arrow) {\n                            ctor = is_async(value) ? AST_AsyncArrow : AST_Arrow;\n                        } else if (i === j && !(compressor.parent() instanceof AST_Call)) {\n                            return;\n                        } else {\n                            ctor = value.CTOR;\n                        }\n                        value = make_node(ctor, value, value);\n                    }\n                    values.push(value);\n                }\n                return make_node(AST_Sub, this, {\n                    expression: make_node(AST_Array, expr, { elements: values }),\n                    property: make_node(AST_Number, this, { value: i }),\n                });\n            }\n        }\n    });\n\n    OPT(AST_Dot, function(self, compressor) {\n        if (self.property == \"arguments\" || self.property == \"caller\") {\n            AST_Node.warn(\"Function.prototype.{prop} not supported [{file}:{line},{col}]\", {\n                prop: self.property,\n                file: self.start.file,\n                line: self.start.line,\n                col: self.start.col,\n            });\n        }\n        var parent = compressor.parent();\n        if (is_lhs(compressor.self(), parent)) return self;\n        var terminated = trim_optional_chain(self, compressor);\n        if (terminated) return terminated;\n        if (compressor.option(\"sequences\")\n            && parent.TYPE != \"Call\"\n            && !(parent instanceof AST_ForEnumeration && parent.init === self)) {\n            var seq = lift_sequence_in_expression(self, compressor);\n            if (seq !== self) return seq.optimize(compressor);\n        }\n        if (compressor.option(\"unsafe_proto\")\n            && self.expression instanceof AST_Dot\n            && self.expression.property == \"prototype\") {\n            var exp = self.expression.expression;\n            if (is_undeclared_ref(exp)) switch (exp.name) {\n              case \"Array\":\n                self.expression = make_node(AST_Array, self.expression, {\n                    elements: []\n                });\n                break;\n              case \"Function\":\n                self.expression = make_node(AST_Function, self.expression, {\n                    argnames: [],\n                    body: []\n                }).init_vars(exp.scope);\n                break;\n              case \"Number\":\n                self.expression = make_node(AST_Number, self.expression, {\n                    value: 0\n                });\n                break;\n              case \"Object\":\n                self.expression = make_node(AST_Object, self.expression, {\n                    properties: []\n                });\n                break;\n              case \"RegExp\":\n                self.expression = make_node(AST_RegExp, self.expression, {\n                    value: /t/\n                });\n                break;\n              case \"String\":\n                self.expression = make_node(AST_String, self.expression, {\n                    value: \"\"\n                });\n                break;\n            }\n        }\n        var sub = self.flatten_object(self.property, compressor);\n        if (sub) return sub.optimize(compressor);\n        return try_evaluate(compressor, self);\n    });\n\n    OPT(AST_DestructuredArray, function(self, compressor) {\n        if (compressor.option(\"rests\") && self.rest instanceof AST_DestructuredArray) {\n            return make_node(AST_DestructuredArray, self, {\n                elements: self.elements.concat(self.rest.elements),\n                rest: self.rest.rest,\n            });\n        }\n        return self;\n    });\n\n    OPT(AST_DestructuredKeyVal, function(self, compressor) {\n        if (compressor.option(\"objects\")) {\n            var key = self.key;\n            if (key instanceof AST_Node) {\n                key = key.evaluate(compressor);\n                if (key !== self.key) self.key = \"\" + key;\n            }\n        }\n        return self;\n    });\n\n    OPT(AST_Object, function(self, compressor) {\n        if (!compressor.option(\"objects\")) return self;\n        var changed = false;\n        var found = false;\n        var generated = false;\n        var keep_duplicate = compressor.has_directive(\"use strict\");\n        var keys = [];\n        var map = new Dictionary();\n        var values = [];\n        self.properties.forEach(function(prop) {\n            if (!(prop instanceof AST_Spread)) return process(prop);\n            found = true;\n            var exp = prop.expression;\n            if (compressor.option(\"spreads\") && exp instanceof AST_Object && all(exp.properties, function(prop) {\n                if (prop instanceof AST_ObjectGetter) return false;\n                if (prop instanceof AST_Spread) return false;\n                if (prop.key !== \"__proto__\") return true;\n                if (prop instanceof AST_ObjectSetter) return true;\n                return !prop.value.has_side_effects(compressor);\n            })) {\n                changed = true;\n                exp.properties.forEach(function(prop) {\n                    var key = prop.key;\n                    var setter = prop instanceof AST_ObjectSetter;\n                    if (key === \"__proto__\") {\n                        if (!setter) return;\n                        key = make_node_from_constant(key, prop);\n                    }\n                    process(setter ? make_node(AST_ObjectKeyVal, prop, {\n                        key: key,\n                        value: make_node(AST_Undefined, prop).optimize(compressor),\n                    }) : prop);\n                });\n            } else {\n                generated = true;\n                flush();\n                values.push(prop);\n            }\n        });\n        flush();\n        if (!changed) return self;\n        if (found && generated && values.length == 1) {\n            var value = values[0];\n            if (value instanceof AST_ObjectProperty && value.key instanceof AST_Number) {\n                value.key = \"\" + value.key.value;\n            }\n        }\n        return make_node(AST_Object, self, { properties: values });\n\n        function flush() {\n            keys.forEach(function(key) {\n                var props = map.get(key);\n                switch (props.length) {\n                  case 0:\n                    return;\n                  case 1:\n                    return values.push(props[0]);\n                }\n                changed = true;\n                var tail = keep_duplicate && !generated && props.pop();\n                values.push(props.length == 1 ? props[0] : make_node(AST_ObjectKeyVal, self, {\n                    key: props[0].key,\n                    value: make_sequence(self, props.map(function(prop) {\n                        return prop.value;\n                    })),\n                }));\n                if (tail) values.push(tail);\n                props.length = 0;\n            });\n            keys = [];\n            map = new Dictionary();\n        }\n\n        function process(prop) {\n            var key = prop.key;\n            if (key instanceof AST_Node) {\n                found = true;\n                key = key.evaluate(compressor);\n                if (key === prop.key || key === \"__proto__\") {\n                    generated = true;\n                } else {\n                    key = prop.key = \"\" + key;\n                }\n            }\n            if (can_hoist_property(prop)) {\n                if (prop.value.has_side_effects(compressor)) flush();\n                keys.push(key);\n                map.add(key, prop);\n            } else {\n                flush();\n                values.push(prop);\n            }\n            if (found && !generated && typeof key == \"string\" && RE_POSITIVE_INTEGER.test(key)) {\n                generated = true;\n                if (map.has(key)) prop = map.get(key)[0];\n                prop.key = make_node(AST_Number, prop, { value: +key });\n            }\n        }\n    });\n\n    OPT(AST_Return, function(self, compressor) {\n        if (compressor.option(\"side_effects\")\n            && self.value\n            && is_undefined(self.value, compressor)\n            && !in_async_generator(compressor.find_parent(AST_Scope))) {\n            self.value = null;\n        }\n        return self;\n    });\n})(function(node, optimizer) {\n    node.DEFMETHOD(\"optimize\", function(compressor) {\n        var self = this;\n        if (self._optimized) return self;\n        if (compressor.has_directive(\"use asm\")) return self;\n        var opt = optimizer(self, compressor);\n        opt._optimized = true;\n        return opt;\n    });\n});\n","\"use strict\";\n\nvar to_ascii, to_base64;\nif (typeof Buffer == \"undefined\") {\n    to_ascii = atob;\n    to_base64 = btoa;\n} else if (typeof Buffer.alloc == \"undefined\") {\n    to_ascii = function(b64) {\n        return new Buffer(b64, \"base64\").toString();\n    };\n    to_base64 = function(str) {\n        return new Buffer(str).toString(\"base64\");\n    };\n} else {\n    to_ascii = function(b64) {\n        return Buffer.from(b64, \"base64\").toString();\n    };\n    to_base64 = function(str) {\n        return Buffer.from(str).toString(\"base64\");\n    };\n}\n\nfunction read_source_map(name, toplevel) {\n    var comments = toplevel.end.comments_after;\n    for (var i = comments.length; --i >= 0;) {\n        var comment = comments[i];\n        if (comment.type != \"comment1\") break;\n        var match = /^# ([^\\s=]+)=(\\S+)\\s*$/.exec(comment.value);\n        if (!match) break;\n        if (match[1] == \"sourceMappingURL\") {\n            match = /^data:application\\/json(;.*?)?;base64,(\\S+)$/.exec(match[2]);\n            if (!match) break;\n            return to_ascii(match[2]);\n        }\n    }\n    AST_Node.warn(\"inline source map not found: {name}\", {\n        name: name,\n    });\n}\n\nfunction parse_source_map(content) {\n    try {\n        return JSON.parse(content);\n    } catch (ex) {\n        throw new Error(\"invalid input source map: \" + content);\n    }\n}\n\nfunction set_shorthand(name, options, keys) {\n    keys.forEach(function(key) {\n        if (options[key]) {\n            if (typeof options[key] != \"object\") options[key] = {};\n            if (!(name in options[key])) options[key][name] = options[name];\n        }\n    });\n}\n\nfunction init_cache(cache) {\n    if (!cache) return;\n    if (!(\"props\" in cache)) {\n        cache.props = new Dictionary();\n    } else if (!(cache.props instanceof Dictionary)) {\n        cache.props = Dictionary.fromObject(cache.props);\n    }\n}\n\nfunction to_json(cache) {\n    return {\n        props: cache.props.toObject()\n    };\n}\n\nfunction minify(files, options) {\n    try {\n        options = defaults(options, {\n            annotations: undefined,\n            compress: {},\n            enclose: false,\n            ie: false,\n            ie8: false,\n            keep_fnames: false,\n            mangle: {},\n            nameCache: null,\n            output: {},\n            parse: {},\n            rename: undefined,\n            sourceMap: false,\n            timings: false,\n            toplevel: false,\n            v8: false,\n            validate: false,\n            warnings: false,\n            webkit: false,\n            wrap: false,\n        }, true);\n        if (options.validate) AST_Node.enable_validation();\n        var timings = options.timings && { start: Date.now() };\n        if (options.rename === undefined) options.rename = options.compress && options.mangle;\n        if (options.annotations !== undefined) set_shorthand(\"annotations\", options, [ \"compress\", \"output\" ]);\n        if (options.ie8) options.ie = options.ie || options.ie8;\n        if (options.ie) set_shorthand(\"ie\", options, [ \"compress\", \"mangle\", \"output\" ]);\n        if (options.keep_fnames) set_shorthand(\"keep_fnames\", options, [ \"compress\", \"mangle\" ]);\n        if (options.toplevel) set_shorthand(\"toplevel\", options, [ \"compress\", \"mangle\" ]);\n        if (options.v8) set_shorthand(\"v8\", options, [ \"mangle\", \"output\" ]);\n        if (options.webkit) set_shorthand(\"webkit\", options, [ \"compress\", \"mangle\", \"output\" ]);\n        var quoted_props;\n        if (options.mangle) {\n            options.mangle = defaults(options.mangle, {\n                cache: options.nameCache && (options.nameCache.vars || {}),\n                eval: false,\n                ie: false,\n                keep_fnames: false,\n                properties: false,\n                reserved: [],\n                toplevel: false,\n                v8: false,\n                webkit: false,\n            }, true);\n            if (options.mangle.properties) {\n                if (typeof options.mangle.properties != \"object\") {\n                    options.mangle.properties = {};\n                }\n                if (options.mangle.properties.keep_quoted) {\n                    quoted_props = options.mangle.properties.reserved;\n                    if (!Array.isArray(quoted_props)) quoted_props = [];\n                    options.mangle.properties.reserved = quoted_props;\n                }\n                if (options.nameCache && !(\"cache\" in options.mangle.properties)) {\n                    options.mangle.properties.cache = options.nameCache.props || {};\n                }\n            }\n            init_cache(options.mangle.cache);\n            init_cache(options.mangle.properties.cache);\n        }\n        if (options.sourceMap) {\n            options.sourceMap = defaults(options.sourceMap, {\n                content: null,\n                filename: null,\n                includeSources: false,\n                names: true,\n                root: null,\n                url: null,\n            }, true);\n        }\n        var warnings = [];\n        if (options.warnings) AST_Node.log_function(function(warning) {\n            warnings.push(warning);\n        }, options.warnings == \"verbose\");\n        if (timings) timings.parse = Date.now();\n        var toplevel;\n        if (files instanceof AST_Toplevel) {\n            toplevel = files;\n        } else {\n            if (typeof files == \"string\") {\n                files = [ files ];\n            }\n            options.parse = options.parse || {};\n            options.parse.toplevel = null;\n            var source_map_content = options.sourceMap && options.sourceMap.content;\n            if (typeof source_map_content == \"string\" && source_map_content != \"inline\") {\n                source_map_content = parse_source_map(source_map_content);\n            }\n            if (source_map_content) options.sourceMap.orig = Object.create(null);\n            for (var name in files) if (HOP(files, name)) {\n                options.parse.filename = name;\n                options.parse.toplevel = toplevel = parse(files[name], options.parse);\n                if (source_map_content == \"inline\") {\n                    var inlined_content = read_source_map(name, toplevel);\n                    if (inlined_content) {\n                        options.sourceMap.orig[name] = parse_source_map(inlined_content);\n                    }\n                } else if (source_map_content) {\n                    options.sourceMap.orig[name] = source_map_content;\n                }\n            }\n        }\n        if (quoted_props) {\n            reserve_quoted_keys(toplevel, quoted_props);\n        }\n        [ \"enclose\", \"wrap\" ].forEach(function(action) {\n            var option = options[action];\n            if (!option) return;\n            var orig = toplevel.print_to_string().slice(0, -1);\n            toplevel = toplevel[action](option);\n            files[toplevel.start.file] = toplevel.print_to_string().replace(orig, \"\");\n        });\n        if (options.validate) toplevel.validate_ast();\n        if (timings) timings.rename = Date.now();\n        if (options.rename) {\n            toplevel.figure_out_scope(options.mangle);\n            toplevel.expand_names(options.mangle);\n        }\n        if (timings) timings.compress = Date.now();\n        if (options.compress) {\n            toplevel = new Compressor(options.compress).compress(toplevel);\n            if (options.validate) toplevel.validate_ast();\n        }\n        if (timings) timings.scope = Date.now();\n        if (options.mangle) toplevel.figure_out_scope(options.mangle);\n        if (timings) timings.mangle = Date.now();\n        if (options.mangle) {\n            toplevel.compute_char_frequency(options.mangle);\n            toplevel.mangle_names(options.mangle);\n        }\n        if (timings) timings.properties = Date.now();\n        if (options.mangle && options.mangle.properties) mangle_properties(toplevel, options.mangle.properties);\n        if (timings) timings.output = Date.now();\n        var result = {};\n        var output = defaults(options.output, {\n            ast: false,\n            code: true,\n        });\n        if (output.ast) result.ast = toplevel;\n        if (output.code) {\n            if (options.sourceMap) {\n                output.source_map = SourceMap(options.sourceMap);\n                if (options.sourceMap.includeSources) {\n                    if (files instanceof AST_Toplevel) {\n                        throw new Error(\"original source content unavailable\");\n                    } else for (var name in files) if (HOP(files, name)) {\n                        output.source_map.setSourceContent(name, files[name]);\n                    }\n                }\n            }\n            delete output.ast;\n            delete output.code;\n            var stream = OutputStream(output);\n            toplevel.print(stream);\n            result.code = stream.get();\n            if (options.sourceMap) {\n                result.map = output.source_map.toString();\n                var url = options.sourceMap.url;\n                if (url) {\n                    result.code = result.code.replace(/\\n\\/\\/# sourceMappingURL=\\S+\\s*$/, \"\");\n                    if (url == \"inline\") {\n                        result.code += \"\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,\" + to_base64(result.map);\n                    } else {\n                        result.code += \"\\n//# sourceMappingURL=\" + url;\n                    }\n                }\n            }\n        }\n        if (options.nameCache && options.mangle) {\n            if (options.mangle.cache) options.nameCache.vars = to_json(options.mangle.cache);\n            if (options.mangle.properties && options.mangle.properties.cache) {\n                options.nameCache.props = to_json(options.mangle.properties.cache);\n            }\n        }\n        if (timings) {\n            timings.end = Date.now();\n            result.timings = {\n                parse: 1e-3 * (timings.rename - timings.parse),\n                rename: 1e-3 * (timings.compress - timings.rename),\n                compress: 1e-3 * (timings.scope - timings.compress),\n                scope: 1e-3 * (timings.mangle - timings.scope),\n                mangle: 1e-3 * (timings.properties - timings.mangle),\n                properties: 1e-3 * (timings.output - timings.properties),\n                output: 1e-3 * (timings.end - timings.output),\n                total: 1e-3 * (timings.end - timings.start)\n            };\n        }\n        if (warnings.length) {\n            result.warnings = warnings;\n        }\n        return result;\n    } catch (ex) {\n        return { error: ex };\n    } finally {\n        AST_Node.log_function();\n        AST_Node.disable_validation();\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz)),\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: argnames,\n                rest: rest,\n            });\n            var node = from_moz(M.body);\n            if (node instanceof AST_BlockStatement) {\n                fn.body = normalize_directives(node.body);\n                fn.value = null;\n            } else {\n                fn.body = [];\n                fn.value = node;\n            }\n            return fn;\n        },\n        FunctionDeclaration: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n            } else {\n                ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        FunctionExpression: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n            } else {\n                ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        ClassDeclaration: function(M) {\n            return new AST_DefClass({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        ClassExpression: function(M) {\n            return new AST_ClassExpression({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        MethodDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            var ctor = AST_ClassMethod, value = from_moz(M.value);\n            switch (M.kind) {\n              case \"get\":\n                ctor = AST_ClassGetter;\n                value = new AST_Accessor(value);\n                break;\n              case \"set\":\n                ctor = AST_ClassSetter;\n                value = new AST_Accessor(value);\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: value,\n            });\n        },\n        PropertyDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            return new AST_ClassField({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: from_moz(M.value),\n            });\n        },\n        ForOfStatement: function(M) {\n            return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n            });\n        },\n        Property: function(M) {\n            var key = M.computed ? from_moz(M.key) : read_name(M.key);\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                value: from_moz(M.value),\n            };\n            if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                }),\n            });\n        },\n        ArrayPattern: function(M) {\n            var elements = [], rest = null;\n            M.elements.forEach(function(el) {\n                if (el === null) {\n                    elements.push(new AST_Hole());\n                } else if (el.type == \"RestElement\") {\n                    rest = from_moz(el.argument);\n                } else {\n                    elements.push(from_moz(el));\n                }\n            });\n            return new AST_DestructuredArray({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: elements,\n                rest: rest,\n            });\n        },\n        ObjectPattern: function(M) {\n            var props = [], rest = null;\n            M.properties.forEach(function(prop) {\n                if (prop.type == \"RestElement\") {\n                    rest = from_moz(prop.argument);\n                } else {\n                    props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                }\n            });\n            return new AST_DestructuredObject({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: props,\n                rest: rest,\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                optional: M.optional,\n                expression: from_moz(M.object),\n                property: M.computed ? from_moz(M.property) : M.property.name,\n            });\n        },\n        MetaProperty: function(M) {\n            var expr = from_moz(M.meta);\n            var prop = read_name(M.property);\n            if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"new.target\",\n            });\n            return new AST_Dot({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: expr,\n                property: prop,\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz),\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            var alias = M.exported ? read_name(M.exported) : \"*\";\n            return new AST_ExportForeign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                aliases: [ alias ],\n                keys: [ \"*\" ],\n                path: M.source.value,\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            var decl = from_moz(M.declaration);\n            if (!decl.name) switch (decl.CTOR) {\n              case AST_AsyncDefun:\n                decl = new AST_AsyncFunction(decl);\n                break;\n              case AST_AsyncGeneratorDefun:\n                decl = new AST_AsyncGeneratorFunction(decl);\n                break;\n              case AST_DefClass:\n                decl = new AST_ClassExpression(decl);\n                break;\n              case AST_Defun:\n                decl = new AST_Function(decl);\n                break;\n              case AST_GeneratorDefun:\n                decl = new AST_GeneratorFunction(decl);\n                break;\n            }\n            return new AST_ExportDefault({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: decl,\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) return new AST_ExportDeclaration({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.declaration),\n            });\n            if (M.source) {\n                var aliases = [], keys = [];\n                M.specifiers.forEach(function(prop) {\n                    aliases.push(read_name(prop.exported));\n                    keys.push(read_name(prop.local));\n                });\n                return new AST_ExportForeign({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    aliases: aliases,\n                    keys: keys,\n                    path: M.source.value,\n                });\n            }\n            return new AST_ExportReferences({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: M.specifiers.map(function(prop) {\n                    var sym = new AST_SymbolExport(from_moz(prop.local));\n                    sym.alias = read_name(prop.exported);\n                    return sym;\n                }),\n            });\n        },\n        ImportDeclaration: function(M) {\n            var all = null, def = null, props = null;\n            M.specifiers.forEach(function(prop) {\n                var sym = new AST_SymbolImport(from_moz(prop.local));\n                switch (prop.type) {\n                  case \"ImportDefaultSpecifier\":\n                    def = sym;\n                    def.key = \"\";\n                    break;\n                  case \"ImportNamespaceSpecifier\":\n                    all = sym;\n                    all.key = \"*\";\n                    break;\n                  default:\n                    sym.key = prop.imported.name || syn.name;\n                    if (!props) props = [];\n                    props.push(sym);\n                    break;\n                }\n            });\n            return new AST_Import({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                all: all,\n                default: def,\n                properties: props,\n                path: M.source.value,\n            });\n        },\n        ImportExpression: function(M) {\n            var start = my_start_token(M);\n            var arg = from_moz(M.source);\n            return new AST_Call({\n                start: start,\n                end: my_end_token(M),\n                expression: new AST_SymbolRef({\n                    start: start,\n                    end: arg.start,\n                    name: \"import\",\n                }),\n                args: [ arg ],\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new ({\n                const: AST_Const,\n                let: AST_Let,\n            }[M.kind] || AST_Var)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                definitions: M.declarations.map(from_moz),\n            });\n        },\n        Literal: function(M) {\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n            };\n            if (M.bigint) {\n                args.value = M.bigint.toLowerCase() + \"n\";\n                return new AST_BigInt(args);\n            }\n            var val = M.value;\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                if (isNaN(val)) return new AST_NaN(args);\n                var negate, node;\n                if (isFinite(val)) {\n                    negate = 1 / val < 0;\n                    args.value = negate ? -val : val;\n                    node = new AST_Number(args);\n                } else {\n                    negate = val < 0;\n                    node = new AST_Infinity(args);\n                }\n                return negate ? new AST_UnaryPrefix({\n                    start: args.start,\n                    end: args.end,\n                    operator: \"-\",\n                    expression: node,\n                }) : node;\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        TemplateLiteral: function(M) {\n            return new AST_Template({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expressions: M.expressions.map(from_moz),\n                strings: M.quasis.map(function(el) {\n                    return el.value.raw;\n                }),\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            var tmpl = from_moz(M.quasi);\n            tmpl.start = my_start_token(M);\n            tmpl.end = my_end_token(M);\n            tmpl.tag = from_moz(M.tag);\n            return tmpl;\n        },\n        Identifier: function(M) {\n            var p, level = FROM_MOZ_STACK.length - 1;\n            do {\n                p = FROM_MOZ_STACK[--level];\n            } while (p.type == \"ArrayPattern\"\n                || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                || p.type == \"ObjectPattern\"\n                || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n            var ctor = AST_SymbolRef;\n            switch (p.type) {\n              case \"ArrowFunctionExpression\":\n                if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                break;\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n                ctor = AST_LabelRef;\n                break;\n              case \"CatchClause\":\n                ctor = AST_SymbolCatch;\n                break;\n              case \"ClassDeclaration\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                break;\n              case \"ClassExpression\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                break;\n              case \"FunctionDeclaration\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                break;\n              case \"FunctionExpression\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                break;\n              case \"LabeledStatement\":\n                ctor = AST_Label;\n                break;\n              case \"VariableDeclaration\":\n                ctor = {\n                    const: AST_SymbolConst,\n                    let: AST_SymbolLet,\n                }[p.kind] || AST_SymbolVar;\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name,\n            });\n        },\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"this\",\n            });\n        },\n        ParenthesizedExpression: function(M) {\n            var node = from_moz(M.expression);\n            if (!node.start.parens) node.start.parens = [];\n            node.start.parens.push(my_start_token(M));\n            if (!node.end.parens) node.end.parens = [];\n            node.end.parens.push(my_end_token(M));\n            return node;\n        },\n        ChainExpression: function(M) {\n            var node = from_moz(M.expression);\n            node.terminal = true;\n            return node;\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n    map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n    map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n    map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        if (is_arrow(M)) return {\n            type: \"ArrowFunctionExpression\",\n            async: is_async(M),\n            params: params,\n            body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n        };\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n        return {\n            type: \"ClassDeclaration\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n        return {\n            type: \"ClassExpression\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    function To_Moz_MethodDefinition(kind) {\n        return function(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"MethodDefinition\",\n                kind: kind,\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        };\n    }\n    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : M.private ? {\n            type: \"PrivateIdentifier\",\n            name: M.key.slice(1),\n        } : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"PropertyDefinition\",\n            computed: computed,\n            key: key,\n            static: M.static,\n            value: to_moz(M.value),\n        };\n    });\n\n    function To_Moz_ForOfStatement(is_await) {\n        return function(M) {\n            return {\n                type: \"ForOfStatement\",\n                await: is_await,\n                left: to_moz(M.init),\n                right: to_moz(M.object),\n                body: to_moz(M.body),\n            };\n        };\n    }\n    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: set_moz_loc(M, {\n                type: \"Literal\",\n                value: M.value,\n            }),\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally),\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M),\n        };\n    });\n\n    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n        return {\n            type: \"ExportDefaultDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n        if (M.keys[0] == \"*\") return {\n            type: \"ExportAllDeclaration\",\n            exported: M.aliases[0] == \"*\" ? null : {\n                type: \"Identifier\",\n                name: M.aliases[0],\n            },\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n        var specifiers = [];\n        for (var i = 0; i < M.aliases.length; i++) {\n            specifiers.push({\n                type: \"ExportSpecifier\",\n                exported: {\n                    type: \"Identifier\",\n                    name: M.aliases[i],\n                },\n                local: {\n                    type: \"Identifier\",\n                    name: M.keys[i],\n                },\n            });\n        }\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: specifiers,\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n    });\n\n    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: M.properties.map(function(prop) {\n                return {\n                    type: \"ExportSpecifier\",\n                    local: to_moz(prop),\n                    exported: {\n                        type: \"Identifier\",\n                        name: prop.alias,\n                    },\n                };\n            }),\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = M.properties ? M.properties.map(function(prop) {\n            return {\n                type: \"ImportSpecifier\",\n                local: to_moz(prop),\n                imported: {\n                    type: \"Identifier\",\n                    name: prop.key,\n                },\n            };\n        }) : [];\n        if (M.all) specifiers.unshift({\n            type: \"ImportNamespaceSpecifier\",\n            local: to_moz(M.all),\n        });\n        if (M.default) specifiers.unshift({\n            type: \"ImportDefaultSpecifier\",\n            local: to_moz(M.default),\n        });\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: M.TYPE.toLowerCase(),\n            declarations: M.definitions.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var computed = M instanceof AST_Sub;\n        var expr = {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: computed,\n            optional: M.optional,\n            property: computed ? to_moz(M.property) : {\n                type: \"Identifier\",\n                name: M.property,\n            },\n        };\n        return M.terminal ? {\n            type: \"ChainExpression\",\n            expression: expr,\n        } : expr;\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n        var elements = M.elements.map(to_moz);\n        if (M.rest) elements.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ArrayPattern\",\n            elements: elements,\n        };\n    });\n\n    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"Property\",\n            kind: \"init\",\n            computed: computed,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n        var props = M.properties.map(to_moz);\n        if (M.rest) props.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ObjectPattern\",\n            properties: props,\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            computed: computed,\n            method: M instanceof AST_ObjectMethod,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name,\n        };\n    });\n\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return { type: \"Super\" };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\",\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\",\n            },\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/[gimuy]*$/)[0];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags\n            }\n        };\n    });\n\n    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            bigint: value.slice(0, -1),\n            raw: value,\n        };\n    });\n\n    function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw,\n                },\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw,\n        };\n    }\n    def_to_moz(AST_Boolean, To_Moz_Literal);\n    def_to_moz(AST_Constant, To_Moz_Literal);\n    def_to_moz(AST_Null, To_Moz_Literal);\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value),\n        };\n    });\n\n    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n        var last = M.strings.length - 1;\n        var tmpl = {\n            type: \"TemplateLiteral\",\n            expressions: M.expressions.map(to_moz),\n            quasis: M.strings.map(function(str, index) {\n                return {\n                    type: \"TemplateElement\",\n                    tail: index == last,\n                    value: { raw: str },\n                };\n            }),\n        };\n        if (!M.tag) return tmpl;\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.tag),\n            quasi: tmpl,\n        };\n    });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n    AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n        throw new Error(\"Cannot convert AST_\" + this.TYPE);\n    });\n\n    /* -----[ tools ]----- */\n\n    function normalize_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_SimpleStatement)) break;\n            var node = stat.body;\n            if (!(node instanceof AST_String)) break;\n            if (stat.start.pos !== node.start.pos) break;\n            body[i] = new AST_Directive(node);\n        }\n        return body;\n    }\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function read_name(M) {\n        return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = [\n            \"start: my_start_token(M)\",\n            \"end: my_end_token(M)\",\n        ];\n        var me_to_moz = [\n            \"type: \" + JSON.stringify(moztype),\n        ];\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            switch (how) {\n              case \"@\":\n                moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                break;\n              case \">\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                break;\n              case \"=\":\n                moz_to_me.push(my + \": M.\" + moz);\n                me_to_moz.push(moz + \": M.\" + my);\n                break;\n              case \"%\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                me_to_moz.push(moz + \": to_moz_block(M)\");\n                break;\n              default:\n                throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n            \"return function From_Moz_\" + moztype + \"(M) {\",\n            \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n            moz_to_me.join(\",\\n\"),\n            \"    });\",\n            \"};\",\n        ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n        def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n            \"return function To_Moz_\" + moztype + \"(M) {\",\n            \"    return {\",\n            me_to_moz.join(\",\\n\"),\n            \"    };\",\n            \"};\",\n        ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(moz) {\n        FROM_MOZ_STACK.push(moz);\n        var node = null;\n        if (moz) {\n            if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n            node = MOZ_TO_ME[moz.type](moz);\n        }\n        FROM_MOZ_STACK.pop();\n        return node;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null,\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz),\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body,\n        };\n    }\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction is_some_comments(comment) {\n    // multiline comment\n    return comment.type == \"comment2\" && /@preserve|@license|@cc_on/i.test(comment.value);\n}\n\nfunction OutputStream(options) {\n    options = defaults(options, {\n        annotations      : false,\n        ascii_only       : false,\n        beautify         : false,\n        braces           : false,\n        comments         : false,\n        galio            : false,\n        ie               : false,\n        indent_level     : 4,\n        indent_start     : 0,\n        inline_script    : true,\n        keep_quoted_props: false,\n        max_line_len     : false,\n        preamble         : null,\n        preserve_line    : false,\n        quote_keys       : false,\n        quote_style      : 0,\n        semicolons       : true,\n        shebang          : true,\n        source_map       : null,\n        v8               : false,\n        webkit           : false,\n        width            : 80,\n        wrap_iife        : false,\n    }, true);\n\n    // Convert comment option to RegExp if neccessary and set up comments filter\n    var comment_filter = return_false; // Default case, throw all comments away\n    if (options.comments) {\n        var comments = options.comments;\n        if (typeof options.comments === \"string\" && /^\\/.*\\/[a-zA-Z]*$/.test(options.comments)) {\n            var regex_pos = options.comments.lastIndexOf(\"/\");\n            comments = new RegExp(\n                options.comments.substr(1, regex_pos - 1),\n                options.comments.substr(regex_pos + 1)\n            );\n        }\n        if (comments instanceof RegExp) {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments.test(comment.value);\n            };\n        } else if (typeof comments === \"function\") {\n            comment_filter = function(comment) {\n                return comment.type != \"comment5\" && comments(this, comment);\n            };\n        } else if (comments === \"some\") {\n            comment_filter = is_some_comments;\n        } else { // NOTE includes \"all\" option\n            comment_filter = return_true;\n        }\n    }\n\n    var current_col = 0;\n    var current_line = 1;\n    var current_pos = 0;\n    var indentation = options.indent_start;\n    var last;\n    var line_end = 0;\n    var line_fixed = true;\n    var mappings = options.source_map && [];\n    var mapping_name;\n    var mapping_token;\n    var might_need_space;\n    var might_need_semicolon;\n    var need_newline_indented = false;\n    var need_space = false;\n    var newline_insert = -1;\n    var stack;\n    var OUTPUT;\n\n    function reset() {\n        last = \"\";\n        might_need_space = false;\n        might_need_semicolon = false;\n        stack = [];\n        var str = OUTPUT;\n        OUTPUT = \"\";\n        return str;\n    }\n\n    reset();\n    var to_utf8 = options.ascii_only ? function(str, identifier) {\n        if (identifier) str = str.replace(/[\\ud800-\\udbff][\\udc00-\\udfff]/g, function(ch) {\n            return \"\\\\u{\" + (ch.charCodeAt(0) - 0xd7c0 << 10 | ch.charCodeAt(1) - 0xdc00).toString(16) + \"}\";\n        });\n        return str.replace(/[\\u0000-\\u001f\\u007f-\\uffff]/g, function(ch) {\n            var code = ch.charCodeAt(0).toString(16);\n            if (code.length <= 2 && !identifier) {\n                while (code.length < 2) code = \"0\" + code;\n                return \"\\\\x\" + code;\n            } else {\n                while (code.length < 4) code = \"0\" + code;\n                return \"\\\\u\" + code;\n            }\n        });\n    } : function(str) {\n        var s = \"\";\n        for (var i = 0, j = 0; i < str.length; i++) {\n            var code = str.charCodeAt(i);\n            if (is_surrogate_pair_head(code)) {\n                if (is_surrogate_pair_tail(str.charCodeAt(i + 1))) {\n                    i++;\n                    continue;\n                }\n            } else if (!is_surrogate_pair_tail(code)) {\n                continue;\n            }\n            s += str.slice(j, i) + \"\\\\u\" + code.toString(16);\n            j = i + 1;\n        }\n        return j == 0 ? str : s + str.slice(j);\n    };\n\n    function quote_single(str) {\n        return \"'\" + str.replace(/\\x27/g, \"\\\\'\") + \"'\";\n    }\n\n    function quote_double(str) {\n        return '\"' + str.replace(/\\x22/g, '\\\\\"') + '\"';\n    }\n\n    var quote_string = [\n        null,\n        quote_single,\n        quote_double,\n        function(str, quote) {\n            return quote == \"'\" ? quote_single(str) : quote_double(str);\n        },\n    ][options.quote_style] || function(str, quote, dq, sq) {\n        return dq > sq ? quote_single(str) : quote_double(str);\n    };\n\n    function make_string(str, quote) {\n        var dq = 0, sq = 0;\n        str = str.replace(/[\\\\\\b\\f\\n\\r\\v\\t\\x22\\x27\\u2028\\u2029\\0\\ufeff]/g, function(s, i) {\n            switch (s) {\n              case '\"': ++dq; return '\"';\n              case \"'\": ++sq; return \"'\";\n              case \"\\\\\": return \"\\\\\\\\\";\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\\\t\";\n              case \"\\b\": return \"\\\\b\";\n              case \"\\f\": return \"\\\\f\";\n              case \"\\x0B\": return options.ie ? \"\\\\x0B\" : \"\\\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              case \"\\ufeff\": return \"\\\\ufeff\";\n              case \"\\0\":\n                  return /[0-9]/.test(str.charAt(i+1)) ? \"\\\\x00\" : \"\\\\0\";\n            }\n            return s;\n        });\n        return quote_string(to_utf8(str), quote, dq, sq);\n    }\n\n    /* -----[ beautification/minification ]----- */\n\n    var adjust_mappings = mappings ? function(line, col) {\n        mappings.forEach(function(mapping) {\n            mapping.line += line;\n            mapping.col += col;\n        });\n    } : noop;\n\n    var flush_mappings = mappings ? function() {\n        mappings.forEach(function(mapping) {\n            options.source_map.add(\n                mapping.token.file,\n                mapping.line, mapping.col,\n                mapping.token.line, mapping.token.col,\n                !mapping.name && mapping.token.type == \"name\" ? mapping.token.value : mapping.name\n            );\n        });\n        mappings = [];\n    } : noop;\n\n    function insert_newlines(count) {\n        var index = OUTPUT.lastIndexOf(\"\\n\");\n        if (line_end < index) line_end = index;\n        var left = OUTPUT.slice(0, line_end);\n        var right = OUTPUT.slice(line_end);\n        adjust_mappings(count, right.length - current_col);\n        current_line += count;\n        current_pos += count;\n        current_col = right.length;\n        OUTPUT = left;\n        while (count--) OUTPUT += \"\\n\";\n        OUTPUT += right;\n    }\n\n    var fix_line = options.max_line_len ? function() {\n        if (line_fixed) {\n            if (current_col > options.max_line_len) {\n                AST_Node.warn(\"Output exceeds {max_line_len} characters\", options);\n            }\n            return;\n        }\n        if (current_col > options.max_line_len) insert_newlines(1);\n        line_fixed = true;\n        flush_mappings();\n    } : noop;\n\n    var requireSemicolonChars = makePredicate(\"( [ + * / - , .\");\n\n    var print = options.beautify\n        || options.comments\n        || options.max_line_len\n        || options.preserve_line\n        || options.shebang\n        || !options.semicolons\n        || options.source_map\n        || options.width ? function(str) {\n        var ch = str.charAt(0);\n        if (need_newline_indented && ch) {\n            need_newline_indented = false;\n            if (ch != \"\\n\") {\n                print(\"\\n\");\n                indent();\n            }\n        }\n        if (need_space && ch) {\n            need_space = false;\n            if (!/[\\s;})]/.test(ch)) {\n                space();\n            }\n        }\n        newline_insert = -1;\n        var prev = last.slice(-1);\n        if (might_need_semicolon) {\n            might_need_semicolon = false;\n\n            if (prev == \":\" && ch == \"}\" || (!ch || \";}\".indexOf(ch) < 0) && prev != \";\") {\n                if (options.semicolons || requireSemicolonChars[ch]) {\n                    OUTPUT += \";\";\n                    current_col++;\n                    current_pos++;\n                } else {\n                    fix_line();\n                    OUTPUT += \"\\n\";\n                    current_pos++;\n                    current_line++;\n                    current_col = 0;\n\n                    if (/^\\s+$/.test(str)) {\n                        // reset the semicolon flag, since we didn't print one\n                        // now and might still have to later\n                        might_need_semicolon = true;\n                    }\n                }\n\n                if (!options.beautify)\n                    might_need_space = false;\n            }\n        }\n\n        if (might_need_space) {\n            if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == \"\\\\\")\n                || (ch == \"/\" && ch == prev)\n                || ((ch == \"+\" || ch == \"-\") && ch == last)\n                || str == \"--\" && last == \"!\"\n                || str == \"in\" && prev == \"/\"\n                || last == \"--\" && ch == \">\") {\n                OUTPUT += \" \";\n                current_col++;\n                current_pos++;\n            }\n            if (prev != \"<\" || str != \"!\") might_need_space = false;\n        }\n\n        if (mapping_token) {\n            mappings.push({\n                token: mapping_token,\n                name: mapping_name,\n                line: current_line,\n                col: current_col\n            });\n            mapping_token = false;\n            if (line_fixed) flush_mappings();\n        }\n\n        OUTPUT += str;\n        current_pos += str.length;\n        var a = str.split(/\\r?\\n/), n = a.length - 1;\n        current_line += n;\n        current_col += a[0].length;\n        if (n > 0) {\n            fix_line();\n            current_col = a[n].length;\n        }\n        last = str;\n    } : function(str) {\n        var ch = str.charAt(0);\n        var prev = last.slice(-1);\n        if (might_need_semicolon) {\n            might_need_semicolon = false;\n            if (prev == \":\" && ch == \"}\" || (!ch || \";}\".indexOf(ch) < 0) && prev != \";\") {\n                OUTPUT += \";\";\n                might_need_space = false;\n            }\n        }\n        if (might_need_space) {\n            if (is_identifier_char(prev) && (is_identifier_char(ch) || ch == \"\\\\\")\n                || (ch == \"/\" && ch == prev)\n                || ((ch == \"+\" || ch == \"-\") && ch == last)\n                || str == \"--\" && last == \"!\"\n                || str == \"in\" && prev == \"/\"\n                || last == \"--\" && ch == \">\") {\n                OUTPUT += \" \";\n            }\n            if (prev != \"<\" || str != \"!\") might_need_space = false;\n        }\n        OUTPUT += str;\n        last = str;\n    };\n\n    var space = options.beautify ? function() {\n        print(\" \");\n    } : function() {\n        might_need_space = true;\n    };\n\n    var indent = options.beautify ? function(half) {\n        if (need_newline_indented) print(\"\\n\");\n        print(repeat_string(\" \", half ? indentation - (options.indent_level >> 1) : indentation));\n    } : noop;\n\n    var with_indent = options.beautify ? function(cont) {\n        var save_indentation = indentation;\n        indentation += options.indent_level;\n        cont();\n        indentation = save_indentation;\n    } : function(cont) { cont() };\n\n    var may_add_newline = options.max_line_len || options.preserve_line ? function() {\n        fix_line();\n        line_end = OUTPUT.length;\n        line_fixed = false;\n    } : noop;\n\n    var newline = options.beautify ? function() {\n        if (newline_insert < 0) return print(\"\\n\");\n        if (OUTPUT[newline_insert] != \"\\n\") {\n            OUTPUT = OUTPUT.slice(0, newline_insert) + \"\\n\" + OUTPUT.slice(newline_insert);\n            current_pos++;\n            current_line++;\n        }\n        newline_insert++;\n    } : may_add_newline;\n\n    var semicolon = options.beautify ? function() {\n        print(\";\");\n    } : function() {\n        might_need_semicolon = true;\n    };\n\n    function force_semicolon() {\n        if (might_need_semicolon) print(\";\");\n        print(\";\");\n    }\n\n    function with_block(cont) {\n        print(\"{\");\n        newline();\n        with_indent(cont);\n        indent();\n        print(\"}\");\n    }\n\n    function with_parens(cont) {\n        print(\"(\");\n        may_add_newline();\n        cont();\n        may_add_newline();\n        print(\")\");\n    }\n\n    function with_square(cont) {\n        print(\"[\");\n        may_add_newline();\n        cont();\n        may_add_newline();\n        print(\"]\");\n    }\n\n    function comma() {\n        may_add_newline();\n        print(\",\");\n        may_add_newline();\n        space();\n    }\n\n    function colon() {\n        print(\":\");\n        space();\n    }\n\n    var add_mapping = mappings ? function(token, name) {\n        mapping_token = token;\n        mapping_name = name;\n    } : noop;\n\n    function get() {\n        if (!line_fixed) fix_line();\n        return OUTPUT;\n    }\n\n    function has_nlb() {\n        var index = OUTPUT.lastIndexOf(\"\\n\");\n        return /^ *$/.test(OUTPUT.slice(index + 1));\n    }\n\n    function pad_comment(token, force) {\n        if (need_newline_indented) return;\n        if (token.nlb && (force || !has_nlb())) {\n            need_newline_indented = true;\n        } else if (force) {\n            need_space = true;\n        }\n    }\n\n    function print_comment(comment) {\n        var value = comment.value.replace(/[@#]__PURE__/g, \" \");\n        if (/^\\s*$/.test(value) && !/^\\s*$/.test(comment.value)) return false;\n        if (/comment[134]/.test(comment.type)) {\n            print(\"//\" + value);\n            need_newline_indented = true;\n        } else if (comment.type == \"comment2\") {\n            print(\"/*\" + value + \"*/\");\n        }\n        return true;\n    }\n\n    function should_merge_comments(node, parent) {\n        if (parent instanceof AST_Binary) return parent.left === node;\n        if (parent.TYPE == \"Call\") return parent.expression === node;\n        if (parent instanceof AST_Conditional) return parent.condition === node;\n        if (parent instanceof AST_Dot) return parent.expression === node;\n        if (parent instanceof AST_Exit) return true;\n        if (parent instanceof AST_Sequence) return parent.expressions[0] === node;\n        if (parent instanceof AST_Sub) return parent.expression === node;\n        if (parent instanceof AST_UnaryPostfix) return true;\n        if (parent instanceof AST_Yield) return true;\n    }\n\n    function prepend_comments(node) {\n        var self = this;\n        var scan;\n        if (node instanceof AST_Exit) {\n            scan = node.value;\n        } else if (node instanceof AST_Yield) {\n            scan = node.expression;\n        }\n        var comments = dump(node);\n        if (!comments) comments = [];\n\n        if (scan) {\n            var tw = new TreeWalker(function(node) {\n                if (!should_merge_comments(node, tw.parent())) return true;\n                var before = dump(node);\n                if (before) comments = comments.concat(before);\n            });\n            tw.push(node);\n            scan.walk(tw);\n        }\n\n        if (current_pos == 0) {\n            if (comments.length > 0 && options.shebang && comments[0].type == \"comment5\") {\n                print(\"#!\" + comments.shift().value + \"\\n\");\n                indent();\n            }\n            var preamble = options.preamble;\n            if (preamble) {\n                print(preamble.replace(/\\r\\n?|[\\n\\u2028\\u2029]|\\s*$/g, \"\\n\"));\n            }\n        }\n\n        comments = comments.filter(comment_filter, node);\n        var printed = false;\n        comments.forEach(function(comment, index) {\n            pad_comment(comment, index);\n            if (print_comment(comment)) printed = true;\n        });\n        if (printed) pad_comment(node.start, true);\n\n        function dump(node) {\n            var token = node.start;\n            if (!token) {\n                if (!scan) return;\n                node.start = token = new AST_Token();\n            }\n            var comments = token.comments_before;\n            if (!comments) {\n                if (!scan) return;\n                token.comments_before = comments = [];\n            }\n            if (comments._dumped === self) return;\n            comments._dumped = self;\n            return comments;\n        }\n    }\n\n    function append_comments(node, tail) {\n        var self = this;\n        var token = node.end;\n        if (!token) return;\n        var comments = token[tail ? \"comments_before\" : \"comments_after\"];\n        if (!comments || comments._dumped === self) return;\n        if (!(node instanceof AST_Statement || all(comments, function(c) {\n            return !/comment[134]/.test(c.type);\n        }))) return;\n        comments._dumped = self;\n        var insert = OUTPUT.length;\n        comments.filter(comment_filter, node).forEach(function(comment, index) {\n            pad_comment(comment, index || !tail);\n            print_comment(comment);\n        });\n        if (OUTPUT.length > insert) newline_insert = insert;\n    }\n\n    return {\n        get             : get,\n        reset           : reset,\n        indent          : indent,\n        should_break    : options.width ? function() {\n            return current_col - indentation >= options.width;\n        } : return_false,\n        has_parens      : function() { return last.slice(-1) == \"(\" },\n        newline         : newline,\n        print           : print,\n        space           : space,\n        comma           : comma,\n        colon           : colon,\n        last            : function() { return last },\n        semicolon       : semicolon,\n        force_semicolon : force_semicolon,\n        to_utf8         : to_utf8,\n        print_name      : function(name) { print(to_utf8(name.toString(), true)) },\n        print_string    : options.inline_script ? function(str, quote) {\n            str = make_string(str, quote).replace(/<\\x2f(script)([>\\/\\t\\n\\f\\r ])/gi, \"<\\\\/$1$2\");\n            print(str.replace(/\\x3c!--/g, \"\\\\x3c!--\").replace(/--\\x3e/g, \"--\\\\x3e\"));\n        } : function(str, quote) {\n            print(make_string(str, quote));\n        },\n        with_indent     : with_indent,\n        with_block      : with_block,\n        with_parens     : with_parens,\n        with_square     : with_square,\n        add_mapping     : add_mapping,\n        option          : function(opt) { return options[opt] },\n        prepend_comments: options.comments || options.shebang ? prepend_comments : noop,\n        append_comments : options.comments ? append_comments : noop,\n        push_node       : function(node) { stack.push(node) },\n        pop_node        : options.preserve_line ? function() {\n            var node = stack.pop();\n            if (node.start && node.start.line > current_line) {\n                insert_newlines(node.start.line - current_line);\n            }\n        } : function() {\n            stack.pop();\n        },\n        parent          : function(n) {\n            return stack[stack.length - 2 - (n || 0)];\n        },\n    };\n}\n\n/* -----[ code generators ]----- */\n\n(function() {\n\n    /* -----[ utils ]----- */\n\n    function DEFPRINT(nodetype, generator) {\n        nodetype.DEFMETHOD(\"_codegen\", generator);\n    }\n\n    var use_asm = false;\n\n    AST_Node.DEFMETHOD(\"print\", function(stream, force_parens) {\n        var self = this;\n        stream.push_node(self);\n        if (force_parens || self.needs_parens(stream)) {\n            stream.with_parens(doit);\n        } else {\n            doit();\n        }\n        stream.pop_node();\n\n        function doit() {\n            stream.prepend_comments(self);\n            self.add_source_map(stream);\n            self._codegen(stream);\n            stream.append_comments(self);\n        }\n    });\n    var readonly = OutputStream({\n        inline_script: false,\n        shebang: false,\n        width: false,\n    });\n    AST_Node.DEFMETHOD(\"print_to_string\", function(options) {\n        if (options) {\n            var stream = OutputStream(options);\n            this.print(stream);\n            return stream.get();\n        }\n        this.print(readonly);\n        return readonly.reset();\n    });\n\n    /* -----[ PARENTHESES ]----- */\n\n    function PARENS(nodetype, func) {\n        nodetype.DEFMETHOD(\"needs_parens\", func);\n    }\n\n    PARENS(AST_Node, return_false);\n\n    // a function expression needs parens around it when it's provably\n    // the first token to appear in a statement.\n    function needs_parens_function(output) {\n        var p = output.parent();\n        if (!output.has_parens() && first_in_statement(output, false, true)) {\n            // export default function() {}\n            // export default (function foo() {});\n            // export default (function() {})(foo);\n            // export default (function() {})`foo`;\n            // export default (function() {}) ? foo : bar;\n            return this.name || !(p instanceof AST_ExportDefault);\n        }\n        if (output.option(\"webkit\") && p instanceof AST_PropAccess && p.expression === this) return true;\n        if (output.option(\"wrap_iife\") && p instanceof AST_Call && p.expression === this) return true;\n    }\n    PARENS(AST_AsyncFunction, needs_parens_function);\n    PARENS(AST_AsyncGeneratorFunction, needs_parens_function);\n    PARENS(AST_ClassExpression, needs_parens_function);\n    PARENS(AST_Function, needs_parens_function);\n    PARENS(AST_GeneratorFunction, needs_parens_function);\n\n    // same goes for an object literal, because otherwise it would be\n    // interpreted as a block of code.\n    function needs_parens_obj(output) {\n        return !output.has_parens() && first_in_statement(output, true);\n    }\n    PARENS(AST_Object, needs_parens_obj);\n\n    function needs_parens_unary(output) {\n        var p = output.parent();\n        // (-x) ** y\n        if (p instanceof AST_Binary) return p.operator == \"**\" && p.left === this;\n        // (await x)(y)\n        // new (await x)\n        if (p instanceof AST_Call) return p.expression === this;\n        // class extends (x++) {}\n        // class x extends (typeof y) {}\n        if (p instanceof AST_Class) return true;\n        // (x++)[y]\n        // (typeof x).y\n        if (p instanceof AST_PropAccess) return p.expression === this;\n        // (~x)`foo`\n        if (p instanceof AST_Template) return p.tag === this;\n    }\n    PARENS(AST_Await, needs_parens_unary);\n    PARENS(AST_Unary, needs_parens_unary);\n\n    PARENS(AST_Sequence, function(output) {\n        var p = output.parent();\n            // [ 1, (2, 3), 4 ] ---> [ 1, 3, 4 ]\n        return p instanceof AST_Array\n            // () ---> (foo, bar)\n            || is_arrow(p) && p.value === this\n            // await (foo, bar)\n            || p instanceof AST_Await\n            // 1 + (2, 3) + 4 ---> 8\n            || p instanceof AST_Binary\n            // new (foo, bar) or foo(1, (2, 3), 4)\n            || p instanceof AST_Call\n            // class extends (foo, bar) {}\n            // class foo extends (bar, baz) {}\n            || p instanceof AST_Class\n            // class { foo = (bar, baz) }\n            // class { [(foo, bar)]() {} }\n            || p instanceof AST_ClassProperty\n            // (false, true) ? (a = 10, b = 20) : (c = 30)\n            // ---> 20 (side effect, set a := 10 and b := 20)\n            || p instanceof AST_Conditional\n            // [ a = (1, 2) ] = [] ---> a == 2\n            || p instanceof AST_DefaultValue\n            // { [(1, 2)]: foo } = bar\n            // { 1: (2, foo) } = bar\n            || p instanceof AST_DestructuredKeyVal\n            // export default (foo, bar)\n            || p instanceof AST_ExportDefault\n            // for (foo of (bar, baz));\n            || p instanceof AST_ForOf\n            // { [(1, 2)]: 3 }[2] ---> 3\n            // { foo: (1, 2) }.foo ---> 2\n            || p instanceof AST_ObjectProperty\n            // (1, {foo:2}).foo or (1, {foo:2})[\"foo\"] ---> 2\n            || p instanceof AST_PropAccess && p.expression === this\n            // ...(foo, bar, baz)\n            || p instanceof AST_Spread\n            // (foo, bar)`baz`\n            || p instanceof AST_Template && p.tag === this\n            // !(foo, bar, baz)\n            || p instanceof AST_Unary\n            // var a = (1, 2), b = a + a; ---> b == 4\n            || p instanceof AST_VarDef\n            // yield (foo, bar)\n            || p instanceof AST_Yield;\n    });\n\n    PARENS(AST_Binary, function(output) {\n        var p = output.parent();\n        // await (foo && bar)\n        if (p instanceof AST_Await) return true;\n        // this deals with precedence:\n        //   3 * (2 + 1)\n        //   3 - (2 - 1)\n        //   (1 ** 2) ** 3\n        if (p instanceof AST_Binary) {\n            var po = p.operator, pp = PRECEDENCE[po];\n            var so = this.operator, sp = PRECEDENCE[so];\n            return pp > sp\n                || po == \"??\" && (so == \"&&\" || so == \"||\")\n                || (pp == sp && this === p[po == \"**\" ? \"left\" : \"right\"]);\n        }\n        // (foo && bar)()\n        if (p instanceof AST_Call) return p.expression === this;\n        // class extends (foo && bar) {}\n        // class foo extends (bar || null) {}\n        if (p instanceof AST_Class) return true;\n        // (foo && bar)[\"prop\"], (foo && bar).prop\n        if (p instanceof AST_PropAccess) return p.expression === this;\n        // (foo && bar)``\n        if (p instanceof AST_Template) return p.tag === this;\n        // typeof (foo && bar)\n        if (p instanceof AST_Unary) return true;\n    });\n\n    function need_chain_parens(node, parent) {\n        if (!node.terminal) return false;\n        if (!(parent instanceof AST_Call || parent instanceof AST_PropAccess)) return false;\n        return parent.expression === node;\n    }\n\n    PARENS(AST_PropAccess, function(output) {\n        var node = this;\n        var p = output.parent();\n        // i.e. new (foo().bar)\n        //\n        // if there's one call into this subtree, then we need\n        // parens around it too, otherwise the call will be\n        // interpreted as passing the arguments to the upper New\n        // expression.\n        if (p instanceof AST_New && p.expression === node && root_expr(node).TYPE == \"Call\") return true;\n        // (foo?.bar)()\n        // (foo?.bar).baz\n        // new (foo?.bar)()\n        return need_chain_parens(node, p);\n    });\n\n    PARENS(AST_Call, function(output) {\n        var node = this;\n        var p = output.parent();\n        if (p instanceof AST_New) return p.expression === node;\n        // https://bugs.webkit.org/show_bug.cgi?id=123506\n        if (output.option(\"webkit\")\n            && node.expression instanceof AST_Function\n            && p instanceof AST_PropAccess\n            && p.expression === node) {\n            var g = output.parent(1);\n            if (g instanceof AST_Assign && g.left === p) return true;\n        }\n        // (foo?.())()\n        // (foo?.()).bar\n        // new (foo?.())()\n        return need_chain_parens(node, p);\n    });\n\n    PARENS(AST_New, function(output) {\n        if (need_constructor_parens(this, output)) return false;\n        var p = output.parent();\n        // (new foo)(bar)\n        if (p instanceof AST_Call) return p.expression === this;\n        // (new Date).getTime(), (new Date)[\"getTime\"]()\n        if (p instanceof AST_PropAccess) return true;\n        // (new foo)`bar`\n        if (p instanceof AST_Template) return p.tag === this;\n    });\n\n    PARENS(AST_Number, function(output) {\n        if (!output.option(\"galio\")) return false;\n        // https://github.com/mishoo/UglifyJS/pull/1009\n        var p = output.parent();\n        return p instanceof AST_PropAccess && p.expression === this && /^0/.test(make_num(this.value));\n    });\n\n    function needs_parens_assign_cond(self, output) {\n        var p = output.parent();\n        // await (a = foo)\n        if (p instanceof AST_Await) return true;\n        // 1 + (a = 2) + 3  6, side effect setting a = 2\n        if (p instanceof AST_Binary) return !(p instanceof AST_Assign);\n        // (a = func)() or new (a = Object)()\n        if (p instanceof AST_Call) return p.expression === self;\n        // class extends (a = foo) {}\n        // class foo extends (bar ? baz : moo) {}\n        if (p instanceof AST_Class) return true;\n        // (a = foo) ? bar : baz\n        if (p instanceof AST_Conditional) return p.condition === self;\n        // (a = foo)[\"prop\"] or (a = foo).prop\n        if (p instanceof AST_PropAccess) return p.expression === self;\n        // (a = foo)`bar`\n        if (p instanceof AST_Template) return p.tag === self;\n        // !(a = false)  true\n        if (p instanceof AST_Unary) return true;\n    }\n    PARENS(AST_Arrow, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n    PARENS(AST_Assign, function(output) {\n        if (needs_parens_assign_cond(this, output)) return true;\n        //  v8 parser bug   --->     workaround\n        // f([1], [a] = []) ---> f([1], ([a] = []))\n        if (output.option(\"v8\")) return this.left instanceof AST_Destructured;\n        // ({ p: a } = o);\n        if (this.left instanceof AST_DestructuredObject) return needs_parens_obj(output);\n    });\n    PARENS(AST_AsyncArrow, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n    PARENS(AST_Conditional, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n    PARENS(AST_Yield, function(output) {\n        return needs_parens_assign_cond(this, output);\n    });\n\n    /* -----[ PRINTERS ]----- */\n\n    DEFPRINT(AST_Directive, function(output) {\n        var quote = this.quote;\n        var value = this.value;\n        switch (output.option(\"quote_style\")) {\n          case 0:\n          case 2:\n            if (value.indexOf('\"') == -1) quote = '\"';\n            break;\n          case 1:\n            if (value.indexOf(\"'\") == -1) quote = \"'\";\n            break;\n        }\n        output.print(quote + value + quote);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Debugger, function(output) {\n        output.print(\"debugger\");\n        output.semicolon();\n    });\n\n    /* -----[ statements ]----- */\n\n    function display_body(body, is_toplevel, output, allow_directives) {\n        var last = body.length - 1;\n        var in_directive = allow_directives;\n        var was_asm = use_asm;\n        body.forEach(function(stmt, i) {\n            if (in_directive) {\n                if (stmt instanceof AST_Directive) {\n                    if (stmt.value == \"use asm\") use_asm = true;\n                } else if (!(stmt instanceof AST_EmptyStatement)) {\n                    if (stmt instanceof AST_SimpleStatement && stmt.body instanceof AST_String) {\n                        output.force_semicolon();\n                    }\n                    in_directive = false;\n                }\n            }\n            if (stmt instanceof AST_EmptyStatement) return;\n            output.indent();\n            stmt.print(output);\n            if (i == last && is_toplevel) return;\n            output.newline();\n            if (is_toplevel) output.newline();\n        });\n        use_asm = was_asm;\n    }\n\n    DEFPRINT(AST_Toplevel, function(output) {\n        display_body(this.body, true, output, true);\n        output.print(\"\");\n    });\n    DEFPRINT(AST_LabeledStatement, function(output) {\n        this.label.print(output);\n        output.colon();\n        this.body.print(output);\n    });\n    DEFPRINT(AST_SimpleStatement, function(output) {\n        this.body.print(output);\n        output.semicolon();\n    });\n    function print_braced_empty(self, output) {\n        output.print(\"{\");\n        output.with_indent(function() {\n            output.append_comments(self, true);\n        });\n        output.print(\"}\");\n    }\n    function print_braced(self, output, allow_directives) {\n        if (self.body.length > 0) {\n            output.with_block(function() {\n                display_body(self.body, false, output, allow_directives);\n            });\n        } else print_braced_empty(self, output);\n    }\n    DEFPRINT(AST_BlockStatement, function(output) {\n        print_braced(this, output);\n    });\n    DEFPRINT(AST_EmptyStatement, function(output) {\n        output.semicolon();\n    });\n    DEFPRINT(AST_Do, function(output) {\n        var self = this;\n        output.print(\"do\");\n        make_block(self.body, output);\n        output.space();\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        output.semicolon();\n    });\n    DEFPRINT(AST_While, function(output) {\n        var self = this;\n        output.print(\"while\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        force_statement(self.body, output);\n    });\n    DEFPRINT(AST_For, function(output) {\n        var self = this;\n        output.print(\"for\");\n        output.space();\n        output.with_parens(function() {\n            if (self.init) {\n                if (self.init instanceof AST_Definitions) {\n                    self.init.print(output);\n                } else {\n                    parenthesize_for_noin(self.init, output, true);\n                }\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.condition) {\n                self.condition.print(output);\n                output.print(\";\");\n                output.space();\n            } else {\n                output.print(\";\");\n            }\n            if (self.step) {\n                self.step.print(output);\n            }\n        });\n        force_statement(self.body, output);\n    });\n    function print_for_enum(prefix, infix) {\n        return function(output) {\n            var self = this;\n            output.print(prefix);\n            output.space();\n            output.with_parens(function() {\n                self.init.print(output);\n                output.space();\n                output.print(infix);\n                output.space();\n                self.object.print(output);\n            });\n            force_statement(self.body, output);\n        };\n    }\n    DEFPRINT(AST_ForAwaitOf, print_for_enum(\"for await\", \"of\"));\n    DEFPRINT(AST_ForIn, print_for_enum(\"for\", \"in\"));\n    DEFPRINT(AST_ForOf, print_for_enum(\"for\", \"of\"));\n    DEFPRINT(AST_With, function(output) {\n        var self = this;\n        output.print(\"with\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        force_statement(self.body, output);\n    });\n    DEFPRINT(AST_ExportDeclaration, function(output) {\n        output.print(\"export\");\n        output.space();\n        this.body.print(output);\n    });\n    DEFPRINT(AST_ExportDefault, function(output) {\n        output.print(\"export\");\n        output.space();\n        output.print(\"default\");\n        output.space();\n        var body = this.body;\n        body.print(output);\n        if (body instanceof AST_ClassExpression) {\n            if (!body.name) return;\n        }\n        if (body instanceof AST_DefClass) return;\n        if (body instanceof AST_LambdaDefinition) return;\n        if (body instanceof AST_LambdaExpression) {\n            if (!body.name && !is_arrow(body)) return;\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_ExportForeign, function(output) {\n        var self = this;\n        output.print(\"export\");\n        output.space();\n        var len = self.keys.length;\n        if (len == 0) {\n            print_braced_empty(self, output);\n        } else if (self.keys[0] == \"*\") {\n            print_entry(0);\n        } else output.with_block(function() {\n            output.indent();\n            print_entry(0);\n            for (var i = 1; i < len; i++) {\n                output.print(\",\");\n                output.newline();\n                output.indent();\n                print_entry(i);\n            }\n            output.newline();\n        });\n        output.space();\n        output.print(\"from\");\n        output.space();\n        output.print_string(self.path, self.quote);\n        output.semicolon();\n\n        function print_entry(index) {\n            var alias = self.aliases[index];\n            var key = self.keys[index];\n            output.print_name(key);\n            if (alias != key) {\n                output.space();\n                output.print(\"as\");\n                output.space();\n                output.print_name(alias);\n            }\n        }\n    });\n    DEFPRINT(AST_ExportReferences, function(output) {\n        var self = this;\n        output.print(\"export\");\n        output.space();\n        print_properties(self, output);\n        output.semicolon();\n    });\n    DEFPRINT(AST_Import, function(output) {\n        var self = this;\n        output.print(\"import\");\n        output.space();\n        if (self.default) self.default.print(output);\n        if (self.all) {\n            if (self.default) output.comma();\n            self.all.print(output);\n        }\n        if (self.properties) {\n            if (self.default) output.comma();\n            print_properties(self, output);\n        }\n        if (self.all || self.default || self.properties) {\n            output.space();\n            output.print(\"from\");\n            output.space();\n        }\n        output.print_string(self.path, self.quote);\n        output.semicolon();\n    });\n\n    /* -----[ functions ]----- */\n    function print_funargs(self, output) {\n        output.with_parens(function() {\n            self.argnames.forEach(function(arg, i) {\n                if (i) output.comma();\n                arg.print(output);\n            });\n            if (self.rest) {\n                if (self.argnames.length) output.comma();\n                output.print(\"...\");\n                self.rest.print(output);\n            }\n        });\n    }\n    function print_arrow(self, output) {\n        var argname = self.argnames.length == 1 && !self.rest && self.argnames[0];\n        if (argname instanceof AST_SymbolFunarg && argname.name != \"yield\") {\n            argname.print(output);\n        } else {\n            print_funargs(self, output);\n        }\n        output.space();\n        output.print(\"=>\");\n        output.space();\n        if (self.value) {\n            self.value.print(output);\n        } else {\n            print_braced(self, output, true);\n        }\n    }\n    DEFPRINT(AST_Arrow, function(output) {\n        print_arrow(this, output);\n    });\n    DEFPRINT(AST_AsyncArrow, function(output) {\n        output.print(\"async\");\n        output.space();\n        print_arrow(this, output);\n    });\n    function print_lambda(self, output) {\n        if (self.name) {\n            output.space();\n            self.name.print(output);\n        }\n        print_funargs(self, output);\n        output.space();\n        print_braced(self, output, true);\n    }\n    DEFPRINT(AST_Lambda, function(output) {\n        output.print(\"function\");\n        print_lambda(this, output);\n    });\n    function print_async(output) {\n        output.print(\"async\");\n        output.space();\n        output.print(\"function\");\n        print_lambda(this, output);\n    }\n    DEFPRINT(AST_AsyncDefun, print_async);\n    DEFPRINT(AST_AsyncFunction, print_async);\n    function print_async_generator(output) {\n        output.print(\"async\");\n        output.space();\n        output.print(\"function*\");\n        print_lambda(this, output);\n    }\n    DEFPRINT(AST_AsyncGeneratorDefun, print_async_generator);\n    DEFPRINT(AST_AsyncGeneratorFunction, print_async_generator);\n    function print_generator(output) {\n        output.print(\"function*\");\n        print_lambda(this, output);\n    }\n    DEFPRINT(AST_GeneratorDefun, print_generator);\n    DEFPRINT(AST_GeneratorFunction, print_generator);\n\n    /* -----[ classes ]----- */\n    DEFPRINT(AST_Class, function(output) {\n        var self = this;\n        output.print(\"class\");\n        if (self.name) {\n            output.space();\n            self.name.print(output);\n        }\n        if (self.extends) {\n            output.space();\n            output.print(\"extends\");\n            output.space();\n            self.extends.print(output);\n        }\n        output.space();\n        print_properties(self, output, true);\n    });\n    DEFPRINT(AST_ClassField, function(output) {\n        var self = this;\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n        print_property_key(self, output);\n        if (self.value) {\n            output.space();\n            output.print(\"=\");\n            output.space();\n            self.value.print(output);\n        }\n        output.semicolon();\n    });\n    DEFPRINT(AST_ClassGetter, print_accessor(\"get\"));\n    DEFPRINT(AST_ClassSetter, print_accessor(\"set\"));\n    function print_method(self, output) {\n        var fn = self.value;\n        if (is_async(fn)) {\n            output.print(\"async\");\n            output.space();\n        }\n        if (is_generator(fn)) output.print(\"*\");\n        print_property_key(self, output);\n        print_lambda(self.value, output);\n    }\n    DEFPRINT(AST_ClassMethod, function(output) {\n        var self = this;\n        if (self.static) {\n            output.print(\"static\");\n            output.space();\n        }\n        print_method(self, output);\n    });\n\n    /* -----[ jumps ]----- */\n    function print_jump(kind, prop) {\n        return function(output) {\n            output.print(kind);\n            var target = this[prop];\n            if (target) {\n                output.space();\n                target.print(output);\n            }\n            output.semicolon();\n        };\n    }\n    DEFPRINT(AST_Return, print_jump(\"return\", \"value\"));\n    DEFPRINT(AST_Throw, print_jump(\"throw\", \"value\"));\n    DEFPRINT(AST_Break, print_jump(\"break\", \"label\"));\n    DEFPRINT(AST_Continue, print_jump(\"continue\", \"label\"));\n\n    /* -----[ if ]----- */\n    function make_then(self, output) {\n        var b = self.body;\n        if (output.option(\"braces\") && !(b instanceof AST_Const || b instanceof AST_Let)\n            || output.option(\"ie\") && b instanceof AST_Do)\n            return make_block(b, output);\n        // The squeezer replaces \"block\"-s that contain only a single\n        // statement with the statement itself; technically, the AST\n        // is correct, but this can create problems when we output an\n        // IF having an ELSE clause where the THEN clause ends in an\n        // IF *without* an ELSE block (then the outer ELSE would refer\n        // to the inner IF).  This function checks for this case and\n        // adds the block braces if needed.\n        if (!b) return output.force_semicolon();\n        while (true) {\n            if (b instanceof AST_If) {\n                if (!b.alternative) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = b.alternative;\n            } else if (b instanceof AST_StatementWithBody) {\n                b = b.body;\n            } else break;\n        }\n        force_statement(self.body, output);\n    }\n    DEFPRINT(AST_If, function(output) {\n        var self = this;\n        output.print(\"if\");\n        output.space();\n        output.with_parens(function() {\n            self.condition.print(output);\n        });\n        if (self.alternative) {\n            make_then(self, output);\n            output.space();\n            output.print(\"else\");\n            if (self.alternative instanceof AST_If) {\n                output.space();\n                self.alternative.print(output);\n            } else {\n                force_statement(self.alternative, output);\n            }\n        } else {\n            force_statement(self.body, output);\n        }\n    });\n\n    /* -----[ switch ]----- */\n    DEFPRINT(AST_Switch, function(output) {\n        var self = this;\n        output.print(\"switch\");\n        output.space();\n        output.with_parens(function() {\n            self.expression.print(output);\n        });\n        output.space();\n        var last = self.body.length - 1;\n        if (last < 0) print_braced_empty(self, output);\n        else output.with_block(function() {\n            self.body.forEach(function(branch, i) {\n                output.indent(true);\n                branch.print(output);\n                if (i < last && branch.body.length > 0)\n                    output.newline();\n            });\n        });\n    });\n    function print_branch_body(self, output) {\n        output.newline();\n        self.body.forEach(function(stmt) {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n    DEFPRINT(AST_Default, function(output) {\n        output.print(\"default:\");\n        print_branch_body(this, output);\n    });\n    DEFPRINT(AST_Case, function(output) {\n        var self = this;\n        output.print(\"case\");\n        output.space();\n        self.expression.print(output);\n        output.print(\":\");\n        print_branch_body(self, output);\n    });\n\n    /* -----[ exceptions ]----- */\n    DEFPRINT(AST_Try, function(output) {\n        var self = this;\n        output.print(\"try\");\n        output.space();\n        print_braced(self, output);\n        if (self.bcatch) {\n            output.space();\n            self.bcatch.print(output);\n        }\n        if (self.bfinally) {\n            output.space();\n            self.bfinally.print(output);\n        }\n    });\n    DEFPRINT(AST_Catch, function(output) {\n        var self = this;\n        output.print(\"catch\");\n        if (self.argname) {\n            output.space();\n            output.with_parens(function() {\n                self.argname.print(output);\n            });\n        }\n        output.space();\n        print_braced(self, output);\n    });\n    DEFPRINT(AST_Finally, function(output) {\n        output.print(\"finally\");\n        output.space();\n        print_braced(this, output);\n    });\n\n    function print_definitinos(type) {\n        return function(output) {\n            var self = this;\n            output.print(type);\n            output.space();\n            self.definitions.forEach(function(def, i) {\n                if (i) output.comma();\n                def.print(output);\n            });\n            var p = output.parent();\n            if (!(p instanceof AST_IterationStatement && p.init === self)) output.semicolon();\n        };\n    }\n    DEFPRINT(AST_Const, print_definitinos(\"const\"));\n    DEFPRINT(AST_Let, print_definitinos(\"let\"));\n    DEFPRINT(AST_Var, print_definitinos(\"var\"));\n\n    function parenthesize_for_noin(node, output, noin) {\n        var parens = false;\n        // need to take some precautions here:\n        //    https://github.com/mishoo/UglifyJS/issues/60\n        if (noin) node.walk(new TreeWalker(function(node) {\n            if (parens) return true;\n            if (node instanceof AST_Binary && node.operator == \"in\") return parens = true;\n            if (node instanceof AST_Scope && !(is_arrow(node) && node.value)) return true;\n        }));\n        node.print(output, parens);\n    }\n\n    DEFPRINT(AST_VarDef, function(output) {\n        var self = this;\n        self.name.print(output);\n        if (self.value) {\n            output.space();\n            output.print(\"=\");\n            output.space();\n            var p = output.parent(1);\n            var noin = p instanceof AST_For || p instanceof AST_ForEnumeration;\n            parenthesize_for_noin(self.value, output, noin);\n        }\n    });\n\n    DEFPRINT(AST_DefaultValue, function(output) {\n        var self = this;\n        self.name.print(output);\n        output.space();\n        output.print(\"=\");\n        output.space();\n        self.value.print(output);\n    });\n\n    /* -----[ other expressions ]----- */\n    function print_annotation(self, output) {\n        if (!output.option(\"annotations\")) return;\n        if (!self.pure) return;\n        var level = 0, parent = self, node;\n        do {\n            node = parent;\n            parent = output.parent(level++);\n            if (parent instanceof AST_Call && parent.expression === node) return;\n        } while (parent instanceof AST_PropAccess && parent.expression === node);\n        output.print(\"/*@__PURE__*/\");\n    }\n    function print_call_args(self, output) {\n        if (self.expression instanceof AST_Call || self.expression instanceof AST_Lambda) {\n            output.add_mapping(self.start);\n        }\n        output.with_parens(function() {\n            self.args.forEach(function(expr, i) {\n                if (i) output.comma();\n                expr.print(output);\n            });\n        });\n    }\n    DEFPRINT(AST_Call, function(output) {\n        var self = this;\n        print_annotation(self, output);\n        self.expression.print(output);\n        if (self.optional) output.print(\"?.\");\n        print_call_args(self, output);\n    });\n    DEFPRINT(AST_New, function(output) {\n        var self = this;\n        print_annotation(self, output);\n        output.print(\"new\");\n        output.space();\n        self.expression.print(output);\n        if (need_constructor_parens(self, output)) print_call_args(self, output);\n    });\n    DEFPRINT(AST_Sequence, function(output) {\n        this.expressions.forEach(function(node, index) {\n            if (index > 0) {\n                output.comma();\n                if (output.should_break()) {\n                    output.newline();\n                    output.indent();\n                }\n            }\n            node.print(output);\n        });\n    });\n    DEFPRINT(AST_Dot, function(output) {\n        var self = this;\n        var expr = self.expression;\n        expr.print(output);\n        var prop = self.property;\n        if (output.option(\"ie\") && RESERVED_WORDS[prop]) {\n            output.print(self.optional ? \"?.[\" : \"[\");\n            output.add_mapping(self.end);\n            output.print_string(prop);\n            output.print(\"]\");\n        } else {\n            if (expr instanceof AST_Number && !/[ex.)]/i.test(output.last())) output.print(\".\");\n            output.print(self.optional ? \"?.\" : \".\");\n            // the name after dot would be mapped about here.\n            output.add_mapping(self.end);\n            output.print_name(prop);\n        }\n    });\n    DEFPRINT(AST_Sub, function(output) {\n        var self = this;\n        self.expression.print(output);\n        output.print(self.optional ? \"?.[\" : \"[\");\n        self.property.print(output);\n        output.print(\"]\");\n    });\n    DEFPRINT(AST_Spread, function(output) {\n        output.print(\"...\");\n        this.expression.print(output);\n    });\n    DEFPRINT(AST_UnaryPrefix, function(output) {\n        var op = this.operator;\n        var exp = this.expression;\n        output.print(op);\n        if (/^[a-z]/i.test(op)\n            || (/[+-]$/.test(op)\n                && exp instanceof AST_UnaryPrefix\n                && /^[+-]/.test(exp.operator))) {\n            output.space();\n        }\n        exp.print(output);\n    });\n    DEFPRINT(AST_UnaryPostfix, function(output) {\n        this.expression.print(output);\n        output.print(this.operator);\n    });\n    DEFPRINT(AST_Binary, function(output) {\n        var self = this;\n        self.left.print(output);\n        output.space();\n        output.print(self.operator);\n        output.space();\n        self.right.print(output);\n    });\n    DEFPRINT(AST_Conditional, function(output) {\n        var self = this;\n        self.condition.print(output);\n        output.space();\n        output.print(\"?\");\n        output.space();\n        self.consequent.print(output);\n        output.space();\n        output.colon();\n        self.alternative.print(output);\n    });\n    DEFPRINT(AST_Await, function(output) {\n        output.print(\"await\");\n        output.space();\n        this.expression.print(output);\n    });\n    DEFPRINT(AST_Yield, function(output) {\n        output.print(this.nested ? \"yield*\" : \"yield\");\n        if (this.expression) {\n            output.space();\n            this.expression.print(output);\n        }\n    });\n\n    /* -----[ literals ]----- */\n    DEFPRINT(AST_Array, function(output) {\n        var a = this.elements, len = a.length;\n        output.with_square(len > 0 ? function() {\n            output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                if (i === len - 1 && exp instanceof AST_Hole)\n                  output.comma();\n            });\n            output.space();\n        } : noop);\n    });\n    DEFPRINT(AST_DestructuredArray, function(output) {\n        var a = this.elements, len = a.length, rest = this.rest;\n        output.with_square(len || rest ? function() {\n            output.space();\n            a.forEach(function(exp, i) {\n                if (i) output.comma();\n                exp.print(output);\n            });\n            if (rest) {\n                if (len) output.comma();\n                output.print(\"...\");\n                rest.print(output);\n            } else if (a[len - 1] instanceof AST_Hole) {\n                // If the final element is a hole, we need to make sure it\n                // doesn't look like a trailing comma, by inserting an actual\n                // trailing comma.\n                output.comma();\n            }\n            output.space();\n        } : noop);\n    });\n    DEFPRINT(AST_DestructuredKeyVal, function(output) {\n        var self = this;\n        var key = print_property_key(self, output);\n        var value = self.value;\n        if (key) {\n            if (value instanceof AST_DefaultValue) {\n                if (value.name instanceof AST_Symbol && key == get_symbol_name(value.name)) {\n                    output.space();\n                    output.print(\"=\");\n                    output.space();\n                    value.value.print(output);\n                    return;\n                }\n            } else if (value instanceof AST_Symbol) {\n                if (key == get_symbol_name(value)) return;\n            }\n        }\n        output.colon();\n        value.print(output);\n    });\n    DEFPRINT(AST_DestructuredObject, function(output) {\n        var props = this.properties, len = props.length, rest = this.rest;\n        if (len || rest) output.with_block(function() {\n            props.forEach(function(prop, i) {\n                if (i) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            if (rest) {\n                if (len) {\n                    output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                output.print(\"...\");\n                rest.print(output);\n            }\n            output.newline();\n        });\n        else print_braced_empty(this, output);\n    });\n    function print_properties(self, output, no_comma) {\n        var props = self.properties;\n        if (props.length > 0) output.with_block(function() {\n            props.forEach(function(prop, i) {\n                if (i) {\n                    if (!no_comma) output.print(\",\");\n                    output.newline();\n                }\n                output.indent();\n                prop.print(output);\n            });\n            output.newline();\n        });\n        else print_braced_empty(self, output);\n    }\n    DEFPRINT(AST_Object, function(output) {\n        print_properties(this, output);\n    });\n\n    function print_property_key(self, output) {\n        var key = self.key;\n        if (key instanceof AST_Node) return output.with_square(function() {\n            key.print(output);\n        });\n        var quote = self.start && self.start.quote;\n        if (output.option(\"quote_keys\") || quote && output.option(\"keep_quoted_props\")) {\n            output.print_string(key, quote);\n        } else if (\"\" + +key == key && key >= 0) {\n            output.print(make_num(key));\n        } else if (self.private) {\n            output.print_name(key);\n        } else if (RESERVED_WORDS[key] ? !output.option(\"ie\") : is_identifier_string(key)) {\n            output.print_name(key);\n            return key;\n        } else {\n            output.print_string(key, quote);\n        }\n    }\n    DEFPRINT(AST_ObjectKeyVal, function(output) {\n        var self = this;\n        print_property_key(self, output);\n        output.colon();\n        self.value.print(output);\n    });\n    DEFPRINT(AST_ObjectMethod, function(output) {\n        print_method(this, output);\n    });\n    function print_accessor(type) {\n        return function(output) {\n            var self = this;\n            if (self.static) {\n                output.print(\"static\");\n                output.space();\n            }\n            output.print(type);\n            output.space();\n            print_property_key(self, output);\n            print_lambda(self.value, output);\n        };\n    }\n    DEFPRINT(AST_ObjectGetter, print_accessor(\"get\"));\n    DEFPRINT(AST_ObjectSetter, print_accessor(\"set\"));\n    function get_symbol_name(sym) {\n        var def = sym.definition();\n        return def && def.mangled_name || sym.name;\n    }\n    DEFPRINT(AST_Symbol, function(output) {\n        output.print_name(get_symbol_name(this));\n    });\n    DEFPRINT(AST_SymbolExport, function(output) {\n        var self = this;\n        var name = get_symbol_name(self);\n        output.print_name(name);\n        var alias = self.alias;\n        if (alias != name) {\n            output.space();\n            output.print(\"as\");\n            output.space();\n            output.print_name(alias);\n        }\n    });\n    DEFPRINT(AST_SymbolImport, function(output) {\n        var self = this;\n        var name = get_symbol_name(self);\n        var key = self.key;\n        if (key && key != name) {\n            output.print_name(key);\n            output.space();\n            output.print(\"as\");\n            output.space();\n        }\n        output.print_name(name);\n    });\n    DEFPRINT(AST_Hole, noop);\n    DEFPRINT(AST_Template, function(output) {\n        var self = this;\n        if (self.tag) self.tag.print(output);\n        output.print(\"`\");\n        for (var i = 0; i < self.expressions.length; i++) {\n            output.print(self.strings[i]);\n            output.print(\"${\");\n            self.expressions[i].print(output);\n            output.print(\"}\");\n        }\n        output.print(self.strings[i]);\n        output.print(\"`\");\n    });\n    DEFPRINT(AST_Constant, function(output) {\n        output.print(\"\" + this.value);\n    });\n    DEFPRINT(AST_String, function(output) {\n        output.print_string(this.value, this.quote);\n    });\n    DEFPRINT(AST_Number, function(output) {\n        var start = this.start;\n        if (use_asm && start && start.raw != null) {\n            output.print(start.raw);\n        } else {\n            output.print(make_num(this.value));\n        }\n    });\n\n    DEFPRINT(AST_RegExp, function(output) {\n        var regexp = this.value;\n        var str = regexp.toString();\n        var end = str.lastIndexOf(\"/\");\n        if (regexp.raw_source) {\n            str = \"/\" + regexp.raw_source + str.slice(end);\n        } else if (end == 1) {\n            str = \"/(?:)\" + str.slice(end);\n        } else if (str.indexOf(\"/\", 1) < end) {\n            str = \"/\" + str.slice(1, end).replace(/\\\\\\\\|[^/]?\\//g, function(match) {\n                return match[0] == \"\\\\\" ? match : match.slice(0, -1) + \"\\\\/\";\n            }) + str.slice(end);\n        }\n        output.print(output.to_utf8(str).replace(/\\\\(?:\\0(?![0-9])|[^\\0])/g, function(match) {\n            switch (match[1]) {\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\t\": return \"\\t\";\n              case \"\\b\": return \"\\b\";\n              case \"\\f\": return \"\\f\";\n              case \"\\0\": return \"\\0\";\n              case \"\\x0B\": return \"\\v\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n              default: return match;\n            }\n        }).replace(/[\\n\\r\\u2028\\u2029]/g, function(c) {\n            switch (c) {\n              case \"\\n\": return \"\\\\n\";\n              case \"\\r\": return \"\\\\r\";\n              case \"\\u2028\": return \"\\\\u2028\";\n              case \"\\u2029\": return \"\\\\u2029\";\n            }\n        }));\n        var p = output.parent();\n        if (p instanceof AST_Binary && /^in/.test(p.operator) && p.left === this)\n            output.print(\" \");\n    });\n\n    function force_statement(stat, output) {\n        if (output.option(\"braces\") && !(stat instanceof AST_Const || stat instanceof AST_Let)) {\n            make_block(stat, output);\n        } else if (stat instanceof AST_EmptyStatement) {\n            output.force_semicolon();\n        } else {\n            output.space();\n            stat.print(output);\n        }\n    }\n\n    // self should be AST_New.  decide if we want to show parens or not.\n    function need_constructor_parens(self, output) {\n        // Always print parentheses with arguments\n        if (self.args.length > 0) return true;\n\n        return output.option(\"beautify\");\n    }\n\n    function best_of(a) {\n        var best = a[0], len = best.length;\n        for (var i = 1; i < a.length; ++i) {\n            if (a[i].length < len) {\n                best = a[i];\n                len = best.length;\n            }\n        }\n        return best;\n    }\n\n    function make_num(num) {\n        var str = num.toString(10).replace(/^0\\./, \".\").replace(\"e+\", \"e\");\n        var candidates = [ str ];\n        if (Math.floor(num) === num) {\n            if (num < 0) {\n                candidates.push(\"-0x\" + (-num).toString(16).toLowerCase());\n            } else {\n                candidates.push(\"0x\" + num.toString(16).toLowerCase());\n            }\n        }\n        var match, len, digits;\n        if (match = /^\\.0+/.exec(str)) {\n            len = match[0].length;\n            digits = str.slice(len);\n            candidates.push(digits + \"e-\" + (digits.length + len - 1));\n        } else if (match = /0+$/.exec(str)) {\n            len = match[0].length;\n            candidates.push(str.slice(0, -len) + \"e\" + len);\n        } else if (match = /^(\\d)\\.(\\d+)e(-?\\d+)$/.exec(str)) {\n            candidates.push(match[1] + match[2] + \"e\" + (match[3] - match[2].length));\n        }\n        return best_of(candidates);\n    }\n\n    function make_block(stmt, output) {\n        output.space();\n        if (stmt instanceof AST_EmptyStatement) {\n            print_braced_empty(stmt, output);\n        } else if (stmt instanceof AST_BlockStatement) {\n            stmt.print(output);\n        } else output.with_block(function() {\n            output.indent();\n            stmt.print(output);\n            output.newline();\n        });\n    }\n\n    /* -----[ source map generators ]----- */\n\n    function DEFMAP(nodetype, generator) {\n        nodetype.forEach(function(nodetype) {\n            nodetype.DEFMETHOD(\"add_source_map\", generator);\n        });\n    }\n\n    DEFMAP([\n        // We could easily add info for ALL nodes, but it seems to me that\n        // would be quite wasteful, hence this noop in the base class.\n        AST_Node,\n        // since the label symbol will mark it\n        AST_LabeledStatement,\n    ], noop);\n\n    // XXX: I'm not exactly sure if we need it for all of these nodes,\n    // or if we should add even more.\n    DEFMAP([\n        AST_Array,\n        AST_BlockStatement,\n        AST_Catch,\n        AST_Constant,\n        AST_Debugger,\n        AST_Definitions,\n        AST_Destructured,\n        AST_Finally,\n        AST_Jump,\n        AST_Lambda,\n        AST_New,\n        AST_Object,\n        AST_StatementWithBody,\n        AST_Symbol,\n        AST_Switch,\n        AST_SwitchBranch,\n        AST_Try,\n    ], function(output) {\n        output.add_mapping(this.start);\n    });\n\n    DEFMAP([\n        AST_ClassProperty,\n        AST_DestructuredKeyVal,\n        AST_ObjectProperty,\n    ], function(output) {\n        if (typeof this.key == \"string\") output.add_mapping(this.start, this.key);\n    });\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n    Parser based on parse-js (http://marijn.haverbeke.nl/parse-js/).\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar KEYWORDS = \"break case catch class const continue debugger default delete do else extends finally for function if in instanceof new return switch throw try typeof var void while with\";\nvar KEYWORDS_ATOM = \"false null true\";\nvar RESERVED_WORDS = [\n    \"abstract async await boolean byte char double enum export final float goto implements import int interface let long native package private protected public short static super synchronized this throws transient volatile yield\",\n    KEYWORDS_ATOM,\n    KEYWORDS,\n].join(\" \");\nvar KEYWORDS_BEFORE_EXPRESSION = \"return new delete throw else case\";\n\nKEYWORDS = makePredicate(KEYWORDS);\nRESERVED_WORDS = makePredicate(RESERVED_WORDS);\nKEYWORDS_BEFORE_EXPRESSION = makePredicate(KEYWORDS_BEFORE_EXPRESSION);\nKEYWORDS_ATOM = makePredicate(KEYWORDS_ATOM);\n\nvar RE_BIN_NUMBER = /^0b([01]+)$/i;\nvar RE_HEX_NUMBER = /^0x([0-9a-f]+)$/i;\nvar RE_OCT_NUMBER = /^0o?([0-7]+)$/i;\n\nvar OPERATORS = makePredicate([\n    \"in\",\n    \"instanceof\",\n    \"typeof\",\n    \"new\",\n    \"void\",\n    \"delete\",\n    \"++\",\n    \"--\",\n    \"+\",\n    \"-\",\n    \"!\",\n    \"~\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"**\",\n    \">>\",\n    \"<<\",\n    \">>>\",\n    \"<\",\n    \">\",\n    \"<=\",\n    \">=\",\n    \"==\",\n    \"===\",\n    \"!=\",\n    \"!==\",\n    \"?\",\n    \"=\",\n    \"+=\",\n    \"-=\",\n    \"/=\",\n    \"*=\",\n    \"%=\",\n    \"**=\",\n    \">>=\",\n    \"<<=\",\n    \">>>=\",\n    \"&=\",\n    \"|=\",\n    \"^=\",\n    \"&&\",\n    \"||\",\n    \"??\",\n    \"&&=\",\n    \"||=\",\n    \"??=\",\n]);\n\nvar NEWLINE_CHARS = \"\\n\\r\\u2028\\u2029\";\nvar OPERATOR_CHARS = \"+-*&%=<>!?|~^\";\nvar PUNC_OPENERS = \"[{(\";\nvar PUNC_SEPARATORS = \",;:\";\nvar PUNC_CLOSERS = \")}]\";\nvar PUNC_AFTER_EXPRESSION = PUNC_SEPARATORS + PUNC_CLOSERS;\nvar PUNC_BEFORE_EXPRESSION = PUNC_OPENERS + PUNC_SEPARATORS;\nvar PUNC_CHARS = PUNC_BEFORE_EXPRESSION + \"`\" + PUNC_CLOSERS;\nvar WHITESPACE_CHARS = NEWLINE_CHARS + \" \\u00a0\\t\\f\\u000b\\u200b\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\uFEFF\";\nvar NON_IDENTIFIER_CHARS = makePredicate(characters(\"./'\\\"#\" + OPERATOR_CHARS + PUNC_CHARS + WHITESPACE_CHARS));\n\nNEWLINE_CHARS = makePredicate(characters(NEWLINE_CHARS));\nOPERATOR_CHARS = makePredicate(characters(OPERATOR_CHARS));\nPUNC_AFTER_EXPRESSION = makePredicate(characters(PUNC_AFTER_EXPRESSION));\nPUNC_BEFORE_EXPRESSION = makePredicate(characters(PUNC_BEFORE_EXPRESSION));\nPUNC_CHARS = makePredicate(characters(PUNC_CHARS));\nWHITESPACE_CHARS = makePredicate(characters(WHITESPACE_CHARS));\n\n/* -----[ Tokenizer ]----- */\n\nfunction is_surrogate_pair_head(code) {\n    return code >= 0xd800 && code <= 0xdbff;\n}\n\nfunction is_surrogate_pair_tail(code) {\n    return code >= 0xdc00 && code <= 0xdfff;\n}\n\nfunction is_digit(code) {\n    return code >= 48 && code <= 57;\n}\n\nfunction is_identifier_char(ch) {\n    return !NON_IDENTIFIER_CHARS[ch];\n}\n\nfunction is_identifier_string(str) {\n    return /^[a-z_$][a-z0-9_$]*$/i.test(str);\n}\n\nfunction decode_escape_sequence(seq) {\n    switch (seq[0]) {\n      case \"b\": return \"\\b\";\n      case \"f\": return \"\\f\";\n      case \"n\": return \"\\n\";\n      case \"r\": return \"\\r\";\n      case \"t\": return \"\\t\";\n      case \"u\":\n        var code;\n        if (seq[1] == \"{\" && seq.slice(-1) == \"}\") {\n            code = seq.slice(2, -1);\n        } else if (seq.length == 5) {\n            code = seq.slice(1);\n        } else {\n            return;\n        }\n        var num = parseInt(code, 16);\n        if (num < 0 || isNaN(num)) return;\n        if (num < 0x10000) return String.fromCharCode(num);\n        if (num > 0x10ffff) return;\n        return String.fromCharCode((num >> 10) + 0xd7c0) + String.fromCharCode((num & 0x03ff) + 0xdc00);\n      case \"v\": return \"\\u000b\";\n      case \"x\":\n        if (seq.length != 3) return;\n        var num = parseInt(seq.slice(1), 16);\n        if (num < 0 || isNaN(num)) return;\n        return String.fromCharCode(num);\n      case \"\\r\":\n      case \"\\n\":\n        return \"\";\n      default:\n        if (seq == \"0\") return \"\\0\";\n        if (seq[0] >= \"0\" && seq[0] <= \"9\") return;\n        return seq;\n    }\n}\n\nfunction parse_js_number(num) {\n    var match;\n    if (match = RE_BIN_NUMBER.exec(num)) return parseInt(match[1], 2);\n    if (match = RE_HEX_NUMBER.exec(num)) return parseInt(match[1], 16);\n    if (match = RE_OCT_NUMBER.exec(num)) return parseInt(match[1], 8);\n    var val = parseFloat(num);\n    if (val == num) return val;\n}\n\nfunction JS_Parse_Error(message, filename, line, col, pos) {\n    this.message = message;\n    this.filename = filename;\n    this.line = line;\n    this.col = col;\n    this.pos = pos;\n}\nJS_Parse_Error.prototype = Object.create(Error.prototype);\nJS_Parse_Error.prototype.constructor = JS_Parse_Error;\nJS_Parse_Error.prototype.name = \"SyntaxError\";\nconfigure_error_stack(JS_Parse_Error);\n\nfunction js_error(message, filename, line, col, pos) {\n    throw new JS_Parse_Error(message, filename, line, col, pos);\n}\n\nfunction is_token(token, type, val) {\n    return token.type == type && (val == null || token.value == val);\n}\n\nvar EX_EOF = {};\n\nfunction tokenizer($TEXT, filename, html5_comments, shebang) {\n\n    var S = {\n        text            : $TEXT,\n        filename        : filename,\n        pos             : 0,\n        tokpos          : 0,\n        line            : 1,\n        tokline         : 0,\n        col             : 0,\n        tokcol          : 0,\n        newline_before  : false,\n        regex_allowed   : false,\n        comments_before : [],\n        directives      : {},\n        directive_stack : [],\n        read_template   : with_eof_error(\"Unterminated template literal\", function(strings) {\n            var s = \"\";\n            for (;;) {\n                var ch = read();\n                switch (ch) {\n                  case \"\\\\\":\n                    ch += read();\n                    break;\n                  case \"`\":\n                    strings.push(s);\n                    return;\n                  case \"$\":\n                    if (peek() == \"{\") {\n                        next();\n                        strings.push(s);\n                        S.regex_allowed = true;\n                        return true;\n                    }\n                }\n                s += ch;\n            }\n\n            function read() {\n                var ch = next(true, true);\n                return ch == \"\\r\" ? \"\\n\" : ch;\n            }\n        }),\n    };\n    var prev_was_dot = false;\n\n    function peek() {\n        return S.text.charAt(S.pos);\n    }\n\n    function next(signal_eof, in_string) {\n        var ch = S.text.charAt(S.pos++);\n        if (signal_eof && !ch)\n            throw EX_EOF;\n        if (NEWLINE_CHARS[ch]) {\n            S.col = 0;\n            S.line++;\n            if (!in_string) S.newline_before = true;\n            if (ch == \"\\r\" && peek() == \"\\n\") {\n                // treat `\\r\\n` as `\\n`\n                S.pos++;\n                ch = \"\\n\";\n            }\n        } else {\n            S.col++;\n        }\n        return ch;\n    }\n\n    function forward(i) {\n        while (i-- > 0) next();\n    }\n\n    function looking_at(str) {\n        return S.text.substr(S.pos, str.length) == str;\n    }\n\n    function find_eol() {\n        var text = S.text;\n        for (var i = S.pos; i < S.text.length; ++i) {\n            if (NEWLINE_CHARS[text[i]]) return i;\n        }\n        return -1;\n    }\n\n    function find(what, signal_eof) {\n        var pos = S.text.indexOf(what, S.pos);\n        if (signal_eof && pos == -1) throw EX_EOF;\n        return pos;\n    }\n\n    function start_token() {\n        S.tokline = S.line;\n        S.tokcol = S.col;\n        S.tokpos = S.pos;\n    }\n\n    function token(type, value, is_comment) {\n        S.regex_allowed = type == \"operator\" && !UNARY_POSTFIX[value]\n            || type == \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[value]\n            || type == \"punc\" && PUNC_BEFORE_EXPRESSION[value];\n        if (type == \"punc\" && value == \".\") prev_was_dot = true;\n        else if (!is_comment) prev_was_dot = false;\n        var ret = {\n            type    : type,\n            value   : value,\n            line    : S.tokline,\n            col     : S.tokcol,\n            pos     : S.tokpos,\n            endline : S.line,\n            endcol  : S.col,\n            endpos  : S.pos,\n            nlb     : S.newline_before,\n            file    : filename\n        };\n        if (/^(?:num|string|regexp)$/i.test(type)) {\n            ret.raw = $TEXT.substring(ret.pos, ret.endpos);\n        }\n        if (!is_comment) {\n            ret.comments_before = S.comments_before;\n            ret.comments_after = S.comments_before = [];\n        }\n        S.newline_before = false;\n        return new AST_Token(ret);\n    }\n\n    function skip_whitespace() {\n        while (WHITESPACE_CHARS[peek()])\n            next();\n    }\n\n    function read_while(pred) {\n        var ret = \"\", ch;\n        while ((ch = peek()) && pred(ch, ret)) ret += next();\n        return ret;\n    }\n\n    function parse_error(err) {\n        js_error(err, filename, S.tokline, S.tokcol, S.tokpos);\n    }\n\n    function is_octal(num) {\n        return /^0[0-7_]+$/.test(num);\n    }\n\n    function read_num(prefix) {\n        var has_e = false, after_e = false, has_x = false, has_dot = prefix == \".\";\n        var num = read_while(function(ch, str) {\n            switch (ch) {\n              case \"x\": case \"X\":\n                return has_x ? false : (has_x = true);\n              case \"e\": case \"E\":\n                return has_x ? true : has_e ? false : (has_e = after_e = true);\n              case \"+\": case \"-\":\n                return after_e;\n              case (after_e = false, \".\"):\n                return has_dot || has_e || has_x || is_octal(str) ? false : (has_dot = true);\n            }\n            return /[_0-9a-dfo]/i.test(ch);\n        });\n        if (prefix) num = prefix + num;\n        if (is_octal(num)) {\n            if (next_token.has_directive(\"use strict\")) parse_error(\"Legacy octal literals are not allowed in strict mode\");\n        } else {\n            num = num.replace(has_x ? /([1-9a-f]|.0)_(?=[0-9a-f])/gi : /([1-9]|.0)_(?=[0-9])/gi, \"$1\");\n        }\n        var valid = parse_js_number(num);\n        if (isNaN(valid)) parse_error(\"Invalid syntax: \" + num);\n        if (has_dot || has_e || peek() != \"n\") return token(\"num\", valid);\n        return token(\"bigint\", num.toLowerCase() + next());\n    }\n\n    function read_escaped_char(in_string) {\n        var seq = next(true, in_string);\n        if (seq >= \"0\" && seq <= \"7\") return read_octal_escape_sequence(seq);\n        if (seq == \"u\") {\n            var ch = next(true, in_string);\n            seq += ch;\n            if (ch != \"{\") {\n                seq += next(true, in_string) + next(true, in_string) + next(true, in_string);\n            } else do {\n                ch = next(true, in_string);\n                seq += ch;\n            } while (ch != \"}\");\n        } else if (seq == \"x\") {\n            seq += next(true, in_string) + next(true, in_string);\n        }\n        var str = decode_escape_sequence(seq);\n        if (typeof str != \"string\") parse_error(\"Invalid escape sequence: \\\\\" + seq);\n        return str;\n    }\n\n    function read_octal_escape_sequence(ch) {\n        // Read\n        var p = peek();\n        if (p >= \"0\" && p <= \"7\") {\n            ch += next(true);\n            if (ch[0] <= \"3\" && (p = peek()) >= \"0\" && p <= \"7\")\n                ch += next(true);\n        }\n\n        // Parse\n        if (ch === \"0\") return \"\\0\";\n        if (ch.length > 0 && next_token.has_directive(\"use strict\"))\n            parse_error(\"Legacy octal escape sequences are not allowed in strict mode\");\n        return String.fromCharCode(parseInt(ch, 8));\n    }\n\n    var read_string = with_eof_error(\"Unterminated string constant\", function(quote_char) {\n        var quote = next(), ret = \"\";\n        for (;;) {\n            var ch = next(true, true);\n            if (ch == \"\\\\\") ch = read_escaped_char(true);\n            else if (NEWLINE_CHARS[ch]) parse_error(\"Unterminated string constant\");\n            else if (ch == quote) break;\n            ret += ch;\n        }\n        var tok = token(\"string\", ret);\n        tok.quote = quote_char;\n        return tok;\n    });\n\n    function skip_line_comment(type) {\n        var regex_allowed = S.regex_allowed;\n        var i = find_eol(), ret;\n        if (i == -1) {\n            ret = S.text.substr(S.pos);\n            S.pos = S.text.length;\n        } else {\n            ret = S.text.substring(S.pos, i);\n            S.pos = i;\n        }\n        S.col = S.tokcol + (S.pos - S.tokpos);\n        S.comments_before.push(token(type, ret, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    }\n\n    var skip_multiline_comment = with_eof_error(\"Unterminated multiline comment\", function() {\n        var regex_allowed = S.regex_allowed;\n        var i = find(\"*/\", true);\n        var text = S.text.substring(S.pos, i).replace(/\\r\\n|\\r|\\u2028|\\u2029/g, \"\\n\");\n        // update stream position\n        forward(text.length /* doesn't count \\r\\n as 2 char while S.pos - i does */ + 2);\n        S.comments_before.push(token(\"comment2\", text, true));\n        S.regex_allowed = regex_allowed;\n        return next_token;\n    });\n\n    function read_name() {\n        var backslash = false, ch, escaped = false, name = peek() == \"#\" ? next() : \"\";\n        while (ch = peek()) {\n            if (!backslash) {\n                if (ch == \"\\\\\") escaped = backslash = true, next();\n                else if (is_identifier_char(ch)) name += next();\n                else break;\n            } else {\n                if (ch != \"u\") parse_error(\"Expecting UnicodeEscapeSequence -- uXXXX\");\n                ch = read_escaped_char();\n                if (!is_identifier_char(ch)) parse_error(\"Unicode char: \" + ch.charCodeAt(0) + \" is not valid in identifier\");\n                name += ch;\n                backslash = false;\n            }\n        }\n        if (KEYWORDS[name] && escaped) {\n            var hex = name.charCodeAt(0).toString(16).toUpperCase();\n            name = \"\\\\u\" + \"0000\".substr(hex.length) + hex + name.slice(1);\n        }\n        return name;\n    }\n\n    var read_regexp = with_eof_error(\"Unterminated regular expression\", function(source) {\n        var prev_backslash = false, ch, in_class = false;\n        while ((ch = next(true))) if (NEWLINE_CHARS[ch]) {\n            parse_error(\"Unexpected line terminator\");\n        } else if (prev_backslash) {\n            source += \"\\\\\" + ch;\n            prev_backslash = false;\n        } else if (ch == \"[\") {\n            in_class = true;\n            source += ch;\n        } else if (ch == \"]\" && in_class) {\n            in_class = false;\n            source += ch;\n        } else if (ch == \"/\" && !in_class) {\n            break;\n        } else if (ch == \"\\\\\") {\n            prev_backslash = true;\n        } else {\n            source += ch;\n        }\n        var mods = read_name();\n        try {\n            var regexp = new RegExp(source, mods);\n            regexp.raw_source = source;\n            return token(\"regexp\", regexp);\n        } catch (e) {\n            parse_error(e.message);\n        }\n    });\n\n    function read_operator(prefix) {\n        function grow(op) {\n            if (!peek()) return op;\n            var bigger = op + peek();\n            if (OPERATORS[bigger]) {\n                next();\n                return grow(bigger);\n            } else {\n                return op;\n            }\n        }\n        return token(\"operator\", grow(prefix || next()));\n    }\n\n    function handle_slash() {\n        next();\n        switch (peek()) {\n          case \"/\":\n            next();\n            return skip_line_comment(\"comment1\");\n          case \"*\":\n            next();\n            return skip_multiline_comment();\n        }\n        return S.regex_allowed ? read_regexp(\"\") : read_operator(\"/\");\n    }\n\n    function handle_dot() {\n        next();\n        var ch = peek();\n        if (ch == \".\") {\n            var op = \".\";\n            do {\n                op += \".\";\n                next();\n            } while (peek() == \".\");\n            return token(\"operator\", op);\n        }\n        return is_digit(ch.charCodeAt(0)) ? read_num(\".\") : token(\"punc\", \".\");\n    }\n\n    function read_word() {\n        var word = read_name();\n        if (prev_was_dot) return token(\"name\", word);\n        return KEYWORDS_ATOM[word] ? token(\"atom\", word)\n            : !KEYWORDS[word] ? token(\"name\", word)\n            : OPERATORS[word] ? token(\"operator\", word)\n            : token(\"keyword\", word);\n    }\n\n    function with_eof_error(eof_error, cont) {\n        return function(x) {\n            try {\n                return cont(x);\n            } catch (ex) {\n                if (ex === EX_EOF) parse_error(eof_error);\n                else throw ex;\n            }\n        };\n    }\n\n    function next_token(force_regexp) {\n        if (force_regexp != null)\n            return read_regexp(force_regexp);\n        if (shebang && S.pos == 0 && looking_at(\"#!\")) {\n            start_token();\n            forward(2);\n            skip_line_comment(\"comment5\");\n        }\n        for (;;) {\n            skip_whitespace();\n            start_token();\n            if (html5_comments) {\n                if (looking_at(\"<!--\")) {\n                    forward(4);\n                    skip_line_comment(\"comment3\");\n                    continue;\n                }\n                if (looking_at(\"-->\") && S.newline_before) {\n                    forward(3);\n                    skip_line_comment(\"comment4\");\n                    continue;\n                }\n            }\n            var ch = peek();\n            if (!ch) return token(\"eof\");\n            var code = ch.charCodeAt(0);\n            switch (code) {\n              case 34: case 39: return read_string(ch);\n              case 46: return handle_dot();\n              case 47:\n                var tok = handle_slash();\n                if (tok === next_token) continue;\n                return tok;\n            }\n            if (is_digit(code)) return read_num();\n            if (PUNC_CHARS[ch]) return token(\"punc\", next());\n            if (looking_at(\"=>\")) return token(\"punc\", next() + next());\n            if (OPERATOR_CHARS[ch]) return read_operator();\n            if (code == 35 || code == 92 || !NON_IDENTIFIER_CHARS[ch]) return read_word();\n            break;\n        }\n        parse_error(\"Unexpected character '\" + ch + \"'\");\n    }\n\n    next_token.context = function(nc) {\n        if (nc) S = nc;\n        return S;\n    };\n\n    next_token.add_directive = function(directive) {\n        S.directive_stack[S.directive_stack.length - 1].push(directive);\n        if (S.directives[directive]) S.directives[directive]++;\n        else S.directives[directive] = 1;\n    }\n\n    next_token.push_directives_stack = function() {\n        S.directive_stack.push([]);\n    }\n\n    next_token.pop_directives_stack = function() {\n        var directives = S.directive_stack.pop();\n        for (var i = directives.length; --i >= 0;) {\n            S.directives[directives[i]]--;\n        }\n    }\n\n    next_token.has_directive = function(directive) {\n        return S.directives[directive] > 0;\n    }\n\n    return next_token;\n}\n\n/* -----[ Parser (constants) ]----- */\n\nvar UNARY_PREFIX = makePredicate(\"typeof void delete -- ++ ! ~ - +\");\n\nvar UNARY_POSTFIX = makePredicate(\"-- ++\");\n\nvar ASSIGNMENT = makePredicate(\"= += -= /= *= %= **= >>= <<= >>>= &= |= ^= &&= ||= ??=\");\n\nvar PRECEDENCE = function(a, ret) {\n    for (var i = 0; i < a.length;) {\n        var b = a[i++];\n        for (var j = 0; j < b.length; j++) {\n            ret[b[j]] = i;\n        }\n    }\n    return ret;\n}([\n    [\"??\"],\n    [\"||\"],\n    [\"&&\"],\n    [\"|\"],\n    [\"^\"],\n    [\"&\"],\n    [\"==\", \"===\", \"!=\", \"!==\"],\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n    [\">>\", \"<<\", \">>>\"],\n    [\"+\", \"-\"],\n    [\"*\", \"/\", \"%\"],\n    [\"**\"],\n], {});\n\nvar ATOMIC_START_TOKEN = makePredicate(\"atom bigint num regexp string\");\n\n/* -----[ Parser ]----- */\n\nfunction parse($TEXT, options) {\n    options = defaults(options, {\n        bare_returns   : false,\n        expression     : false,\n        filename       : null,\n        html5_comments : true,\n        shebang        : true,\n        strict         : false,\n        toplevel       : null,\n    }, true);\n\n    var S = {\n        input         : typeof $TEXT == \"string\"\n                        ? tokenizer($TEXT, options.filename, options.html5_comments, options.shebang)\n                        : $TEXT,\n        in_async      : false,\n        in_directives : true,\n        in_funarg     : -1,\n        in_function   : 0,\n        in_generator  : false,\n        in_loop       : 0,\n        labels        : [],\n        peeked        : null,\n        prev          : null,\n        token         : null,\n    };\n\n    S.token = next();\n\n    function is(type, value) {\n        return is_token(S.token, type, value);\n    }\n\n    function peek() {\n        return S.peeked || (S.peeked = S.input());\n    }\n\n    function next() {\n        S.prev = S.token;\n        if (S.peeked) {\n            S.token = S.peeked;\n            S.peeked = null;\n        } else {\n            S.token = S.input();\n        }\n        S.in_directives = S.in_directives && (\n            S.token.type == \"string\" || is(\"punc\", \";\")\n        );\n        return S.token;\n    }\n\n    function prev() {\n        return S.prev;\n    }\n\n    function croak(msg, line, col, pos) {\n        var ctx = S.input.context();\n        js_error(msg,\n                 ctx.filename,\n                 line != null ? line : ctx.tokline,\n                 col != null ? col : ctx.tokcol,\n                 pos != null ? pos : ctx.tokpos);\n    }\n\n    function token_error(token, msg) {\n        croak(msg, token.line, token.col);\n    }\n\n    function token_to_string(type, value) {\n        return type + (value === undefined ? \"\" : \" \" + value + \"\");\n    }\n\n    function unexpected(token) {\n        if (token == null) token = S.token;\n        token_error(token, \"Unexpected token: \" + token_to_string(token.type, token.value));\n    }\n\n    function expect_token(type, val) {\n        if (is(type, val)) return next();\n        token_error(S.token, \"Unexpected token: \" + token_to_string(S.token.type, S.token.value) + \", expected: \" + token_to_string(type, val));\n    }\n\n    function expect(punc) {\n        return expect_token(\"punc\", punc);\n    }\n\n    function has_newline_before(token) {\n        return token.nlb || !all(token.comments_before, function(comment) {\n            return !comment.nlb;\n        });\n    }\n\n    function can_insert_semicolon() {\n        return !options.strict\n            && (is(\"eof\") || is(\"punc\", \"}\") || has_newline_before(S.token));\n    }\n\n    function semicolon(optional) {\n        if (is(\"punc\", \";\")) next();\n        else if (!optional && !can_insert_semicolon()) expect(\";\");\n    }\n\n    function parenthesised() {\n        expect(\"(\");\n        var exp = expression();\n        expect(\")\");\n        return exp;\n    }\n\n    function embed_tokens(parser) {\n        return function() {\n            var start = S.token;\n            var expr = parser.apply(null, arguments);\n            var end = prev();\n            expr.start = start;\n            expr.end = end;\n            return expr;\n        };\n    }\n\n    function handle_regexp() {\n        if (is(\"operator\", \"/\") || is(\"operator\", \"/=\")) {\n            S.peeked = null;\n            S.token = S.input(S.token.value.substr(1)); // force regexp\n        }\n    }\n\n    var statement = embed_tokens(function() {\n        handle_regexp();\n        switch (S.token.type) {\n          case \"string\":\n            var dir = S.in_directives;\n            var body = expression();\n            if (dir) {\n                if (body instanceof AST_String) {\n                    var value = body.start.raw.slice(1, -1);\n                    S.input.add_directive(value);\n                    body.value = value;\n                } else {\n                    S.in_directives = dir = false;\n                }\n            }\n            semicolon();\n            return dir ? new AST_Directive(body) : new AST_SimpleStatement({ body: body });\n          case \"num\":\n          case \"bigint\":\n          case \"regexp\":\n          case \"operator\":\n          case \"atom\":\n            return simple_statement();\n\n          case \"name\":\n            switch (S.token.value) {\n              case \"async\":\n                if (is_token(peek(), \"keyword\", \"function\")) {\n                    next();\n                    next();\n                    if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n                    next();\n                    return function_(AST_AsyncGeneratorDefun);\n                }\n                break;\n              case \"await\":\n                if (S.in_async) return simple_statement();\n                break;\n              case \"export\":\n                next();\n                return export_();\n              case \"import\":\n                var token = peek();\n                if (!(token.type == \"punc\" && /^[(.]$/.test(token.value))) {\n                    next();\n                    return import_();\n                }\n                break;\n              case \"let\":\n                if (is_vardefs()) {\n                    next();\n                    var node = let_();\n                    semicolon();\n                    return node;\n                }\n                break;\n              case \"yield\":\n                if (S.in_generator) return simple_statement();\n                break;\n            }\n            return is_token(peek(), \"punc\", \":\")\n                ? labeled_statement()\n                : simple_statement();\n\n          case \"punc\":\n            switch (S.token.value) {\n              case \"{\":\n                return new AST_BlockStatement({\n                    start : S.token,\n                    body  : block_(),\n                    end   : prev()\n                });\n              case \"[\":\n              case \"(\":\n              case \"`\":\n                return simple_statement();\n              case \";\":\n                S.in_directives = false;\n                next();\n                return new AST_EmptyStatement();\n              default:\n                unexpected();\n            }\n\n          case \"keyword\":\n            switch (S.token.value) {\n              case \"break\":\n                next();\n                return break_cont(AST_Break);\n\n              case \"class\":\n                next();\n                return class_(AST_DefClass);\n\n              case \"const\":\n                next();\n                var node = const_();\n                semicolon();\n                return node;\n\n              case \"continue\":\n                next();\n                return break_cont(AST_Continue);\n\n              case \"debugger\":\n                next();\n                semicolon();\n                return new AST_Debugger();\n\n              case \"do\":\n                next();\n                var body = in_loop(statement);\n                expect_token(\"keyword\", \"while\");\n                var condition = parenthesised();\n                semicolon(true);\n                return new AST_Do({\n                    body      : body,\n                    condition : condition\n                });\n\n              case \"while\":\n                next();\n                return new AST_While({\n                    condition : parenthesised(),\n                    body      : in_loop(statement)\n                });\n\n              case \"for\":\n                next();\n                return for_();\n\n              case \"function\":\n                next();\n                if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n                next();\n                return function_(AST_GeneratorDefun);\n\n              case \"if\":\n                next();\n                return if_();\n\n              case \"return\":\n                if (S.in_function == 0 && !options.bare_returns)\n                    croak(\"'return' outside of function\");\n                next();\n                var value = null;\n                if (is(\"punc\", \";\")) {\n                    next();\n                } else if (!can_insert_semicolon()) {\n                    value = expression();\n                    semicolon();\n                }\n                return new AST_Return({\n                    value: value\n                });\n\n              case \"switch\":\n                next();\n                return new AST_Switch({\n                    expression : parenthesised(),\n                    body       : in_loop(switch_body_)\n                });\n\n              case \"throw\":\n                next();\n                if (has_newline_before(S.token))\n                    croak(\"Illegal newline after 'throw'\");\n                var value = expression();\n                semicolon();\n                return new AST_Throw({\n                    value: value\n                });\n\n              case \"try\":\n                next();\n                return try_();\n\n              case \"var\":\n                next();\n                var node = var_();\n                semicolon();\n                return node;\n\n              case \"with\":\n                if (S.input.has_directive(\"use strict\")) {\n                    croak(\"Strict mode may not include a with statement\");\n                }\n                next();\n                return new AST_With({\n                    expression : parenthesised(),\n                    body       : statement()\n                });\n            }\n        }\n        unexpected();\n    });\n\n    function labeled_statement() {\n        var label = as_symbol(AST_Label);\n        if (!all(S.labels, function(l) {\n            return l.name != label.name;\n        })) {\n            // ECMA-262, 12.12: An ECMAScript program is considered\n            // syntactically incorrect if it contains a\n            // LabelledStatement that is enclosed by a\n            // LabelledStatement with the same Identifier as label.\n            croak(\"Label \" + label.name + \" defined twice\");\n        }\n        expect(\":\");\n        S.labels.push(label);\n        var stat = statement();\n        S.labels.pop();\n        if (!(stat instanceof AST_IterationStatement)) {\n            // check for `continue` that refers to this label.\n            // those should be reported as syntax errors.\n            // https://github.com/mishoo/UglifyJS/issues/287\n            label.references.forEach(function(ref) {\n                if (ref instanceof AST_Continue) {\n                    token_error(ref.label.start, \"Continue label `\" + label.name + \"` must refer to IterationStatement\");\n                }\n            });\n        }\n        return new AST_LabeledStatement({ body: stat, label: label });\n    }\n\n    function simple_statement() {\n        var body = expression();\n        semicolon();\n        return new AST_SimpleStatement({ body: body });\n    }\n\n    function break_cont(type) {\n        var label = null, ldef;\n        if (!can_insert_semicolon()) {\n            label = as_symbol(AST_LabelRef, true);\n        }\n        if (label != null) {\n            ldef = find_if(function(l) {\n                return l.name == label.name;\n            }, S.labels);\n            if (!ldef) token_error(label.start, \"Undefined label \" + label.name);\n            label.thedef = ldef;\n        } else if (S.in_loop == 0) croak(type.TYPE + \" not inside a loop or switch\");\n        semicolon();\n        var stat = new type({ label: label });\n        if (ldef) ldef.references.push(stat);\n        return stat;\n    }\n\n    function has_modifier(name) {\n        if (!is(\"name\", name)) return;\n        var token = peek();\n        if (!token) return;\n        if (is_token(token, \"operator\", \"=\")) return;\n        if (token.type == \"punc\" && /^[(;}]$/.test(token.value)) return;\n        if (has_newline_before(token)) return;\n        return next();\n    }\n\n    function class_(ctor) {\n        var was_async = S.in_async;\n        var was_gen = S.in_generator;\n        S.input.push_directives_stack();\n        S.input.add_directive(\"use strict\");\n        var name;\n        if (ctor === AST_DefClass) {\n            name = as_symbol(AST_SymbolDefClass);\n        } else {\n            name = as_symbol(AST_SymbolClass, true);\n        }\n        var parent = null;\n        if (is(\"keyword\", \"extends\")) {\n            next();\n            handle_regexp();\n            parent = expr_atom(true);\n        }\n        expect(\"{\");\n        var props = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"punc\", \";\")) {\n                next();\n                continue;\n            }\n            var start = S.token;\n            var fixed = !!has_modifier(\"static\");\n            var async = has_modifier(\"async\");\n            if (is(\"operator\", \"*\")) {\n                next();\n                var internal = is(\"name\") && /^#/.test(S.token.value);\n                var key = as_property_key();\n                var gen_start = S.token;\n                var gen = function_(async ? AST_AsyncGeneratorFunction : AST_GeneratorFunction);\n                gen.start = gen_start;\n                gen.end = prev();\n                props.push(new AST_ClassMethod({\n                    start: start,\n                    static: fixed,\n                    private: internal,\n                    key: key,\n                    value: gen,\n                    end: prev(),\n                }));\n                continue;\n            }\n            var internal = is(\"name\") && /^#/.test(S.token.value);\n            var key = as_property_key();\n            if (is(\"punc\", \"(\")) {\n                var func_start = S.token;\n                var func = function_(async ? AST_AsyncFunction : AST_Function);\n                func.start = func_start;\n                func.end = prev();\n                props.push(new AST_ClassMethod({\n                    start: start,\n                    static: fixed,\n                    private: internal,\n                    key: key,\n                    value: func,\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (async) unexpected(async);\n            var value = null;\n            if (is(\"operator\", \"=\")) {\n                next();\n                S.in_async = false;\n                S.in_generator = false;\n                value = maybe_assign();\n                S.in_generator = was_gen;\n                S.in_async = was_async;\n            } else if (!(is(\"punc\", \";\") || is(\"punc\", \"}\"))) {\n                var type = null;\n                switch (key) {\n                  case \"get\":\n                    type = AST_ClassGetter;\n                    break;\n                  case \"set\":\n                    type = AST_ClassSetter;\n                    break;\n                }\n                if (type) {\n                    props.push(new type({\n                        start: start,\n                        static: fixed,\n                        private: is(\"name\") && /^#/.test(S.token.value),\n                        key: as_property_key(),\n                        value: create_accessor(),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n            }\n            semicolon();\n            props.push(new AST_ClassField({\n                start: start,\n                static: fixed,\n                private: internal,\n                key: key,\n                value: value,\n                end: prev(),\n            }));\n        }\n        next();\n        S.input.pop_directives_stack();\n        S.in_generator = was_gen;\n        S.in_async = was_async;\n        return new ctor({\n            extends: parent,\n            name: name,\n            properties: props,\n        });\n    }\n\n    function for_() {\n        var await = is(\"name\", \"await\") && next();\n        expect(\"(\");\n        var init = null;\n        if (await || !is(\"punc\", \";\")) {\n            init = is(\"keyword\", \"const\")\n                ? (next(), const_(true))\n                : is(\"name\", \"let\") && is_vardefs()\n                ? (next(), let_(true))\n                : is(\"keyword\", \"var\")\n                ? (next(), var_(true))\n                : expression(true);\n            var ctor;\n            if (await) {\n                expect_token(\"name\", \"of\");\n                ctor = AST_ForAwaitOf;\n            } else if (is(\"operator\", \"in\")) {\n                next();\n                ctor = AST_ForIn;\n            } else if (is(\"name\", \"of\")) {\n                next();\n                ctor = AST_ForOf;\n            }\n            if (ctor) {\n                if (init instanceof AST_Definitions) {\n                    if (init.definitions.length > 1) {\n                        token_error(init.start, \"Only one variable declaration allowed in for..in/of loop\");\n                    }\n                    if (ctor !== AST_ForIn && init.definitions[0].value) {\n                        token_error(init.definitions[0].value.start, \"No initializers allowed in for..of loop\");\n                    }\n                } else if (!(is_assignable(init) || (init = to_destructured(init)) instanceof AST_Destructured)) {\n                    token_error(init.start, \"Invalid left-hand side in for..in/of loop\");\n                }\n                return for_enum(ctor, init);\n            }\n        }\n        return regular_for(init);\n    }\n\n    function regular_for(init) {\n        expect(\";\");\n        var test = is(\"punc\", \";\") ? null : expression();\n        expect(\";\");\n        var step = is(\"punc\", \")\") ? null : expression();\n        expect(\")\");\n        return new AST_For({\n            init      : init,\n            condition : test,\n            step      : step,\n            body      : in_loop(statement)\n        });\n    }\n\n    function for_enum(ctor, init) {\n        handle_regexp();\n        var obj = expression();\n        expect(\")\");\n        return new ctor({\n            init   : init,\n            object : obj,\n            body   : in_loop(statement)\n        });\n    }\n\n    function to_funarg(node) {\n        if (node instanceof AST_Array) {\n            var rest = null;\n            if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                rest = to_funarg(node.elements.pop().expression);\n            }\n            return new AST_DestructuredArray({\n                start: node.start,\n                elements: node.elements.map(to_funarg),\n                rest: rest,\n                end: node.end,\n            });\n        }\n        if (node instanceof AST_Assign) return new AST_DefaultValue({\n            start: node.start,\n            name: to_funarg(node.left),\n            value: node.right,\n            end: node.end,\n        });\n        if (node instanceof AST_DefaultValue) {\n            node.name = to_funarg(node.name);\n            return node;\n        }\n        if (node instanceof AST_DestructuredArray) {\n            node.elements = node.elements.map(to_funarg);\n            if (node.rest) node.rest = to_funarg(node.rest);\n            return node;\n        }\n        if (node instanceof AST_DestructuredObject) {\n            node.properties.forEach(function(prop) {\n                prop.value = to_funarg(prop.value);\n            });\n            if (node.rest) node.rest = to_funarg(node.rest);\n            return node;\n        }\n        if (node instanceof AST_Hole) return node;\n        if (node instanceof AST_Object) {\n            var rest = null;\n            if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n                rest = to_funarg(node.properties.pop().expression);\n            }\n            return new AST_DestructuredObject({\n                start: node.start,\n                properties: node.properties.map(function(prop) {\n                    if (!(prop instanceof AST_ObjectKeyVal)) token_error(prop.start, \"Invalid destructuring assignment\");\n                    return new AST_DestructuredKeyVal({\n                        start: prop.start,\n                        key: prop.key,\n                        value: to_funarg(prop.value),\n                        end: prop.end,\n                    });\n                }),\n                rest: rest,\n                end: node.end,\n            });\n        }\n        if (node instanceof AST_SymbolFunarg) return node;\n        if (node instanceof AST_SymbolRef) return new AST_SymbolFunarg(node);\n        if (node instanceof AST_Yield) return new AST_SymbolFunarg({\n            start: node.start,\n            name: \"yield\",\n            end: node.end,\n        });\n        token_error(node.start, \"Invalid arrow parameter\");\n    }\n\n    function arrow(exprs, start, async) {\n        var was_async = S.in_async;\n        var was_gen = S.in_generator;\n        S.in_async = async;\n        S.in_generator = false;\n        var was_funarg = S.in_funarg;\n        S.in_funarg = S.in_function;\n        var argnames = exprs.map(to_funarg);\n        var rest = exprs.rest || null;\n        if (rest) rest = to_funarg(rest);\n        S.in_funarg = was_funarg;\n        expect(\"=>\");\n        var body, value;\n        var loop = S.in_loop;\n        var labels = S.labels;\n        ++S.in_function;\n        S.in_directives = true;\n        S.input.push_directives_stack();\n        S.in_loop = 0;\n        S.labels = [];\n        if (is(\"punc\", \"{\")) {\n            body = block_();\n            value = null;\n        } else {\n            body = [];\n            handle_regexp();\n            value = maybe_assign();\n        }\n        var is_strict = S.input.has_directive(\"use strict\");\n        S.input.pop_directives_stack();\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_generator = was_gen;\n        S.in_async = was_async;\n        var node = new (async ? AST_AsyncArrow : AST_Arrow)({\n            start: start,\n            argnames: argnames,\n            rest: rest,\n            body: body,\n            value: value,\n            end: prev(),\n        });\n        if (is_strict) node.each_argname(strict_verify_symbol);\n        return node;\n    }\n\n    var function_ = function(ctor) {\n        var was_async = S.in_async;\n        var was_gen = S.in_generator;\n        var name;\n        if (/Defun$/.test(ctor.TYPE)) {\n            name = as_symbol(AST_SymbolDefun);\n            S.in_async = /^Async/.test(ctor.TYPE);\n            S.in_generator = /Generator/.test(ctor.TYPE);\n        } else {\n            S.in_async = /^Async/.test(ctor.TYPE);\n            S.in_generator = /Generator/.test(ctor.TYPE);\n            name = as_symbol(AST_SymbolLambda, true);\n        }\n        if (name && ctor !== AST_Accessor && !(name instanceof AST_SymbolDeclaration))\n            unexpected(prev());\n        expect(\"(\");\n        var was_funarg = S.in_funarg;\n        S.in_funarg = S.in_function;\n        var argnames = expr_list(\")\", !options.strict, false, function() {\n            return maybe_default(AST_SymbolFunarg);\n        });\n        S.in_funarg = was_funarg;\n        var loop = S.in_loop;\n        var labels = S.labels;\n        ++S.in_function;\n        S.in_directives = true;\n        S.input.push_directives_stack();\n        S.in_loop = 0;\n        S.labels = [];\n        var body = block_();\n        var is_strict = S.input.has_directive(\"use strict\");\n        S.input.pop_directives_stack();\n        --S.in_function;\n        S.in_loop = loop;\n        S.labels = labels;\n        S.in_generator = was_gen;\n        S.in_async = was_async;\n        var node = new ctor({\n            name: name,\n            argnames: argnames,\n            rest: argnames.rest || null,\n            body: body\n        });\n        if (is_strict) {\n            if (name) strict_verify_symbol(name);\n            node.each_argname(strict_verify_symbol);\n        }\n        return node;\n    };\n\n    function if_() {\n        var cond = parenthesised(), body = statement(), belse = null;\n        if (is(\"keyword\", \"else\")) {\n            next();\n            belse = statement();\n        }\n        return new AST_If({\n            condition   : cond,\n            body        : body,\n            alternative : belse\n        });\n    }\n\n    function is_alias() {\n        return is(\"name\") || is_identifier_string(S.token.value);\n    }\n\n    function export_() {\n        if (is(\"operator\", \"*\")) {\n            next();\n            var alias = \"*\";\n            if (is(\"name\", \"as\")) {\n                next();\n                if (!is_alias()) expect_token(\"name\");\n                alias = S.token.value;\n                next();\n            }\n            expect_token(\"name\", \"from\");\n            var path = S.token;\n            expect_token(\"string\");\n            semicolon();\n            return new AST_ExportForeign({\n                aliases: [ alias ],\n                keys: [ \"*\" ],\n                path: path.value,\n                quote: path.quote,\n            });\n        }\n        if (is(\"punc\", \"{\")) {\n            next();\n            var aliases = [];\n            var keys = [];\n            while (is_alias()) {\n                var key = S.token;\n                next();\n                keys.push(key);\n                if (is(\"name\", \"as\")) {\n                    next();\n                    if (!is_alias()) expect_token(\"name\");\n                    aliases.push(S.token.value);\n                    next();\n                } else {\n                    aliases.push(key.value);\n                }\n                if (!is(\"punc\", \"}\")) expect(\",\");\n            }\n            expect(\"}\");\n            if (is(\"name\", \"from\")) {\n                next();\n                var path = S.token;\n                expect_token(\"string\");\n                semicolon();\n                return new AST_ExportForeign({\n                    aliases: aliases,\n                    keys: keys.map(function(token) {\n                        return token.value;\n                    }),\n                    path: path.value,\n                    quote: path.quote,\n                });\n            }\n            semicolon();\n            return new AST_ExportReferences({\n                properties: keys.map(function(token, index) {\n                    if (!is_token(token, \"name\")) token_error(token, \"Name expected\");\n                    var sym = _make_symbol(AST_SymbolExport, token);\n                    sym.alias = aliases[index];\n                    return sym;\n                }),\n            });\n        }\n        if (is(\"keyword\", \"default\")) {\n            next();\n            var start = S.token;\n            var body = export_default_decl();\n            if (body) {\n                body.start = start;\n                body.end = prev();\n            } else {\n                handle_regexp();\n                body = expression();\n                semicolon();\n            }\n            return new AST_ExportDefault({ body: body });\n        }\n        return new AST_ExportDeclaration({ body: export_decl() });\n    }\n\n    function maybe_named(def, expr) {\n        if (expr.name) {\n            expr = new def(expr);\n            expr.name = new (def === AST_DefClass ? AST_SymbolDefClass : AST_SymbolDefun)(expr.name);\n        }\n        return expr;\n    }\n\n    function export_default_decl() {\n        if (is(\"name\", \"async\")) {\n            if (!is_token(peek(), \"keyword\", \"function\")) return;\n            next();\n            next();\n            if (!is(\"operator\", \"*\")) return maybe_named(AST_AsyncDefun, function_(AST_AsyncFunction));\n            next();\n            return maybe_named(AST_AsyncGeneratorDefun, function_(AST_AsyncGeneratorFunction));\n        } else if (is(\"keyword\")) switch (S.token.value) {\n          case \"class\":\n            next();\n            return maybe_named(AST_DefClass, class_(AST_ClassExpression));\n          case \"function\":\n            next();\n            if (!is(\"operator\", \"*\")) return maybe_named(AST_Defun, function_(AST_Function));\n            next();\n            return maybe_named(AST_GeneratorDefun, function_(AST_GeneratorFunction));\n        }\n    }\n\n    var export_decl = embed_tokens(function() {\n        if (is(\"name\")) switch (S.token.value) {\n          case \"async\":\n            next();\n            expect_token(\"keyword\", \"function\");\n            if (!is(\"operator\", \"*\")) return function_(AST_AsyncDefun);\n            next();\n            return function_(AST_AsyncGeneratorDefun);\n          case \"let\":\n            next();\n            var node = let_();\n            semicolon();\n            return node;\n        } else if (is(\"keyword\")) switch (S.token.value) {\n          case \"class\":\n            next();\n            return class_(AST_DefClass);\n          case \"const\":\n            next();\n            var node = const_();\n            semicolon();\n            return node;\n          case \"function\":\n            next();\n            if (!is(\"operator\", \"*\")) return function_(AST_Defun);\n            next();\n            return function_(AST_GeneratorDefun);\n          case \"var\":\n            next();\n            var node = var_();\n            semicolon();\n            return node;\n        }\n        unexpected();\n    });\n\n    function import_() {\n        var all = null;\n        var def = as_symbol(AST_SymbolImport, true);\n        var props = null;\n        if (def ? (def.key = \"\", is(\"punc\", \",\") && next()) : !is(\"string\")) {\n            if (is(\"operator\", \"*\")) {\n                next();\n                expect_token(\"name\", \"as\");\n                all = as_symbol(AST_SymbolImport);\n                all.key = \"*\";\n            } else {\n                expect(\"{\");\n                props = [];\n                while (is_alias()) {\n                    var alias;\n                    if (is_token(peek(), \"name\", \"as\")) {\n                        var key = S.token.value;\n                        next();\n                        next();\n                        alias = as_symbol(AST_SymbolImport);\n                        alias.key = key;\n                    } else {\n                        alias = as_symbol(AST_SymbolImport);\n                        alias.key = alias.name;\n                    }\n                    props.push(alias);\n                    if (!is(\"punc\", \"}\")) expect(\",\");\n                }\n                expect(\"}\");\n            }\n        }\n        if (all || def || props) expect_token(\"name\", \"from\");\n        var path = S.token;\n        expect_token(\"string\");\n        semicolon();\n        return new AST_Import({\n            all: all,\n            default: def,\n            path: path.value,\n            properties: props,\n            quote: path.quote,\n        });\n    }\n\n    function block_() {\n        expect(\"{\");\n        var a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) expect(\"}\");\n            a.push(statement());\n        }\n        next();\n        return a;\n    }\n\n    function switch_body_() {\n        expect(\"{\");\n        var a = [], branch, cur, default_branch, tmp;\n        while (!is(\"punc\", \"}\")) {\n            if (is(\"eof\")) expect(\"}\");\n            if (is(\"keyword\", \"case\")) {\n                if (branch) branch.end = prev();\n                cur = [];\n                branch = new AST_Case({\n                    start      : (tmp = S.token, next(), tmp),\n                    expression : expression(),\n                    body       : cur\n                });\n                a.push(branch);\n                expect(\":\");\n            } else if (is(\"keyword\", \"default\")) {\n                if (branch) branch.end = prev();\n                if (default_branch) croak(\"More than one default clause in switch statement\");\n                cur = [];\n                branch = new AST_Default({\n                    start : (tmp = S.token, next(), expect(\":\"), tmp),\n                    body  : cur\n                });\n                a.push(branch);\n                default_branch = branch;\n            } else {\n                if (!cur) unexpected();\n                cur.push(statement());\n            }\n        }\n        if (branch) branch.end = prev();\n        next();\n        return a;\n    }\n\n    function try_() {\n        var body = block_(), bcatch = null, bfinally = null;\n        if (is(\"keyword\", \"catch\")) {\n            var start = S.token;\n            next();\n            var name = null;\n            if (is(\"punc\", \"(\")) {\n                next();\n                name = maybe_destructured(AST_SymbolCatch);\n                expect(\")\");\n            }\n            bcatch = new AST_Catch({\n                start   : start,\n                argname : name,\n                body    : block_(),\n                end     : prev()\n            });\n        }\n        if (is(\"keyword\", \"finally\")) {\n            var start = S.token;\n            next();\n            bfinally = new AST_Finally({\n                start : start,\n                body  : block_(),\n                end   : prev()\n            });\n        }\n        if (!bcatch && !bfinally)\n            croak(\"Missing catch/finally blocks\");\n        return new AST_Try({\n            body     : body,\n            bcatch   : bcatch,\n            bfinally : bfinally\n        });\n    }\n\n    function vardefs(type, no_in) {\n        var a = [];\n        for (;;) {\n            var start = S.token;\n            var name = maybe_destructured(type);\n            var value = null;\n            if (is(\"operator\", \"=\")) {\n                next();\n                value = maybe_assign(no_in);\n            } else if (!no_in && (type === AST_SymbolConst || name instanceof AST_Destructured)) {\n                croak(\"Missing initializer in declaration\");\n            }\n            a.push(new AST_VarDef({\n                start : start,\n                name  : name,\n                value : value,\n                end   : prev()\n            }));\n            if (!is(\"punc\", \",\"))\n                break;\n            next();\n        }\n        return a;\n    }\n\n    function is_vardefs() {\n        var token = peek();\n        return is_token(token, \"name\") || is_token(token, \"punc\", \"[\") || is_token(token, \"punc\", \"{\");\n    }\n\n    var const_ = function(no_in) {\n        return new AST_Const({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolConst, no_in),\n            end         : prev()\n        });\n    };\n\n    var let_ = function(no_in) {\n        return new AST_Let({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolLet, no_in),\n            end         : prev()\n        });\n    };\n\n    var var_ = function(no_in) {\n        return new AST_Var({\n            start       : prev(),\n            definitions : vardefs(AST_SymbolVar, no_in),\n            end         : prev()\n        });\n    };\n\n    var new_ = function(allow_calls) {\n        var start = S.token;\n        expect_token(\"operator\", \"new\");\n        var call;\n        if (is(\"punc\", \".\") && is_token(peek(), \"name\", \"target\")) {\n            next();\n            next();\n            call = new AST_NewTarget();\n        } else {\n            var exp = expr_atom(false), args;\n            if (is(\"punc\", \"(\")) {\n                next();\n                args = expr_list(\")\", !options.strict);\n            } else {\n                args = [];\n            }\n            call = new AST_New({ expression: exp, args: args });\n        }\n        call.start = start;\n        call.end = prev();\n        return subscripts(call, allow_calls);\n    };\n\n    function as_atom_node() {\n        var ret, tok = S.token, value = tok.value;\n        switch (tok.type) {\n          case \"num\":\n            if (isFinite(value)) {\n                ret = new AST_Number({ value: value });\n            } else {\n                ret = new AST_Infinity();\n                if (value < 0) ret = new AST_UnaryPrefix({ operator: \"-\", expression: ret });\n            }\n            break;\n          case \"bigint\":\n            ret = new AST_BigInt({ value: value });\n            break;\n          case \"string\":\n            ret = new AST_String({ value : value, quote : tok.quote });\n            break;\n          case \"regexp\":\n            ret = new AST_RegExp({ value: value });\n            break;\n          case \"atom\":\n            switch (value) {\n              case \"false\":\n                ret = new AST_False();\n                break;\n              case \"true\":\n                ret = new AST_True();\n                break;\n              case \"null\":\n                ret = new AST_Null();\n                break;\n              default:\n                unexpected();\n            }\n            break;\n          default:\n            unexpected();\n        }\n        next();\n        ret.start = ret.end = tok;\n        return ret;\n    }\n\n    var expr_atom = function(allow_calls) {\n        if (is(\"operator\", \"new\")) {\n            return new_(allow_calls);\n        }\n        var start = S.token;\n        if (is(\"punc\")) {\n            switch (start.value) {\n              case \"`\":\n                return subscripts(template(null), allow_calls);\n              case \"(\":\n                next();\n                if (is(\"punc\", \")\")) {\n                    next();\n                    return arrow([], start);\n                }\n                var ex = expression(false, true);\n                var len = start.comments_before.length;\n                [].unshift.apply(ex.start.comments_before, start.comments_before);\n                start.comments_before.length = 0;\n                start.comments_before = ex.start.comments_before;\n                start.comments_before_length = len;\n                if (len == 0 && start.comments_before.length > 0) {\n                    var comment = start.comments_before[0];\n                    if (!comment.nlb) {\n                        comment.nlb = start.nlb;\n                        start.nlb = false;\n                    }\n                }\n                start.comments_after = ex.start.comments_after;\n                ex.start = start;\n                expect(\")\");\n                var end = prev();\n                end.comments_before = ex.end.comments_before;\n                end.comments_after.forEach(function(comment) {\n                    ex.end.comments_after.push(comment);\n                    if (comment.nlb) S.token.nlb = true;\n                });\n                end.comments_after.length = 0;\n                end.comments_after = ex.end.comments_after;\n                ex.end = end;\n                if (is(\"punc\", \"=>\")) return arrow(ex instanceof AST_Sequence ? ex.expressions : [ ex ], start);\n                return subscripts(ex, allow_calls);\n              case \"[\":\n                return subscripts(array_(), allow_calls);\n              case \"{\":\n                return subscripts(object_(), allow_calls);\n            }\n            unexpected();\n        }\n        if (is(\"keyword\")) switch (start.value) {\n          case \"class\":\n            next();\n            var clazz = class_(AST_ClassExpression);\n            clazz.start = start;\n            clazz.end = prev();\n            return subscripts(clazz, allow_calls);\n          case \"function\":\n            next();\n            var func;\n            if (is(\"operator\", \"*\")) {\n                next();\n                func = function_(AST_GeneratorFunction);\n            } else {\n                func = function_(AST_Function);\n            }\n            func.start = start;\n            func.end = prev();\n            return subscripts(func, allow_calls);\n        }\n        if (is(\"name\")) {\n            var sym = _make_symbol(AST_SymbolRef, start);\n            next();\n            if (sym.name == \"async\") {\n                if (is(\"keyword\", \"function\")) {\n                    next();\n                    var func;\n                    if (is(\"operator\", \"*\")) {\n                        next();\n                        func = function_(AST_AsyncGeneratorFunction);\n                    } else {\n                        func = function_(AST_AsyncFunction);\n                    }\n                    func.start = start;\n                    func.end = prev();\n                    return subscripts(func, allow_calls);\n                }\n                if (is(\"name\") && is_token(peek(), \"punc\", \"=>\")) {\n                    start = S.token;\n                    sym = _make_symbol(AST_SymbolRef, start);\n                    next();\n                    return arrow([ sym ], start, true);\n                }\n                if (is(\"punc\", \"(\")) {\n                    var call = subscripts(sym, allow_calls);\n                    if (!is(\"punc\", \"=>\")) return call;\n                    var args = call.args;\n                    if (args[args.length - 1] instanceof AST_Spread) {\n                        args.rest = args.pop().expression;\n                    }\n                    return arrow(args, start, true);\n                }\n            }\n            return is(\"punc\", \"=>\") ? arrow([ sym ], start) : subscripts(sym, allow_calls);\n        }\n        if (ATOMIC_START_TOKEN[S.token.type]) {\n            return subscripts(as_atom_node(), allow_calls);\n        }\n        unexpected();\n    };\n\n    function expr_list(closing, allow_trailing_comma, allow_empty, parser) {\n        if (!parser) parser = maybe_assign;\n        var first = true, a = [];\n        while (!is(\"punc\", closing)) {\n            if (first) first = false; else expect(\",\");\n            if (allow_trailing_comma && is(\"punc\", closing)) break;\n            if (allow_empty && is(\"punc\", \",\")) {\n                a.push(new AST_Hole({ start: S.token, end: S.token }));\n            } else if (!is(\"operator\", \"...\")) {\n                a.push(parser());\n            } else if (parser === maybe_assign) {\n                a.push(new AST_Spread({\n                    start: S.token,\n                    expression: (next(), parser()),\n                    end: prev(),\n                }));\n            } else {\n                next();\n                a.rest = parser();\n                if (a.rest instanceof AST_DefaultValue) token_error(a.rest.start, \"Invalid rest parameter\");\n                break;\n            }\n        }\n        expect(closing);\n        return a;\n    }\n\n    var array_ = embed_tokens(function() {\n        expect(\"[\");\n        return new AST_Array({\n            elements: expr_list(\"]\", !options.strict, true)\n        });\n    });\n\n    var create_accessor = embed_tokens(function() {\n        return function_(AST_Accessor);\n    });\n\n    var object_ = embed_tokens(function() {\n        expect(\"{\");\n        var first = true, a = [];\n        while (!is(\"punc\", \"}\")) {\n            if (first) first = false; else expect(\",\");\n            // allow trailing comma\n            if (!options.strict && is(\"punc\", \"}\")) break;\n            var start = S.token;\n            if (is(\"operator\", \"*\")) {\n                next();\n                var key = as_property_key();\n                var gen_start = S.token;\n                var gen = function_(AST_GeneratorFunction);\n                gen.start = gen_start;\n                gen.end = prev();\n                a.push(new AST_ObjectMethod({\n                    start: start,\n                    key: key,\n                    value: gen,\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is(\"operator\", \"...\")) {\n                next();\n                a.push(new AST_Spread({\n                    start: start,\n                    expression: maybe_assign(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is_token(peek(), \"operator\", \"=\")) {\n                var name = as_symbol(AST_SymbolRef);\n                next();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: start.value,\n                    value: new AST_Assign({\n                        start: start,\n                        left: name,\n                        operator: \"=\",\n                        right: maybe_assign(),\n                        end: prev(),\n                    }),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is_token(peek(), \"punc\", \",\") || is_token(peek(), \"punc\", \"}\")) {\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: start.value,\n                    value: as_symbol(AST_SymbolRef),\n                    end: prev(),\n                }));\n                continue;\n            }\n            var key = as_property_key();\n            if (is(\"punc\", \"(\")) {\n                var func_start = S.token;\n                var func = function_(AST_Function);\n                func.start = func_start;\n                func.end = prev();\n                a.push(new AST_ObjectMethod({\n                    start: start,\n                    key: key,\n                    value: func,\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (is(\"punc\", \":\")) {\n                next();\n                a.push(new AST_ObjectKeyVal({\n                    start: start,\n                    key: key,\n                    value: maybe_assign(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            if (start.type == \"name\") switch (key) {\n              case \"async\":\n                var is_gen = is(\"operator\", \"*\") && next();\n                key = as_property_key();\n                var func_start = S.token;\n                var func = function_(is_gen ? AST_AsyncGeneratorFunction : AST_AsyncFunction);\n                func.start = func_start;\n                func.end = prev();\n                a.push(new AST_ObjectMethod({\n                    start: start,\n                    key: key,\n                    value: func,\n                    end: prev(),\n                }));\n                continue;\n              case \"get\":\n                a.push(new AST_ObjectGetter({\n                    start: start,\n                    key: as_property_key(),\n                    value: create_accessor(),\n                    end: prev(),\n                }));\n                continue;\n              case \"set\":\n                a.push(new AST_ObjectSetter({\n                    start: start,\n                    key: as_property_key(),\n                    value: create_accessor(),\n                    end: prev(),\n                }));\n                continue;\n            }\n            unexpected();\n        }\n        next();\n        return new AST_Object({ properties: a });\n    });\n\n    function as_property_key() {\n        var tmp = S.token;\n        switch (tmp.type) {\n          case \"operator\":\n            if (!KEYWORDS[tmp.value]) unexpected();\n          case \"num\":\n          case \"string\":\n          case \"name\":\n          case \"keyword\":\n          case \"atom\":\n            next();\n            return \"\" + tmp.value;\n          case \"punc\":\n            expect(\"[\");\n            var key = maybe_assign();\n            expect(\"]\");\n            return key;\n          default:\n            unexpected();\n        }\n    }\n\n    function as_name() {\n        var name = S.token.value;\n        expect_token(\"name\");\n        return name;\n    }\n\n    function _make_symbol(type, token) {\n        var name = token.value;\n        switch (name) {\n          case \"await\":\n            if (S.in_async) unexpected(token);\n            break;\n          case \"super\":\n            type = AST_Super;\n            break;\n          case \"this\":\n            type = AST_This;\n            break;\n          case \"yield\":\n            if (S.in_generator) unexpected(token);\n            break;\n        }\n        return new type({\n            name: \"\" + name,\n            start: token,\n            end: token,\n        });\n    }\n\n    function strict_verify_symbol(sym) {\n        if (sym.name == \"arguments\" || sym.name == \"eval\" || sym.name == \"let\")\n            token_error(sym.start, \"Unexpected \" + sym.name + \" in strict mode\");\n    }\n\n    function as_symbol(type, noerror) {\n        if (!is(\"name\")) {\n            if (!noerror) croak(\"Name expected\");\n            return null;\n        }\n        var sym = _make_symbol(type, S.token);\n        if (S.input.has_directive(\"use strict\") && sym instanceof AST_SymbolDeclaration) {\n            strict_verify_symbol(sym);\n        }\n        next();\n        return sym;\n    }\n\n    function maybe_destructured(type) {\n        var start = S.token;\n        if (is(\"punc\", \"[\")) {\n            next();\n            var elements = expr_list(\"]\", !options.strict, true, function() {\n                return maybe_default(type);\n            });\n            return new AST_DestructuredArray({\n                start: start,\n                elements: elements,\n                rest: elements.rest || null,\n                end: prev(),\n            });\n        }\n        if (is(\"punc\", \"{\")) {\n            next();\n            var first = true, a = [], rest = null;\n            while (!is(\"punc\", \"}\")) {\n                if (first) first = false; else expect(\",\");\n                // allow trailing comma\n                if (!options.strict && is(\"punc\", \"}\")) break;\n                var key_start = S.token;\n                if (is(\"punc\", \"[\") || is_token(peek(), \"punc\", \":\")) {\n                    var key = as_property_key();\n                    expect(\":\");\n                    a.push(new AST_DestructuredKeyVal({\n                        start: key_start,\n                        key: key,\n                        value: maybe_default(type),\n                        end: prev(),\n                    }));\n                    continue;\n                }\n                if (is(\"operator\", \"...\")) {\n                    next();\n                    rest = maybe_destructured(type);\n                    break;\n                }\n                var name = as_symbol(type);\n                if (is(\"operator\", \"=\")) {\n                    next();\n                    name = new AST_DefaultValue({\n                        start: name.start,\n                        name: name,\n                        value: maybe_assign(),\n                        end: prev(),\n                    });\n                }\n                a.push(new AST_DestructuredKeyVal({\n                    start: key_start,\n                    key: key_start.value,\n                    value: name,\n                    end: prev(),\n                }));\n            }\n            expect(\"}\");\n            return new AST_DestructuredObject({\n                start: start,\n                properties: a,\n                rest: rest,\n                end: prev(),\n            });\n        }\n        return as_symbol(type);\n    }\n\n    function maybe_default(type) {\n        var start = S.token;\n        var name = maybe_destructured(type);\n        if (!is(\"operator\", \"=\")) return name;\n        next();\n        return new AST_DefaultValue({\n            start: start,\n            name: name,\n            value: maybe_assign(),\n            end: prev(),\n        });\n    }\n\n    function template(tag) {\n        var start = tag ? tag.start : S.token;\n        var read = S.input.context().read_template;\n        var strings = [];\n        var expressions = [];\n        while (read(strings)) {\n            next();\n            expressions.push(expression());\n            if (!is(\"punc\", \"}\")) unexpected();\n        }\n        next();\n        return new AST_Template({\n            start: start,\n            expressions: expressions,\n            strings: strings,\n            tag: tag,\n            end: prev(),\n        });\n    }\n\n    function subscripts(expr, allow_calls) {\n        var start = expr.start;\n        var optional = null;\n        while (true) {\n            if (is(\"operator\", \"?\") && is_token(peek(), \"punc\", \".\")) {\n                next();\n                next();\n                optional = expr;\n            }\n            if (is(\"punc\", \"[\")) {\n                next();\n                var prop = expression();\n                expect(\"]\");\n                expr = new AST_Sub({\n                    start: start,\n                    optional: optional === expr,\n                    expression: expr,\n                    property: prop,\n                    end: prev(),\n                });\n            } else if (allow_calls && is(\"punc\", \"(\")) {\n                next();\n                expr = new AST_Call({\n                    start: start,\n                    optional: optional === expr,\n                    expression: expr,\n                    args: expr_list(\")\", !options.strict),\n                    end: prev(),\n                });\n            } else if (optional === expr || is(\"punc\", \".\")) {\n                if (optional !== expr) next();\n                expr = new AST_Dot({\n                    start: start,\n                    optional: optional === expr,\n                    expression: expr,\n                    property: as_name(),\n                    end: prev(),\n                });\n            } else if (is(\"punc\", \"`\")) {\n                if (optional) croak(\"Invalid template on optional chain\");\n                expr = template(expr);\n            } else {\n                break;\n            }\n        }\n        if (optional) expr.terminal = true;\n        if (expr instanceof AST_Call && !expr.pure) {\n            var start = expr.start;\n            var comments = start.comments_before;\n            var i = HOP(start, \"comments_before_length\") ? start.comments_before_length : comments.length;\n            while (--i >= 0) {\n                if (/[@#]__PURE__/.test(comments[i].value)) {\n                    expr.pure = true;\n                    break;\n                }\n            }\n        }\n        return expr;\n    }\n\n    function maybe_unary(no_in) {\n        var start = S.token;\n        if (S.in_async && is(\"name\", \"await\")) {\n            if (S.in_funarg === S.in_function) croak(\"Invalid use of await in function argument\");\n            S.input.context().regex_allowed = true;\n            next();\n            return new AST_Await({\n                start: start,\n                expression: maybe_unary(no_in),\n                end: prev(),\n            });\n        }\n        if (S.in_generator && is(\"name\", \"yield\")) {\n            if (S.in_funarg === S.in_function) croak(\"Invalid use of yield in function argument\");\n            S.input.context().regex_allowed = true;\n            next();\n            var exp = null;\n            var nested = false;\n            if (is(\"operator\", \"*\")) {\n                next();\n                exp = maybe_assign(no_in);\n                nested = true;\n            } else if (is(\"punc\") ? !PUNC_AFTER_EXPRESSION[S.token.value] : !can_insert_semicolon()) {\n                exp = maybe_assign(no_in);\n            }\n            return new AST_Yield({\n                start: start,\n                expression: exp,\n                nested: nested,\n                end: prev(),\n            });\n        }\n        if (is(\"operator\") && UNARY_PREFIX[start.value]) {\n            next();\n            handle_regexp();\n            var ex = make_unary(AST_UnaryPrefix, start, maybe_unary(no_in));\n            ex.start = start;\n            ex.end = prev();\n            return ex;\n        }\n        var val = expr_atom(true);\n        while (is(\"operator\") && UNARY_POSTFIX[S.token.value] && !has_newline_before(S.token)) {\n            val = make_unary(AST_UnaryPostfix, S.token, val);\n            val.start = start;\n            val.end = S.token;\n            next();\n        }\n        return val;\n    }\n\n    function make_unary(ctor, token, expr) {\n        var op = token.value;\n        switch (op) {\n          case \"++\":\n          case \"--\":\n            if (!is_assignable(expr))\n                token_error(token, \"Invalid use of \" + op + \" operator\");\n            break;\n          case \"delete\":\n            if (expr instanceof AST_SymbolRef && S.input.has_directive(\"use strict\"))\n                token_error(expr.start, \"Calling delete on expression not allowed in strict mode\");\n            break;\n        }\n        return new ctor({ operator: op, expression: expr });\n    }\n\n    var expr_op = function(left, min_prec, no_in) {\n        var op = is(\"operator\") ? S.token.value : null;\n        if (op == \"in\" && no_in) op = null;\n        var prec = op != null ? PRECEDENCE[op] : null;\n        if (prec != null && prec > min_prec) {\n            next();\n            var right = expr_op(maybe_unary(no_in), op == \"**\" ? prec - 1 : prec, no_in);\n            return expr_op(new AST_Binary({\n                start    : left.start,\n                left     : left,\n                operator : op,\n                right    : right,\n                end      : right.end\n            }), min_prec, no_in);\n        }\n        return left;\n    };\n\n    function expr_ops(no_in) {\n        return expr_op(maybe_unary(no_in), 0, no_in);\n    }\n\n    var maybe_conditional = function(no_in) {\n        var start = S.token;\n        var expr = expr_ops(no_in);\n        if (is(\"operator\", \"?\")) {\n            next();\n            var yes = maybe_assign();\n            expect(\":\");\n            return new AST_Conditional({\n                start       : start,\n                condition   : expr,\n                consequent  : yes,\n                alternative : maybe_assign(no_in),\n                end         : prev()\n            });\n        }\n        return expr;\n    };\n\n    function is_assignable(expr) {\n        return expr instanceof AST_PropAccess && !expr.optional || expr instanceof AST_SymbolRef;\n    }\n\n    function to_destructured(node) {\n        if (node instanceof AST_Array) {\n            var rest = null;\n            if (node.elements[node.elements.length - 1] instanceof AST_Spread) {\n                rest = to_destructured(node.elements.pop().expression);\n                if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n            }\n            var elements = node.elements.map(to_destructured);\n            return all(elements, function(node) {\n                return node instanceof AST_DefaultValue\n                    || node instanceof AST_Destructured\n                    || node instanceof AST_Hole\n                    || is_assignable(node);\n            }) ? new AST_DestructuredArray({\n                start: node.start,\n                elements: elements,\n                rest: rest,\n                end: node.end,\n            }) : node;\n        }\n        if (node instanceof AST_Assign) {\n            var name = to_destructured(node.left);\n            return name instanceof AST_Destructured || is_assignable(name) ? new AST_DefaultValue({\n                start: node.start,\n                name: name,\n                value: node.right,\n                end: node.end,\n            }) : node;\n        }\n        if (!(node instanceof AST_Object)) return node;\n        var rest = null;\n        if (node.properties[node.properties.length - 1] instanceof AST_Spread) {\n            rest = to_destructured(node.properties.pop().expression);\n            if (!(rest instanceof AST_Destructured || is_assignable(rest))) return node;\n        }\n        var props = [];\n        for (var i = 0; i < node.properties.length; i++) {\n            var prop = node.properties[i];\n            if (!(prop instanceof AST_ObjectKeyVal)) return node;\n            var value = to_destructured(prop.value);\n            if (!(value instanceof AST_DefaultValue || value instanceof AST_Destructured || is_assignable(value))) {\n                return node;\n            }\n            props.push(new AST_DestructuredKeyVal({\n                start: prop.start,\n                key: prop.key,\n                value: value,\n                end: prop.end,\n            }));\n        }\n        return new AST_DestructuredObject({\n            start: node.start,\n            properties: props,\n            rest: rest,\n            end: node.end,\n        });\n    }\n\n    function maybe_assign(no_in) {\n        var start = S.token;\n        var left = maybe_conditional(no_in), val = S.token.value;\n        if (is(\"operator\") && ASSIGNMENT[val]) {\n            if (is_assignable(left) || val == \"=\" && (left = to_destructured(left)) instanceof AST_Destructured) {\n                next();\n                return new AST_Assign({\n                    start    : start,\n                    left     : left,\n                    operator : val,\n                    right    : maybe_assign(no_in),\n                    end      : prev()\n                });\n            }\n            croak(\"Invalid assignment\");\n        }\n        return left;\n    }\n\n    function expression(no_in, maybe_arrow) {\n        var start = S.token;\n        var exprs = [];\n        while (true) {\n            if (maybe_arrow && is(\"operator\", \"...\")) {\n                next();\n                exprs.rest = maybe_destructured(AST_SymbolFunarg);\n                break;\n            }\n            exprs.push(maybe_assign(no_in));\n            if (!is(\"punc\", \",\")) break;\n            next();\n            if (maybe_arrow && is(\"punc\", \")\") && is_token(peek(), \"punc\", \"=>\")) break;\n        }\n        return exprs.length == 1 && !exprs.rest ? exprs[0] : new AST_Sequence({\n            start: start,\n            expressions: exprs,\n            end: prev(),\n        });\n    }\n\n    function in_loop(cont) {\n        ++S.in_loop;\n        var ret = cont();\n        --S.in_loop;\n        return ret;\n    }\n\n    if (options.expression) {\n        handle_regexp();\n        var exp = expression();\n        expect_token(\"eof\");\n        return exp;\n    }\n\n    return function() {\n        var start = S.token;\n        var body = [];\n        S.input.push_directives_stack();\n        while (!is(\"eof\"))\n            body.push(statement());\n        S.input.pop_directives_stack();\n        var end = prev() || start;\n        var toplevel = options.toplevel;\n        if (toplevel) {\n            toplevel.body = toplevel.body.concat(body);\n            toplevel.end = end;\n        } else {\n            toplevel = new AST_Toplevel({ start: start, body: body, end: end });\n        }\n        return toplevel;\n    }();\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar builtins = function() {\n    var names = new Dictionary();\n    // NaN will be included due to Number.NaN\n    [\n        \"null\",\n        \"true\",\n        \"false\",\n        \"Infinity\",\n        \"-Infinity\",\n        \"undefined\",\n    ].forEach(add);\n    [\n        Array,\n        Boolean,\n        Date,\n        Error,\n        Function,\n        Math,\n        Number,\n        Object,\n        RegExp,\n        String,\n    ].forEach(function(ctor) {\n        Object.getOwnPropertyNames(ctor).map(add);\n        if (ctor.prototype) {\n            Object.getOwnPropertyNames(new ctor()).map(add);\n            Object.getOwnPropertyNames(ctor.prototype).map(add);\n        }\n    });\n    return names;\n\n    function add(name) {\n        names.set(name, true);\n    }\n}();\n\nfunction reserve_quoted_keys(ast, reserved) {\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_ClassProperty) {\n            if (node.start && node.start.quote) add(node.key);\n        } else if (node instanceof AST_ObjectProperty) {\n            if (node.start && node.start.quote) add(node.key);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n\n    function add(name) {\n        push_uniq(reserved, name);\n    }\n}\n\nfunction addStrings(node, add) {\n    if (node instanceof AST_Conditional) {\n        addStrings(node.consequent, add);\n        addStrings(node.alternative, add);\n    } else if (node instanceof AST_Sequence) {\n        addStrings(node.tail_node(), add);\n    } else if (node instanceof AST_String) {\n        add(node.value);\n    }\n}\n\nfunction mangle_properties(ast, options) {\n    options = defaults(options, {\n        builtins: false,\n        cache: null,\n        debug: false,\n        keep_quoted: false,\n        regex: null,\n        reserved: null,\n    }, true);\n\n    var reserved = options.builtins ? new Dictionary() : builtins.clone();\n    if (Array.isArray(options.reserved)) options.reserved.forEach(function(name) {\n        reserved.set(name, true);\n    });\n\n    var cname = -1;\n    var cache;\n    if (options.cache) {\n        cache = options.cache.props;\n        cache.each(function(name) {\n            reserved.set(name, true);\n        });\n    } else {\n        cache = new Dictionary();\n    }\n\n    var regex = options.regex;\n\n    // note debug is either false (disabled), or a string of the debug suffix to use (enabled).\n    // note debug may be enabled as an empty string, which is falsey. Also treat passing 'true'\n    // the same as passing an empty string.\n    var debug = options.debug !== false;\n    var debug_suffix;\n    if (debug) debug_suffix = options.debug === true ? \"\" : options.debug;\n\n    var names_to_mangle = new Dictionary();\n    var unmangleable = reserved.clone();\n\n    // step 1: find candidates to mangle\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Binary) {\n            if (node.operator == \"in\") addStrings(node.left, add);\n        } else if (node.TYPE == \"Call\") {\n            var exp = node.expression;\n            if (exp instanceof AST_Dot) switch (exp.property) {\n              case \"defineProperty\":\n              case \"getOwnPropertyDescriptor\":\n                if (node.args.length < 2) break;\n                exp = exp.expression;\n                if (!(exp instanceof AST_SymbolRef)) break;\n                if (exp.name != \"Object\") break;\n                if (!exp.definition().undeclared) break;\n                addStrings(node.args[1], add);\n                break;\n              case \"hasOwnProperty\":\n                if (node.args.length < 1) break;\n                addStrings(node.args[0], add);\n                break;\n            }\n        } else if (node instanceof AST_ClassProperty) {\n            if (typeof node.key == \"string\") add(node.key);\n        } else if (node instanceof AST_Dot) {\n            add(node.property);\n        } else if (node instanceof AST_ObjectProperty) {\n            if (typeof node.key == \"string\") add(node.key);\n        } else if (node instanceof AST_Sub) {\n            addStrings(node.property, add);\n        }\n    }));\n\n    // step 2: renaming properties\n    ast.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_Binary) {\n            if (node.operator == \"in\") mangleStrings(node.left);\n        } else if (node.TYPE == \"Call\") {\n            var exp = node.expression;\n            if (exp instanceof AST_Dot) switch (exp.property) {\n              case \"defineProperty\":\n              case \"getOwnPropertyDescriptor\":\n                if (node.args.length < 2) break;\n                exp = exp.expression;\n                if (!(exp instanceof AST_SymbolRef)) break;\n                if (exp.name != \"Object\") break;\n                if (!exp.definition().undeclared) break;\n                mangleStrings(node.args[1]);\n                break;\n              case \"hasOwnProperty\":\n                if (node.args.length < 1) break;\n                mangleStrings(node.args[0]);\n                break;\n            }\n        } else if (node instanceof AST_ClassProperty) {\n            if (typeof node.key == \"string\") node.key = mangle(node.key);\n        } else if (node instanceof AST_Dot) {\n            node.property = mangle(node.property);\n        } else if (node instanceof AST_ObjectProperty) {\n            if (typeof node.key == \"string\") node.key = mangle(node.key);\n        } else if (node instanceof AST_Sub) {\n            if (!options.keep_quoted) mangleStrings(node.property);\n        }\n    }));\n\n    // only function declarations after this line\n\n    function can_mangle(name) {\n        if (unmangleable.has(name)) return false;\n        if (/^-?[0-9]+(\\.[0-9]+)?(e[+-][0-9]+)?$/.test(name)) return false;\n        return true;\n    }\n\n    function should_mangle(name) {\n        if (reserved.has(name)) return false;\n        if (regex && !regex.test(name)) return false;\n        return cache.has(name) || names_to_mangle.has(name);\n    }\n\n    function add(name) {\n        if (can_mangle(name)) names_to_mangle.set(name, true);\n        if (!should_mangle(name)) unmangleable.set(name, true);\n    }\n\n    function mangle(name) {\n        if (!should_mangle(name)) return name;\n        var mangled = cache.get(name);\n        if (!mangled) {\n            if (debug) {\n                // debug mode: use a prefix and suffix to preserve readability, e.g. o.foo ---> o._$foo$NNN_.\n                var debug_mangled = \"_$\" + name + \"$\" + debug_suffix + \"_\";\n                if (can_mangle(debug_mangled)) mangled = debug_mangled;\n            }\n            // either debug mode is off, or it is on and we could not use the mangled name\n            if (!mangled) do {\n                mangled = base54(++cname);\n            } while (!can_mangle(mangled));\n            if (/^#/.test(name)) mangled = \"#\" + mangled;\n            cache.set(name, mangled);\n        }\n        return mangled;\n    }\n\n    function mangleStrings(node) {\n        if (node instanceof AST_Sequence) {\n            mangleStrings(node.expressions.tail_node());\n        } else if (node instanceof AST_String) {\n            node.value = mangle(node.value);\n        } else if (node instanceof AST_Conditional) {\n            mangleStrings(node.consequent);\n            mangleStrings(node.alternative);\n        }\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction SymbolDef(id, scope, orig, init) {\n    this._bits = 0;\n    this.defun = undefined;\n    this.eliminated = 0;\n    this.id = id;\n    this.init = init;\n    this.mangled_name = null;\n    this.name = orig.name;\n    this.orig = [ orig ];\n    this.references = [];\n    this.replaced = 0;\n    this.safe_ids = undefined;\n    this.scope = scope;\n}\n\nSymbolDef.prototype = {\n    forEach: function(fn) {\n        this.orig.forEach(fn);\n        this.references.forEach(fn);\n    },\n    mangle: function(options) {\n        var cache = options.cache && options.cache.props;\n        if (this.global && cache && cache.has(this.name)) {\n            this.mangled_name = cache.get(this.name);\n        } else if (!this.mangled_name && !this.unmangleable(options)) {\n            var def = this.redefined();\n            if (def) {\n                this.mangled_name = def.mangled_name || def.name;\n            } else {\n                this.mangled_name = next_mangled_name(this, options);\n            }\n            if (this.global && cache) {\n                cache.set(this.name, this.mangled_name);\n            }\n        }\n    },\n    redefined: function() {\n        var self = this;\n        var scope = self.defun;\n        if (!scope) return;\n        var name = self.name;\n        var def = scope.variables.get(name)\n            || scope instanceof AST_Toplevel && scope.globals.get(name)\n            || self.orig[0] instanceof AST_SymbolConst && find_if(function(def) {\n                return def.name == name;\n            }, scope.enclosed);\n        if (def && def !== self) return def.redefined() || def;\n    },\n    unmangleable: function(options) {\n        return this.global && !options.toplevel\n            || this.exported\n            || this.undeclared\n            || !options.eval && this.scope.pinned()\n            || options.keep_fnames\n                && (this.orig[0] instanceof AST_SymbolClass\n                    || this.orig[0] instanceof AST_SymbolDefClass\n                    || this.orig[0] instanceof AST_SymbolDefun\n                    || this.orig[0] instanceof AST_SymbolLambda);\n    },\n};\n\nDEF_BITPROPS(SymbolDef, [\n    \"const_redefs\",\n    \"cross_loop\",\n    \"direct_access\",\n    \"exported\",\n    \"global\",\n    \"undeclared\",\n]);\n\nvar unary_side_effects = makePredicate(\"delete ++ --\");\n\nfunction is_lhs(node, parent) {\n    if (parent instanceof AST_Assign) return parent.left === node && node;\n    if (parent instanceof AST_DefaultValue) return parent.name === node && node;\n    if (parent instanceof AST_Destructured) return node;\n    if (parent instanceof AST_DestructuredKeyVal) return node;\n    if (parent instanceof AST_ForEnumeration) return parent.init === node && node;\n    if (parent instanceof AST_Unary) return unary_side_effects[parent.operator] && parent.expression;\n}\n\nAST_Toplevel.DEFMETHOD(\"figure_out_scope\", function(options) {\n    options = defaults(options, {\n        cache: null,\n        ie: false,\n    });\n\n    // pass 1: setup scope chaining and handle definitions\n    var self = this;\n    var defun = null;\n    var exported = false;\n    var next_def_id = 0;\n    var scope = self.parent_scope = null;\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_DefClass) {\n            var save_exported = exported;\n            exported = tw.parent() instanceof AST_ExportDeclaration;\n            node.name.walk(tw);\n            exported = save_exported;\n            walk_scope(function() {\n                if (node.extends) node.extends.walk(tw);\n                node.properties.forEach(function(prop) {\n                    prop.walk(tw);\n                });\n            });\n            return true;\n        }\n        if (node instanceof AST_Definitions) {\n            var save_exported = exported;\n            exported = tw.parent() instanceof AST_ExportDeclaration;\n            descend();\n            exported = save_exported;\n            return true;\n        }\n        if (node instanceof AST_LambdaDefinition) {\n            var save_exported = exported;\n            exported = tw.parent() instanceof AST_ExportDeclaration;\n            node.name.walk(tw);\n            exported = save_exported;\n            walk_scope(function() {\n                node.argnames.forEach(function(argname) {\n                    argname.walk(tw);\n                });\n                if (node.rest) node.rest.walk(tw);\n                walk_body(node, tw);\n            });\n            return true;\n        }\n        if (node instanceof AST_SwitchBranch) {\n            node.init_vars(scope);\n            descend();\n            return true;\n        }\n        if (node instanceof AST_Try) {\n            walk_scope(function() {\n                walk_body(node, tw);\n            });\n            if (node.bcatch) node.bcatch.walk(tw);\n            if (node.bfinally) node.bfinally.walk(tw);\n            return true;\n        }\n        if (node instanceof AST_With) {\n            var s = scope;\n            do {\n                s = s.resolve();\n                if (s.uses_with) break;\n                s.uses_with = true;\n            } while (s = s.parent_scope);\n            walk_scope(descend);\n            return true;\n        }\n        if (node instanceof AST_BlockScope) {\n            walk_scope(descend);\n            return true;\n        }\n        if (node instanceof AST_Symbol) {\n            node.scope = scope;\n        }\n        if (node instanceof AST_Label) {\n            node.thedef = node;\n            node.references = [];\n        }\n        if (node instanceof AST_SymbolCatch) {\n            scope.def_variable(node).defun = defun;\n        } else if (node instanceof AST_SymbolConst) {\n            var def = scope.def_variable(node);\n            def.defun = defun;\n            if (exported) def.exported = true;\n        } else if (node instanceof AST_SymbolDefun) {\n            var def = defun.def_function(node, tw.parent());\n            if (exported) def.exported = true;\n            entangle(defun, scope);\n        } else if (node instanceof AST_SymbolFunarg) {\n            defun.def_variable(node);\n            entangle(defun, scope);\n        } else if (node instanceof AST_SymbolLambda) {\n            var def = defun.def_function(node, node.name == \"arguments\" ? undefined : defun);\n            if (options.ie) def.defun = defun.parent_scope.resolve();\n        } else if (node instanceof AST_SymbolLet) {\n            var def = scope.def_variable(node);\n            if (exported) def.exported = true;\n        } else if (node instanceof AST_SymbolVar) {\n            var def = defun.def_variable(node, node instanceof AST_SymbolImport ? undefined : null);\n            if (exported) def.exported = true;\n            entangle(defun, scope);\n        }\n\n        function walk_scope(descend) {\n            node.init_vars(scope);\n            var save_defun = defun;\n            var save_scope = scope;\n            if (node instanceof AST_Scope) defun = node;\n            scope = node;\n            descend();\n            scope = save_scope;\n            defun = save_defun;\n        }\n\n        function entangle(defun, scope) {\n            if (defun === scope) return;\n            node.mark_enclosed(options);\n            var def = scope.find_variable(node.name);\n            if (node.thedef === def) return;\n            node.thedef = def;\n            def.orig.push(node);\n            node.mark_enclosed(options);\n        }\n    });\n    self.make_def = function(orig, init) {\n        return new SymbolDef(++next_def_id, this, orig, init);\n    };\n    self.walk(tw);\n\n    // pass 2: find back references and eval\n    self.globals = new Dictionary();\n    var in_arg = [];\n    var tw = new TreeWalker(function(node) {\n        if (node instanceof AST_Catch) {\n            if (!(node.argname instanceof AST_Destructured)) return;\n            in_arg.push(node);\n            node.argname.walk(tw);\n            in_arg.pop();\n            walk_body(node, tw);\n            return true;\n        }\n        if (node instanceof AST_Lambda) {\n            in_arg.push(node);\n            node.argnames.forEach(function(argname) {\n                argname.walk(tw);\n            });\n            if (node.rest) node.rest.walk(tw);\n            in_arg.pop();\n            walk_lambda(node, tw);\n            return true;\n        }\n        if (node instanceof AST_LoopControl) {\n            if (node.label) node.label.thedef.references.push(node);\n            return true;\n        }\n        if (node instanceof AST_SymbolDeclaration) {\n            var def = node.definition();\n            def.preinit = def.references.length;\n            if (node instanceof AST_SymbolCatch) {\n                // ensure mangling works if `catch` reuses a scope variable\n                var redef = def.redefined();\n                if (redef) for (var s = node.scope; s; s = s.parent_scope) {\n                    push_uniq(s.enclosed, redef);\n                    if (s === redef.scope) break;\n                }\n            } else if (node instanceof AST_SymbolConst) {\n                // ensure compression works if `const` reuses a scope variable\n                var redef = def.redefined();\n                if (redef) redef.const_redefs = true;\n            }\n            if (node.name != \"arguments\") return true;\n            var parent = node instanceof AST_SymbolVar && tw.parent();\n            if (parent instanceof AST_VarDef && !parent.value) return true;\n            var sym = node.scope.resolve().find_variable(\"arguments\");\n            if (sym && is_arguments(sym)) sym.scope.uses_arguments = 3;\n            return true;\n        }\n        if (node instanceof AST_SymbolRef) {\n            var name = node.name;\n            var sym = node.scope.find_variable(name);\n            for (var i = in_arg.length; i > 0 && sym;) {\n                i = in_arg.lastIndexOf(sym.scope, i - 1);\n                if (i < 0) break;\n                var decl = sym.orig[0];\n                if (decl instanceof AST_SymbolCatch\n                    || decl instanceof AST_SymbolFunarg\n                    || decl instanceof AST_SymbolLambda) {\n                    node.in_arg = true;\n                    break;\n                }\n                sym = sym.scope.parent_scope.find_variable(name);\n            }\n            if (!sym) {\n                sym = self.def_global(node);\n            } else if (name == \"arguments\" && is_arguments(sym)) {\n                var parent = tw.parent();\n                if (is_lhs(node, parent)) {\n                    sym.scope.uses_arguments = 3;\n                } else if (sym.scope.uses_arguments < 2\n                    && !(parent instanceof AST_PropAccess && parent.expression === node)) {\n                    sym.scope.uses_arguments = 2;\n                } else if (!sym.scope.uses_arguments) {\n                    sym.scope.uses_arguments = true;\n                }\n            }\n            if (name == \"eval\") {\n                var parent = tw.parent();\n                if (parent.TYPE == \"Call\" && parent.expression === node) {\n                    var s = node.scope;\n                    do {\n                        s = s.resolve();\n                        if (s.uses_eval) break;\n                        s.uses_eval = true;\n                    } while (s = s.parent_scope);\n                } else if (sym.undeclared) {\n                    self.uses_eval = true;\n                }\n            }\n            if (sym.init instanceof AST_LambdaDefinition && sym.scope !== sym.init.name.scope) {\n                var scope = node.scope;\n                do {\n                    if (scope === sym.init.name.scope) break;\n                } while (scope = scope.parent_scope);\n                if (!scope) sym.init = undefined;\n            }\n            node.thedef = sym;\n            node.reference(options);\n            return true;\n        }\n    });\n    self.walk(tw);\n\n    // pass 3: fix up any scoping issue with IE8\n    if (options.ie) self.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_SymbolCatch) {\n            var scope = node.thedef.defun;\n            if (scope.name instanceof AST_SymbolLambda && scope.name.name == node.name) {\n                scope = scope.parent_scope.resolve();\n            }\n            redefine(node, scope);\n            return true;\n        }\n        if (node instanceof AST_SymbolLambda) {\n            var def = node.thedef;\n            if (!redefine(node, node.scope.parent_scope.resolve())) {\n                def.defun = undefined;\n            } else if (typeof node.thedef.init !== \"undefined\") {\n                node.thedef.init = false;\n            } else if (def.init) {\n                node.thedef.init = def.init;\n            }\n            return true;\n        }\n    }));\n\n    function is_arguments(sym) {\n        return sym.orig[0] instanceof AST_SymbolFunarg\n            && !(sym.orig[1] instanceof AST_SymbolFunarg || sym.orig[2] instanceof AST_SymbolFunarg)\n            && !is_arrow(sym.scope);\n    }\n\n    function redefine(node, scope) {\n        var name = node.name;\n        var old_def = node.thedef;\n        if (!all(old_def.orig, function(sym) {\n            return !(sym instanceof AST_SymbolConst || sym instanceof AST_SymbolLet);\n        })) return false;\n        var new_def = scope.find_variable(name);\n        if (new_def) {\n            var redef = new_def.redefined();\n            if (redef) new_def = redef;\n        } else {\n            new_def = self.globals.get(name);\n        }\n        if (new_def) {\n            new_def.orig.push(node);\n        } else {\n            new_def = scope.def_variable(node);\n        }\n        if (new_def.undeclared) self.variables.set(name, new_def);\n        if (name == \"arguments\" && is_arguments(old_def) && node instanceof AST_SymbolLambda) return true;\n        old_def.defun = new_def.scope;\n        old_def.forEach(function(node) {\n            node.redef = old_def;\n            node.thedef = new_def;\n            node.reference(options);\n        });\n        return true;\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"def_global\", function(node) {\n    var globals = this.globals, name = node.name;\n    if (globals.has(name)) {\n        return globals.get(name);\n    } else {\n        var g = this.make_def(node);\n        g.undeclared = true;\n        g.global = true;\n        globals.set(name, g);\n        return g;\n    }\n});\n\nfunction init_block_vars(scope, parent) {\n    scope.enclosed = [];                            // variables from this or outer scope(s) that are referenced from this or inner scopes\n    scope.parent_scope = parent;                    // the parent scope (null if this is the top level)\n    scope.functions = new Dictionary();             // map name to AST_SymbolDefun (functions defined in this scope)\n    scope.variables = new Dictionary();             // map name to AST_SymbolVar (variables defined in this scope; includes functions)\n    if (parent) scope.make_def = parent.make_def;   // top-level tracking of SymbolDef instances\n}\n\nfunction init_scope_vars(scope, parent) {\n    init_block_vars(scope, parent);\n    scope.uses_eval = false;                        // will be set to true if this or nested scope uses the global `eval`\n    scope.uses_with = false;                        // will be set to true if this or some nested scope uses the `with` statement\n}\n\nAST_BlockScope.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_block_vars(this, parent_scope);\n});\nAST_Scope.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n});\nAST_Arrow.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n    return this;\n});\nAST_AsyncArrow.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n});\nAST_Lambda.DEFMETHOD(\"init_vars\", function(parent_scope) {\n    init_scope_vars(this, parent_scope);\n    this.uses_arguments = false;\n    this.def_variable(new AST_SymbolFunarg({\n        name: \"arguments\",\n        start: this.start,\n        end: this.end,\n    }));\n    return this;\n});\n\nAST_Symbol.DEFMETHOD(\"mark_enclosed\", function(options) {\n    var def = this.definition();\n    for (var s = this.scope; s; s = s.parent_scope) {\n        push_uniq(s.enclosed, def);\n        if (!options) {\n            s._var_names = undefined;\n        } else if (options.keep_fnames) {\n            s.functions.each(function(d) {\n                push_uniq(def.scope.enclosed, d);\n            });\n        }\n        if (s === def.scope) break;\n    }\n});\n\nAST_Symbol.DEFMETHOD(\"reference\", function(options) {\n    this.definition().references.push(this);\n    this.mark_enclosed(options);\n});\n\nAST_BlockScope.DEFMETHOD(\"find_variable\", function(name) {\n    return this.variables.get(name)\n        || this.parent_scope && this.parent_scope.find_variable(name);\n});\n\nAST_BlockScope.DEFMETHOD(\"def_function\", function(symbol, init) {\n    var def = this.def_variable(symbol, init);\n    if (!def.init || def.init instanceof AST_LambdaDefinition) def.init = init;\n    this.functions.set(symbol.name, def);\n    return def;\n});\n\nAST_BlockScope.DEFMETHOD(\"def_variable\", function(symbol, init) {\n    var def = this.variables.get(symbol.name);\n    if (def) {\n        def.orig.push(symbol);\n        if (def.init instanceof AST_LambdaExpression) def.init = init;\n    } else {\n        def = this.make_def(symbol, init);\n        this.variables.set(symbol.name, def);\n        def.global = !this.parent_scope;\n    }\n    return symbol.thedef = def;\n});\n\nfunction names_in_use(scope, options) {\n    var names = scope.names_in_use;\n    if (!names) {\n        scope.cname = -1;\n        scope.cname_holes = [];\n        scope.names_in_use = names = new Dictionary();\n        var cache = options.cache && options.cache.props;\n        scope.enclosed.forEach(function(def) {\n            if (def.unmangleable(options)) names.set(def.name, true);\n            if (def.global && cache && cache.has(def.name)) {\n                names.set(cache.get(def.name), true);\n            }\n        });\n    }\n    return names;\n}\n\nfunction next_mangled_name(def, options) {\n    var scope = def.scope;\n    var in_use = names_in_use(scope, options);\n    var holes = scope.cname_holes;\n    var names = new Dictionary();\n    var scopes = [ scope ];\n    def.forEach(function(sym) {\n        var scope = sym.scope;\n        do {\n            if (member(scope, scopes)) break;\n            names_in_use(scope, options).each(function(marker, name) {\n                names.set(name, marker);\n            });\n            scopes.push(scope);\n        } while (scope = scope.parent_scope);\n    });\n    var name;\n    for (var i = 0; i < holes.length; i++) {\n        name = base54(holes[i]);\n        if (names.has(name)) continue;\n        holes.splice(i, 1);\n        in_use.set(name, true);\n        return name;\n    }\n    while (true) {\n        name = base54(++scope.cname);\n        if (in_use.has(name) || RESERVED_WORDS[name] || options.reserved.has[name]) continue;\n        if (!names.has(name)) break;\n        holes.push(scope.cname);\n    }\n    in_use.set(name, true);\n    return name;\n}\n\nAST_Symbol.DEFMETHOD(\"unmangleable\", function(options) {\n    var def = this.definition();\n    return !def || def.unmangleable(options);\n});\n\n// labels are always mangleable\nAST_Label.DEFMETHOD(\"unmangleable\", return_false);\n\nAST_Symbol.DEFMETHOD(\"definition\", function() {\n    return this.thedef;\n});\n\nfunction _default_mangler_options(options) {\n    options = defaults(options, {\n        eval        : false,\n        ie          : false,\n        keep_fnames : false,\n        reserved    : [],\n        toplevel    : false,\n        v8          : false,\n        webkit      : false,\n    });\n    if (!Array.isArray(options.reserved)) options.reserved = [];\n    // Never mangle arguments\n    push_uniq(options.reserved, \"arguments\");\n    options.reserved.has = makePredicate(options.reserved);\n    return options;\n}\n\nAST_Toplevel.DEFMETHOD(\"mangle_names\", function(options) {\n    options = _default_mangler_options(options);\n\n    // We only need to mangle declaration nodes.  Special logic wired\n    // into the code generator will display the mangled name if it's\n    // present (and for AST_SymbolRef-s it'll use the mangled name of\n    // the AST_SymbolDeclaration that it points to).\n    var lname = -1;\n\n    if (options.cache && options.cache.props) {\n        var mangled_names = names_in_use(this, options);\n        options.cache.props.each(function(mangled_name) {\n            mangled_names.set(mangled_name, true);\n        });\n    }\n\n    var redefined = [];\n    var tw = new TreeWalker(function(node, descend) {\n        if (node instanceof AST_LabeledStatement) {\n            // lname is incremented when we get to the AST_Label\n            var save_nesting = lname;\n            descend();\n            if (!options.v8 || !in_label(tw)) lname = save_nesting;\n            return true;\n        }\n        if (node instanceof AST_BlockScope) {\n            if (options.webkit && node instanceof AST_IterationStatement && node.init instanceof AST_Let) {\n                node.init.definitions.forEach(function(defn) {\n                    defn.name.match_symbol(function(sym) {\n                        if (!(sym instanceof AST_SymbolLet)) return;\n                        var def = sym.definition();\n                        var scope = sym.scope.parent_scope;\n                        var redef = scope.def_variable(sym);\n                        sym.thedef = def;\n                        scope.to_mangle.push(redef);\n                        def.redefined = function() {\n                            return redef;\n                        };\n                    });\n                }, true);\n            }\n            node.to_mangle = [];\n            node.variables.each(function(def) {\n                if (!defer_redef(def)) node.to_mangle.push(def);\n            });\n            descend();\n            if (options.cache && node instanceof AST_Toplevel) {\n                node.globals.each(mangle);\n            }\n            if (node instanceof AST_Defun && tw.has_directive(\"use asm\")) {\n                var sym = new AST_SymbolRef(node.name);\n                sym.scope = node;\n                sym.reference(options);\n            }\n            node.to_mangle.forEach(mangle);\n            return true;\n        }\n        if (node instanceof AST_Label) {\n            var name;\n            do {\n                name = base54(++lname);\n            } while (RESERVED_WORDS[name]);\n            node.mangled_name = name;\n            return true;\n        }\n    });\n    this.walk(tw);\n    redefined.forEach(mangle);\n\n    function mangle(def) {\n        if (options.reserved.has[def.name]) return;\n        def.mangle(options);\n    }\n\n    function defer_redef(def) {\n        var sym = def.orig[0];\n        var redef = def.redefined();\n        if (!redef) {\n            if (!(sym instanceof AST_SymbolConst)) return false;\n            var scope = def.scope.resolve();\n            if (def.scope === scope) return false;\n            if (def.scope.parent_scope.find_variable(sym.name)) return false;\n            redef = scope.def_variable(sym);\n            scope.to_mangle.push(redef);\n        }\n        redefined.push(def);\n        def.references.forEach(reference);\n        if (sym instanceof AST_SymbolCatch || sym instanceof AST_SymbolConst) reference(sym);\n        return true;\n\n        function reference(sym) {\n            sym.thedef = redef;\n            sym.reference(options);\n            sym.thedef = def;\n        }\n    }\n\n    function in_label(tw) {\n        var level = 0, parent;\n        while (parent = tw.parent(level++)) {\n            if (parent instanceof AST_Block) return parent instanceof AST_Toplevel && !options.toplevel;\n            if (parent instanceof AST_LabeledStatement) return true;\n        }\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"find_colliding_names\", function(options) {\n    var cache = options.cache && options.cache.props;\n    var avoid = Object.create(RESERVED_WORDS);\n    options.reserved.forEach(to_avoid);\n    this.globals.each(add_def);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_BlockScope) node.variables.each(add_def);\n    }));\n    return avoid;\n\n    function to_avoid(name) {\n        avoid[name] = true;\n    }\n\n    function add_def(def) {\n        var name = def.name;\n        if (def.global && cache && cache.has(name)) name = cache.get(name);\n        else if (!def.unmangleable(options)) return;\n        to_avoid(name);\n    }\n});\n\nAST_Toplevel.DEFMETHOD(\"expand_names\", function(options) {\n    base54.reset();\n    base54.sort();\n    options = _default_mangler_options(options);\n    var avoid = this.find_colliding_names(options);\n    var cname = 0;\n    this.globals.each(rename);\n    this.walk(new TreeWalker(function(node) {\n        if (node instanceof AST_BlockScope) node.variables.each(rename);\n    }));\n\n    function next_name() {\n        var name;\n        do {\n            name = base54(cname++);\n        } while (avoid[name]);\n        return name;\n    }\n\n    function rename(def) {\n        if (def.global && options.cache) return;\n        if (def.unmangleable(options)) return;\n        if (options.reserved.has[def.name]) return;\n        var redef = def.redefined();\n        var name = redef ? redef.rename || redef.name : next_name();\n        def.rename = name;\n        def.forEach(function(sym) {\n            if (sym.definition() === def) sym.name = name;\n        });\n    }\n});\n\nAST_Node.DEFMETHOD(\"tail_node\", return_this);\nAST_Sequence.DEFMETHOD(\"tail_node\", function() {\n    return this.expressions[this.expressions.length - 1];\n});\n\nAST_Toplevel.DEFMETHOD(\"compute_char_frequency\", function(options) {\n    options = _default_mangler_options(options);\n    base54.reset();\n    var fn = AST_Symbol.prototype.add_source_map;\n    try {\n        AST_Symbol.prototype.add_source_map = function() {\n            if (!this.unmangleable(options)) base54.consider(this.name, -1);\n        };\n        if (options.properties) {\n            AST_Dot.prototype.add_source_map = function() {\n                base54.consider(this.property, -1);\n            };\n            AST_Sub.prototype.add_source_map = function() {\n                skip_string(this.property);\n            };\n        }\n        base54.consider(this.print_to_string(), 1);\n    } finally {\n        AST_Symbol.prototype.add_source_map = fn;\n        delete AST_Dot.prototype.add_source_map;\n        delete AST_Sub.prototype.add_source_map;\n    }\n    base54.sort();\n\n    function skip_string(node) {\n        if (node instanceof AST_String) {\n            base54.consider(node.value, -1);\n        } else if (node instanceof AST_Conditional) {\n            skip_string(node.consequent);\n            skip_string(node.alternative);\n        } else if (node instanceof AST_Sequence) {\n            skip_string(node.tail_node());\n        }\n    }\n});\n\nvar base54 = (function() {\n    var freq = Object.create(null);\n    function init(chars) {\n        var array = [];\n        for (var i = 0; i < chars.length; i++) {\n            var ch = chars[i];\n            array.push(ch);\n            freq[ch] = -1e-2 * i;\n        }\n        return array;\n    }\n    var digits = init(\"0123456789\");\n    var leading = init(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_\");\n    var chars, frequency;\n    function reset() {\n        chars = null;\n        frequency = Object.create(freq);\n    }\n    base54.consider = function(str, delta) {\n        for (var i = str.length; --i >= 0;) {\n            frequency[str[i]] += delta;\n        }\n    };\n    function compare(a, b) {\n        return frequency[b] - frequency[a];\n    }\n    base54.sort = function() {\n        chars = leading.sort(compare).concat(digits).sort(compare);\n    };\n    base54.reset = reset;\n    reset();\n    function base54(num) {\n        var ret = leading[num % 54];\n        for (num = Math.floor(num / 54); --num >= 0; num >>= 6) {\n            ret += chars[num & 0x3F];\n        }\n        return ret;\n    }\n    return base54;\n})();\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nvar vlq_char = characters(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\nvar vlq_bits = vlq_char.reduce(function(map, ch, bits) {\n    map[ch] = bits;\n    return map;\n}, Object.create(null));\n\nfunction vlq_decode(indices, str) {\n    var value = 0;\n    var shift = 0;\n    for (var i = 0, j = 0; i < str.length; i++) {\n        var bits = vlq_bits[str[i]];\n        value += (bits & 31) << shift;\n        if (bits & 32) {\n            shift += 5;\n        } else {\n            indices[j++] += value & 1 ? 0x80000000 | -(value >> 1) : value >> 1;\n            value = shift = 0;\n        }\n    }\n    return j;\n}\n\nfunction vlq_encode(num) {\n    var result = \"\";\n    num = Math.abs(num) << 1 | num >>> 31;\n    do {\n        var bits = num & 31;\n        if (num >>>= 5) bits |= 32;\n        result += vlq_char[bits];\n    } while (num);\n    return result;\n}\n\nfunction create_array_map() {\n    var map = new Dictionary();\n    var array = [];\n    array.index = function(name) {\n        var index = map.get(name);\n        if (!(index >= 0)) {\n            index = array.length;\n            array.push(name);\n            map.set(name, index);\n        }\n        return index;\n    };\n    return array;\n}\n\nfunction SourceMap(options) {\n    var sources = create_array_map();\n    var sources_content = options.includeSources && new Dictionary();\n    var names = create_array_map();\n    var mappings = \"\";\n    if (options.orig) Object.keys(options.orig).forEach(function(name) {\n        var map = options.orig[name];\n        var indices = [ 0, 0, 1, 0, 0 ];\n        options.orig[name] = {\n            names: map.names,\n            mappings: map.mappings.split(/;/).map(function(line) {\n                indices[0] = 0;\n                return line.split(/,/).map(function(segment) {\n                    return indices.slice(0, vlq_decode(indices, segment));\n                });\n            }),\n            sources: map.sources,\n        };\n        if (!sources_content || !map.sourcesContent) return;\n        for (var i = 0; i < map.sources.length; i++) {\n            var content = map.sourcesContent[i];\n            if (content) sources_content.set(map.sources[i], content);\n        }\n    });\n    var prev_source;\n    var generated_line = 1;\n    var generated_column = 0;\n    var source_index = 0;\n    var original_line = 1;\n    var original_column = 0;\n    var name_index = 0;\n    return {\n        add: options.orig ? function(source, gen_line, gen_col, orig_line, orig_col, name) {\n            var map = options.orig[source];\n            if (map) {\n                var segments = map.mappings[orig_line - 1];\n                if (!segments) return;\n                var indices;\n                for (var i = 0; i < segments.length; i++) {\n                    var col = segments[i][0];\n                    if (orig_col >= col) indices = segments[i];\n                    if (orig_col <= col) break;\n                }\n                if (!indices || indices.length < 4) {\n                    source = null;\n                } else {\n                    source = map.sources[indices[1]];\n                    orig_line = indices[2];\n                    orig_col = indices[3];\n                    if (indices.length > 4) name = map.names[indices[4]];\n                }\n            }\n            add(source, gen_line, gen_col, orig_line, orig_col, name);\n        } : add,\n        setSourceContent: sources_content ? function(source, content) {\n            if (!sources_content.has(source)) {\n                sources_content.set(source, content);\n            }\n        } : noop,\n        toString: function() {\n            return JSON.stringify({\n                version: 3,\n                file: options.filename || undefined,\n                sourceRoot: options.root || undefined,\n                sources: sources,\n                sourcesContent: sources_content ? sources.map(function(source) {\n                    return sources_content.get(source) || null;\n                }) : undefined,\n                names: names,\n                mappings: mappings,\n            });\n        }\n    };\n\n    function add(source, gen_line, gen_col, orig_line, orig_col, name) {\n        if (prev_source == null && source == null) return;\n        prev_source = source;\n        if (generated_line < gen_line) {\n            generated_column = 0;\n            do {\n                mappings += \";\";\n            } while (++generated_line < gen_line);\n        } else if (mappings) {\n            mappings += \",\";\n        }\n        mappings += vlq_encode(gen_col - generated_column);\n        generated_column = gen_col;\n        if (source == null) return;\n        var src_idx = sources.index(source);\n        mappings += vlq_encode(src_idx - source_index);\n        source_index = src_idx;\n        mappings += vlq_encode(orig_line - original_line);\n        original_line = orig_line;\n        mappings += vlq_encode(orig_col - original_column);\n        original_column = orig_col;\n        if (options.names && name != null) {\n            var name_idx = names.index(name);\n            mappings += vlq_encode(name_idx - name_index);\n            name_index = name_idx;\n        }\n    }\n}\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction TreeTransformer(before, after) {\n    TreeWalker.call(this);\n    this.before = before;\n    this.after = after;\n}\nTreeTransformer.prototype = new TreeWalker;\n\n(function(DEF) {\n    function do_list(list, tw) {\n        return List(list, function(node) {\n            return node.transform(tw, true);\n        });\n    }\n\n    DEF(AST_Node, noop);\n    DEF(AST_LabeledStatement, function(self, tw) {\n        self.label = self.label.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_SimpleStatement, function(self, tw) {\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_Block, function(self, tw) {\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Do, function(self, tw) {\n        self.body = self.body.transform(tw);\n        self.condition = self.condition.transform(tw);\n    });\n    DEF(AST_While, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_For, function(self, tw) {\n        if (self.init) self.init = self.init.transform(tw);\n        if (self.condition) self.condition = self.condition.transform(tw);\n        if (self.step) self.step = self.step.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_ForEnumeration, function(self, tw) {\n        self.init = self.init.transform(tw);\n        self.object = self.object.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_With, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_Exit, function(self, tw) {\n        if (self.value) self.value = self.value.transform(tw);\n    });\n    DEF(AST_LoopControl, function(self, tw) {\n        if (self.label) self.label = self.label.transform(tw);\n    });\n    DEF(AST_If, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.body = self.body.transform(tw);\n        if (self.alternative) self.alternative = self.alternative.transform(tw);\n    });\n    DEF(AST_Switch, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Case, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Try, function(self, tw) {\n        self.body = do_list(self.body, tw);\n        if (self.bcatch) self.bcatch = self.bcatch.transform(tw);\n        if (self.bfinally) self.bfinally = self.bfinally.transform(tw);\n    });\n    DEF(AST_Catch, function(self, tw) {\n        if (self.argname) self.argname = self.argname.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    DEF(AST_Definitions, function(self, tw) {\n        self.definitions = do_list(self.definitions, tw);\n    });\n    DEF(AST_VarDef, function(self, tw) {\n        self.name = self.name.transform(tw);\n        if (self.value) self.value = self.value.transform(tw);\n    });\n    DEF(AST_DefaultValue, function(self, tw) {\n        self.name = self.name.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n    DEF(AST_Lambda, function(self, tw) {\n        if (self.name) self.name = self.name.transform(tw);\n        self.argnames = do_list(self.argnames, tw);\n        if (self.rest) self.rest = self.rest.transform(tw);\n        self.body = do_list(self.body, tw);\n    });\n    function transform_arrow(self, tw) {\n        self.argnames = do_list(self.argnames, tw);\n        if (self.rest) self.rest = self.rest.transform(tw);\n        if (self.value) {\n            self.value = self.value.transform(tw);\n        } else {\n            self.body = do_list(self.body, tw);\n        }\n    }\n    DEF(AST_Arrow, transform_arrow);\n    DEF(AST_AsyncArrow, transform_arrow);\n    DEF(AST_Class, function(self, tw) {\n        if (self.name) self.name = self.name.transform(tw);\n        if (self.extends) self.extends = self.extends.transform(tw);\n        self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_ClassProperty, function(self, tw) {\n        if (self.key instanceof AST_Node) self.key = self.key.transform(tw);\n        if (self.value) self.value = self.value.transform(tw);\n    });\n    DEF(AST_Call, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.args = do_list(self.args, tw);\n    });\n    DEF(AST_Sequence, function(self, tw) {\n        self.expressions = do_list(self.expressions, tw);\n    });\n    DEF(AST_Await, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Yield, function(self, tw) {\n        if (self.expression) self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Dot, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Sub, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n        self.property = self.property.transform(tw);\n    });\n    DEF(AST_Spread, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Unary, function(self, tw) {\n        self.expression = self.expression.transform(tw);\n    });\n    DEF(AST_Binary, function(self, tw) {\n        self.left = self.left.transform(tw);\n        self.right = self.right.transform(tw);\n    });\n    DEF(AST_Conditional, function(self, tw) {\n        self.condition = self.condition.transform(tw);\n        self.consequent = self.consequent.transform(tw);\n        self.alternative = self.alternative.transform(tw);\n    });\n    DEF(AST_Array, function(self, tw) {\n        self.elements = do_list(self.elements, tw);\n    });\n    DEF(AST_DestructuredArray, function(self, tw) {\n        self.elements = do_list(self.elements, tw);\n        if (self.rest) self.rest = self.rest.transform(tw);\n    });\n    DEF(AST_DestructuredKeyVal, function(self, tw) {\n        if (self.key instanceof AST_Node) self.key = self.key.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n    DEF(AST_DestructuredObject, function(self, tw) {\n        self.properties = do_list(self.properties, tw);\n        if (self.rest) self.rest = self.rest.transform(tw);\n    });\n    DEF(AST_Object, function(self, tw) {\n        self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_ObjectProperty, function(self, tw) {\n        if (self.key instanceof AST_Node) self.key = self.key.transform(tw);\n        self.value = self.value.transform(tw);\n    });\n    DEF(AST_ExportDeclaration, function(self, tw) {\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_ExportDefault, function(self, tw) {\n        self.body = self.body.transform(tw);\n    });\n    DEF(AST_ExportReferences, function(self, tw) {\n        self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_Import, function(self, tw) {\n        if (self.all) self.all = self.all.transform(tw);\n        if (self.default) self.default = self.default.transform(tw);\n        if (self.properties) self.properties = do_list(self.properties, tw);\n    });\n    DEF(AST_Template, function(self, tw) {\n        if (self.tag) self.tag = self.tag.transform(tw);\n        self.expressions = do_list(self.expressions, tw);\n    });\n})(function(node, descend) {\n    node.DEFMETHOD(\"transform\", function(tw, in_list) {\n        var x, y;\n        tw.push(this);\n        if (tw.before) x = tw.before(this, descend, in_list);\n        if (typeof x === \"undefined\") {\n            x = this;\n            descend(x, tw);\n            if (tw.after) {\n                y = tw.after(x, in_list);\n                if (typeof y !== \"undefined\") x = y;\n            }\n        }\n        tw.pop();\n        return x;\n    });\n});\n","/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\nfunction characters(str) {\n    return str.split(\"\");\n}\n\nfunction member(name, array) {\n    return array.indexOf(name) >= 0;\n}\n\nfunction find_if(func, array) {\n    for (var i = array.length; --i >= 0;) if (func(array[i])) return array[i];\n}\n\nfunction repeat_string(str, i) {\n    if (i <= 0) return \"\";\n    if (i == 1) return str;\n    var d = repeat_string(str, i >> 1);\n    d += d;\n    return i & 1 ? d + str : d;\n}\n\nfunction configure_error_stack(fn) {\n    Object.defineProperty(fn.prototype, \"stack\", {\n        get: function() {\n            var err = new Error(this.message);\n            err.name = this.name;\n            try {\n                throw err;\n            } catch (e) {\n                return e.stack;\n            }\n        }\n    });\n}\n\nfunction DefaultsError(msg, defs) {\n    this.message = msg;\n    this.defs = defs;\n}\nDefaultsError.prototype = Object.create(Error.prototype);\nDefaultsError.prototype.constructor = DefaultsError;\nDefaultsError.prototype.name = \"DefaultsError\";\nconfigure_error_stack(DefaultsError);\n\nfunction defaults(args, defs, croak) {\n    if (croak) for (var i in args) {\n        if (HOP(args, i) && !HOP(defs, i)) throw new DefaultsError(\"`\" + i + \"` is not a supported option\", defs);\n    }\n    for (var i in args) {\n        if (HOP(args, i)) defs[i] = args[i];\n    }\n    return defs;\n}\n\nfunction noop() {}\nfunction return_false() { return false; }\nfunction return_true() { return true; }\nfunction return_this() { return this; }\nfunction return_null() { return null; }\n\nvar List = (function() {\n    function List(a, f) {\n        var ret = [];\n        for (var i = 0; i < a.length; i++) {\n            var val = f(a[i], i);\n            if (val === skip) continue;\n            if (val instanceof Splice) {\n                ret.push.apply(ret, val.v);\n            } else {\n                ret.push(val);\n            }\n        }\n        return ret;\n    }\n    List.is_op = function(val) {\n        return val === skip || val instanceof Splice;\n    };\n    List.splice = function(val) {\n        return new Splice(val);\n    };\n    var skip = List.skip = {};\n    function Splice(val) {\n        this.v = val;\n    }\n    return List;\n})();\n\nfunction push_uniq(array, el) {\n    if (array.indexOf(el) < 0) return array.push(el);\n}\n\nfunction string_template(text, props) {\n    return text.replace(/\\{([^{}]+)\\}/g, function(str, p) {\n        var value = props[p];\n        return value instanceof AST_Node ? value.print_to_string() : value;\n    });\n}\n\nfunction remove(array, el) {\n    var index = array.indexOf(el);\n    if (index >= 0) array.splice(index, 1);\n}\n\nfunction makePredicate(words) {\n    if (!Array.isArray(words)) words = words.split(\" \");\n    var map = Object.create(null);\n    words.forEach(function(word) {\n        map[word] = true;\n    });\n    return map;\n}\n\nfunction all(array, predicate) {\n    for (var i = array.length; --i >= 0;)\n        if (!predicate(array[i], i))\n            return false;\n    return true;\n}\n\nfunction Dictionary() {\n    this.values = Object.create(null);\n}\nDictionary.prototype = {\n    set: function(key, val) {\n        if (key == \"__proto__\") {\n            this.proto_value = val;\n        } else {\n            this.values[key] = val;\n        }\n        return this;\n    },\n    add: function(key, val) {\n        var list = this.get(key);\n        if (list) {\n            list.push(val);\n        } else {\n            this.set(key, [ val ]);\n        }\n        return this;\n    },\n    get: function(key) {\n        return key == \"__proto__\" ? this.proto_value : this.values[key];\n    },\n    del: function(key) {\n        if (key == \"__proto__\") {\n            delete this.proto_value;\n        } else {\n            delete this.values[key];\n        }\n        return this;\n    },\n    has: function(key) {\n        return key == \"__proto__\" ? \"proto_value\" in this : key in this.values;\n    },\n    all: function(predicate) {\n        for (var i in this.values)\n            if (!predicate(this.values[i], i)) return false;\n        if (\"proto_value\" in this && !predicate(this.proto_value, \"__proto__\")) return false;\n        return true;\n    },\n    each: function(f) {\n        for (var i in this.values)\n            f(this.values[i], i);\n        if (\"proto_value\" in this) f(this.proto_value, \"__proto__\");\n    },\n    size: function() {\n        return Object.keys(this.values).length + (\"proto_value\" in this);\n    },\n    map: function(f) {\n        var ret = [];\n        for (var i in this.values)\n            ret.push(f(this.values[i], i));\n        if (\"proto_value\" in this) ret.push(f(this.proto_value, \"__proto__\"));\n        return ret;\n    },\n    clone: function() {\n        var ret = new Dictionary();\n        this.each(function(value, i) {\n            ret.set(i, value);\n        });\n        return ret;\n    },\n    toObject: function() {\n        var obj = {};\n        this.each(function(value, i) {\n            obj[\"$\" + i] = value;\n        });\n        return obj;\n    },\n};\nDictionary.fromObject = function(obj) {\n    var dict = new Dictionary();\n    for (var i in obj)\n        if (HOP(obj, i)) dict.set(i.slice(1), obj[i]);\n    return dict;\n};\n\nfunction HOP(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n// return true if the node at the top of the stack (that means the\n// innermost node in the current output) is lexically the first in\n// a statement.\nfunction first_in_statement(stack, arrow, export_default) {\n    var node = stack.parent(-1);\n    for (var i = 0, p; p = stack.parent(i++); node = p) {\n        if (is_arrow(p)) {\n            return arrow && p.value === node;\n        } else if (p instanceof AST_Binary) {\n            if (p.left === node) continue;\n        } else if (p.TYPE == \"Call\") {\n            if (p.expression === node) continue;\n        } else if (p instanceof AST_Conditional) {\n            if (p.condition === node) continue;\n        } else if (p instanceof AST_ExportDefault) {\n            return export_default;\n        } else if (p instanceof AST_PropAccess) {\n            if (p.expression === node) continue;\n        } else if (p instanceof AST_Sequence) {\n            if (p.expressions[0] === node) continue;\n        } else if (p instanceof AST_SimpleStatement) {\n            return true;\n        } else if (p instanceof AST_Template) {\n            if (p.tag === node) continue;\n        } else if (p instanceof AST_UnaryPostfix) {\n            if (p.expression === node) continue;\n        }\n        return false;\n    }\n}\n\nfunction DEF_BITPROPS(ctor, props) {\n    if (props.length > 31) throw new Error(\"Too many properties: \" + props.length + \"\\n\" + props.join(\", \"));\n    props.forEach(function(name, pos) {\n        var mask = 1 << pos;\n        Object.defineProperty(ctor.prototype, name, {\n            get: function() {\n                return !!(this._bits & mask);\n            },\n            set: function(val) {\n                if (val)\n                    this._bits |= mask;\n                else\n                    this._bits &= ~mask;\n            },\n        });\n    });\n}\n","exports[\"Dictionary\"] = Dictionary;\nexports[\"is_statement\"] = is_statement;\nexports[\"List\"] = List;\nexports[\"minify\"] = minify;\nexports[\"parse\"] = parse;\nexports[\"push_uniq\"] = push_uniq;\nexports[\"TreeTransformer\"] = TreeTransformer;\nexports[\"TreeWalker\"] = TreeWalker;\n","var fs = require(\"fs\");\n\nexports.FILES = [\n    require.resolve(\"../lib/utils.js\"),\n    require.resolve(\"../lib/ast.js\"),\n    require.resolve(\"../lib/transform.js\"),\n    require.resolve(\"../lib/parse.js\"),\n    require.resolve(\"../lib/scope.js\"),\n    require.resolve(\"../lib/compress.js\"),\n    require.resolve(\"../lib/output.js\"),\n    require.resolve(\"../lib/sourcemap.js\"),\n    require.resolve(\"../lib/mozilla-ast.js\"),\n    require.resolve(\"../lib/propmangle.js\"),\n    require.resolve(\"../lib/minify.js\"),\n    require.resolve(\"./exports.js\"),\n];\n\nnew Function(\"exports\", function() {\n    var code = exports.FILES.map(function(file) {\n        return fs.readFileSync(file, \"utf8\");\n    });\n    code.push(\"exports.describe_ast = \" + describe_ast.toString());\n    return code.join(\"\\n\\n\");\n}())(exports);\n\nfunction to_comment(value) {\n    if (typeof value != \"string\") value = JSON.stringify(value, function(key, value) {\n        return typeof value == \"function\" ? \"<[ \" + value + \" ]>\" : value;\n    }, 2);\n    return \"// \" + value.replace(/\\n/g, \"\\n// \");\n}\n\nif (+process.env[\"UGLIFY_BUG_REPORT\"]) exports.minify = function(files, options) {\n    if (typeof options == \"undefined\") options = \"<<undefined>>\";\n    var code = [\n        \"// UGLIFY_BUG_REPORT\",\n        to_comment(options),\n    ];\n    if (typeof files == \"string\") {\n        code.push(\"\");\n        code.push(\"//-------------------------------------------------------------\")\n        code.push(\"// INPUT CODE\", files);\n    } else for (var name in files) {\n        code.push(\"\");\n        code.push(\"//-------------------------------------------------------------\")\n        code.push(to_comment(name), files[name]);\n    }\n    if (options.sourceMap && options.sourceMap.url) {\n        code.push(\"\");\n        code.push(\"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiJ9\");\n    }\n    var result = { code: code.join(\"\\n\") };\n    if (options.sourceMap) result.map = '{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\"}';\n    return result;\n};\n\nfunction describe_ast() {\n    var out = OutputStream({ beautify: true });\n    doitem(AST_Node);\n    return out.get() + \"\\n\";\n\n    function doitem(ctor) {\n        out.print(\"AST_\" + ctor.TYPE);\n        var props = ctor.SELF_PROPS.filter(function(prop) {\n            return !/^\\$/.test(prop);\n        });\n        if (props.length > 0) {\n            out.space();\n            out.with_parens(function() {\n                props.forEach(function(prop, i) {\n                    if (i) out.space();\n                    out.print(prop);\n                });\n            });\n        }\n        if (ctor.documentation) {\n            out.space();\n            out.print_string(ctor.documentation);\n        }\n        if (ctor.SUBCLASSES.length > 0) {\n            out.space();\n            out.with_block(function() {\n                ctor.SUBCLASSES.sort(function(a, b) {\n                    return a.TYPE < b.TYPE ? -1 : 1;\n                }).forEach(function(ctor, i) {\n                    out.indent();\n                    doitem(ctor);\n                    out.newline();\n                });\n            });\n        }\n    }\n}\n\nfunction infer_options(options) {\n    var result = exports.minify(\"\", options);\n    return result.error && result.error.defs;\n}\n\nexports.default_options = function() {\n    var defs = infer_options({ 0: 0 });\n    Object.keys(defs).forEach(function(component) {\n        var options = {};\n        options[component] = { 0: 0 };\n        if (options = infer_options(options)) {\n            defs[component] = options;\n        }\n    });\n    return defs;\n};\n","import { unified } from \"unified\";\nimport rehypeParse from \"rehype-parse\";\nimport rehypeMinifyWhitespace from \"rehype-minify-whitespace\";\n\nimport rehypePresetMinify from \"rehype-preset-minify\";\nimport App from \"./App.svelte\";\nconst omitDeep = require(\"omit-deep-lodash\");\n\ndocument.querySelectorAll(\".oissu\").forEach((element) => {\n  const ast = omitDeep(\n    unified()\n      .use(rehypeParse, {\n        fragment: true,\n        verbose: false,\n      })\n\n      .use(rehypePresetMinify)\n      .parse(element.outerHTML),\n    \"position\"\n  );\n  // const ast = unified()\n  //     .use(rehypeParse, {\n  //         fragment: true,\n  //         verbose: false,\n  //     })\n  //     .parse(element.outerHTML);\n  console.debug(\"ast\");\n  console.debug(ast);\n  element.innerHTML = \"\";\n  new App({\n    target: element,\n    props: {\n      ast: ast,\n    },\n  });\n  // }\n});\n\n// export default app;\n","/**\n * See <https://tools.ietf.org/html/rfc4647#section-3.1>\n * for more information on the algorithms.\n */\n\n/**\n * @typedef {string} Tag\n * @typedef {Array<Tag>} Tags\n * @typedef {string} Range\n * @typedef {Array<Range>} Ranges\n */\n\n/**\n * @callback Check\n * @param {Tag} tag\n * @param {Range} range\n * @returns {boolean}\n */\n\n/**\n * @callback Filter\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * @callback Lookup\n * @param {Tag|Tags} tag\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\n\n/**\n * Factory to perform a filter or a lookup.\n * This factory creates a function that accepts a list of tags and a list of\n * ranges, and contains logic to exit early for lookups.\n * `check` just has to deal with one tag and one range.\n * This match function iterates over ranges, and for each range,\n * iterates over tags.  That way, earlier ranges matching any tag have\n * precedence over later ranges.\n *\n * @type {{\n *   (check: Check, filter: true): Filter\n *   (check: Check, filter?: false): Lookup\n * }}\n */\n// prettier-ignore\nconst factory = (\n  /**\n   * @param {Check} check\n   * @param {boolean} [filter=false]\n   */\n  function (check, filter) {\n    return match\n\n    /**\n     * @param {Tag|Tags} tags\n     * @param {Range|Ranges} [ranges='*']\n     * @returns {Tag|Tags|undefined}\n     */\n    function match(tags, ranges) {\n      let left = cast(tags, 'tag')\n      const right = cast(\n        ranges === null || ranges === undefined ? '*' : ranges,\n        'range'\n      )\n      /** @type {Tags} */\n      const matches = []\n      let rightIndex = -1\n\n      while (++rightIndex < right.length) {\n        const range = right[rightIndex].toLowerCase()\n\n        // Ignore wildcards in lookup mode.\n        if (!filter && range === '*') continue\n\n        let leftIndex = -1\n        /** @type {Tags} */\n        const next = []\n\n        while (++leftIndex < left.length) {\n          if (check(left[leftIndex].toLowerCase(), range)) {\n            // Exit if this is a lookup and we have a match.\n            if (!filter) return left[leftIndex]\n            matches.push(left[leftIndex])\n          } else {\n            next.push(left[leftIndex])\n          }\n        }\n\n        left = next\n      }\n\n      // If this is a filter, return the list.  If its a lookup, we didnt find\n      // a match, so return `undefined`.\n      return filter ? matches : undefined\n    }\n  }\n)\n\n/**\n * Basic Filtering (Section 3.3.1) matches a language priority list consisting\n * of basic language ranges (Section 2.1) to sets of language tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport const basicFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    return range === '*' || tag === range || tag.includes(range + '-')\n  },\n  true\n)\n\n/**\n * Extended Filtering (Section 3.3.2) matches a language priority list\n * consisting of extended language ranges (Section 2.2) to sets of language\n * tags.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tags}\n */\nexport const extendedFilter = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    // 3.3.2.1\n    const left = tag.split('-')\n    const right = range.split('-')\n    let leftIndex = 0\n    let rightIndex = 0\n\n    // 3.3.2.2\n    if (right[rightIndex] !== '*' && left[leftIndex] !== right[rightIndex]) {\n      return false\n    }\n\n    leftIndex++\n    rightIndex++\n\n    // 3.3.2.3\n    while (rightIndex < right.length) {\n      // 3.3.2.3.A\n      if (right[rightIndex] === '*') {\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.B\n      if (!left[leftIndex]) return false\n\n      // 3.3.2.3.C\n      if (left[leftIndex] === right[rightIndex]) {\n        leftIndex++\n        rightIndex++\n        continue\n      }\n\n      // 3.3.2.3.D\n      if (left[leftIndex].length === 1) return false\n\n      // 3.3.2.3.E\n      leftIndex++\n    }\n\n    // 3.3.2.4\n    return true\n  },\n  true\n)\n\n/**\n * Lookup (Section 3.4) matches a language priority list consisting of basic\n * language ranges to sets of language tags to find the one exact language tag\n * that best matches the range.\n * @param {Tag|Tags} tags\n * @param {Range|Ranges} [ranges]\n * @returns {Tag}\n */\nexport const lookup = factory(\n  /** @type {Check} */\n  function (tag, range) {\n    let right = range\n\n    /* eslint-disable-next-line no-constant-condition */\n    while (true) {\n      if (right === '*' || tag === right) return true\n\n      let index = right.lastIndexOf('-')\n\n      if (index < 0) return false\n\n      if (right.charAt(index - 2) === '-') index -= 2\n\n      right = right.slice(0, index)\n    }\n  }\n)\n\n/**\n * Validate tags or ranges, and cast them to arrays.\n *\n * @param {string|Array<string>} values\n * @param {string} name\n * @returns {Array<string>}\n */\nfunction cast(values, name) {\n  const value = values && typeof values === 'string' ? [values] : values\n\n  if (!value || typeof value !== 'object' || !('length' in value)) {\n    throw new Error(\n      'Invalid ' + name + ' `' + value + '`, expected non-empty string'\n    )\n  }\n\n  return value\n}\n","/**\n * @typedef {'script'|'region'|'variants'} Field\n *\n * @typedef AddOrRemove\n * @property {Field} field\n * @property {string} value\n *\n * @typedef Change\n * @property {AddOrRemove} from\n * @property {AddOrRemove} to\n */\n\n/**\n * @type {Array<Change>}\n */\nexport const fields = [\n  {\n    from: {\n      field: 'script',\n      value: 'qaai'\n    },\n    to: {\n      field: 'script',\n      value: 'zinh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'bu'\n    },\n    to: {\n      field: 'region',\n      value: 'mm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'ct'\n    },\n    to: {\n      field: 'region',\n      value: 'ki'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'dd'\n    },\n    to: {\n      field: 'region',\n      value: 'de'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'dy'\n    },\n    to: {\n      field: 'region',\n      value: 'bj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'fx'\n    },\n    to: {\n      field: 'region',\n      value: 'fr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'hv'\n    },\n    to: {\n      field: 'region',\n      value: 'bf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'jt'\n    },\n    to: {\n      field: 'region',\n      value: 'um'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'mi'\n    },\n    to: {\n      field: 'region',\n      value: 'um'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'nh'\n    },\n    to: {\n      field: 'region',\n      value: 'vu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'nq'\n    },\n    to: {\n      field: 'region',\n      value: 'aq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'pu'\n    },\n    to: {\n      field: 'region',\n      value: 'um'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'pz'\n    },\n    to: {\n      field: 'region',\n      value: 'pa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'qu'\n    },\n    to: {\n      field: 'region',\n      value: 'eu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'rh'\n    },\n    to: {\n      field: 'region',\n      value: 'zw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'tp'\n    },\n    to: {\n      field: 'region',\n      value: 'tl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'uk'\n    },\n    to: {\n      field: 'region',\n      value: 'gb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'vd'\n    },\n    to: {\n      field: 'region',\n      value: 'vn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'wk'\n    },\n    to: {\n      field: 'region',\n      value: 'um'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'yd'\n    },\n    to: {\n      field: 'region',\n      value: 'ye'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: 'zr'\n    },\n    to: {\n      field: 'region',\n      value: 'cd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '230'\n    },\n    to: {\n      field: 'region',\n      value: 'et'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '280'\n    },\n    to: {\n      field: 'region',\n      value: 'de'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '736'\n    },\n    to: {\n      field: 'region',\n      value: 'sd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '886'\n    },\n    to: {\n      field: 'region',\n      value: 'ye'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '958'\n    },\n    to: {\n      field: 'region',\n      value: 'aa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '020'\n    },\n    to: {\n      field: 'region',\n      value: 'ad'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '784'\n    },\n    to: {\n      field: 'region',\n      value: 'ae'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '004'\n    },\n    to: {\n      field: 'region',\n      value: 'af'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '028'\n    },\n    to: {\n      field: 'region',\n      value: 'ag'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '660'\n    },\n    to: {\n      field: 'region',\n      value: 'ai'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '008'\n    },\n    to: {\n      field: 'region',\n      value: 'al'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '051'\n    },\n    to: {\n      field: 'region',\n      value: 'am'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '024'\n    },\n    to: {\n      field: 'region',\n      value: 'ao'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '010'\n    },\n    to: {\n      field: 'region',\n      value: 'aq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '032'\n    },\n    to: {\n      field: 'region',\n      value: 'ar'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '016'\n    },\n    to: {\n      field: 'region',\n      value: 'as'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '040'\n    },\n    to: {\n      field: 'region',\n      value: 'at'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '036'\n    },\n    to: {\n      field: 'region',\n      value: 'au'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '533'\n    },\n    to: {\n      field: 'region',\n      value: 'aw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '248'\n    },\n    to: {\n      field: 'region',\n      value: 'ax'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '031'\n    },\n    to: {\n      field: 'region',\n      value: 'az'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '070'\n    },\n    to: {\n      field: 'region',\n      value: 'ba'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '052'\n    },\n    to: {\n      field: 'region',\n      value: 'bb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '050'\n    },\n    to: {\n      field: 'region',\n      value: 'bd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '056'\n    },\n    to: {\n      field: 'region',\n      value: 'be'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '854'\n    },\n    to: {\n      field: 'region',\n      value: 'bf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '100'\n    },\n    to: {\n      field: 'region',\n      value: 'bg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '048'\n    },\n    to: {\n      field: 'region',\n      value: 'bh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '108'\n    },\n    to: {\n      field: 'region',\n      value: 'bi'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '204'\n    },\n    to: {\n      field: 'region',\n      value: 'bj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '652'\n    },\n    to: {\n      field: 'region',\n      value: 'bl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '060'\n    },\n    to: {\n      field: 'region',\n      value: 'bm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '096'\n    },\n    to: {\n      field: 'region',\n      value: 'bn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '068'\n    },\n    to: {\n      field: 'region',\n      value: 'bo'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '535'\n    },\n    to: {\n      field: 'region',\n      value: 'bq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '076'\n    },\n    to: {\n      field: 'region',\n      value: 'br'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '044'\n    },\n    to: {\n      field: 'region',\n      value: 'bs'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '064'\n    },\n    to: {\n      field: 'region',\n      value: 'bt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '104'\n    },\n    to: {\n      field: 'region',\n      value: 'mm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '074'\n    },\n    to: {\n      field: 'region',\n      value: 'bv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '072'\n    },\n    to: {\n      field: 'region',\n      value: 'bw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '112'\n    },\n    to: {\n      field: 'region',\n      value: 'by'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '084'\n    },\n    to: {\n      field: 'region',\n      value: 'bz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '124'\n    },\n    to: {\n      field: 'region',\n      value: 'ca'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '166'\n    },\n    to: {\n      field: 'region',\n      value: 'cc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '180'\n    },\n    to: {\n      field: 'region',\n      value: 'cd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '140'\n    },\n    to: {\n      field: 'region',\n      value: 'cf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '178'\n    },\n    to: {\n      field: 'region',\n      value: 'cg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '756'\n    },\n    to: {\n      field: 'region',\n      value: 'ch'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '384'\n    },\n    to: {\n      field: 'region',\n      value: 'ci'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '184'\n    },\n    to: {\n      field: 'region',\n      value: 'ck'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '152'\n    },\n    to: {\n      field: 'region',\n      value: 'cl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '120'\n    },\n    to: {\n      field: 'region',\n      value: 'cm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '156'\n    },\n    to: {\n      field: 'region',\n      value: 'cn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '170'\n    },\n    to: {\n      field: 'region',\n      value: 'co'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '188'\n    },\n    to: {\n      field: 'region',\n      value: 'cr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '192'\n    },\n    to: {\n      field: 'region',\n      value: 'cu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '132'\n    },\n    to: {\n      field: 'region',\n      value: 'cv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '531'\n    },\n    to: {\n      field: 'region',\n      value: 'cw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '162'\n    },\n    to: {\n      field: 'region',\n      value: 'cx'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '196'\n    },\n    to: {\n      field: 'region',\n      value: 'cy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '203'\n    },\n    to: {\n      field: 'region',\n      value: 'cz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '278'\n    },\n    to: {\n      field: 'region',\n      value: 'de'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '276'\n    },\n    to: {\n      field: 'region',\n      value: 'de'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '262'\n    },\n    to: {\n      field: 'region',\n      value: 'dj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '208'\n    },\n    to: {\n      field: 'region',\n      value: 'dk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '212'\n    },\n    to: {\n      field: 'region',\n      value: 'dm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '214'\n    },\n    to: {\n      field: 'region',\n      value: 'do'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '012'\n    },\n    to: {\n      field: 'region',\n      value: 'dz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '218'\n    },\n    to: {\n      field: 'region',\n      value: 'ec'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '233'\n    },\n    to: {\n      field: 'region',\n      value: 'ee'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '818'\n    },\n    to: {\n      field: 'region',\n      value: 'eg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '732'\n    },\n    to: {\n      field: 'region',\n      value: 'eh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '232'\n    },\n    to: {\n      field: 'region',\n      value: 'er'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '724'\n    },\n    to: {\n      field: 'region',\n      value: 'es'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '231'\n    },\n    to: {\n      field: 'region',\n      value: 'et'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '246'\n    },\n    to: {\n      field: 'region',\n      value: 'fi'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '242'\n    },\n    to: {\n      field: 'region',\n      value: 'fj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '238'\n    },\n    to: {\n      field: 'region',\n      value: 'fk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '583'\n    },\n    to: {\n      field: 'region',\n      value: 'fm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '234'\n    },\n    to: {\n      field: 'region',\n      value: 'fo'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '250'\n    },\n    to: {\n      field: 'region',\n      value: 'fr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '249'\n    },\n    to: {\n      field: 'region',\n      value: 'fr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '266'\n    },\n    to: {\n      field: 'region',\n      value: 'ga'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '826'\n    },\n    to: {\n      field: 'region',\n      value: 'gb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '308'\n    },\n    to: {\n      field: 'region',\n      value: 'gd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '268'\n    },\n    to: {\n      field: 'region',\n      value: 'ge'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '254'\n    },\n    to: {\n      field: 'region',\n      value: 'gf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '831'\n    },\n    to: {\n      field: 'region',\n      value: 'gg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '288'\n    },\n    to: {\n      field: 'region',\n      value: 'gh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '292'\n    },\n    to: {\n      field: 'region',\n      value: 'gi'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '304'\n    },\n    to: {\n      field: 'region',\n      value: 'gl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '270'\n    },\n    to: {\n      field: 'region',\n      value: 'gm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '324'\n    },\n    to: {\n      field: 'region',\n      value: 'gn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '312'\n    },\n    to: {\n      field: 'region',\n      value: 'gp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '226'\n    },\n    to: {\n      field: 'region',\n      value: 'gq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '300'\n    },\n    to: {\n      field: 'region',\n      value: 'gr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '239'\n    },\n    to: {\n      field: 'region',\n      value: 'gs'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '320'\n    },\n    to: {\n      field: 'region',\n      value: 'gt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '316'\n    },\n    to: {\n      field: 'region',\n      value: 'gu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '624'\n    },\n    to: {\n      field: 'region',\n      value: 'gw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '328'\n    },\n    to: {\n      field: 'region',\n      value: 'gy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '344'\n    },\n    to: {\n      field: 'region',\n      value: 'hk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '334'\n    },\n    to: {\n      field: 'region',\n      value: 'hm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '340'\n    },\n    to: {\n      field: 'region',\n      value: 'hn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '191'\n    },\n    to: {\n      field: 'region',\n      value: 'hr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '332'\n    },\n    to: {\n      field: 'region',\n      value: 'ht'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '348'\n    },\n    to: {\n      field: 'region',\n      value: 'hu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '360'\n    },\n    to: {\n      field: 'region',\n      value: 'id'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '372'\n    },\n    to: {\n      field: 'region',\n      value: 'ie'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '376'\n    },\n    to: {\n      field: 'region',\n      value: 'il'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '833'\n    },\n    to: {\n      field: 'region',\n      value: 'im'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '356'\n    },\n    to: {\n      field: 'region',\n      value: 'in'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '086'\n    },\n    to: {\n      field: 'region',\n      value: 'io'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '368'\n    },\n    to: {\n      field: 'region',\n      value: 'iq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '364'\n    },\n    to: {\n      field: 'region',\n      value: 'ir'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '352'\n    },\n    to: {\n      field: 'region',\n      value: 'is'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '380'\n    },\n    to: {\n      field: 'region',\n      value: 'it'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '832'\n    },\n    to: {\n      field: 'region',\n      value: 'je'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '388'\n    },\n    to: {\n      field: 'region',\n      value: 'jm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '400'\n    },\n    to: {\n      field: 'region',\n      value: 'jo'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '392'\n    },\n    to: {\n      field: 'region',\n      value: 'jp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '404'\n    },\n    to: {\n      field: 'region',\n      value: 'ke'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '417'\n    },\n    to: {\n      field: 'region',\n      value: 'kg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '116'\n    },\n    to: {\n      field: 'region',\n      value: 'kh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '296'\n    },\n    to: {\n      field: 'region',\n      value: 'ki'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '174'\n    },\n    to: {\n      field: 'region',\n      value: 'km'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '659'\n    },\n    to: {\n      field: 'region',\n      value: 'kn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '408'\n    },\n    to: {\n      field: 'region',\n      value: 'kp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '410'\n    },\n    to: {\n      field: 'region',\n      value: 'kr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '414'\n    },\n    to: {\n      field: 'region',\n      value: 'kw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '136'\n    },\n    to: {\n      field: 'region',\n      value: 'ky'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '398'\n    },\n    to: {\n      field: 'region',\n      value: 'kz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '418'\n    },\n    to: {\n      field: 'region',\n      value: 'la'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '422'\n    },\n    to: {\n      field: 'region',\n      value: 'lb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '662'\n    },\n    to: {\n      field: 'region',\n      value: 'lc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '438'\n    },\n    to: {\n      field: 'region',\n      value: 'li'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '144'\n    },\n    to: {\n      field: 'region',\n      value: 'lk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '430'\n    },\n    to: {\n      field: 'region',\n      value: 'lr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '426'\n    },\n    to: {\n      field: 'region',\n      value: 'ls'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '440'\n    },\n    to: {\n      field: 'region',\n      value: 'lt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '442'\n    },\n    to: {\n      field: 'region',\n      value: 'lu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '428'\n    },\n    to: {\n      field: 'region',\n      value: 'lv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '434'\n    },\n    to: {\n      field: 'region',\n      value: 'ly'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '504'\n    },\n    to: {\n      field: 'region',\n      value: 'ma'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '492'\n    },\n    to: {\n      field: 'region',\n      value: 'mc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '498'\n    },\n    to: {\n      field: 'region',\n      value: 'md'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '499'\n    },\n    to: {\n      field: 'region',\n      value: 'me'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '663'\n    },\n    to: {\n      field: 'region',\n      value: 'mf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '450'\n    },\n    to: {\n      field: 'region',\n      value: 'mg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '584'\n    },\n    to: {\n      field: 'region',\n      value: 'mh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '807'\n    },\n    to: {\n      field: 'region',\n      value: 'mk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '466'\n    },\n    to: {\n      field: 'region',\n      value: 'ml'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '496'\n    },\n    to: {\n      field: 'region',\n      value: 'mn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '446'\n    },\n    to: {\n      field: 'region',\n      value: 'mo'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '580'\n    },\n    to: {\n      field: 'region',\n      value: 'mp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '474'\n    },\n    to: {\n      field: 'region',\n      value: 'mq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '478'\n    },\n    to: {\n      field: 'region',\n      value: 'mr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '500'\n    },\n    to: {\n      field: 'region',\n      value: 'ms'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '470'\n    },\n    to: {\n      field: 'region',\n      value: 'mt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '480'\n    },\n    to: {\n      field: 'region',\n      value: 'mu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '462'\n    },\n    to: {\n      field: 'region',\n      value: 'mv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '454'\n    },\n    to: {\n      field: 'region',\n      value: 'mw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '484'\n    },\n    to: {\n      field: 'region',\n      value: 'mx'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '458'\n    },\n    to: {\n      field: 'region',\n      value: 'my'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '508'\n    },\n    to: {\n      field: 'region',\n      value: 'mz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '516'\n    },\n    to: {\n      field: 'region',\n      value: 'na'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '540'\n    },\n    to: {\n      field: 'region',\n      value: 'nc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '562'\n    },\n    to: {\n      field: 'region',\n      value: 'ne'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '574'\n    },\n    to: {\n      field: 'region',\n      value: 'nf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '566'\n    },\n    to: {\n      field: 'region',\n      value: 'ng'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '558'\n    },\n    to: {\n      field: 'region',\n      value: 'ni'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '528'\n    },\n    to: {\n      field: 'region',\n      value: 'nl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '578'\n    },\n    to: {\n      field: 'region',\n      value: 'no'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '524'\n    },\n    to: {\n      field: 'region',\n      value: 'np'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '520'\n    },\n    to: {\n      field: 'region',\n      value: 'nr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '570'\n    },\n    to: {\n      field: 'region',\n      value: 'nu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '554'\n    },\n    to: {\n      field: 'region',\n      value: 'nz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '512'\n    },\n    to: {\n      field: 'region',\n      value: 'om'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '591'\n    },\n    to: {\n      field: 'region',\n      value: 'pa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '604'\n    },\n    to: {\n      field: 'region',\n      value: 'pe'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '258'\n    },\n    to: {\n      field: 'region',\n      value: 'pf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '598'\n    },\n    to: {\n      field: 'region',\n      value: 'pg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '608'\n    },\n    to: {\n      field: 'region',\n      value: 'ph'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '586'\n    },\n    to: {\n      field: 'region',\n      value: 'pk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '616'\n    },\n    to: {\n      field: 'region',\n      value: 'pl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '666'\n    },\n    to: {\n      field: 'region',\n      value: 'pm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '612'\n    },\n    to: {\n      field: 'region',\n      value: 'pn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '630'\n    },\n    to: {\n      field: 'region',\n      value: 'pr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '275'\n    },\n    to: {\n      field: 'region',\n      value: 'ps'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '620'\n    },\n    to: {\n      field: 'region',\n      value: 'pt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '585'\n    },\n    to: {\n      field: 'region',\n      value: 'pw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '600'\n    },\n    to: {\n      field: 'region',\n      value: 'py'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '634'\n    },\n    to: {\n      field: 'region',\n      value: 'qa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '959'\n    },\n    to: {\n      field: 'region',\n      value: 'qm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '960'\n    },\n    to: {\n      field: 'region',\n      value: 'qn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '962'\n    },\n    to: {\n      field: 'region',\n      value: 'qp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '963'\n    },\n    to: {\n      field: 'region',\n      value: 'qq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '964'\n    },\n    to: {\n      field: 'region',\n      value: 'qr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '965'\n    },\n    to: {\n      field: 'region',\n      value: 'qs'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '966'\n    },\n    to: {\n      field: 'region',\n      value: 'qt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '967'\n    },\n    to: {\n      field: 'region',\n      value: 'eu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '968'\n    },\n    to: {\n      field: 'region',\n      value: 'qv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '969'\n    },\n    to: {\n      field: 'region',\n      value: 'qw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '970'\n    },\n    to: {\n      field: 'region',\n      value: 'qx'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '971'\n    },\n    to: {\n      field: 'region',\n      value: 'qy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '972'\n    },\n    to: {\n      field: 'region',\n      value: 'qz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '638'\n    },\n    to: {\n      field: 'region',\n      value: 're'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '642'\n    },\n    to: {\n      field: 'region',\n      value: 'ro'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '688'\n    },\n    to: {\n      field: 'region',\n      value: 'rs'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '643'\n    },\n    to: {\n      field: 'region',\n      value: 'ru'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '646'\n    },\n    to: {\n      field: 'region',\n      value: 'rw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '682'\n    },\n    to: {\n      field: 'region',\n      value: 'sa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '090'\n    },\n    to: {\n      field: 'region',\n      value: 'sb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '690'\n    },\n    to: {\n      field: 'region',\n      value: 'sc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '729'\n    },\n    to: {\n      field: 'region',\n      value: 'sd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '752'\n    },\n    to: {\n      field: 'region',\n      value: 'se'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '702'\n    },\n    to: {\n      field: 'region',\n      value: 'sg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '654'\n    },\n    to: {\n      field: 'region',\n      value: 'sh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '705'\n    },\n    to: {\n      field: 'region',\n      value: 'si'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '744'\n    },\n    to: {\n      field: 'region',\n      value: 'sj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '703'\n    },\n    to: {\n      field: 'region',\n      value: 'sk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '694'\n    },\n    to: {\n      field: 'region',\n      value: 'sl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '674'\n    },\n    to: {\n      field: 'region',\n      value: 'sm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '686'\n    },\n    to: {\n      field: 'region',\n      value: 'sn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '706'\n    },\n    to: {\n      field: 'region',\n      value: 'so'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '740'\n    },\n    to: {\n      field: 'region',\n      value: 'sr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '728'\n    },\n    to: {\n      field: 'region',\n      value: 'ss'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '678'\n    },\n    to: {\n      field: 'region',\n      value: 'st'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '222'\n    },\n    to: {\n      field: 'region',\n      value: 'sv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '534'\n    },\n    to: {\n      field: 'region',\n      value: 'sx'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '760'\n    },\n    to: {\n      field: 'region',\n      value: 'sy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '748'\n    },\n    to: {\n      field: 'region',\n      value: 'sz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '796'\n    },\n    to: {\n      field: 'region',\n      value: 'tc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '148'\n    },\n    to: {\n      field: 'region',\n      value: 'td'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '260'\n    },\n    to: {\n      field: 'region',\n      value: 'tf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '768'\n    },\n    to: {\n      field: 'region',\n      value: 'tg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '764'\n    },\n    to: {\n      field: 'region',\n      value: 'th'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '762'\n    },\n    to: {\n      field: 'region',\n      value: 'tj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '772'\n    },\n    to: {\n      field: 'region',\n      value: 'tk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '626'\n    },\n    to: {\n      field: 'region',\n      value: 'tl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '795'\n    },\n    to: {\n      field: 'region',\n      value: 'tm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '788'\n    },\n    to: {\n      field: 'region',\n      value: 'tn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '776'\n    },\n    to: {\n      field: 'region',\n      value: 'to'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '792'\n    },\n    to: {\n      field: 'region',\n      value: 'tr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '780'\n    },\n    to: {\n      field: 'region',\n      value: 'tt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '798'\n    },\n    to: {\n      field: 'region',\n      value: 'tv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '158'\n    },\n    to: {\n      field: 'region',\n      value: 'tw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '834'\n    },\n    to: {\n      field: 'region',\n      value: 'tz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '804'\n    },\n    to: {\n      field: 'region',\n      value: 'ua'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '800'\n    },\n    to: {\n      field: 'region',\n      value: 'ug'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '581'\n    },\n    to: {\n      field: 'region',\n      value: 'um'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '840'\n    },\n    to: {\n      field: 'region',\n      value: 'us'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '858'\n    },\n    to: {\n      field: 'region',\n      value: 'uy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '860'\n    },\n    to: {\n      field: 'region',\n      value: 'uz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '336'\n    },\n    to: {\n      field: 'region',\n      value: 'va'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '670'\n    },\n    to: {\n      field: 'region',\n      value: 'vc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '862'\n    },\n    to: {\n      field: 'region',\n      value: 've'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '092'\n    },\n    to: {\n      field: 'region',\n      value: 'vg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '850'\n    },\n    to: {\n      field: 'region',\n      value: 'vi'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '704'\n    },\n    to: {\n      field: 'region',\n      value: 'vn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '548'\n    },\n    to: {\n      field: 'region',\n      value: 'vu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '876'\n    },\n    to: {\n      field: 'region',\n      value: 'wf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '882'\n    },\n    to: {\n      field: 'region',\n      value: 'ws'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '973'\n    },\n    to: {\n      field: 'region',\n      value: 'xa'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '974'\n    },\n    to: {\n      field: 'region',\n      value: 'xb'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '975'\n    },\n    to: {\n      field: 'region',\n      value: 'xc'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '976'\n    },\n    to: {\n      field: 'region',\n      value: 'xd'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '977'\n    },\n    to: {\n      field: 'region',\n      value: 'xe'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '978'\n    },\n    to: {\n      field: 'region',\n      value: 'xf'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '979'\n    },\n    to: {\n      field: 'region',\n      value: 'xg'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '980'\n    },\n    to: {\n      field: 'region',\n      value: 'xh'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '981'\n    },\n    to: {\n      field: 'region',\n      value: 'xi'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '982'\n    },\n    to: {\n      field: 'region',\n      value: 'xj'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '983'\n    },\n    to: {\n      field: 'region',\n      value: 'xk'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '984'\n    },\n    to: {\n      field: 'region',\n      value: 'xl'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '985'\n    },\n    to: {\n      field: 'region',\n      value: 'xm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '986'\n    },\n    to: {\n      field: 'region',\n      value: 'xn'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '987'\n    },\n    to: {\n      field: 'region',\n      value: 'xo'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '988'\n    },\n    to: {\n      field: 'region',\n      value: 'xp'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '989'\n    },\n    to: {\n      field: 'region',\n      value: 'xq'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '990'\n    },\n    to: {\n      field: 'region',\n      value: 'xr'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '991'\n    },\n    to: {\n      field: 'region',\n      value: 'xs'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '992'\n    },\n    to: {\n      field: 'region',\n      value: 'xt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '993'\n    },\n    to: {\n      field: 'region',\n      value: 'xu'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '994'\n    },\n    to: {\n      field: 'region',\n      value: 'xv'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '995'\n    },\n    to: {\n      field: 'region',\n      value: 'xw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '996'\n    },\n    to: {\n      field: 'region',\n      value: 'xx'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '997'\n    },\n    to: {\n      field: 'region',\n      value: 'xy'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '998'\n    },\n    to: {\n      field: 'region',\n      value: 'xz'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '720'\n    },\n    to: {\n      field: 'region',\n      value: 'ye'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '887'\n    },\n    to: {\n      field: 'region',\n      value: 'ye'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '175'\n    },\n    to: {\n      field: 'region',\n      value: 'yt'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '710'\n    },\n    to: {\n      field: 'region',\n      value: 'za'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '894'\n    },\n    to: {\n      field: 'region',\n      value: 'zm'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '716'\n    },\n    to: {\n      field: 'region',\n      value: 'zw'\n    }\n  },\n  {\n    from: {\n      field: 'region',\n      value: '999'\n    },\n    to: {\n      field: 'region',\n      value: 'zz'\n    }\n  },\n  {\n    from: {\n      field: 'variants',\n      value: 'polytoni'\n    },\n    to: {\n      field: 'variants',\n      value: 'polyton'\n    }\n  },\n  {\n    from: {\n      field: 'variants',\n      value: 'heploc'\n    },\n    to: {\n      field: 'variants',\n      value: 'alalc97'\n    }\n  }\n]\n","/**\n * @typedef {import('bcp-47').Warning} Warning\n * @typedef {import('bcp-47').Schema} Schema\n * @typedef {import('bcp-47').Extension} Extension\n *\n * @typedef Options\n * @property {boolean} [forgiving]\n * @property {Warning} [warning]\n */\n\nimport {parse, stringify} from 'bcp-47'\nimport {extendedFilter} from 'bcp-47-match'\nimport {matches} from './matches.js'\nimport {fields} from './fields.js'\nimport {many} from './many.js'\nimport {likely} from './likely.js'\n\nconst own = {}.hasOwnProperty\n\nconst collator = new Intl.Collator()\n\n/**\n * @param {Schema} base\n * @param {Partial<Schema>} changes\n * @returns {Schema}\n */\nfunction merge(base, changes) {\n  if (!base.language) base.language = changes.language\n  if (!base.script) base.script = changes.script\n  if (!base.region) base.region = changes.region\n  if (changes.variants) base.variants.push(...changes.variants)\n\n  return base\n}\n\n/**\n * Mostly like:\n * <https://github.com/formatjs/formatjs/blob/a15e757/packages/intl-locale/index.ts#L254>\n * But doesnt crash.\n *\n * @param {Schema} schema\n * @returns {string}\n */\nfunction addLikelySubtags(schema) {\n  const {language, script, region} = schema\n  /** @type {string|undefined} */\n  let match\n\n  if (\n    script &&\n    region &&\n    (match = likely[stringify({language, script, region})])\n  ) {\n    schema.script = undefined\n    schema.region = undefined\n  } else if (script && (match = likely[stringify({language, script})])) {\n    schema.script = undefined\n  } else if (region && (match = likely[stringify({language, region})])) {\n    schema.region = undefined\n  } else if (language && (match = likely[language])) {\n    // Empty.\n  }\n\n  if (match) {\n    schema.language = undefined\n    merge(schema, parse(match))\n  }\n\n  return stringify(schema)\n}\n\n/**\n * @param {Schema} schema\n */\nfunction removeLikelySubtags(schema) {\n  addLikelySubtags(schema)\n\n  const {language, script, region} = schema\n\n  if (!language) return schema\n\n  const maxLocale = stringify({language, script, region})\n\n  if (maxLocale === addLikelySubtags(parse(language))) {\n    schema.script = undefined\n    schema.region = undefined\n  } else if (\n    region &&\n    maxLocale === addLikelySubtags(parse(language + '-' + region))\n  ) {\n    schema.script = undefined\n  } else if (\n    script &&\n    maxLocale === addLikelySubtags(parse(language + '-' + script))\n  ) {\n    schema.region = undefined\n  }\n\n  return schema\n}\n\n/**\n * Normalize the given BCP 47 tag according to Unicode CLDR suggestions.\n *\n * @param {string} tag\n *   BCP 47 tag.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Normal, canonical, and pretty BCP 47 tag.\n */\nexport function bcp47Normalize(tag, options) {\n  const settings = options || {}\n  // 1. normalize and lowercase the tag (`sgn-be-fr` -> `sfb`).\n  const schema = parse(String(tag || '').toLowerCase(), settings)\n  const value = stringify(schema)\n\n  if (!value) {\n    return value\n  }\n\n  let index = -1\n\n  // 2. Do fancy, expensive replaces (`ha-latn-gh` -> `ha-gh`).\n  while (++index < matches.length) {\n    let from = matches[index].from\n\n    if (from.slice(0, 4) === 'und-' && schema.language) {\n      from = schema.language + from.slice(3)\n    }\n\n    if (extendedFilter(value, from).length > 0) {\n      replace(schema, from, matches[index].to)\n    }\n  }\n\n  // 3. Do basic field replaces (`en-840` -> `en-us`).\n  index = -1\n\n  while (++index < fields.length) {\n    if (remove(schema, fields[index].from.field, fields[index].from.value)) {\n      add(schema, fields[index].to.field, fields[index].to.value)\n    }\n  }\n\n  // 4. Minimize.\n  removeLikelySubtags(schema)\n\n  // 5. Sort variants, and sort extensions on singleton.\n  schema.variants.sort(collator.compare)\n  schema.extensions.sort(compareSingleton)\n\n  // 6. Warn if fields (currently only regions) should be updated but have\n  // multiple choices.\n  if (settings.warning) {\n    /** @type {keyof many} */\n    let key\n\n    for (key in many) {\n      if (own.call(many, key)) {\n        const map = many[key]\n        const value = schema[key]\n        if (value && own.call(map, value)) {\n          const replacements = map[value]\n          settings.warning(\n            'Deprecated ' +\n              key +\n              ' `' +\n              value +\n              '`, expected one of `' +\n              replacements.join('`, `') +\n              '`',\n            -1,\n            7\n          )\n        }\n      }\n    }\n  }\n\n  // 7. Add proper casing back.\n  // Format script (ISO 15924) as titlecase (example: `Latn`):\n  if (schema.script) {\n    schema.script =\n      schema.script.charAt(0).toUpperCase() + schema.script.slice(1)\n  }\n\n  // Format region (ISO 3166) as uppercase (note: this doesnt affect numeric\n  // codes, which is fine):\n  if (schema.region) {\n    schema.region = schema.region.toUpperCase()\n  }\n\n  return stringify(schema)\n}\n\n/**\n * @param {Schema} schema\n * @param {string} from\n * @param {string} to\n * @returns {void}\n */\nfunction replace(schema, from, to) {\n  const left = parse(from)\n  const right = parse(to)\n  /** @type {Array<string>} */\n  const removed = []\n  /** @type {string|null|undefined} */\n  const lang = left.language\n  /** @type {keyof schema} */\n  let key\n\n  // Remove values from `from`:\n  for (key in left) {\n    if (own.call(left, key)) {\n      const value = left[key]\n      if (value && remove(schema, key, value)) {\n        removed.push(key)\n      }\n    }\n  }\n\n  // Add values from `to`:\n  for (key in right) {\n    if (own.call(right, key)) {\n      const value = right[key]\n      // Only add values that are defined on `to`, and that were either removed by\n      // `from` or are currently empty.\n      if (lang && value && (removed.includes(key) || !schema[key])) {\n        add(schema, key, key === 'language' && value === 'und' ? lang : value)\n      }\n    }\n  }\n}\n\n/**\n * @param {Schema} object\n * @param {keyof Schema} key\n * @param {string|Array<string>|Array<Extension>} value\n * @returns {boolean}\n */\nfunction remove(object, key, value) {\n  let removed = false\n  /** @type {string|Array<string>|Array<Extension>|null|undefined} */\n  let result\n\n  if (value) {\n    const current = object[key]\n    result = current\n\n    if (Array.isArray(current)) {\n      result = []\n      let index = -1\n\n      while (++index < current.length) {\n        const item = current[index]\n\n        // @ts-expect-error: TS cant handle the two lists.\n        if (value.includes(item)) {\n          removed = true\n        } else {\n          // @ts-expect-error: TS cant handle the two lists.\n          result.push(item)\n        }\n      }\n    } else if (current === value) {\n      result = null\n      removed = true\n    }\n\n    // @ts-expect-error: Assume the value matches.\n    object[key] = result\n  }\n\n  return removed\n}\n\n/**\n * @param {Schema} object\n * @param {keyof Schema} key\n * @param {string|Array<string>|Array<Extension>} value\n * @returns {void}\n */\nfunction add(object, key, value) {\n  /** @type {string|Array<string>|Array<Extension>|null|undefined} */\n  const current = object[key]\n\n  if (Array.isArray(current)) {\n    const list = Array.isArray(value) ? value : [value]\n    /** @type {number} */\n    let index = -1\n\n    while (++index < list.length) {\n      const item = list[index]\n\n      // @ts-expect-error: TS cant handle the two lists.\n      if (!current.includes(item)) {\n        // @ts-expect-error: TS cant handle the two lists.\n        current.push(item)\n      }\n    }\n  } else {\n    // @ts-expect-error: Assume the value matches.\n    object[key] = value\n  }\n}\n\n/**\n * @param {Extension} left\n * @param {Extension} right\n * @returns {number}\n */\nfunction compareSingleton(left, right) {\n  return collator.compare(left.singleton, right.singleton)\n}\n","/**\n * @type {Record<string, string>}\n */\nexport const likely = {\n  aa: 'aa-latn-et',\n  aai: 'aai-latn-zz',\n  aak: 'aak-latn-zz',\n  aau: 'aau-latn-zz',\n  ab: 'ab-cyrl-ge',\n  abi: 'abi-latn-zz',\n  abq: 'abq-cyrl-zz',\n  abr: 'abr-latn-gh',\n  abt: 'abt-latn-zz',\n  aby: 'aby-latn-zz',\n  acd: 'acd-latn-zz',\n  ace: 'ace-latn-id',\n  ach: 'ach-latn-ug',\n  ada: 'ada-latn-gh',\n  ade: 'ade-latn-zz',\n  adj: 'adj-latn-zz',\n  adp: 'adp-tibt-bt',\n  ady: 'ady-cyrl-ru',\n  adz: 'adz-latn-zz',\n  ae: 'ae-avst-ir',\n  aeb: 'aeb-arab-tn',\n  aey: 'aey-latn-zz',\n  af: 'af-latn-za',\n  agc: 'agc-latn-zz',\n  agd: 'agd-latn-zz',\n  agg: 'agg-latn-zz',\n  agm: 'agm-latn-zz',\n  ago: 'ago-latn-zz',\n  agq: 'agq-latn-cm',\n  aha: 'aha-latn-zz',\n  ahl: 'ahl-latn-zz',\n  aho: 'aho-ahom-in',\n  ajg: 'ajg-latn-zz',\n  ak: 'ak-latn-gh',\n  akk: 'akk-xsux-iq',\n  ala: 'ala-latn-zz',\n  ali: 'ali-latn-zz',\n  aln: 'aln-latn-xk',\n  alt: 'alt-cyrl-ru',\n  am: 'am-ethi-et',\n  amm: 'amm-latn-zz',\n  amn: 'amn-latn-zz',\n  amo: 'amo-latn-ng',\n  amp: 'amp-latn-zz',\n  an: 'an-latn-es',\n  anc: 'anc-latn-zz',\n  ank: 'ank-latn-zz',\n  ann: 'ann-latn-zz',\n  any: 'any-latn-zz',\n  aoj: 'aoj-latn-zz',\n  aom: 'aom-latn-zz',\n  aoz: 'aoz-latn-id',\n  apc: 'apc-arab-zz',\n  apd: 'apd-arab-tg',\n  ape: 'ape-latn-zz',\n  apr: 'apr-latn-zz',\n  aps: 'aps-latn-zz',\n  apz: 'apz-latn-zz',\n  ar: 'ar-arab-eg',\n  arc: 'arc-armi-ir',\n  'arc-nbat': 'arc-nbat-jo',\n  'arc-palm': 'arc-palm-sy',\n  arh: 'arh-latn-zz',\n  arn: 'arn-latn-cl',\n  aro: 'aro-latn-bo',\n  arq: 'arq-arab-dz',\n  ars: 'ars-arab-sa',\n  ary: 'ary-arab-ma',\n  arz: 'arz-arab-eg',\n  as: 'as-beng-in',\n  asa: 'asa-latn-tz',\n  ase: 'ase-sgnw-us',\n  asg: 'asg-latn-zz',\n  aso: 'aso-latn-zz',\n  ast: 'ast-latn-es',\n  ata: 'ata-latn-zz',\n  atg: 'atg-latn-zz',\n  atj: 'atj-latn-ca',\n  auy: 'auy-latn-zz',\n  av: 'av-cyrl-ru',\n  avl: 'avl-arab-zz',\n  avn: 'avn-latn-zz',\n  avt: 'avt-latn-zz',\n  avu: 'avu-latn-zz',\n  awa: 'awa-deva-in',\n  awb: 'awb-latn-zz',\n  awo: 'awo-latn-zz',\n  awx: 'awx-latn-zz',\n  ay: 'ay-latn-bo',\n  ayb: 'ayb-latn-zz',\n  az: 'az-latn-az',\n  'az-arab': 'az-arab-ir',\n  'az-iq': 'az-arab-iq',\n  'az-ir': 'az-arab-ir',\n  'az-ru': 'az-cyrl-ru',\n  ba: 'ba-cyrl-ru',\n  bal: 'bal-arab-pk',\n  ban: 'ban-latn-id',\n  bap: 'bap-deva-np',\n  bar: 'bar-latn-at',\n  bas: 'bas-latn-cm',\n  bav: 'bav-latn-zz',\n  bax: 'bax-bamu-cm',\n  bba: 'bba-latn-zz',\n  bbb: 'bbb-latn-zz',\n  bbc: 'bbc-latn-id',\n  bbd: 'bbd-latn-zz',\n  bbj: 'bbj-latn-cm',\n  bbp: 'bbp-latn-zz',\n  bbr: 'bbr-latn-zz',\n  bcf: 'bcf-latn-zz',\n  bch: 'bch-latn-zz',\n  bci: 'bci-latn-ci',\n  bcm: 'bcm-latn-zz',\n  bcn: 'bcn-latn-zz',\n  bco: 'bco-latn-zz',\n  bcq: 'bcq-ethi-zz',\n  bcu: 'bcu-latn-zz',\n  bdd: 'bdd-latn-zz',\n  be: 'be-cyrl-by',\n  bef: 'bef-latn-zz',\n  beh: 'beh-latn-zz',\n  bej: 'bej-arab-sd',\n  bem: 'bem-latn-zm',\n  bet: 'bet-latn-zz',\n  bew: 'bew-latn-id',\n  bex: 'bex-latn-zz',\n  bez: 'bez-latn-tz',\n  bfd: 'bfd-latn-cm',\n  bfq: 'bfq-taml-in',\n  bft: 'bft-arab-pk',\n  bfy: 'bfy-deva-in',\n  bg: 'bg-cyrl-bg',\n  bgc: 'bgc-deva-in',\n  bgn: 'bgn-arab-pk',\n  bgx: 'bgx-grek-tr',\n  bhb: 'bhb-deva-in',\n  bhg: 'bhg-latn-zz',\n  bhi: 'bhi-deva-in',\n  bhl: 'bhl-latn-zz',\n  bho: 'bho-deva-in',\n  bhy: 'bhy-latn-zz',\n  bi: 'bi-latn-vu',\n  bib: 'bib-latn-zz',\n  big: 'big-latn-zz',\n  bik: 'bik-latn-ph',\n  bim: 'bim-latn-zz',\n  bin: 'bin-latn-ng',\n  bio: 'bio-latn-zz',\n  biq: 'biq-latn-zz',\n  bjh: 'bjh-latn-zz',\n  bji: 'bji-ethi-zz',\n  bjj: 'bjj-deva-in',\n  bjn: 'bjn-latn-id',\n  bjo: 'bjo-latn-zz',\n  bjr: 'bjr-latn-zz',\n  bjt: 'bjt-latn-sn',\n  bjz: 'bjz-latn-zz',\n  bkc: 'bkc-latn-zz',\n  bkm: 'bkm-latn-cm',\n  bkq: 'bkq-latn-zz',\n  bku: 'bku-latn-ph',\n  bkv: 'bkv-latn-zz',\n  blg: 'blg-latn-my',\n  blt: 'blt-tavt-vn',\n  bm: 'bm-latn-ml',\n  bmh: 'bmh-latn-zz',\n  bmk: 'bmk-latn-zz',\n  bmq: 'bmq-latn-ml',\n  bmu: 'bmu-latn-zz',\n  bn: 'bn-beng-bd',\n  bng: 'bng-latn-zz',\n  bnm: 'bnm-latn-zz',\n  bnp: 'bnp-latn-zz',\n  bo: 'bo-tibt-cn',\n  boj: 'boj-latn-zz',\n  bom: 'bom-latn-zz',\n  bon: 'bon-latn-zz',\n  bpy: 'bpy-beng-in',\n  bqc: 'bqc-latn-zz',\n  bqi: 'bqi-arab-ir',\n  bqp: 'bqp-latn-zz',\n  bqv: 'bqv-latn-ci',\n  br: 'br-latn-fr',\n  bra: 'bra-deva-in',\n  brh: 'brh-arab-pk',\n  brx: 'brx-deva-in',\n  brz: 'brz-latn-zz',\n  bs: 'bs-latn-ba',\n  bsj: 'bsj-latn-zz',\n  bsq: 'bsq-bass-lr',\n  bss: 'bss-latn-cm',\n  bst: 'bst-ethi-zz',\n  bto: 'bto-latn-ph',\n  btt: 'btt-latn-zz',\n  btv: 'btv-deva-pk',\n  bua: 'bua-cyrl-ru',\n  buc: 'buc-latn-yt',\n  bud: 'bud-latn-zz',\n  bug: 'bug-latn-id',\n  buk: 'buk-latn-zz',\n  bum: 'bum-latn-cm',\n  buo: 'buo-latn-zz',\n  bus: 'bus-latn-zz',\n  buu: 'buu-latn-zz',\n  bvb: 'bvb-latn-gq',\n  bwd: 'bwd-latn-zz',\n  bwr: 'bwr-latn-zz',\n  bxh: 'bxh-latn-zz',\n  bye: 'bye-latn-zz',\n  byn: 'byn-ethi-er',\n  byr: 'byr-latn-zz',\n  bys: 'bys-latn-zz',\n  byv: 'byv-latn-cm',\n  byx: 'byx-latn-zz',\n  bza: 'bza-latn-zz',\n  bze: 'bze-latn-ml',\n  bzf: 'bzf-latn-zz',\n  bzh: 'bzh-latn-zz',\n  bzw: 'bzw-latn-zz',\n  ca: 'ca-latn-es',\n  cad: 'cad-latn-us',\n  can: 'can-latn-zz',\n  cbj: 'cbj-latn-zz',\n  cch: 'cch-latn-ng',\n  ccp: 'ccp-cakm-bd',\n  ce: 'ce-cyrl-ru',\n  ceb: 'ceb-latn-ph',\n  cfa: 'cfa-latn-zz',\n  cgg: 'cgg-latn-ug',\n  ch: 'ch-latn-gu',\n  chk: 'chk-latn-fm',\n  chm: 'chm-cyrl-ru',\n  cho: 'cho-latn-us',\n  chp: 'chp-latn-ca',\n  chr: 'chr-cher-us',\n  cic: 'cic-latn-us',\n  cja: 'cja-arab-kh',\n  cjm: 'cjm-cham-vn',\n  cjv: 'cjv-latn-zz',\n  ckb: 'ckb-arab-iq',\n  ckl: 'ckl-latn-zz',\n  cko: 'cko-latn-zz',\n  cky: 'cky-latn-zz',\n  cla: 'cla-latn-zz',\n  cme: 'cme-latn-zz',\n  cmg: 'cmg-soyo-mn',\n  co: 'co-latn-fr',\n  cop: 'cop-copt-eg',\n  cps: 'cps-latn-ph',\n  cr: 'cr-cans-ca',\n  crh: 'crh-cyrl-ua',\n  crj: 'crj-cans-ca',\n  crk: 'crk-cans-ca',\n  crl: 'crl-cans-ca',\n  crm: 'crm-cans-ca',\n  crs: 'crs-latn-sc',\n  cs: 'cs-latn-cz',\n  csb: 'csb-latn-pl',\n  csw: 'csw-cans-ca',\n  ctd: 'ctd-pauc-mm',\n  cu: 'cu-cyrl-ru',\n  'cu-glag': 'cu-glag-bg',\n  cv: 'cv-cyrl-ru',\n  cy: 'cy-latn-gb',\n  da: 'da-latn-dk',\n  dad: 'dad-latn-zz',\n  daf: 'daf-latn-ci',\n  dag: 'dag-latn-zz',\n  dah: 'dah-latn-zz',\n  dak: 'dak-latn-us',\n  dar: 'dar-cyrl-ru',\n  dav: 'dav-latn-ke',\n  dbd: 'dbd-latn-zz',\n  dbq: 'dbq-latn-zz',\n  dcc: 'dcc-arab-in',\n  ddn: 'ddn-latn-zz',\n  de: 'de-latn-de',\n  ded: 'ded-latn-zz',\n  den: 'den-latn-ca',\n  dga: 'dga-latn-zz',\n  dgh: 'dgh-latn-zz',\n  dgi: 'dgi-latn-zz',\n  dgl: 'dgl-arab-zz',\n  dgr: 'dgr-latn-ca',\n  dgz: 'dgz-latn-zz',\n  dia: 'dia-latn-zz',\n  dje: 'dje-latn-ne',\n  dmf: 'dmf-medf-ng',\n  dnj: 'dnj-latn-ci',\n  dob: 'dob-latn-zz',\n  doi: 'doi-deva-in',\n  dop: 'dop-latn-zz',\n  dow: 'dow-latn-zz',\n  drh: 'drh-mong-cn',\n  dri: 'dri-latn-zz',\n  drs: 'drs-ethi-zz',\n  dsb: 'dsb-latn-de',\n  dtm: 'dtm-latn-ml',\n  dtp: 'dtp-latn-my',\n  dts: 'dts-latn-zz',\n  dty: 'dty-deva-np',\n  dua: 'dua-latn-cm',\n  duc: 'duc-latn-zz',\n  dud: 'dud-latn-zz',\n  dug: 'dug-latn-zz',\n  dv: 'dv-thaa-mv',\n  dva: 'dva-latn-zz',\n  dww: 'dww-latn-zz',\n  dyo: 'dyo-latn-sn',\n  dyu: 'dyu-latn-bf',\n  dz: 'dz-tibt-bt',\n  dzg: 'dzg-latn-zz',\n  ebu: 'ebu-latn-ke',\n  ee: 'ee-latn-gh',\n  efi: 'efi-latn-ng',\n  egl: 'egl-latn-it',\n  egy: 'egy-egyp-eg',\n  eka: 'eka-latn-zz',\n  eky: 'eky-kali-mm',\n  el: 'el-grek-gr',\n  ema: 'ema-latn-zz',\n  emi: 'emi-latn-zz',\n  en: 'en-latn-us',\n  'en-shaw': 'en-shaw-gb',\n  enn: 'enn-latn-zz',\n  enq: 'enq-latn-zz',\n  eo: 'eo-latn-001',\n  eri: 'eri-latn-zz',\n  es: 'es-latn-es',\n  esg: 'esg-gonm-in',\n  esu: 'esu-latn-us',\n  et: 'et-latn-ee',\n  etr: 'etr-latn-zz',\n  ett: 'ett-ital-it',\n  etu: 'etu-latn-zz',\n  etx: 'etx-latn-zz',\n  eu: 'eu-latn-es',\n  ewo: 'ewo-latn-cm',\n  ext: 'ext-latn-es',\n  eza: 'eza-latn-zz',\n  fa: 'fa-arab-ir',\n  faa: 'faa-latn-zz',\n  fab: 'fab-latn-zz',\n  fag: 'fag-latn-zz',\n  fai: 'fai-latn-zz',\n  fan: 'fan-latn-gq',\n  ff: 'ff-latn-sn',\n  'ff-adlm': 'ff-adlm-gn',\n  ffi: 'ffi-latn-zz',\n  ffm: 'ffm-latn-ml',\n  fi: 'fi-latn-fi',\n  fia: 'fia-arab-sd',\n  fil: 'fil-latn-ph',\n  fit: 'fit-latn-se',\n  fj: 'fj-latn-fj',\n  flr: 'flr-latn-zz',\n  fmp: 'fmp-latn-zz',\n  fo: 'fo-latn-fo',\n  fod: 'fod-latn-zz',\n  fon: 'fon-latn-bj',\n  for: 'for-latn-zz',\n  fpe: 'fpe-latn-zz',\n  fqs: 'fqs-latn-zz',\n  fr: 'fr-latn-fr',\n  frc: 'frc-latn-us',\n  frp: 'frp-latn-fr',\n  frr: 'frr-latn-de',\n  frs: 'frs-latn-de',\n  fub: 'fub-arab-cm',\n  fud: 'fud-latn-wf',\n  fue: 'fue-latn-zz',\n  fuf: 'fuf-latn-gn',\n  fuh: 'fuh-latn-zz',\n  fuq: 'fuq-latn-ne',\n  fur: 'fur-latn-it',\n  fuv: 'fuv-latn-ng',\n  fuy: 'fuy-latn-zz',\n  fvr: 'fvr-latn-sd',\n  fy: 'fy-latn-nl',\n  ga: 'ga-latn-ie',\n  gaa: 'gaa-latn-gh',\n  gaf: 'gaf-latn-zz',\n  gag: 'gag-latn-md',\n  gah: 'gah-latn-zz',\n  gaj: 'gaj-latn-zz',\n  gam: 'gam-latn-zz',\n  gan: 'gan-hans-cn',\n  gaw: 'gaw-latn-zz',\n  gay: 'gay-latn-id',\n  gba: 'gba-latn-zz',\n  gbf: 'gbf-latn-zz',\n  gbm: 'gbm-deva-in',\n  gby: 'gby-latn-zz',\n  gbz: 'gbz-arab-ir',\n  gcr: 'gcr-latn-gf',\n  gd: 'gd-latn-gb',\n  gde: 'gde-latn-zz',\n  gdn: 'gdn-latn-zz',\n  gdr: 'gdr-latn-zz',\n  geb: 'geb-latn-zz',\n  gej: 'gej-latn-zz',\n  gel: 'gel-latn-zz',\n  gez: 'gez-ethi-et',\n  gfk: 'gfk-latn-zz',\n  ggn: 'ggn-deva-np',\n  ghs: 'ghs-latn-zz',\n  gil: 'gil-latn-ki',\n  gim: 'gim-latn-zz',\n  gjk: 'gjk-arab-pk',\n  gjn: 'gjn-latn-zz',\n  gju: 'gju-arab-pk',\n  gkn: 'gkn-latn-zz',\n  gkp: 'gkp-latn-zz',\n  gl: 'gl-latn-es',\n  glk: 'glk-arab-ir',\n  gmm: 'gmm-latn-zz',\n  gmv: 'gmv-ethi-zz',\n  gn: 'gn-latn-py',\n  gnd: 'gnd-latn-zz',\n  gng: 'gng-latn-zz',\n  god: 'god-latn-zz',\n  gof: 'gof-ethi-zz',\n  goi: 'goi-latn-zz',\n  gom: 'gom-deva-in',\n  gon: 'gon-telu-in',\n  gor: 'gor-latn-id',\n  gos: 'gos-latn-nl',\n  got: 'got-goth-ua',\n  grb: 'grb-latn-zz',\n  grc: 'grc-cprt-cy',\n  'grc-linb': 'grc-linb-gr',\n  grt: 'grt-beng-in',\n  grw: 'grw-latn-zz',\n  gsw: 'gsw-latn-ch',\n  gu: 'gu-gujr-in',\n  gub: 'gub-latn-br',\n  guc: 'guc-latn-co',\n  gud: 'gud-latn-zz',\n  gur: 'gur-latn-gh',\n  guw: 'guw-latn-zz',\n  gux: 'gux-latn-zz',\n  guz: 'guz-latn-ke',\n  gv: 'gv-latn-im',\n  gvf: 'gvf-latn-zz',\n  gvr: 'gvr-deva-np',\n  gvs: 'gvs-latn-zz',\n  gwc: 'gwc-arab-zz',\n  gwi: 'gwi-latn-ca',\n  gwt: 'gwt-arab-zz',\n  gyi: 'gyi-latn-zz',\n  ha: 'ha-latn-ng',\n  'ha-cm': 'ha-arab-cm',\n  'ha-sd': 'ha-arab-sd',\n  hag: 'hag-latn-zz',\n  hak: 'hak-hans-cn',\n  ham: 'ham-latn-zz',\n  haw: 'haw-latn-us',\n  haz: 'haz-arab-af',\n  hbb: 'hbb-latn-zz',\n  hdy: 'hdy-ethi-zz',\n  he: 'he-hebr-il',\n  hhy: 'hhy-latn-zz',\n  hi: 'hi-deva-in',\n  hia: 'hia-latn-zz',\n  hif: 'hif-latn-fj',\n  hig: 'hig-latn-zz',\n  hih: 'hih-latn-zz',\n  hil: 'hil-latn-ph',\n  hla: 'hla-latn-zz',\n  hlu: 'hlu-hluw-tr',\n  hmd: 'hmd-plrd-cn',\n  hmt: 'hmt-latn-zz',\n  hnd: 'hnd-arab-pk',\n  hne: 'hne-deva-in',\n  hnj: 'hnj-hmnp-us',\n  hnn: 'hnn-latn-ph',\n  hno: 'hno-arab-pk',\n  ho: 'ho-latn-pg',\n  hoc: 'hoc-deva-in',\n  hoj: 'hoj-deva-in',\n  hot: 'hot-latn-zz',\n  hr: 'hr-latn-hr',\n  hsb: 'hsb-latn-de',\n  hsn: 'hsn-hans-cn',\n  ht: 'ht-latn-ht',\n  hu: 'hu-latn-hu',\n  hui: 'hui-latn-zz',\n  hy: 'hy-armn-am',\n  hz: 'hz-latn-na',\n  ia: 'ia-latn-001',\n  ian: 'ian-latn-zz',\n  iar: 'iar-latn-zz',\n  iba: 'iba-latn-my',\n  ibb: 'ibb-latn-ng',\n  iby: 'iby-latn-zz',\n  ica: 'ica-latn-zz',\n  ich: 'ich-latn-zz',\n  id: 'id-latn-id',\n  idd: 'idd-latn-zz',\n  idi: 'idi-latn-zz',\n  idu: 'idu-latn-zz',\n  ife: 'ife-latn-tg',\n  ig: 'ig-latn-ng',\n  igb: 'igb-latn-zz',\n  ige: 'ige-latn-zz',\n  ii: 'ii-yiii-cn',\n  ijj: 'ijj-latn-zz',\n  ik: 'ik-latn-us',\n  ikk: 'ikk-latn-zz',\n  ikt: 'ikt-latn-ca',\n  ikw: 'ikw-latn-zz',\n  ikx: 'ikx-latn-zz',\n  ilo: 'ilo-latn-ph',\n  imo: 'imo-latn-zz',\n  in: 'in-latn-id',\n  inh: 'inh-cyrl-ru',\n  io: 'io-latn-001',\n  iou: 'iou-latn-zz',\n  iri: 'iri-latn-zz',\n  is: 'is-latn-is',\n  it: 'it-latn-it',\n  iu: 'iu-cans-ca',\n  iw: 'iw-hebr-il',\n  iwm: 'iwm-latn-zz',\n  iws: 'iws-latn-zz',\n  izh: 'izh-latn-ru',\n  izi: 'izi-latn-zz',\n  ja: 'ja-jpan-jp',\n  jab: 'jab-latn-zz',\n  jam: 'jam-latn-jm',\n  jar: 'jar-latn-zz',\n  jbo: 'jbo-latn-001',\n  jbu: 'jbu-latn-zz',\n  jen: 'jen-latn-zz',\n  jgk: 'jgk-latn-zz',\n  jgo: 'jgo-latn-cm',\n  ji: 'ji-hebr-ua',\n  jib: 'jib-latn-zz',\n  jmc: 'jmc-latn-tz',\n  jml: 'jml-deva-np',\n  jra: 'jra-latn-zz',\n  jut: 'jut-latn-dk',\n  jv: 'jv-latn-id',\n  jw: 'jw-latn-id',\n  ka: 'ka-geor-ge',\n  kaa: 'kaa-cyrl-uz',\n  kab: 'kab-latn-dz',\n  kac: 'kac-latn-mm',\n  kad: 'kad-latn-zz',\n  kai: 'kai-latn-zz',\n  kaj: 'kaj-latn-ng',\n  kam: 'kam-latn-ke',\n  kao: 'kao-latn-ml',\n  kbd: 'kbd-cyrl-ru',\n  kbm: 'kbm-latn-zz',\n  kbp: 'kbp-latn-zz',\n  kbq: 'kbq-latn-zz',\n  kbx: 'kbx-latn-zz',\n  kby: 'kby-arab-ne',\n  kcg: 'kcg-latn-ng',\n  kck: 'kck-latn-zw',\n  kcl: 'kcl-latn-zz',\n  kct: 'kct-latn-zz',\n  kde: 'kde-latn-tz',\n  kdh: 'kdh-latn-tg',\n  kdl: 'kdl-latn-zz',\n  kdt: 'kdt-thai-th',\n  kea: 'kea-latn-cv',\n  ken: 'ken-latn-cm',\n  kez: 'kez-latn-zz',\n  kfo: 'kfo-latn-ci',\n  kfr: 'kfr-deva-in',\n  kfy: 'kfy-deva-in',\n  kg: 'kg-latn-cd',\n  kge: 'kge-latn-id',\n  kgf: 'kgf-latn-zz',\n  kgp: 'kgp-latn-br',\n  kha: 'kha-latn-in',\n  khb: 'khb-talu-cn',\n  khn: 'khn-deva-in',\n  khq: 'khq-latn-ml',\n  khs: 'khs-latn-zz',\n  kht: 'kht-mymr-in',\n  khw: 'khw-arab-pk',\n  khz: 'khz-latn-zz',\n  ki: 'ki-latn-ke',\n  kij: 'kij-latn-zz',\n  kiu: 'kiu-latn-tr',\n  kiw: 'kiw-latn-zz',\n  kj: 'kj-latn-na',\n  kjd: 'kjd-latn-zz',\n  kjg: 'kjg-laoo-la',\n  kjs: 'kjs-latn-zz',\n  kjy: 'kjy-latn-zz',\n  kk: 'kk-cyrl-kz',\n  'kk-af': 'kk-arab-af',\n  'kk-arab': 'kk-arab-cn',\n  'kk-cn': 'kk-arab-cn',\n  'kk-ir': 'kk-arab-ir',\n  'kk-mn': 'kk-arab-mn',\n  kkc: 'kkc-latn-zz',\n  kkj: 'kkj-latn-cm',\n  kl: 'kl-latn-gl',\n  kln: 'kln-latn-ke',\n  klq: 'klq-latn-zz',\n  klt: 'klt-latn-zz',\n  klx: 'klx-latn-zz',\n  km: 'km-khmr-kh',\n  kmb: 'kmb-latn-ao',\n  kmh: 'kmh-latn-zz',\n  kmo: 'kmo-latn-zz',\n  kms: 'kms-latn-zz',\n  kmu: 'kmu-latn-zz',\n  kmw: 'kmw-latn-zz',\n  kn: 'kn-knda-in',\n  knf: 'knf-latn-gw',\n  knp: 'knp-latn-zz',\n  ko: 'ko-kore-kr',\n  koi: 'koi-cyrl-ru',\n  kok: 'kok-deva-in',\n  kol: 'kol-latn-zz',\n  kos: 'kos-latn-fm',\n  koz: 'koz-latn-zz',\n  kpe: 'kpe-latn-lr',\n  kpf: 'kpf-latn-zz',\n  kpo: 'kpo-latn-zz',\n  kpr: 'kpr-latn-zz',\n  kpx: 'kpx-latn-zz',\n  kqb: 'kqb-latn-zz',\n  kqf: 'kqf-latn-zz',\n  kqs: 'kqs-latn-zz',\n  kqy: 'kqy-ethi-zz',\n  kr: 'kr-latn-zz',\n  krc: 'krc-cyrl-ru',\n  kri: 'kri-latn-sl',\n  krj: 'krj-latn-ph',\n  krl: 'krl-latn-ru',\n  krs: 'krs-latn-zz',\n  kru: 'kru-deva-in',\n  ks: 'ks-arab-in',\n  ksb: 'ksb-latn-tz',\n  ksd: 'ksd-latn-zz',\n  ksf: 'ksf-latn-cm',\n  ksh: 'ksh-latn-de',\n  ksj: 'ksj-latn-zz',\n  ksr: 'ksr-latn-zz',\n  ktb: 'ktb-ethi-zz',\n  ktm: 'ktm-latn-zz',\n  kto: 'kto-latn-zz',\n  ktr: 'ktr-latn-my',\n  ku: 'ku-latn-tr',\n  'ku-arab': 'ku-arab-iq',\n  'ku-lb': 'ku-arab-lb',\n  'ku-yezi': 'ku-yezi-ge',\n  kub: 'kub-latn-zz',\n  kud: 'kud-latn-zz',\n  kue: 'kue-latn-zz',\n  kuj: 'kuj-latn-zz',\n  kum: 'kum-cyrl-ru',\n  kun: 'kun-latn-zz',\n  kup: 'kup-latn-zz',\n  kus: 'kus-latn-zz',\n  kv: 'kv-cyrl-ru',\n  kvg: 'kvg-latn-zz',\n  kvr: 'kvr-latn-id',\n  kvx: 'kvx-arab-pk',\n  kw: 'kw-latn-gb',\n  kwj: 'kwj-latn-zz',\n  kwo: 'kwo-latn-zz',\n  kwq: 'kwq-latn-zz',\n  kxa: 'kxa-latn-zz',\n  kxc: 'kxc-ethi-zz',\n  kxe: 'kxe-latn-zz',\n  kxl: 'kxl-deva-in',\n  kxm: 'kxm-thai-th',\n  kxp: 'kxp-arab-pk',\n  kxw: 'kxw-latn-zz',\n  kxz: 'kxz-latn-zz',\n  ky: 'ky-cyrl-kg',\n  'ky-arab': 'ky-arab-cn',\n  'ky-cn': 'ky-arab-cn',\n  'ky-latn': 'ky-latn-tr',\n  'ky-tr': 'ky-latn-tr',\n  kye: 'kye-latn-zz',\n  kyx: 'kyx-latn-zz',\n  kzh: 'kzh-arab-zz',\n  kzj: 'kzj-latn-my',\n  kzr: 'kzr-latn-zz',\n  kzt: 'kzt-latn-my',\n  la: 'la-latn-va',\n  lab: 'lab-lina-gr',\n  lad: 'lad-hebr-il',\n  lag: 'lag-latn-tz',\n  lah: 'lah-arab-pk',\n  laj: 'laj-latn-ug',\n  las: 'las-latn-zz',\n  lb: 'lb-latn-lu',\n  lbe: 'lbe-cyrl-ru',\n  lbu: 'lbu-latn-zz',\n  lbw: 'lbw-latn-id',\n  lcm: 'lcm-latn-zz',\n  lcp: 'lcp-thai-cn',\n  ldb: 'ldb-latn-zz',\n  led: 'led-latn-zz',\n  lee: 'lee-latn-zz',\n  lem: 'lem-latn-zz',\n  lep: 'lep-lepc-in',\n  leq: 'leq-latn-zz',\n  leu: 'leu-latn-zz',\n  lez: 'lez-cyrl-ru',\n  lg: 'lg-latn-ug',\n  lgg: 'lgg-latn-zz',\n  li: 'li-latn-nl',\n  lia: 'lia-latn-zz',\n  lid: 'lid-latn-zz',\n  lif: 'lif-deva-np',\n  'lif-limb': 'lif-limb-in',\n  lig: 'lig-latn-zz',\n  lih: 'lih-latn-zz',\n  lij: 'lij-latn-it',\n  lis: 'lis-lisu-cn',\n  ljp: 'ljp-latn-id',\n  lki: 'lki-arab-ir',\n  lkt: 'lkt-latn-us',\n  lle: 'lle-latn-zz',\n  lln: 'lln-latn-zz',\n  lmn: 'lmn-telu-in',\n  lmo: 'lmo-latn-it',\n  lmp: 'lmp-latn-zz',\n  ln: 'ln-latn-cd',\n  lns: 'lns-latn-zz',\n  lnu: 'lnu-latn-zz',\n  lo: 'lo-laoo-la',\n  loj: 'loj-latn-zz',\n  lok: 'lok-latn-zz',\n  lol: 'lol-latn-cd',\n  lor: 'lor-latn-zz',\n  los: 'los-latn-zz',\n  loz: 'loz-latn-zm',\n  lrc: 'lrc-arab-ir',\n  lt: 'lt-latn-lt',\n  ltg: 'ltg-latn-lv',\n  lu: 'lu-latn-cd',\n  lua: 'lua-latn-cd',\n  luo: 'luo-latn-ke',\n  luy: 'luy-latn-ke',\n  luz: 'luz-arab-ir',\n  lv: 'lv-latn-lv',\n  lwl: 'lwl-thai-th',\n  lzh: 'lzh-hans-cn',\n  lzz: 'lzz-latn-tr',\n  mad: 'mad-latn-id',\n  maf: 'maf-latn-cm',\n  mag: 'mag-deva-in',\n  mai: 'mai-deva-in',\n  mak: 'mak-latn-id',\n  man: 'man-latn-gm',\n  'man-gn': 'man-nkoo-gn',\n  'man-nkoo': 'man-nkoo-gn',\n  mas: 'mas-latn-ke',\n  maw: 'maw-latn-zz',\n  maz: 'maz-latn-mx',\n  mbh: 'mbh-latn-zz',\n  mbo: 'mbo-latn-zz',\n  mbq: 'mbq-latn-zz',\n  mbu: 'mbu-latn-zz',\n  mbw: 'mbw-latn-zz',\n  mci: 'mci-latn-zz',\n  mcp: 'mcp-latn-zz',\n  mcq: 'mcq-latn-zz',\n  mcr: 'mcr-latn-zz',\n  mcu: 'mcu-latn-zz',\n  mda: 'mda-latn-zz',\n  mde: 'mde-arab-zz',\n  mdf: 'mdf-cyrl-ru',\n  mdh: 'mdh-latn-ph',\n  mdj: 'mdj-latn-zz',\n  mdr: 'mdr-latn-id',\n  mdx: 'mdx-ethi-zz',\n  med: 'med-latn-zz',\n  mee: 'mee-latn-zz',\n  mek: 'mek-latn-zz',\n  men: 'men-latn-sl',\n  mer: 'mer-latn-ke',\n  met: 'met-latn-zz',\n  meu: 'meu-latn-zz',\n  mfa: 'mfa-arab-th',\n  mfe: 'mfe-latn-mu',\n  mfn: 'mfn-latn-zz',\n  mfo: 'mfo-latn-zz',\n  mfq: 'mfq-latn-zz',\n  mg: 'mg-latn-mg',\n  mgh: 'mgh-latn-mz',\n  mgl: 'mgl-latn-zz',\n  mgo: 'mgo-latn-cm',\n  mgp: 'mgp-deva-np',\n  mgy: 'mgy-latn-tz',\n  mh: 'mh-latn-mh',\n  mhi: 'mhi-latn-zz',\n  mhl: 'mhl-latn-zz',\n  mi: 'mi-latn-nz',\n  mif: 'mif-latn-zz',\n  min: 'min-latn-id',\n  miw: 'miw-latn-zz',\n  mk: 'mk-cyrl-mk',\n  mki: 'mki-arab-zz',\n  mkl: 'mkl-latn-zz',\n  mkp: 'mkp-latn-zz',\n  mkw: 'mkw-latn-zz',\n  ml: 'ml-mlym-in',\n  mle: 'mle-latn-zz',\n  mlp: 'mlp-latn-zz',\n  mls: 'mls-latn-sd',\n  mmo: 'mmo-latn-zz',\n  mmu: 'mmu-latn-zz',\n  mmx: 'mmx-latn-zz',\n  mn: 'mn-cyrl-mn',\n  'mn-cn': 'mn-mong-cn',\n  'mn-mong': 'mn-mong-cn',\n  mna: 'mna-latn-zz',\n  mnf: 'mnf-latn-zz',\n  mni: 'mni-beng-in',\n  mnw: 'mnw-mymr-mm',\n  mo: 'mo-latn-ro',\n  moa: 'moa-latn-zz',\n  moe: 'moe-latn-ca',\n  moh: 'moh-latn-ca',\n  mos: 'mos-latn-bf',\n  mox: 'mox-latn-zz',\n  mpp: 'mpp-latn-zz',\n  mps: 'mps-latn-zz',\n  mpt: 'mpt-latn-zz',\n  mpx: 'mpx-latn-zz',\n  mql: 'mql-latn-zz',\n  mr: 'mr-deva-in',\n  mrd: 'mrd-deva-np',\n  mrj: 'mrj-cyrl-ru',\n  mro: 'mro-mroo-bd',\n  ms: 'ms-latn-my',\n  'ms-cc': 'ms-arab-cc',\n  mt: 'mt-latn-mt',\n  mtc: 'mtc-latn-zz',\n  mtf: 'mtf-latn-zz',\n  mti: 'mti-latn-zz',\n  mtr: 'mtr-deva-in',\n  mua: 'mua-latn-cm',\n  mur: 'mur-latn-zz',\n  mus: 'mus-latn-us',\n  mva: 'mva-latn-zz',\n  mvn: 'mvn-latn-zz',\n  mvy: 'mvy-arab-pk',\n  mwk: 'mwk-latn-ml',\n  mwr: 'mwr-deva-in',\n  mwv: 'mwv-latn-id',\n  mww: 'mww-hmnp-us',\n  mxc: 'mxc-latn-zw',\n  mxm: 'mxm-latn-zz',\n  my: 'my-mymr-mm',\n  myk: 'myk-latn-zz',\n  mym: 'mym-ethi-zz',\n  myv: 'myv-cyrl-ru',\n  myw: 'myw-latn-zz',\n  myx: 'myx-latn-ug',\n  myz: 'myz-mand-ir',\n  mzk: 'mzk-latn-zz',\n  mzm: 'mzm-latn-zz',\n  mzn: 'mzn-arab-ir',\n  mzp: 'mzp-latn-zz',\n  mzw: 'mzw-latn-zz',\n  mzz: 'mzz-latn-zz',\n  na: 'na-latn-nr',\n  nac: 'nac-latn-zz',\n  naf: 'naf-latn-zz',\n  nak: 'nak-latn-zz',\n  nan: 'nan-hans-cn',\n  nap: 'nap-latn-it',\n  naq: 'naq-latn-na',\n  nas: 'nas-latn-zz',\n  nb: 'nb-latn-no',\n  nca: 'nca-latn-zz',\n  nce: 'nce-latn-zz',\n  ncf: 'ncf-latn-zz',\n  nch: 'nch-latn-mx',\n  nco: 'nco-latn-zz',\n  ncu: 'ncu-latn-zz',\n  nd: 'nd-latn-zw',\n  ndc: 'ndc-latn-mz',\n  nds: 'nds-latn-de',\n  ne: 'ne-deva-np',\n  neb: 'neb-latn-zz',\n  new: 'new-deva-np',\n  nex: 'nex-latn-zz',\n  nfr: 'nfr-latn-zz',\n  ng: 'ng-latn-na',\n  nga: 'nga-latn-zz',\n  ngb: 'ngb-latn-zz',\n  ngl: 'ngl-latn-mz',\n  nhb: 'nhb-latn-zz',\n  nhe: 'nhe-latn-mx',\n  nhw: 'nhw-latn-mx',\n  nif: 'nif-latn-zz',\n  nii: 'nii-latn-zz',\n  nij: 'nij-latn-id',\n  nin: 'nin-latn-zz',\n  niu: 'niu-latn-nu',\n  niy: 'niy-latn-zz',\n  niz: 'niz-latn-zz',\n  njo: 'njo-latn-in',\n  nkg: 'nkg-latn-zz',\n  nko: 'nko-latn-zz',\n  nl: 'nl-latn-nl',\n  nmg: 'nmg-latn-cm',\n  nmz: 'nmz-latn-zz',\n  nn: 'nn-latn-no',\n  nnf: 'nnf-latn-zz',\n  nnh: 'nnh-latn-cm',\n  nnk: 'nnk-latn-zz',\n  nnm: 'nnm-latn-zz',\n  nnp: 'nnp-wcho-in',\n  no: 'no-latn-no',\n  nod: 'nod-lana-th',\n  noe: 'noe-deva-in',\n  non: 'non-runr-se',\n  nop: 'nop-latn-zz',\n  nou: 'nou-latn-zz',\n  nqo: 'nqo-nkoo-gn',\n  nr: 'nr-latn-za',\n  nrb: 'nrb-latn-zz',\n  nsk: 'nsk-cans-ca',\n  nsn: 'nsn-latn-zz',\n  nso: 'nso-latn-za',\n  nss: 'nss-latn-zz',\n  nst: 'nst-tnsa-in',\n  ntm: 'ntm-latn-zz',\n  ntr: 'ntr-latn-zz',\n  nui: 'nui-latn-zz',\n  nup: 'nup-latn-zz',\n  nus: 'nus-latn-ss',\n  nuv: 'nuv-latn-zz',\n  nux: 'nux-latn-zz',\n  nv: 'nv-latn-us',\n  nwb: 'nwb-latn-zz',\n  nxq: 'nxq-latn-cn',\n  nxr: 'nxr-latn-zz',\n  ny: 'ny-latn-mw',\n  nym: 'nym-latn-tz',\n  nyn: 'nyn-latn-ug',\n  nzi: 'nzi-latn-gh',\n  oc: 'oc-latn-fr',\n  ogc: 'ogc-latn-zz',\n  okr: 'okr-latn-zz',\n  okv: 'okv-latn-zz',\n  om: 'om-latn-et',\n  ong: 'ong-latn-zz',\n  onn: 'onn-latn-zz',\n  ons: 'ons-latn-zz',\n  opm: 'opm-latn-zz',\n  or: 'or-orya-in',\n  oro: 'oro-latn-zz',\n  oru: 'oru-arab-zz',\n  os: 'os-cyrl-ge',\n  osa: 'osa-osge-us',\n  ota: 'ota-arab-zz',\n  otk: 'otk-orkh-mn',\n  oui: 'oui-ougr-143',\n  ozm: 'ozm-latn-zz',\n  pa: 'pa-guru-in',\n  'pa-arab': 'pa-arab-pk',\n  'pa-pk': 'pa-arab-pk',\n  pag: 'pag-latn-ph',\n  pal: 'pal-phli-ir',\n  'pal-phlp': 'pal-phlp-cn',\n  pam: 'pam-latn-ph',\n  pap: 'pap-latn-aw',\n  pau: 'pau-latn-pw',\n  pbi: 'pbi-latn-zz',\n  pcd: 'pcd-latn-fr',\n  pcm: 'pcm-latn-ng',\n  pdc: 'pdc-latn-us',\n  pdt: 'pdt-latn-ca',\n  ped: 'ped-latn-zz',\n  peo: 'peo-xpeo-ir',\n  pex: 'pex-latn-zz',\n  pfl: 'pfl-latn-de',\n  phl: 'phl-arab-zz',\n  phn: 'phn-phnx-lb',\n  pil: 'pil-latn-zz',\n  pip: 'pip-latn-zz',\n  pka: 'pka-brah-in',\n  pko: 'pko-latn-ke',\n  pl: 'pl-latn-pl',\n  pla: 'pla-latn-zz',\n  pms: 'pms-latn-it',\n  png: 'png-latn-zz',\n  pnn: 'pnn-latn-zz',\n  pnt: 'pnt-grek-gr',\n  pon: 'pon-latn-fm',\n  ppa: 'ppa-deva-in',\n  ppo: 'ppo-latn-zz',\n  pra: 'pra-khar-pk',\n  prd: 'prd-arab-ir',\n  prg: 'prg-latn-001',\n  ps: 'ps-arab-af',\n  pss: 'pss-latn-zz',\n  pt: 'pt-latn-br',\n  ptp: 'ptp-latn-zz',\n  puu: 'puu-latn-ga',\n  pwa: 'pwa-latn-zz',\n  qu: 'qu-latn-pe',\n  quc: 'quc-latn-gt',\n  qug: 'qug-latn-ec',\n  rai: 'rai-latn-zz',\n  raj: 'raj-deva-in',\n  rao: 'rao-latn-zz',\n  rcf: 'rcf-latn-re',\n  rej: 'rej-latn-id',\n  rel: 'rel-latn-zz',\n  res: 'res-latn-zz',\n  rgn: 'rgn-latn-it',\n  rhg: 'rhg-rohg-mm',\n  ria: 'ria-latn-in',\n  rif: 'rif-tfng-ma',\n  'rif-nl': 'rif-latn-nl',\n  rjs: 'rjs-deva-np',\n  rkt: 'rkt-beng-bd',\n  rm: 'rm-latn-ch',\n  rmf: 'rmf-latn-fi',\n  rmo: 'rmo-latn-ch',\n  rmt: 'rmt-arab-ir',\n  rmu: 'rmu-latn-se',\n  rn: 'rn-latn-bi',\n  rna: 'rna-latn-zz',\n  rng: 'rng-latn-mz',\n  ro: 'ro-latn-ro',\n  rob: 'rob-latn-id',\n  rof: 'rof-latn-tz',\n  roo: 'roo-latn-zz',\n  rro: 'rro-latn-zz',\n  rtm: 'rtm-latn-fj',\n  ru: 'ru-cyrl-ru',\n  rue: 'rue-cyrl-ua',\n  rug: 'rug-latn-sb',\n  rw: 'rw-latn-rw',\n  rwk: 'rwk-latn-tz',\n  rwo: 'rwo-latn-zz',\n  ryu: 'ryu-kana-jp',\n  sa: 'sa-deva-in',\n  saf: 'saf-latn-gh',\n  sah: 'sah-cyrl-ru',\n  saq: 'saq-latn-ke',\n  sas: 'sas-latn-id',\n  sat: 'sat-olck-in',\n  sav: 'sav-latn-sn',\n  saz: 'saz-saur-in',\n  sba: 'sba-latn-zz',\n  sbe: 'sbe-latn-zz',\n  sbp: 'sbp-latn-tz',\n  sc: 'sc-latn-it',\n  sck: 'sck-deva-in',\n  scl: 'scl-arab-zz',\n  scn: 'scn-latn-it',\n  sco: 'sco-latn-gb',\n  scs: 'scs-latn-ca',\n  sd: 'sd-arab-pk',\n  'sd-deva': 'sd-deva-in',\n  'sd-khoj': 'sd-khoj-in',\n  'sd-sind': 'sd-sind-in',\n  sdc: 'sdc-latn-it',\n  sdh: 'sdh-arab-ir',\n  se: 'se-latn-no',\n  sef: 'sef-latn-ci',\n  seh: 'seh-latn-mz',\n  sei: 'sei-latn-mx',\n  ses: 'ses-latn-ml',\n  sg: 'sg-latn-cf',\n  sga: 'sga-ogam-ie',\n  sgs: 'sgs-latn-lt',\n  sgw: 'sgw-ethi-zz',\n  sgz: 'sgz-latn-zz',\n  shi: 'shi-tfng-ma',\n  shk: 'shk-latn-zz',\n  shn: 'shn-mymr-mm',\n  shu: 'shu-arab-zz',\n  si: 'si-sinh-lk',\n  sid: 'sid-latn-et',\n  sig: 'sig-latn-zz',\n  sil: 'sil-latn-zz',\n  sim: 'sim-latn-zz',\n  sjr: 'sjr-latn-zz',\n  sk: 'sk-latn-sk',\n  skc: 'skc-latn-zz',\n  skr: 'skr-arab-pk',\n  sks: 'sks-latn-zz',\n  sl: 'sl-latn-si',\n  sld: 'sld-latn-zz',\n  sli: 'sli-latn-pl',\n  sll: 'sll-latn-zz',\n  sly: 'sly-latn-id',\n  sm: 'sm-latn-ws',\n  sma: 'sma-latn-se',\n  smj: 'smj-latn-se',\n  smn: 'smn-latn-fi',\n  smp: 'smp-samr-il',\n  smq: 'smq-latn-zz',\n  sms: 'sms-latn-fi',\n  sn: 'sn-latn-zw',\n  snc: 'snc-latn-zz',\n  snk: 'snk-latn-ml',\n  snp: 'snp-latn-zz',\n  snx: 'snx-latn-zz',\n  sny: 'sny-latn-zz',\n  so: 'so-latn-so',\n  sog: 'sog-sogd-uz',\n  sok: 'sok-latn-zz',\n  soq: 'soq-latn-zz',\n  sou: 'sou-thai-th',\n  soy: 'soy-latn-zz',\n  spd: 'spd-latn-zz',\n  spl: 'spl-latn-zz',\n  sps: 'sps-latn-zz',\n  sq: 'sq-latn-al',\n  sr: 'sr-cyrl-rs',\n  'sr-me': 'sr-latn-me',\n  'sr-ro': 'sr-latn-ro',\n  'sr-ru': 'sr-latn-ru',\n  'sr-tr': 'sr-latn-tr',\n  srb: 'srb-sora-in',\n  srn: 'srn-latn-sr',\n  srr: 'srr-latn-sn',\n  srx: 'srx-deva-in',\n  ss: 'ss-latn-za',\n  ssd: 'ssd-latn-zz',\n  ssg: 'ssg-latn-zz',\n  ssy: 'ssy-latn-er',\n  st: 'st-latn-za',\n  stk: 'stk-latn-zz',\n  stq: 'stq-latn-de',\n  su: 'su-latn-id',\n  sua: 'sua-latn-zz',\n  sue: 'sue-latn-zz',\n  suk: 'suk-latn-tz',\n  sur: 'sur-latn-zz',\n  sus: 'sus-latn-gn',\n  sv: 'sv-latn-se',\n  sw: 'sw-latn-tz',\n  swb: 'swb-arab-yt',\n  swc: 'swc-latn-cd',\n  swg: 'swg-latn-de',\n  swp: 'swp-latn-zz',\n  swv: 'swv-deva-in',\n  sxn: 'sxn-latn-id',\n  sxw: 'sxw-latn-zz',\n  syl: 'syl-beng-bd',\n  syr: 'syr-syrc-iq',\n  szl: 'szl-latn-pl',\n  ta: 'ta-taml-in',\n  taj: 'taj-deva-np',\n  tal: 'tal-latn-zz',\n  tan: 'tan-latn-zz',\n  taq: 'taq-latn-zz',\n  tbc: 'tbc-latn-zz',\n  tbd: 'tbd-latn-zz',\n  tbf: 'tbf-latn-zz',\n  tbg: 'tbg-latn-zz',\n  tbo: 'tbo-latn-zz',\n  tbw: 'tbw-latn-ph',\n  tbz: 'tbz-latn-zz',\n  tci: 'tci-latn-zz',\n  tcy: 'tcy-knda-in',\n  tdd: 'tdd-tale-cn',\n  tdg: 'tdg-deva-np',\n  tdh: 'tdh-deva-np',\n  tdu: 'tdu-latn-my',\n  te: 'te-telu-in',\n  ted: 'ted-latn-zz',\n  tem: 'tem-latn-sl',\n  teo: 'teo-latn-ug',\n  tet: 'tet-latn-tl',\n  tfi: 'tfi-latn-zz',\n  tg: 'tg-cyrl-tj',\n  'tg-arab': 'tg-arab-pk',\n  'tg-pk': 'tg-arab-pk',\n  tgc: 'tgc-latn-zz',\n  tgo: 'tgo-latn-zz',\n  tgu: 'tgu-latn-zz',\n  th: 'th-thai-th',\n  thl: 'thl-deva-np',\n  thq: 'thq-deva-np',\n  thr: 'thr-deva-np',\n  ti: 'ti-ethi-et',\n  tif: 'tif-latn-zz',\n  tig: 'tig-ethi-er',\n  tik: 'tik-latn-zz',\n  tim: 'tim-latn-zz',\n  tio: 'tio-latn-zz',\n  tiv: 'tiv-latn-ng',\n  tk: 'tk-latn-tm',\n  tkl: 'tkl-latn-tk',\n  tkr: 'tkr-latn-az',\n  tkt: 'tkt-deva-np',\n  tl: 'tl-latn-ph',\n  tlf: 'tlf-latn-zz',\n  tlx: 'tlx-latn-zz',\n  tly: 'tly-latn-az',\n  tmh: 'tmh-latn-ne',\n  tmy: 'tmy-latn-zz',\n  tn: 'tn-latn-za',\n  tnh: 'tnh-latn-zz',\n  to: 'to-latn-to',\n  tof: 'tof-latn-zz',\n  tog: 'tog-latn-mw',\n  toq: 'toq-latn-zz',\n  tpi: 'tpi-latn-pg',\n  tpm: 'tpm-latn-zz',\n  tpz: 'tpz-latn-zz',\n  tqo: 'tqo-latn-zz',\n  tr: 'tr-latn-tr',\n  tru: 'tru-latn-tr',\n  trv: 'trv-latn-tw',\n  trw: 'trw-arab-pk',\n  ts: 'ts-latn-za',\n  tsd: 'tsd-grek-gr',\n  tsf: 'tsf-deva-np',\n  tsg: 'tsg-latn-ph',\n  tsj: 'tsj-tibt-bt',\n  tsw: 'tsw-latn-zz',\n  tt: 'tt-cyrl-ru',\n  ttd: 'ttd-latn-zz',\n  tte: 'tte-latn-zz',\n  ttj: 'ttj-latn-ug',\n  ttr: 'ttr-latn-zz',\n  tts: 'tts-thai-th',\n  ttt: 'ttt-latn-az',\n  tuh: 'tuh-latn-zz',\n  tul: 'tul-latn-zz',\n  tum: 'tum-latn-mw',\n  tuq: 'tuq-latn-zz',\n  tvd: 'tvd-latn-zz',\n  tvl: 'tvl-latn-tv',\n  tvu: 'tvu-latn-zz',\n  twh: 'twh-latn-zz',\n  twq: 'twq-latn-ne',\n  txg: 'txg-tang-cn',\n  txo: 'txo-toto-in',\n  ty: 'ty-latn-pf',\n  tya: 'tya-latn-zz',\n  tyv: 'tyv-cyrl-ru',\n  tzm: 'tzm-latn-ma',\n  ubu: 'ubu-latn-zz',\n  udi: 'udi-aghb-ru',\n  udm: 'udm-cyrl-ru',\n  ug: 'ug-arab-cn',\n  'ug-cyrl': 'ug-cyrl-kz',\n  'ug-kz': 'ug-cyrl-kz',\n  'ug-mn': 'ug-cyrl-mn',\n  uga: 'uga-ugar-sy',\n  uk: 'uk-cyrl-ua',\n  uli: 'uli-latn-fm',\n  umb: 'umb-latn-ao',\n  und: 'en-latn-us',\n  'und-002': 'en-latn-ng',\n  'und-003': 'en-latn-us',\n  'und-005': 'pt-latn-br',\n  'und-009': 'en-latn-au',\n  'und-011': 'en-latn-ng',\n  'und-013': 'es-latn-mx',\n  'und-014': 'sw-latn-tz',\n  'und-015': 'ar-arab-eg',\n  'und-017': 'sw-latn-cd',\n  'und-018': 'en-latn-za',\n  'und-019': 'en-latn-us',\n  'und-021': 'en-latn-us',\n  'und-029': 'es-latn-cu',\n  'und-030': 'zh-hans-cn',\n  'und-034': 'hi-deva-in',\n  'und-035': 'id-latn-id',\n  'und-039': 'it-latn-it',\n  'und-053': 'en-latn-au',\n  'und-054': 'en-latn-pg',\n  'und-057': 'en-latn-gu',\n  'und-061': 'sm-latn-ws',\n  'und-142': 'zh-hans-cn',\n  'und-143': 'uz-latn-uz',\n  'und-145': 'ar-arab-sa',\n  'und-150': 'ru-cyrl-ru',\n  'und-151': 'ru-cyrl-ru',\n  'und-154': 'en-latn-gb',\n  'und-155': 'de-latn-de',\n  'und-202': 'en-latn-ng',\n  'und-419': 'es-latn-419',\n  'und-ad': 'ca-latn-ad',\n  'und-adlm': 'ff-adlm-gn',\n  'und-ae': 'ar-arab-ae',\n  'und-af': 'fa-arab-af',\n  'und-aghb': 'udi-aghb-ru',\n  'und-ahom': 'aho-ahom-in',\n  'und-al': 'sq-latn-al',\n  'und-am': 'hy-armn-am',\n  'und-ao': 'pt-latn-ao',\n  'und-aq': 'und-latn-aq',\n  'und-ar': 'es-latn-ar',\n  'und-arab': 'ar-arab-eg',\n  'und-arab-cc': 'ms-arab-cc',\n  'und-arab-cn': 'ug-arab-cn',\n  'und-arab-gb': 'ks-arab-gb',\n  'und-arab-id': 'ms-arab-id',\n  'und-arab-in': 'ur-arab-in',\n  'und-arab-kh': 'cja-arab-kh',\n  'und-arab-mm': 'rhg-arab-mm',\n  'und-arab-mn': 'kk-arab-mn',\n  'und-arab-mu': 'ur-arab-mu',\n  'und-arab-ng': 'ha-arab-ng',\n  'und-arab-pk': 'ur-arab-pk',\n  'und-arab-tg': 'apd-arab-tg',\n  'und-arab-th': 'mfa-arab-th',\n  'und-arab-tj': 'fa-arab-tj',\n  'und-arab-tr': 'az-arab-tr',\n  'und-arab-yt': 'swb-arab-yt',\n  'und-armi': 'arc-armi-ir',\n  'und-armn': 'hy-armn-am',\n  'und-as': 'sm-latn-as',\n  'und-at': 'de-latn-at',\n  'und-avst': 'ae-avst-ir',\n  'und-aw': 'nl-latn-aw',\n  'und-ax': 'sv-latn-ax',\n  'und-az': 'az-latn-az',\n  'und-ba': 'bs-latn-ba',\n  'und-bali': 'ban-bali-id',\n  'und-bamu': 'bax-bamu-cm',\n  'und-bass': 'bsq-bass-lr',\n  'und-batk': 'bbc-batk-id',\n  'und-bd': 'bn-beng-bd',\n  'und-be': 'nl-latn-be',\n  'und-beng': 'bn-beng-bd',\n  'und-bf': 'fr-latn-bf',\n  'und-bg': 'bg-cyrl-bg',\n  'und-bh': 'ar-arab-bh',\n  'und-bhks': 'sa-bhks-in',\n  'und-bi': 'rn-latn-bi',\n  'und-bj': 'fr-latn-bj',\n  'und-bl': 'fr-latn-bl',\n  'und-bn': 'ms-latn-bn',\n  'und-bo': 'es-latn-bo',\n  'und-bopo': 'zh-bopo-tw',\n  'und-bq': 'pap-latn-bq',\n  'und-br': 'pt-latn-br',\n  'und-brah': 'pka-brah-in',\n  'und-brai': 'fr-brai-fr',\n  'und-bt': 'dz-tibt-bt',\n  'und-bugi': 'bug-bugi-id',\n  'und-buhd': 'bku-buhd-ph',\n  'und-bv': 'und-latn-bv',\n  'und-by': 'be-cyrl-by',\n  'und-cakm': 'ccp-cakm-bd',\n  'und-cans': 'cr-cans-ca',\n  'und-cari': 'xcr-cari-tr',\n  'und-cd': 'sw-latn-cd',\n  'und-cf': 'fr-latn-cf',\n  'und-cg': 'fr-latn-cg',\n  'und-ch': 'de-latn-ch',\n  'und-cham': 'cjm-cham-vn',\n  'und-cher': 'chr-cher-us',\n  'und-chrs': 'xco-chrs-uz',\n  'und-ci': 'fr-latn-ci',\n  'und-cl': 'es-latn-cl',\n  'und-cm': 'fr-latn-cm',\n  'und-cn': 'zh-hans-cn',\n  'und-co': 'es-latn-co',\n  'und-copt': 'cop-copt-eg',\n  'und-cp': 'und-latn-cp',\n  'und-cpmn': 'und-cpmn-cy',\n  'und-cpmn-cy': 'und-cpmn-cy',\n  'und-cprt': 'grc-cprt-cy',\n  'und-cr': 'es-latn-cr',\n  'und-cu': 'es-latn-cu',\n  'und-cv': 'pt-latn-cv',\n  'und-cw': 'pap-latn-cw',\n  'und-cy': 'el-grek-cy',\n  'und-cyrl': 'ru-cyrl-ru',\n  'und-cyrl-al': 'mk-cyrl-al',\n  'und-cyrl-ba': 'sr-cyrl-ba',\n  'und-cyrl-ge': 'os-cyrl-ge',\n  'und-cyrl-gr': 'mk-cyrl-gr',\n  'und-cyrl-md': 'uk-cyrl-md',\n  'und-cyrl-ro': 'bg-cyrl-ro',\n  'und-cyrl-sk': 'uk-cyrl-sk',\n  'und-cyrl-tr': 'kbd-cyrl-tr',\n  'und-cyrl-xk': 'sr-cyrl-xk',\n  'und-cz': 'cs-latn-cz',\n  'und-de': 'de-latn-de',\n  'und-deva': 'hi-deva-in',\n  'und-deva-bt': 'ne-deva-bt',\n  'und-deva-fj': 'hif-deva-fj',\n  'und-deva-mu': 'bho-deva-mu',\n  'und-deva-pk': 'btv-deva-pk',\n  'und-diak': 'dv-diak-mv',\n  'und-dj': 'aa-latn-dj',\n  'und-dk': 'da-latn-dk',\n  'und-do': 'es-latn-do',\n  'und-dogr': 'doi-dogr-in',\n  'und-dupl': 'fr-dupl-fr',\n  'und-dz': 'ar-arab-dz',\n  'und-ea': 'es-latn-ea',\n  'und-ec': 'es-latn-ec',\n  'und-ee': 'et-latn-ee',\n  'und-eg': 'ar-arab-eg',\n  'und-egyp': 'egy-egyp-eg',\n  'und-eh': 'ar-arab-eh',\n  'und-elba': 'sq-elba-al',\n  'und-elym': 'arc-elym-ir',\n  'und-er': 'ti-ethi-er',\n  'und-es': 'es-latn-es',\n  'und-et': 'am-ethi-et',\n  'und-ethi': 'am-ethi-et',\n  'und-eu': 'en-latn-ie',\n  'und-ez': 'de-latn-ez',\n  'und-fi': 'fi-latn-fi',\n  'und-fo': 'fo-latn-fo',\n  'und-fr': 'fr-latn-fr',\n  'und-ga': 'fr-latn-ga',\n  'und-ge': 'ka-geor-ge',\n  'und-geor': 'ka-geor-ge',\n  'und-gf': 'fr-latn-gf',\n  'und-gh': 'ak-latn-gh',\n  'und-gl': 'kl-latn-gl',\n  'und-glag': 'cu-glag-bg',\n  'und-gn': 'fr-latn-gn',\n  'und-gong': 'wsg-gong-in',\n  'und-gonm': 'esg-gonm-in',\n  'und-goth': 'got-goth-ua',\n  'und-gp': 'fr-latn-gp',\n  'und-gq': 'es-latn-gq',\n  'und-gr': 'el-grek-gr',\n  'und-gran': 'sa-gran-in',\n  'und-grek': 'el-grek-gr',\n  'und-grek-tr': 'bgx-grek-tr',\n  'und-gs': 'und-latn-gs',\n  'und-gt': 'es-latn-gt',\n  'und-gujr': 'gu-gujr-in',\n  'und-guru': 'pa-guru-in',\n  'und-gw': 'pt-latn-gw',\n  'und-hanb': 'zh-hanb-tw',\n  'und-hang': 'ko-hang-kr',\n  'und-hani': 'zh-hani-cn',\n  'und-hano': 'hnn-hano-ph',\n  'und-hans': 'zh-hans-cn',\n  'und-hant': 'zh-hant-tw',\n  'und-hebr': 'he-hebr-il',\n  'und-hebr-ca': 'yi-hebr-ca',\n  'und-hebr-gb': 'yi-hebr-gb',\n  'und-hebr-se': 'yi-hebr-se',\n  'und-hebr-ua': 'yi-hebr-ua',\n  'und-hebr-us': 'yi-hebr-us',\n  'und-hira': 'ja-hira-jp',\n  'und-hk': 'zh-hant-hk',\n  'und-hluw': 'hlu-hluw-tr',\n  'und-hm': 'und-latn-hm',\n  'und-hmng': 'hnj-hmng-la',\n  'und-hmnp': 'hnj-hmnp-us',\n  'und-hn': 'es-latn-hn',\n  'und-hr': 'hr-latn-hr',\n  'und-ht': 'ht-latn-ht',\n  'und-hu': 'hu-latn-hu',\n  'und-hung': 'hu-hung-hu',\n  'und-ic': 'es-latn-ic',\n  'und-id': 'id-latn-id',\n  'und-il': 'he-hebr-il',\n  'und-in': 'hi-deva-in',\n  'und-iq': 'ar-arab-iq',\n  'und-ir': 'fa-arab-ir',\n  'und-is': 'is-latn-is',\n  'und-it': 'it-latn-it',\n  'und-ital': 'ett-ital-it',\n  'und-jamo': 'ko-jamo-kr',\n  'und-java': 'jv-java-id',\n  'und-jo': 'ar-arab-jo',\n  'und-jp': 'ja-jpan-jp',\n  'und-jpan': 'ja-jpan-jp',\n  'und-kali': 'eky-kali-mm',\n  'und-kana': 'ja-kana-jp',\n  'und-ke': 'sw-latn-ke',\n  'und-kg': 'ky-cyrl-kg',\n  'und-kh': 'km-khmr-kh',\n  'und-khar': 'pra-khar-pk',\n  'und-khmr': 'km-khmr-kh',\n  'und-khoj': 'sd-khoj-in',\n  'und-kits': 'zkt-kits-cn',\n  'und-km': 'ar-arab-km',\n  'und-knda': 'kn-knda-in',\n  'und-kore': 'ko-kore-kr',\n  'und-kp': 'ko-kore-kp',\n  'und-kr': 'ko-kore-kr',\n  'und-kthi': 'bho-kthi-in',\n  'und-kw': 'ar-arab-kw',\n  'und-kz': 'ru-cyrl-kz',\n  'und-la': 'lo-laoo-la',\n  'und-lana': 'nod-lana-th',\n  'und-laoo': 'lo-laoo-la',\n  'und-latn-af': 'tk-latn-af',\n  'und-latn-am': 'ku-latn-am',\n  'und-latn-cn': 'za-latn-cn',\n  'und-latn-cy': 'tr-latn-cy',\n  'und-latn-dz': 'fr-latn-dz',\n  'und-latn-et': 'en-latn-et',\n  'und-latn-ge': 'ku-latn-ge',\n  'und-latn-ir': 'tk-latn-ir',\n  'und-latn-km': 'fr-latn-km',\n  'und-latn-ma': 'fr-latn-ma',\n  'und-latn-mk': 'sq-latn-mk',\n  'und-latn-mm': 'kac-latn-mm',\n  'und-latn-mo': 'pt-latn-mo',\n  'und-latn-mr': 'fr-latn-mr',\n  'und-latn-ru': 'krl-latn-ru',\n  'und-latn-sy': 'fr-latn-sy',\n  'und-latn-tn': 'fr-latn-tn',\n  'und-latn-tw': 'trv-latn-tw',\n  'und-latn-ua': 'pl-latn-ua',\n  'und-lb': 'ar-arab-lb',\n  'und-lepc': 'lep-lepc-in',\n  'und-li': 'de-latn-li',\n  'und-limb': 'lif-limb-in',\n  'und-lina': 'lab-lina-gr',\n  'und-linb': 'grc-linb-gr',\n  'und-lisu': 'lis-lisu-cn',\n  'und-lk': 'si-sinh-lk',\n  'und-ls': 'st-latn-ls',\n  'und-lt': 'lt-latn-lt',\n  'und-lu': 'fr-latn-lu',\n  'und-lv': 'lv-latn-lv',\n  'und-ly': 'ar-arab-ly',\n  'und-lyci': 'xlc-lyci-tr',\n  'und-lydi': 'xld-lydi-tr',\n  'und-ma': 'ar-arab-ma',\n  'und-mahj': 'hi-mahj-in',\n  'und-maka': 'mak-maka-id',\n  'und-mand': 'myz-mand-ir',\n  'und-mani': 'xmn-mani-cn',\n  'und-marc': 'bo-marc-cn',\n  'und-mc': 'fr-latn-mc',\n  'und-md': 'ro-latn-md',\n  'und-me': 'sr-latn-me',\n  'und-medf': 'dmf-medf-ng',\n  'und-mend': 'men-mend-sl',\n  'und-merc': 'xmr-merc-sd',\n  'und-mero': 'xmr-mero-sd',\n  'und-mf': 'fr-latn-mf',\n  'und-mg': 'mg-latn-mg',\n  'und-mk': 'mk-cyrl-mk',\n  'und-ml': 'bm-latn-ml',\n  'und-mlym': 'ml-mlym-in',\n  'und-mm': 'my-mymr-mm',\n  'und-mn': 'mn-cyrl-mn',\n  'und-mo': 'zh-hant-mo',\n  'und-modi': 'mr-modi-in',\n  'und-mong': 'mn-mong-cn',\n  'und-mq': 'fr-latn-mq',\n  'und-mr': 'ar-arab-mr',\n  'und-mroo': 'mro-mroo-bd',\n  'und-mt': 'mt-latn-mt',\n  'und-mtei': 'mni-mtei-in',\n  'und-mu': 'mfe-latn-mu',\n  'und-mult': 'skr-mult-pk',\n  'und-mv': 'dv-thaa-mv',\n  'und-mx': 'es-latn-mx',\n  'und-my': 'ms-latn-my',\n  'und-mymr': 'my-mymr-mm',\n  'und-mymr-in': 'kht-mymr-in',\n  'und-mymr-th': 'mnw-mymr-th',\n  'und-mz': 'pt-latn-mz',\n  'und-na': 'af-latn-na',\n  'und-nand': 'sa-nand-in',\n  'und-narb': 'xna-narb-sa',\n  'und-nbat': 'arc-nbat-jo',\n  'und-nc': 'fr-latn-nc',\n  'und-ne': 'ha-latn-ne',\n  'und-newa': 'new-newa-np',\n  'und-ni': 'es-latn-ni',\n  'und-nkoo': 'man-nkoo-gn',\n  'und-nl': 'nl-latn-nl',\n  'und-no': 'nb-latn-no',\n  'und-np': 'ne-deva-np',\n  'und-nshu': 'zhx-nshu-cn',\n  'und-ogam': 'sga-ogam-ie',\n  'und-olck': 'sat-olck-in',\n  'und-om': 'ar-arab-om',\n  'und-orkh': 'otk-orkh-mn',\n  'und-orya': 'or-orya-in',\n  'und-osge': 'osa-osge-us',\n  'und-osma': 'so-osma-so',\n  'und-ougr': 'oui-ougr-143',\n  'und-pa': 'es-latn-pa',\n  'und-palm': 'arc-palm-sy',\n  'und-pauc': 'ctd-pauc-mm',\n  'und-pe': 'es-latn-pe',\n  'und-perm': 'kv-perm-ru',\n  'und-pf': 'fr-latn-pf',\n  'und-pg': 'tpi-latn-pg',\n  'und-ph': 'fil-latn-ph',\n  'und-phag': 'lzh-phag-cn',\n  'und-phli': 'pal-phli-ir',\n  'und-phlp': 'pal-phlp-cn',\n  'und-phnx': 'phn-phnx-lb',\n  'und-pk': 'ur-arab-pk',\n  'und-pl': 'pl-latn-pl',\n  'und-plrd': 'hmd-plrd-cn',\n  'und-pm': 'fr-latn-pm',\n  'und-pr': 'es-latn-pr',\n  'und-prti': 'xpr-prti-ir',\n  'und-ps': 'ar-arab-ps',\n  'und-pt': 'pt-latn-pt',\n  'und-pw': 'pau-latn-pw',\n  'und-py': 'gn-latn-py',\n  'und-qa': 'ar-arab-qa',\n  'und-qo': 'en-latn-dg',\n  'und-re': 'fr-latn-re',\n  'und-rjng': 'rej-rjng-id',\n  'und-ro': 'ro-latn-ro',\n  'und-rohg': 'rhg-rohg-mm',\n  'und-rs': 'sr-cyrl-rs',\n  'und-ru': 'ru-cyrl-ru',\n  'und-runr': 'non-runr-se',\n  'und-rw': 'rw-latn-rw',\n  'und-sa': 'ar-arab-sa',\n  'und-samr': 'smp-samr-il',\n  'und-sarb': 'xsa-sarb-ye',\n  'und-saur': 'saz-saur-in',\n  'und-sc': 'fr-latn-sc',\n  'und-sd': 'ar-arab-sd',\n  'und-se': 'sv-latn-se',\n  'und-sgnw': 'ase-sgnw-us',\n  'und-shaw': 'en-shaw-gb',\n  'und-shrd': 'sa-shrd-in',\n  'und-si': 'sl-latn-si',\n  'und-sidd': 'sa-sidd-in',\n  'und-sind': 'sd-sind-in',\n  'und-sinh': 'si-sinh-lk',\n  'und-sj': 'nb-latn-sj',\n  'und-sk': 'sk-latn-sk',\n  'und-sm': 'it-latn-sm',\n  'und-sn': 'fr-latn-sn',\n  'und-so': 'so-latn-so',\n  'und-sogd': 'sog-sogd-uz',\n  'und-sogo': 'sog-sogo-uz',\n  'und-sora': 'srb-sora-in',\n  'und-soyo': 'cmg-soyo-mn',\n  'und-sr': 'nl-latn-sr',\n  'und-st': 'pt-latn-st',\n  'und-sund': 'su-sund-id',\n  'und-sv': 'es-latn-sv',\n  'und-sy': 'ar-arab-sy',\n  'und-sylo': 'syl-sylo-bd',\n  'und-syrc': 'syr-syrc-iq',\n  'und-tagb': 'tbw-tagb-ph',\n  'und-takr': 'doi-takr-in',\n  'und-tale': 'tdd-tale-cn',\n  'und-talu': 'khb-talu-cn',\n  'und-taml': 'ta-taml-in',\n  'und-tang': 'txg-tang-cn',\n  'und-tavt': 'blt-tavt-vn',\n  'und-td': 'fr-latn-td',\n  'und-telu': 'te-telu-in',\n  'und-tf': 'fr-latn-tf',\n  'und-tfng': 'zgh-tfng-ma',\n  'und-tg': 'fr-latn-tg',\n  'und-tglg': 'fil-tglg-ph',\n  'und-th': 'th-thai-th',\n  'und-thaa': 'dv-thaa-mv',\n  'und-thai': 'th-thai-th',\n  'und-thai-cn': 'lcp-thai-cn',\n  'und-thai-kh': 'kdt-thai-kh',\n  'und-thai-la': 'kdt-thai-la',\n  'und-tibt': 'bo-tibt-cn',\n  'und-tirh': 'mai-tirh-in',\n  'und-tj': 'tg-cyrl-tj',\n  'und-tk': 'tkl-latn-tk',\n  'und-tl': 'pt-latn-tl',\n  'und-tm': 'tk-latn-tm',\n  'und-tn': 'ar-arab-tn',\n  'und-tnsa': 'nst-tnsa-in',\n  'und-to': 'to-latn-to',\n  'und-toto': 'txo-toto-in',\n  'und-tr': 'tr-latn-tr',\n  'und-tv': 'tvl-latn-tv',\n  'und-tw': 'zh-hant-tw',\n  'und-tz': 'sw-latn-tz',\n  'und-ua': 'uk-cyrl-ua',\n  'und-ug': 'sw-latn-ug',\n  'und-ugar': 'uga-ugar-sy',\n  'und-uy': 'es-latn-uy',\n  'und-uz': 'uz-latn-uz',\n  'und-va': 'it-latn-va',\n  'und-vaii': 'vai-vaii-lr',\n  'und-ve': 'es-latn-ve',\n  'und-vith': 'sq-vith-al',\n  'und-vn': 'vi-latn-vn',\n  'und-vu': 'bi-latn-vu',\n  'und-wara': 'hoc-wara-in',\n  'und-wcho': 'nnp-wcho-in',\n  'und-wf': 'fr-latn-wf',\n  'und-ws': 'sm-latn-ws',\n  'und-xk': 'sq-latn-xk',\n  'und-xpeo': 'peo-xpeo-ir',\n  'und-xsux': 'akk-xsux-iq',\n  'und-ye': 'ar-arab-ye',\n  'und-yezi': 'ku-yezi-ge',\n  'und-yiii': 'ii-yiii-cn',\n  'und-yt': 'fr-latn-yt',\n  'und-zanb': 'cmg-zanb-mn',\n  'und-zw': 'sn-latn-zw',\n  unr: 'unr-beng-in',\n  'unr-deva': 'unr-deva-np',\n  'unr-np': 'unr-deva-np',\n  unx: 'unx-beng-in',\n  uok: 'uok-latn-zz',\n  ur: 'ur-arab-pk',\n  uri: 'uri-latn-zz',\n  urt: 'urt-latn-zz',\n  urw: 'urw-latn-zz',\n  usa: 'usa-latn-zz',\n  uth: 'uth-latn-zz',\n  utr: 'utr-latn-zz',\n  uvh: 'uvh-latn-zz',\n  uvl: 'uvl-latn-zz',\n  uz: 'uz-latn-uz',\n  'uz-af': 'uz-arab-af',\n  'uz-arab': 'uz-arab-af',\n  'uz-cn': 'uz-cyrl-cn',\n  vag: 'vag-latn-zz',\n  vai: 'vai-vaii-lr',\n  van: 'van-latn-zz',\n  ve: 've-latn-za',\n  vec: 'vec-latn-it',\n  vep: 'vep-latn-ru',\n  vi: 'vi-latn-vn',\n  vic: 'vic-latn-sx',\n  viv: 'viv-latn-zz',\n  vls: 'vls-latn-be',\n  vmf: 'vmf-latn-de',\n  vmw: 'vmw-latn-mz',\n  vo: 'vo-latn-001',\n  vot: 'vot-latn-ru',\n  vro: 'vro-latn-ee',\n  vun: 'vun-latn-tz',\n  vut: 'vut-latn-zz',\n  wa: 'wa-latn-be',\n  wae: 'wae-latn-ch',\n  waj: 'waj-latn-zz',\n  wal: 'wal-ethi-et',\n  wan: 'wan-latn-zz',\n  war: 'war-latn-ph',\n  wbp: 'wbp-latn-au',\n  wbq: 'wbq-telu-in',\n  wbr: 'wbr-deva-in',\n  wci: 'wci-latn-zz',\n  wer: 'wer-latn-zz',\n  wgi: 'wgi-latn-zz',\n  whg: 'whg-latn-zz',\n  wib: 'wib-latn-zz',\n  wiu: 'wiu-latn-zz',\n  wiv: 'wiv-latn-zz',\n  wja: 'wja-latn-zz',\n  wji: 'wji-latn-zz',\n  wls: 'wls-latn-wf',\n  wmo: 'wmo-latn-zz',\n  wnc: 'wnc-latn-zz',\n  wni: 'wni-arab-km',\n  wnu: 'wnu-latn-zz',\n  wo: 'wo-latn-sn',\n  wob: 'wob-latn-zz',\n  wos: 'wos-latn-zz',\n  wrs: 'wrs-latn-zz',\n  wsg: 'wsg-gong-in',\n  wsk: 'wsk-latn-zz',\n  wtm: 'wtm-deva-in',\n  wuu: 'wuu-hans-cn',\n  wuv: 'wuv-latn-zz',\n  wwa: 'wwa-latn-zz',\n  xav: 'xav-latn-br',\n  xbi: 'xbi-latn-zz',\n  xco: 'xco-chrs-uz',\n  xcr: 'xcr-cari-tr',\n  xes: 'xes-latn-zz',\n  xh: 'xh-latn-za',\n  xla: 'xla-latn-zz',\n  xlc: 'xlc-lyci-tr',\n  xld: 'xld-lydi-tr',\n  xmf: 'xmf-geor-ge',\n  xmn: 'xmn-mani-cn',\n  xmr: 'xmr-merc-sd',\n  xna: 'xna-narb-sa',\n  xnr: 'xnr-deva-in',\n  xog: 'xog-latn-ug',\n  xon: 'xon-latn-zz',\n  xpr: 'xpr-prti-ir',\n  xrb: 'xrb-latn-zz',\n  xsa: 'xsa-sarb-ye',\n  xsi: 'xsi-latn-zz',\n  xsm: 'xsm-latn-zz',\n  xsr: 'xsr-deva-np',\n  xwe: 'xwe-latn-zz',\n  yam: 'yam-latn-zz',\n  yao: 'yao-latn-mz',\n  yap: 'yap-latn-fm',\n  yas: 'yas-latn-zz',\n  yat: 'yat-latn-zz',\n  yav: 'yav-latn-cm',\n  yay: 'yay-latn-zz',\n  yaz: 'yaz-latn-zz',\n  yba: 'yba-latn-zz',\n  ybb: 'ybb-latn-cm',\n  yby: 'yby-latn-zz',\n  yer: 'yer-latn-zz',\n  ygr: 'ygr-latn-zz',\n  ygw: 'ygw-latn-zz',\n  yi: 'yi-hebr-001',\n  yko: 'yko-latn-zz',\n  yle: 'yle-latn-zz',\n  ylg: 'ylg-latn-zz',\n  yll: 'yll-latn-zz',\n  yml: 'yml-latn-zz',\n  yo: 'yo-latn-ng',\n  yon: 'yon-latn-zz',\n  yrb: 'yrb-latn-zz',\n  yre: 'yre-latn-zz',\n  yrl: 'yrl-latn-br',\n  yss: 'yss-latn-zz',\n  yua: 'yua-latn-mx',\n  yue: 'yue-hant-hk',\n  'yue-cn': 'yue-hans-cn',\n  'yue-hans': 'yue-hans-cn',\n  yuj: 'yuj-latn-zz',\n  yut: 'yut-latn-zz',\n  yuw: 'yuw-latn-zz',\n  za: 'za-latn-cn',\n  zag: 'zag-latn-sd',\n  zdj: 'zdj-arab-km',\n  zea: 'zea-latn-nl',\n  zgh: 'zgh-tfng-ma',\n  zh: 'zh-hans-cn',\n  'zh-au': 'zh-hant-au',\n  'zh-bn': 'zh-hant-bn',\n  'zh-bopo': 'zh-bopo-tw',\n  'zh-gb': 'zh-hant-gb',\n  'zh-gf': 'zh-hant-gf',\n  'zh-hanb': 'zh-hanb-tw',\n  'zh-hant': 'zh-hant-tw',\n  'zh-hk': 'zh-hant-hk',\n  'zh-id': 'zh-hant-id',\n  'zh-mo': 'zh-hant-mo',\n  'zh-pa': 'zh-hant-pa',\n  'zh-pf': 'zh-hant-pf',\n  'zh-ph': 'zh-hant-ph',\n  'zh-sr': 'zh-hant-sr',\n  'zh-th': 'zh-hant-th',\n  'zh-tw': 'zh-hant-tw',\n  'zh-us': 'zh-hant-us',\n  'zh-vn': 'zh-hant-vn',\n  zhx: 'zhx-nshu-cn',\n  zia: 'zia-latn-zz',\n  zkt: 'zkt-kits-cn',\n  zlm: 'zlm-latn-tg',\n  zmi: 'zmi-latn-my',\n  zne: 'zne-latn-zz',\n  zu: 'zu-latn-za',\n  zza: 'zza-latn-tr'\n}\n","/**\n * @typedef {'script'|'region'|'variants'} Field\n */\n\n/**\n * @type {{region: Record<string, Array<string>>}}\n */\nexport const many = {\n  region: {\n    172: [\n      'ru',\n      'am',\n      'az',\n      'by',\n      'ge',\n      'kg',\n      'kz',\n      'md',\n      'tj',\n      'tm',\n      'ua',\n      'uz'\n    ],\n    200: ['cz', 'sk'],\n    530: ['cw', 'sx', 'bq'],\n    532: ['cw', 'sx', 'bq'],\n    536: ['sa', 'iq'],\n    582: ['fm', 'mh', 'mp', 'pw'],\n    810: [\n      'ru',\n      'am',\n      'az',\n      'by',\n      'ee',\n      'ge',\n      'kz',\n      'kg',\n      'lv',\n      'lt',\n      'md',\n      'tj',\n      'tm',\n      'ua',\n      'uz'\n    ],\n    830: ['je', 'gg'],\n    890: ['rs', 'me', 'si', 'hr', 'mk', 'ba'],\n    891: ['rs', 'me'],\n    an: ['cw', 'sx', 'bq'],\n    cs: ['rs', 'me'],\n    fq: ['aq', 'tf'],\n    nt: ['sa', 'iq'],\n    pc: ['fm', 'mh', 'mp', 'pw'],\n    su: [\n      'ru',\n      'am',\n      'az',\n      'by',\n      'ee',\n      'ge',\n      'kz',\n      'kg',\n      'lv',\n      'lt',\n      'md',\n      'tj',\n      'tm',\n      'ua',\n      'uz'\n    ],\n    yu: ['rs', 'me'],\n    '062': ['034', '143'],\n    ant: ['cw', 'sx', 'bq'],\n    scg: ['rs', 'me'],\n    ntz: ['sa', 'iq'],\n    sun: [\n      'ru',\n      'am',\n      'az',\n      'by',\n      'ee',\n      'ge',\n      'kz',\n      'kg',\n      'lv',\n      'lt',\n      'md',\n      'tj',\n      'tm',\n      'ua',\n      'uz'\n    ],\n    yug: ['rs', 'me']\n  }\n}\n","/**\n * @typedef Change\n * @property {string} from\n * @property {string} to\n */\n\n/**\n * @type {Array<Change>}\n */\nexport const matches = [\n  {\n    from: 'in',\n    to: 'id'\n  },\n  {\n    from: 'iw',\n    to: 'he'\n  },\n  {\n    from: 'ji',\n    to: 'yi'\n  },\n  {\n    from: 'jw',\n    to: 'jv'\n  },\n  {\n    from: 'mo',\n    to: 'ro'\n  },\n  {\n    from: 'scc',\n    to: 'sr'\n  },\n  {\n    from: 'scr',\n    to: 'hr'\n  },\n  {\n    from: 'aam',\n    to: 'aas'\n  },\n  {\n    from: 'adp',\n    to: 'dz'\n  },\n  {\n    from: 'aue',\n    to: 'ktz'\n  },\n  {\n    from: 'ayx',\n    to: 'nun'\n  },\n  {\n    from: 'bgm',\n    to: 'bcg'\n  },\n  {\n    from: 'bjd',\n    to: 'drl'\n  },\n  {\n    from: 'ccq',\n    to: 'rki'\n  },\n  {\n    from: 'cjr',\n    to: 'mom'\n  },\n  {\n    from: 'cka',\n    to: 'cmr'\n  },\n  {\n    from: 'cmk',\n    to: 'xch'\n  },\n  {\n    from: 'coy',\n    to: 'pij'\n  },\n  {\n    from: 'cqu',\n    to: 'quh'\n  },\n  {\n    from: 'drh',\n    to: 'mn'\n  },\n  {\n    from: 'drw',\n    to: 'fa-af'\n  },\n  {\n    from: 'gav',\n    to: 'dev'\n  },\n  {\n    from: 'gfx',\n    to: 'vaj'\n  },\n  {\n    from: 'ggn',\n    to: 'gvr'\n  },\n  {\n    from: 'gti',\n    to: 'nyc'\n  },\n  {\n    from: 'guv',\n    to: 'duz'\n  },\n  {\n    from: 'hrr',\n    to: 'jal'\n  },\n  {\n    from: 'ibi',\n    to: 'opa'\n  },\n  {\n    from: 'ilw',\n    to: 'gal'\n  },\n  {\n    from: 'jeg',\n    to: 'oyb'\n  },\n  {\n    from: 'kgc',\n    to: 'tdf'\n  },\n  {\n    from: 'kgh',\n    to: 'kml'\n  },\n  {\n    from: 'koj',\n    to: 'kwv'\n  },\n  {\n    from: 'krm',\n    to: 'bmf'\n  },\n  {\n    from: 'ktr',\n    to: 'dtp'\n  },\n  {\n    from: 'kvs',\n    to: 'gdj'\n  },\n  {\n    from: 'kwq',\n    to: 'yam'\n  },\n  {\n    from: 'kxe',\n    to: 'tvd'\n  },\n  {\n    from: 'kzj',\n    to: 'dtp'\n  },\n  {\n    from: 'kzt',\n    to: 'dtp'\n  },\n  {\n    from: 'lii',\n    to: 'raq'\n  },\n  {\n    from: 'lmm',\n    to: 'rmx'\n  },\n  {\n    from: 'meg',\n    to: 'cir'\n  },\n  {\n    from: 'mst',\n    to: 'mry'\n  },\n  {\n    from: 'mwj',\n    to: 'vaj'\n  },\n  {\n    from: 'myt',\n    to: 'mry'\n  },\n  {\n    from: 'nad',\n    to: 'xny'\n  },\n  {\n    from: 'ncp',\n    to: 'kdz'\n  },\n  {\n    from: 'nnx',\n    to: 'ngv'\n  },\n  {\n    from: 'nts',\n    to: 'pij'\n  },\n  {\n    from: 'oun',\n    to: 'vaj'\n  },\n  {\n    from: 'pcr',\n    to: 'adx'\n  },\n  {\n    from: 'pmc',\n    to: 'huw'\n  },\n  {\n    from: 'pmu',\n    to: 'phr'\n  },\n  {\n    from: 'ppa',\n    to: 'bfy'\n  },\n  {\n    from: 'ppr',\n    to: 'lcq'\n  },\n  {\n    from: 'pry',\n    to: 'prt'\n  },\n  {\n    from: 'puz',\n    to: 'pub'\n  },\n  {\n    from: 'sca',\n    to: 'hle'\n  },\n  {\n    from: 'skk',\n    to: 'oyb'\n  },\n  {\n    from: 'tdu',\n    to: 'dtp'\n  },\n  {\n    from: 'thc',\n    to: 'tpo'\n  },\n  {\n    from: 'thx',\n    to: 'oyb'\n  },\n  {\n    from: 'tie',\n    to: 'ras'\n  },\n  {\n    from: 'tkk',\n    to: 'twm'\n  },\n  {\n    from: 'tlw',\n    to: 'weo'\n  },\n  {\n    from: 'tmp',\n    to: 'tyj'\n  },\n  {\n    from: 'tne',\n    to: 'kak'\n  },\n  {\n    from: 'tnf',\n    to: 'fa-af'\n  },\n  {\n    from: 'tsf',\n    to: 'taj'\n  },\n  {\n    from: 'uok',\n    to: 'ema'\n  },\n  {\n    from: 'xba',\n    to: 'cax'\n  },\n  {\n    from: 'xia',\n    to: 'acn'\n  },\n  {\n    from: 'xkh',\n    to: 'waw'\n  },\n  {\n    from: 'xsj',\n    to: 'suj'\n  },\n  {\n    from: 'ybd',\n    to: 'rki'\n  },\n  {\n    from: 'yma',\n    to: 'lrr'\n  },\n  {\n    from: 'ymt',\n    to: 'mtm'\n  },\n  {\n    from: 'yos',\n    to: 'zom'\n  },\n  {\n    from: 'yuu',\n    to: 'yug'\n  },\n  {\n    from: 'asd',\n    to: 'snz'\n  },\n  {\n    from: 'dit',\n    to: 'dif'\n  },\n  {\n    from: 'llo',\n    to: 'ngt'\n  },\n  {\n    from: 'myd',\n    to: 'aog'\n  },\n  {\n    from: 'nns',\n    to: 'nbr'\n  },\n  {\n    from: 'agp',\n    to: 'apf'\n  },\n  {\n    from: 'ais',\n    to: 'ami'\n  },\n  {\n    from: 'baz',\n    to: 'nvo'\n  },\n  {\n    from: 'bhk',\n    to: 'fbl'\n  },\n  {\n    from: 'bic',\n    to: 'bir'\n  },\n  {\n    from: 'bjq',\n    to: 'bzc'\n  },\n  {\n    from: 'bkb',\n    to: 'ebk'\n  },\n  {\n    from: 'blg',\n    to: 'iba'\n  },\n  {\n    from: 'btb',\n    to: 'beb'\n  },\n  {\n    from: 'daf',\n    to: 'dnj'\n  },\n  {\n    from: 'dap',\n    to: 'njz'\n  },\n  {\n    from: 'djl',\n    to: 'dze'\n  },\n  {\n    from: 'dkl',\n    to: 'aqd'\n  },\n  {\n    from: 'drr',\n    to: 'kzk'\n  },\n  {\n    from: 'dud',\n    to: 'uth'\n  },\n  {\n    from: 'duj',\n    to: 'dwu'\n  },\n  {\n    from: 'dwl',\n    to: 'dbt'\n  },\n  {\n    from: 'elp',\n    to: 'amq'\n  },\n  {\n    from: 'gbc',\n    to: 'wny'\n  },\n  {\n    from: 'ggo',\n    to: 'esg'\n  },\n  {\n    from: 'ggr',\n    to: 'gtu'\n  },\n  {\n    from: 'gio',\n    to: 'aou'\n  },\n  {\n    from: 'gli',\n    to: 'kzk'\n  },\n  {\n    from: 'ill',\n    to: 'ilm'\n  },\n  {\n    from: 'izi',\n    to: 'eza'\n  },\n  {\n    from: 'jar',\n    to: 'jgk'\n  },\n  {\n    from: 'kdv',\n    to: 'zkd'\n  },\n  {\n    from: 'kgd',\n    to: 'ncq'\n  },\n  {\n    from: 'kpp',\n    to: 'jkm'\n  },\n  {\n    from: 'kxl',\n    to: 'kru'\n  },\n  {\n    from: 'kzh',\n    to: 'dgl'\n  },\n  {\n    from: 'leg',\n    to: 'enl'\n  },\n  {\n    from: 'mgx',\n    to: 'jbk'\n  },\n  {\n    from: 'mnt',\n    to: 'wnn'\n  },\n  {\n    from: 'mof',\n    to: 'xnt'\n  },\n  {\n    from: 'mwd',\n    to: 'dmw'\n  },\n  {\n    from: 'nbf',\n    to: 'nru'\n  },\n  {\n    from: 'nbx',\n    to: 'ekc'\n  },\n  {\n    from: 'nln',\n    to: 'azd'\n  },\n  {\n    from: 'nlr',\n    to: 'nrk'\n  },\n  {\n    from: 'noo',\n    to: 'dtd'\n  },\n  {\n    from: 'nxu',\n    to: 'bpp'\n  },\n  {\n    from: 'pat',\n    to: 'kxr'\n  },\n  {\n    from: 'rmr',\n    to: 'emx'\n  },\n  {\n    from: 'sap',\n    to: 'aqt'\n  },\n  {\n    from: 'sgl',\n    to: 'isk'\n  },\n  {\n    from: 'sul',\n    to: 'sgd'\n  },\n  {\n    from: 'sum',\n    to: 'ulw'\n  },\n  {\n    from: 'tgg',\n    to: 'bjp'\n  },\n  {\n    from: 'thw',\n    to: 'ola'\n  },\n  {\n    from: 'tid',\n    to: 'itd'\n  },\n  {\n    from: 'unp',\n    to: 'wro'\n  },\n  {\n    from: 'wgw',\n    to: 'wgb'\n  },\n  {\n    from: 'wit',\n    to: 'nol'\n  },\n  {\n    from: 'wiw',\n    to: 'nwo'\n  },\n  {\n    from: 'xrq',\n    to: 'dmw'\n  },\n  {\n    from: 'yen',\n    to: 'ynq'\n  },\n  {\n    from: 'yiy',\n    to: 'yrm'\n  },\n  {\n    from: 'zir',\n    to: 'scv'\n  },\n  {\n    from: 'sgn-br',\n    to: 'bzs'\n  },\n  {\n    from: 'sgn-co',\n    to: 'csn'\n  },\n  {\n    from: 'sgn-de',\n    to: 'gsg'\n  },\n  {\n    from: 'sgn-dk',\n    to: 'dsl'\n  },\n  {\n    from: 'sgn-fr',\n    to: 'fsl'\n  },\n  {\n    from: 'sgn-gb',\n    to: 'bfi'\n  },\n  {\n    from: 'sgn-gr',\n    to: 'gss'\n  },\n  {\n    from: 'sgn-ie',\n    to: 'isg'\n  },\n  {\n    from: 'sgn-it',\n    to: 'ise'\n  },\n  {\n    from: 'sgn-jp',\n    to: 'jsl'\n  },\n  {\n    from: 'sgn-mx',\n    to: 'mfs'\n  },\n  {\n    from: 'sgn-ni',\n    to: 'ncs'\n  },\n  {\n    from: 'sgn-nl',\n    to: 'dse'\n  },\n  {\n    from: 'sgn-no',\n    to: 'nsi'\n  },\n  {\n    from: 'sgn-pt',\n    to: 'psr'\n  },\n  {\n    from: 'sgn-se',\n    to: 'swl'\n  },\n  {\n    from: 'sgn-us',\n    to: 'ase'\n  },\n  {\n    from: 'sgn-za',\n    to: 'sfs'\n  },\n  {\n    from: 'sgn-es',\n    to: 'ssp'\n  },\n  {\n    from: 'zh-cmn',\n    to: 'zh'\n  },\n  {\n    from: 'zh-cmn-hans',\n    to: 'zh-hans'\n  },\n  {\n    from: 'zh-cmn-hant',\n    to: 'zh-hant'\n  },\n  {\n    from: 'zh-gan',\n    to: 'gan'\n  },\n  {\n    from: 'zh-wuu',\n    to: 'wuu'\n  },\n  {\n    from: 'zh-yue',\n    to: 'yue'\n  },\n  {\n    from: 'no-bokmal',\n    to: 'nb'\n  },\n  {\n    from: 'no-nynorsk',\n    to: 'nn'\n  },\n  {\n    from: 'aa-saaho',\n    to: 'ssy'\n  },\n  {\n    from: 'sh',\n    to: 'sr-latn'\n  },\n  {\n    from: 'cnr',\n    to: 'sr-me'\n  },\n  {\n    from: 'tl',\n    to: 'fil'\n  },\n  {\n    from: 'aju',\n    to: 'jrb'\n  },\n  {\n    from: 'als',\n    to: 'sq'\n  },\n  {\n    from: 'arb',\n    to: 'ar'\n  },\n  {\n    from: 'ayr',\n    to: 'ay'\n  },\n  {\n    from: 'azj',\n    to: 'az'\n  },\n  {\n    from: 'bcc',\n    to: 'bal'\n  },\n  {\n    from: 'bcl',\n    to: 'bik'\n  },\n  {\n    from: 'bxk',\n    to: 'luy'\n  },\n  {\n    from: 'bxr',\n    to: 'bua'\n  },\n  {\n    from: 'cld',\n    to: 'syr'\n  },\n  {\n    from: 'cmn',\n    to: 'zh'\n  },\n  {\n    from: 'cwd',\n    to: 'cr'\n  },\n  {\n    from: 'dgo',\n    to: 'doi'\n  },\n  {\n    from: 'dhd',\n    to: 'mwr'\n  },\n  {\n    from: 'dik',\n    to: 'din'\n  },\n  {\n    from: 'diq',\n    to: 'zza'\n  },\n  {\n    from: 'lbk',\n    to: 'bnc'\n  },\n  {\n    from: 'ekk',\n    to: 'et'\n  },\n  {\n    from: 'emk',\n    to: 'man'\n  },\n  {\n    from: 'esk',\n    to: 'ik'\n  },\n  {\n    from: 'fat',\n    to: 'ak'\n  },\n  {\n    from: 'fuc',\n    to: 'ff'\n  },\n  {\n    from: 'gaz',\n    to: 'om'\n  },\n  {\n    from: 'gbo',\n    to: 'grb'\n  },\n  {\n    from: 'gno',\n    to: 'gon'\n  },\n  {\n    from: 'gug',\n    to: 'gn'\n  },\n  {\n    from: 'gya',\n    to: 'gba'\n  },\n  {\n    from: 'hdn',\n    to: 'hai'\n  },\n  {\n    from: 'hea',\n    to: 'hmn'\n  },\n  {\n    from: 'ike',\n    to: 'iu'\n  },\n  {\n    from: 'kmr',\n    to: 'ku'\n  },\n  {\n    from: 'knc',\n    to: 'kr'\n  },\n  {\n    from: 'kng',\n    to: 'kg'\n  },\n  {\n    from: 'knn',\n    to: 'kok'\n  },\n  {\n    from: 'kpv',\n    to: 'kv'\n  },\n  {\n    from: 'lvs',\n    to: 'lv'\n  },\n  {\n    from: 'mhr',\n    to: 'chm'\n  },\n  {\n    from: 'mup',\n    to: 'raj'\n  },\n  {\n    from: 'khk',\n    to: 'mn'\n  },\n  {\n    from: 'npi',\n    to: 'ne'\n  },\n  {\n    from: 'ojg',\n    to: 'oj'\n  },\n  {\n    from: 'ory',\n    to: 'or'\n  },\n  {\n    from: 'pbu',\n    to: 'ps'\n  },\n  {\n    from: 'pes',\n    to: 'fa'\n  },\n  {\n    from: 'plt',\n    to: 'mg'\n  },\n  {\n    from: 'pnb',\n    to: 'lah'\n  },\n  {\n    from: 'quz',\n    to: 'qu'\n  },\n  {\n    from: 'rmy',\n    to: 'rom'\n  },\n  {\n    from: 'spy',\n    to: 'kln'\n  },\n  {\n    from: 'src',\n    to: 'sc'\n  },\n  {\n    from: 'swh',\n    to: 'sw'\n  },\n  {\n    from: 'ttq',\n    to: 'tmh'\n  },\n  {\n    from: 'tw',\n    to: 'ak'\n  },\n  {\n    from: 'umu',\n    to: 'del'\n  },\n  {\n    from: 'uzn',\n    to: 'uz'\n  },\n  {\n    from: 'xpe',\n    to: 'kpe'\n  },\n  {\n    from: 'xsl',\n    to: 'den'\n  },\n  {\n    from: 'ydd',\n    to: 'yi'\n  },\n  {\n    from: 'zai',\n    to: 'zap'\n  },\n  {\n    from: 'zsm',\n    to: 'ms'\n  },\n  {\n    from: 'zyb',\n    to: 'za'\n  },\n  {\n    from: 'him',\n    to: 'srx'\n  },\n  {\n    from: 'mnk',\n    to: 'man'\n  },\n  {\n    from: 'bh',\n    to: 'bho'\n  },\n  {\n    from: 'prs',\n    to: 'fa-af'\n  },\n  {\n    from: 'swc',\n    to: 'sw-cd'\n  },\n  {\n    from: 'aar',\n    to: 'aa'\n  },\n  {\n    from: 'abk',\n    to: 'ab'\n  },\n  {\n    from: 'ave',\n    to: 'ae'\n  },\n  {\n    from: 'afr',\n    to: 'af'\n  },\n  {\n    from: 'aka',\n    to: 'ak'\n  },\n  {\n    from: 'amh',\n    to: 'am'\n  },\n  {\n    from: 'arg',\n    to: 'an'\n  },\n  {\n    from: 'ara',\n    to: 'ar'\n  },\n  {\n    from: 'asm',\n    to: 'as'\n  },\n  {\n    from: 'ava',\n    to: 'av'\n  },\n  {\n    from: 'aym',\n    to: 'ay'\n  },\n  {\n    from: 'aze',\n    to: 'az'\n  },\n  {\n    from: 'bak',\n    to: 'ba'\n  },\n  {\n    from: 'bel',\n    to: 'be'\n  },\n  {\n    from: 'bul',\n    to: 'bg'\n  },\n  {\n    from: 'bih',\n    to: 'bho'\n  },\n  {\n    from: 'bis',\n    to: 'bi'\n  },\n  {\n    from: 'bam',\n    to: 'bm'\n  },\n  {\n    from: 'ben',\n    to: 'bn'\n  },\n  {\n    from: 'bod',\n    to: 'bo'\n  },\n  {\n    from: 'bre',\n    to: 'br'\n  },\n  {\n    from: 'bos',\n    to: 'bs'\n  },\n  {\n    from: 'cat',\n    to: 'ca'\n  },\n  {\n    from: 'che',\n    to: 'ce'\n  },\n  {\n    from: 'cha',\n    to: 'ch'\n  },\n  {\n    from: 'cos',\n    to: 'co'\n  },\n  {\n    from: 'cre',\n    to: 'cr'\n  },\n  {\n    from: 'ces',\n    to: 'cs'\n  },\n  {\n    from: 'chu',\n    to: 'cu'\n  },\n  {\n    from: 'chv',\n    to: 'cv'\n  },\n  {\n    from: 'cym',\n    to: 'cy'\n  },\n  {\n    from: 'dan',\n    to: 'da'\n  },\n  {\n    from: 'deu',\n    to: 'de'\n  },\n  {\n    from: 'div',\n    to: 'dv'\n  },\n  {\n    from: 'dzo',\n    to: 'dz'\n  },\n  {\n    from: 'ewe',\n    to: 'ee'\n  },\n  {\n    from: 'ell',\n    to: 'el'\n  },\n  {\n    from: 'eng',\n    to: 'en'\n  },\n  {\n    from: 'epo',\n    to: 'eo'\n  },\n  {\n    from: 'spa',\n    to: 'es'\n  },\n  {\n    from: 'est',\n    to: 'et'\n  },\n  {\n    from: 'eus',\n    to: 'eu'\n  },\n  {\n    from: 'fas',\n    to: 'fa'\n  },\n  {\n    from: 'ful',\n    to: 'ff'\n  },\n  {\n    from: 'fin',\n    to: 'fi'\n  },\n  {\n    from: 'fij',\n    to: 'fj'\n  },\n  {\n    from: 'fao',\n    to: 'fo'\n  },\n  {\n    from: 'fra',\n    to: 'fr'\n  },\n  {\n    from: 'fry',\n    to: 'fy'\n  },\n  {\n    from: 'gle',\n    to: 'ga'\n  },\n  {\n    from: 'gla',\n    to: 'gd'\n  },\n  {\n    from: 'glg',\n    to: 'gl'\n  },\n  {\n    from: 'grn',\n    to: 'gn'\n  },\n  {\n    from: 'guj',\n    to: 'gu'\n  },\n  {\n    from: 'glv',\n    to: 'gv'\n  },\n  {\n    from: 'hau',\n    to: 'ha'\n  },\n  {\n    from: 'heb',\n    to: 'he'\n  },\n  {\n    from: 'hin',\n    to: 'hi'\n  },\n  {\n    from: 'hmo',\n    to: 'ho'\n  },\n  {\n    from: 'hrv',\n    to: 'hr'\n  },\n  {\n    from: 'hat',\n    to: 'ht'\n  },\n  {\n    from: 'hun',\n    to: 'hu'\n  },\n  {\n    from: 'hye',\n    to: 'hy'\n  },\n  {\n    from: 'her',\n    to: 'hz'\n  },\n  {\n    from: 'ina',\n    to: 'ia'\n  },\n  {\n    from: 'ind',\n    to: 'id'\n  },\n  {\n    from: 'ile',\n    to: 'ie'\n  },\n  {\n    from: 'ibo',\n    to: 'ig'\n  },\n  {\n    from: 'iii',\n    to: 'ii'\n  },\n  {\n    from: 'ipk',\n    to: 'ik'\n  },\n  {\n    from: 'ido',\n    to: 'io'\n  },\n  {\n    from: 'isl',\n    to: 'is'\n  },\n  {\n    from: 'ita',\n    to: 'it'\n  },\n  {\n    from: 'iku',\n    to: 'iu'\n  },\n  {\n    from: 'jpn',\n    to: 'ja'\n  },\n  {\n    from: 'jav',\n    to: 'jv'\n  },\n  {\n    from: 'kat',\n    to: 'ka'\n  },\n  {\n    from: 'kon',\n    to: 'kg'\n  },\n  {\n    from: 'kik',\n    to: 'ki'\n  },\n  {\n    from: 'kua',\n    to: 'kj'\n  },\n  {\n    from: 'kaz',\n    to: 'kk'\n  },\n  {\n    from: 'kal',\n    to: 'kl'\n  },\n  {\n    from: 'khm',\n    to: 'km'\n  },\n  {\n    from: 'kan',\n    to: 'kn'\n  },\n  {\n    from: 'kor',\n    to: 'ko'\n  },\n  {\n    from: 'kau',\n    to: 'kr'\n  },\n  {\n    from: 'kas',\n    to: 'ks'\n  },\n  {\n    from: 'kur',\n    to: 'ku'\n  },\n  {\n    from: 'kom',\n    to: 'kv'\n  },\n  {\n    from: 'cor',\n    to: 'kw'\n  },\n  {\n    from: 'kir',\n    to: 'ky'\n  },\n  {\n    from: 'lat',\n    to: 'la'\n  },\n  {\n    from: 'ltz',\n    to: 'lb'\n  },\n  {\n    from: 'lug',\n    to: 'lg'\n  },\n  {\n    from: 'lim',\n    to: 'li'\n  },\n  {\n    from: 'lin',\n    to: 'ln'\n  },\n  {\n    from: 'lao',\n    to: 'lo'\n  },\n  {\n    from: 'lit',\n    to: 'lt'\n  },\n  {\n    from: 'lub',\n    to: 'lu'\n  },\n  {\n    from: 'lav',\n    to: 'lv'\n  },\n  {\n    from: 'mlg',\n    to: 'mg'\n  },\n  {\n    from: 'mah',\n    to: 'mh'\n  },\n  {\n    from: 'mri',\n    to: 'mi'\n  },\n  {\n    from: 'mkd',\n    to: 'mk'\n  },\n  {\n    from: 'mal',\n    to: 'ml'\n  },\n  {\n    from: 'mon',\n    to: 'mn'\n  },\n  {\n    from: 'mol',\n    to: 'ro'\n  },\n  {\n    from: 'mar',\n    to: 'mr'\n  },\n  {\n    from: 'msa',\n    to: 'ms'\n  },\n  {\n    from: 'mlt',\n    to: 'mt'\n  },\n  {\n    from: 'mya',\n    to: 'my'\n  },\n  {\n    from: 'nau',\n    to: 'na'\n  },\n  {\n    from: 'nob',\n    to: 'nb'\n  },\n  {\n    from: 'nde',\n    to: 'nd'\n  },\n  {\n    from: 'nep',\n    to: 'ne'\n  },\n  {\n    from: 'ndo',\n    to: 'ng'\n  },\n  {\n    from: 'nld',\n    to: 'nl'\n  },\n  {\n    from: 'nno',\n    to: 'nn'\n  },\n  {\n    from: 'nor',\n    to: 'no'\n  },\n  {\n    from: 'nbl',\n    to: 'nr'\n  },\n  {\n    from: 'nav',\n    to: 'nv'\n  },\n  {\n    from: 'nya',\n    to: 'ny'\n  },\n  {\n    from: 'oci',\n    to: 'oc'\n  },\n  {\n    from: 'oji',\n    to: 'oj'\n  },\n  {\n    from: 'orm',\n    to: 'om'\n  },\n  {\n    from: 'ori',\n    to: 'or'\n  },\n  {\n    from: 'oss',\n    to: 'os'\n  },\n  {\n    from: 'pan',\n    to: 'pa'\n  },\n  {\n    from: 'pli',\n    to: 'pi'\n  },\n  {\n    from: 'pol',\n    to: 'pl'\n  },\n  {\n    from: 'pus',\n    to: 'ps'\n  },\n  {\n    from: 'por',\n    to: 'pt'\n  },\n  {\n    from: 'que',\n    to: 'qu'\n  },\n  {\n    from: 'roh',\n    to: 'rm'\n  },\n  {\n    from: 'run',\n    to: 'rn'\n  },\n  {\n    from: 'ron',\n    to: 'ro'\n  },\n  {\n    from: 'rus',\n    to: 'ru'\n  },\n  {\n    from: 'kin',\n    to: 'rw'\n  },\n  {\n    from: 'san',\n    to: 'sa'\n  },\n  {\n    from: 'srd',\n    to: 'sc'\n  },\n  {\n    from: 'snd',\n    to: 'sd'\n  },\n  {\n    from: 'sme',\n    to: 'se'\n  },\n  {\n    from: 'sag',\n    to: 'sg'\n  },\n  {\n    from: 'hbs',\n    to: 'sr-latn'\n  },\n  {\n    from: 'sin',\n    to: 'si'\n  },\n  {\n    from: 'slk',\n    to: 'sk'\n  },\n  {\n    from: 'slv',\n    to: 'sl'\n  },\n  {\n    from: 'smo',\n    to: 'sm'\n  },\n  {\n    from: 'sna',\n    to: 'sn'\n  },\n  {\n    from: 'som',\n    to: 'so'\n  },\n  {\n    from: 'sqi',\n    to: 'sq'\n  },\n  {\n    from: 'srp',\n    to: 'sr'\n  },\n  {\n    from: 'ssw',\n    to: 'ss'\n  },\n  {\n    from: 'sot',\n    to: 'st'\n  },\n  {\n    from: 'sun',\n    to: 'su'\n  },\n  {\n    from: 'swe',\n    to: 'sv'\n  },\n  {\n    from: 'swa',\n    to: 'sw'\n  },\n  {\n    from: 'tam',\n    to: 'ta'\n  },\n  {\n    from: 'tel',\n    to: 'te'\n  },\n  {\n    from: 'tgk',\n    to: 'tg'\n  },\n  {\n    from: 'tha',\n    to: 'th'\n  },\n  {\n    from: 'tir',\n    to: 'ti'\n  },\n  {\n    from: 'tuk',\n    to: 'tk'\n  },\n  {\n    from: 'tgl',\n    to: 'fil'\n  },\n  {\n    from: 'tsn',\n    to: 'tn'\n  },\n  {\n    from: 'ton',\n    to: 'to'\n  },\n  {\n    from: 'tur',\n    to: 'tr'\n  },\n  {\n    from: 'tso',\n    to: 'ts'\n  },\n  {\n    from: 'tat',\n    to: 'tt'\n  },\n  {\n    from: 'twi',\n    to: 'ak'\n  },\n  {\n    from: 'tah',\n    to: 'ty'\n  },\n  {\n    from: 'uig',\n    to: 'ug'\n  },\n  {\n    from: 'ukr',\n    to: 'uk'\n  },\n  {\n    from: 'urd',\n    to: 'ur'\n  },\n  {\n    from: 'uzb',\n    to: 'uz'\n  },\n  {\n    from: 'ven',\n    to: 've'\n  },\n  {\n    from: 'vie',\n    to: 'vi'\n  },\n  {\n    from: 'vol',\n    to: 'vo'\n  },\n  {\n    from: 'wln',\n    to: 'wa'\n  },\n  {\n    from: 'wol',\n    to: 'wo'\n  },\n  {\n    from: 'xho',\n    to: 'xh'\n  },\n  {\n    from: 'yid',\n    to: 'yi'\n  },\n  {\n    from: 'yor',\n    to: 'yo'\n  },\n  {\n    from: 'zha',\n    to: 'za'\n  },\n  {\n    from: 'zho',\n    to: 'zh'\n  },\n  {\n    from: 'zul',\n    to: 'zu'\n  },\n  {\n    from: 'alb',\n    to: 'sq'\n  },\n  {\n    from: 'arm',\n    to: 'hy'\n  },\n  {\n    from: 'baq',\n    to: 'eu'\n  },\n  {\n    from: 'bur',\n    to: 'my'\n  },\n  {\n    from: 'chi',\n    to: 'zh'\n  },\n  {\n    from: 'cze',\n    to: 'cs'\n  },\n  {\n    from: 'dut',\n    to: 'nl'\n  },\n  {\n    from: 'fre',\n    to: 'fr'\n  },\n  {\n    from: 'geo',\n    to: 'ka'\n  },\n  {\n    from: 'ger',\n    to: 'de'\n  },\n  {\n    from: 'gre',\n    to: 'el'\n  },\n  {\n    from: 'ice',\n    to: 'is'\n  },\n  {\n    from: 'mac',\n    to: 'mk'\n  },\n  {\n    from: 'mao',\n    to: 'mi'\n  },\n  {\n    from: 'may',\n    to: 'ms'\n  },\n  {\n    from: 'per',\n    to: 'fa'\n  },\n  {\n    from: 'rum',\n    to: 'ro'\n  },\n  {\n    from: 'slo',\n    to: 'sk'\n  },\n  {\n    from: 'tib',\n    to: 'bo'\n  },\n  {\n    from: 'wel',\n    to: 'cy'\n  },\n  {\n    from: 'und-aaland',\n    to: 'und-ax'\n  },\n  {\n    from: 'hy-arevmda',\n    to: 'hyw'\n  },\n  {\n    from: 'und-arevmda',\n    to: 'und'\n  },\n  {\n    from: 'und-arevela',\n    to: 'und'\n  },\n  {\n    from: 'und-lojban',\n    to: 'und'\n  },\n  {\n    from: 'und-saaho',\n    to: 'und'\n  },\n  {\n    from: 'und-bokmal',\n    to: 'und'\n  },\n  {\n    from: 'und-nynorsk',\n    to: 'und'\n  },\n  {\n    from: 'und-hakka',\n    to: 'und'\n  },\n  {\n    from: 'und-xiang',\n    to: 'und'\n  },\n  {\n    from: 'und-hepburn-heploc',\n    to: 'und-alalc97'\n  }\n]\n","/** @type {Record<string, string|null>} */\nexport const normal = {\n  'en-gb-oed': 'en-GB-oxendict',\n  'i-ami': 'ami',\n  'i-bnn': 'bnn',\n  'i-default': null,\n  'i-enochian': null,\n  'i-hak': 'hak',\n  'i-klingon': 'tlh',\n  'i-lux': 'lb',\n  'i-mingo': null,\n  'i-navajo': 'nv',\n  'i-pwn': 'pwn',\n  'i-tao': 'tao',\n  'i-tay': 'tay',\n  'i-tsu': 'tsu',\n  'sgn-be-fr': 'sfb',\n  'sgn-be-nl': 'vgt',\n  'sgn-ch-de': 'sgg',\n  'art-lojban': 'jbo',\n  'cel-gaulish': null,\n  'no-bok': 'nb',\n  'no-nyn': 'nn',\n  'zh-guoyu': 'cmn',\n  'zh-hakka': 'hak',\n  'zh-min': null,\n  'zh-min-nan': 'nan',\n  'zh-xiang': 'hsn'\n}\n","/**\n * @callback Warning\n * @param {string} reason\n * @param {number} code\n * @param {number} offset\n * @returns {void}\n *\n * @typedef Options\n * @property {boolean} [normalize=true]\n * @property {boolean} [forgiving=false]\n * @property {Warning} [warning]\n *\n * @typedef Extension\n * @property {string} singleton\n * @property {Array<string>} extensions\n *\n * @typedef Schema\n * @property {string|null|undefined} language\n * @property {Array<string>} extendedLanguageSubtags\n * @property {string|null|undefined} script\n * @property {string|null|undefined} region\n * @property {Array<string>} variants\n * @property {Array<Extension>} extensions\n * @property {Array<string>} privateuse\n * @property {string|null|undefined} irregular\n * @property {string|null|undefined} regular\n */\n\nimport {isAlphanumerical} from 'is-alphanumerical'\nimport {isAlphabetical} from 'is-alphabetical'\nimport {isDecimal} from 'is-decimal'\nimport {regular} from './regular.js'\nimport {normal} from './normal.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Parse a BCP 47 language tag.\n *\n * @param {string} tag\n * @param {Options} [options]\n * @returns {Schema}\n */\nexport function parse(tag, options = {}) {\n  const result = empty()\n  const source = String(tag)\n  const value = source.toLowerCase()\n  let index = 0\n\n  // Check input.\n  if (tag === null || tag === undefined) {\n    throw new Error('Expected string, got `' + tag + '`')\n  }\n\n  // Lets start.\n  // First: the edge cases.\n  if (own.call(normal, value)) {\n    const replacement = normal[value]\n\n    if (\n      (options.normalize === undefined ||\n        options.normalize === null ||\n        options.normalize) &&\n      typeof replacement === 'string'\n    ) {\n      return parse(replacement)\n    }\n\n    result[regular.includes(value) ? 'regular' : 'irregular'] = source\n\n    return result\n  }\n\n  // Now, to actually parse, eat what could be a language.\n  while (isAlphabetical(value.charCodeAt(index)) && index < 9) index++\n\n  // A language.\n  if (index > 1 /* Min 639. */ && index < 9 /* Max subtag. */) {\n    // 5 and up is a subtag.\n    // 4 is the size of reserved languages.\n    // 3 an ISO 639-2 or ISO 639-3.\n    // 2 is an ISO 639-1.\n    // <https://github.com/wooorm/iso-639-2>\n    // <https://github.com/wooorm/iso-639-3>\n    result.language = source.slice(0, index)\n\n    if (index < 4 /* Max 639. */) {\n      let groups = 0\n\n      while (\n        value.charCodeAt(index) === 45 /* `-` */ &&\n        isAlphabetical(value.charCodeAt(index + 1)) &&\n        isAlphabetical(value.charCodeAt(index + 2)) &&\n        isAlphabetical(value.charCodeAt(index + 3)) &&\n        !isAlphabetical(value.charCodeAt(index + 4))\n      ) {\n        if (groups > 2 /* Max extended language subtag count. */) {\n          return fail(\n            index,\n            3,\n            'Too many extended language subtags, expected at most 3 subtags'\n          )\n        }\n\n        // Extended language subtag.\n        result.extendedLanguageSubtags.push(source.slice(index + 1, index + 4))\n        index += 4\n        groups++\n      }\n    }\n\n    // ISO 15924 script.\n    // <https://github.com/wooorm/iso-15924>\n    if (\n      value.charCodeAt(index) === 45 /* `-` */ &&\n      isAlphabetical(value.charCodeAt(index + 1)) &&\n      isAlphabetical(value.charCodeAt(index + 2)) &&\n      isAlphabetical(value.charCodeAt(index + 3)) &&\n      isAlphabetical(value.charCodeAt(index + 4)) &&\n      !isAlphabetical(value.charCodeAt(index + 5))\n    ) {\n      result.script = source.slice(index + 1, index + 5)\n      index += 5\n    }\n\n    if (value.charCodeAt(index) === 45 /* `-` */) {\n      // ISO 3166-1 region.\n      // <https://github.com/wooorm/iso-3166>\n      if (\n        isAlphabetical(value.charCodeAt(index + 1)) &&\n        isAlphabetical(value.charCodeAt(index + 2)) &&\n        !isAlphabetical(value.charCodeAt(index + 3))\n      ) {\n        result.region = source.slice(index + 1, index + 3)\n        index += 3\n      }\n      // UN M49 region.\n      // <https://github.com/wooorm/un-m49>\n      else if (\n        isDecimal(value.charCodeAt(index + 1)) &&\n        isDecimal(value.charCodeAt(index + 2)) &&\n        isDecimal(value.charCodeAt(index + 3)) &&\n        !isDecimal(value.charCodeAt(index + 4))\n      ) {\n        result.region = source.slice(index + 1, index + 4)\n        index += 4\n      }\n    }\n\n    while (value.charCodeAt(index) === 45 /* `-` */) {\n      const start = index + 1\n      let offset = start\n\n      while (isAlphanumerical(value.charCodeAt(offset))) {\n        if (offset - start > 7 /* Max variant. */) {\n          return fail(\n            offset,\n            1,\n            'Too long variant, expected at most 8 characters'\n          )\n        }\n\n        offset++\n      }\n\n      if (\n        // Long variant.\n        offset - start > 4 /* Min alpha numeric variant. */ ||\n        // Short variant.\n        (offset - start > 3 /* Min variant. */ &&\n          isDecimal(value.charCodeAt(start)))\n      ) {\n        result.variants.push(source.slice(start, offset))\n        index = offset\n      }\n      // Something else.\n      else {\n        break\n      }\n    }\n\n    // Extensions.\n    while (value.charCodeAt(index) === 45 /* `-` */) {\n      // Exit if this isnt an extension.\n      if (\n        value.charCodeAt(index + 1) === 120 /* `x` */ ||\n        !isAlphanumerical(value.charCodeAt(index + 1)) ||\n        value.charCodeAt(index + 2) !== 45 /* `-` */ ||\n        !isAlphanumerical(value.charCodeAt(index + 3))\n      ) {\n        break\n      }\n\n      let offset = index + 2\n      let groups = 0\n\n      while (\n        value.charCodeAt(offset) === 45 /* `-` */ &&\n        isAlphanumerical(value.charCodeAt(offset + 1)) &&\n        isAlphanumerical(value.charCodeAt(offset + 2))\n      ) {\n        const start = offset + 1\n        offset = start + 2\n        groups++\n\n        while (isAlphanumerical(value.charCodeAt(offset))) {\n          if (offset - start > 7 /* Max extension. */) {\n            return fail(\n              offset,\n              2,\n              'Too long extension, expected at most 8 characters'\n            )\n          }\n\n          offset++\n        }\n      }\n\n      if (!groups) {\n        return fail(\n          offset,\n          4,\n          'Empty extension, extensions must have at least 2 characters of content'\n        )\n      }\n\n      result.extensions.push({\n        singleton: source.charAt(index + 1),\n        extensions: source.slice(index + 3, offset).split('-')\n      })\n\n      index = offset\n    }\n  }\n  // Not a language.\n  else {\n    index = 0\n  }\n\n  // Private use.\n  if (\n    (index === 0 && value.charCodeAt(index) === 120) /* `x` */ ||\n    (value.charCodeAt(index) === 45 /* `-` */ &&\n      value.charCodeAt(index + 1) === 120) /* `x` */\n  ) {\n    index = index ? index + 2 : 1\n    let offset = index\n\n    while (\n      value.charCodeAt(offset) === 45 /* `-` */ &&\n      isAlphanumerical(value.charCodeAt(offset + 1))\n    ) {\n      const start = index + 1\n      offset = start\n\n      while (isAlphanumerical(value.charCodeAt(offset))) {\n        if (offset - start > 7 /* Max private use. */) {\n          return fail(\n            offset,\n            5,\n            'Too long private-use area, expected at most 8 characters'\n          )\n        }\n\n        offset++\n      }\n\n      result.privateuse.push(source.slice(index + 1, offset))\n      index = offset\n    }\n  }\n\n  if (index !== source.length) {\n    return fail(index, 6, 'Found superfluous content after tag')\n  }\n\n  return result\n\n  /**\n   * Create an empty results object.\n   *\n   * @param {number} offset\n   * @param {number} code\n   * @param {string} reason\n   * @returns {Schema}\n   */\n  function fail(offset, code, reason) {\n    if (options.warning) options.warning(reason, code, offset)\n    return options.forgiving ? result : empty()\n  }\n}\n\n/**\n * Create an empty results object.\n *\n * @returns {Schema}\n */\nfunction empty() {\n  return {\n    language: null,\n    extendedLanguageSubtags: [],\n    script: null,\n    region: null,\n    variants: [],\n    extensions: [],\n    privateuse: [],\n    irregular: null,\n    regular: null\n  }\n}\n","/** @type {Array<string>} */\nexport const regular = [\n  'art-lojban',\n  'cel-gaulish',\n  'no-bok',\n  'no-nyn',\n  'zh-guoyu',\n  'zh-hakka',\n  'zh-min',\n  'zh-min-nan',\n  'zh-xiang'\n]\n","/**\n * @typedef {Partial<import('./parse.js').Schema>} Schema\n * @typedef {Partial<import('./parse.js').Extension>} Extension\n */\n\n/**\n * Compile a language schema to a BCP 47 language tag.\n *\n * @param {Schema} schema\n * @returns {string}\n */\nexport function stringify(schema = {}) {\n  /** @type {Array<string>} */\n  let result = []\n\n  if (schema.irregular) {\n    return schema.irregular\n  }\n\n  if (schema.regular) {\n    return schema.regular\n  }\n\n  if (schema.language) {\n    result = result.concat(\n      schema.language,\n      schema.extendedLanguageSubtags || [],\n      schema.script || [],\n      schema.region || [],\n      schema.variants || []\n    )\n\n    const values = schema.extensions || []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = values[index]\n\n      if (value.singleton && value.extensions && value.extensions.length > 0) {\n        result.push(value.singleton, ...value.extensions)\n      }\n    }\n  }\n\n  if (schema.privateuse && schema.privateuse.length > 0) {\n    result.push('x', ...schema.privateuse)\n  }\n\n  return result.join('-')\n}\n","const rtlRange = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nconst ltrRange =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\n/* eslint-disable no-misleading-character-class */\nconst rtl = new RegExp('^[^' + ltrRange + ']*[' + rtlRange + ']')\nconst ltr = new RegExp('^[^' + rtlRange + ']*[' + ltrRange + ']')\n/* eslint-enable no-misleading-character-class */\n\n/**\n * Detect the direction of text: left-to-right, right-to-left, or neutral\n *\n * @param {string} value\n * @returns {'rtl'|'ltr'|'neutral'}\n */\nexport function direction(value) {\n  const source = String(value || '')\n  return rtl.test(source) ? 'rtl' : ltr.test(source) ? 'ltr' : 'neutral'\n}\n","/**\n * @fileoverview\n *   Set the plain-text value of a hast node.\n *   This is like the DOMs `Node#textContent` setter.\n *   The given node is returned.\n *\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {fromString} from 'hast-util-from-string'\n *\n *   fromString(h('p'), 'Alpha')\n *   // { type: 'element',\n *   //   tagName: 'p',\n *   //   properties: {},\n *   //   children: [ { type: 'text', value: 'Alpha' } ] }\n *   fromString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']), 'Charlie')\n *   // { type: 'element',\n *   //   tagName: 'div',\n *   //   properties: {},\n *   //   children: [ { type: 'text', value: 'Charlie' } ] }\n *   ```\n *\n *   ## API\n *\n *   ### `fromString(node[, value])`\n *\n *   If `node` is a text node (has a `value` property), set that to the given\n *   `value` or an empty string.\n *   If `node` is a parent node (has `children`), replace them with a text node\n *   whose data is set to the given `value`, or if `value` is not given, remove\n *   all its children.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Set the plain-text value of a hast node.\n * This is like the DOMs `Node#textContent` setter.\n * The given node is returned.\n *\n * @template {Node} Thing\n * @param {Thing} node\n * @param {string|null|undefined} [d]\n * @returns {Thing}\n */\nexport function fromString(node, d) {\n  const value = d === undefined || d === null ? '' : String(d)\n\n  if ('children' in node) {\n    node.children = []\n\n    if (value) {\n      node.children.push({type: 'text', value})\n    }\n  } else if (node.type !== 'doctype') {\n    node.value = value\n  }\n\n  return node\n}\n","var own = {}.hasOwnProperty\n\n/**\n * Check if `node` has a set `name` property.\n *\n * @param {unknown} node\n * @param {string} name\n * @returns {boolean}\n */\nexport function hasProperty(node, name) {\n  /** @type {unknown} */\n  var value =\n    name &&\n    node &&\n    typeof node === 'object' &&\n    // @ts-ignore Looks like a node.\n    node.type === 'element' &&\n    // @ts-ignore Looks like an element.\n    node.properties &&\n    // @ts-ignore Looks like an element.\n    own.call(node.properties, name) &&\n    // @ts-ignore Looks like an element.\n    node.properties[name]\n\n  return value !== null && value !== undefined && value !== false\n}\n","/**\n * @fileoverview\n *   Check if a node is a conditional comment.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {u} from 'unist-builder'\n *   import {isConditionalComment} from 'hast-util-is-conditional-comment'\n *\n *   isConditionalComment(u('comment', '[if IE]>...<![endif]')) //=> true\n *   isConditionalComment(u('comment', '<![endif]')) //=> true\n *   isConditionalComment(u('comment', 'foo')) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isConditionalComment(node)`\n *\n *   Return `true` if `node` is a comment node matching one of the know IE\n *   conditional comments.\n */\n\nconst re = /^\\[if[ \\t\\f\\n\\r]+[^\\]]+]|<!\\[endif]$/\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if a node is a conditional comment.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isConditionalComment(node) {\n  return node && node.type === 'comment' && re.test(node.value)\n}\n","/**\n * @fileoverview\n *   Check if an element is a CSS link.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {isCssLink} from 'hast-util-is-css-link'\n *\n *   isCssLink(h('link', {rel: ['stylesheet', 'author']})) //=> true\n *   isCssLink(h('link', {rel: ['stylesheet'], type: 'text/css'})) //=> true\n *   isCssLink(h('link', {rel: ['stylesheet'], type: 'text/foo'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isCssLink(node)`\n *\n *   Return `true` if `node` is a `<link>` element with a `rel` list that\n *   contains `'stylesheet'` and has no `type`, an empty `type`, or `'text/css'`\n *   as its `type`.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if an element is a CSS link.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isCssLink(node) {\n  if (!node || !('tagName' in node) || node.tagName !== 'link') {\n    return false\n  }\n\n  const props = node.properties || {}\n  const rel = props.rel\n\n  if (!rel || !Array.isArray(rel) || !rel.includes('stylesheet')) {\n    return false\n  }\n\n  const type = String(props.type || '')\n    .trim()\n    .toLowerCase()\n\n  return !type || type === 'text/css'\n}\n","/**\n * @fileoverview\n *   Check if an element is a CSS `<style>` element.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {isCssStyle} from 'hast-util-is-css-style'\n *\n *   isCssStyle(h('style')) //=> true\n *   isCssStyle(h('style', {type: ' TEXT/CSS '})) //=> true\n *   isCssStyle(h('style', {type: 'text/foo'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isCssStyle(node)`\n *\n *   Return `true` if `node` is a `<style>` element that has no `type`, an empty\n *   `type`, or `'text/css'` as its `type`.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if an element is a CSS `<style>` element.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isCssStyle(node) {\n  if (!node || !('tagName' in node) || node.tagName !== 'style') {\n    return false\n  }\n\n  const value = (node.properties || {}).type\n\n  return (\n    value === undefined ||\n    value === null ||\n    String(value).trim().toLowerCase() === 'text/css'\n  )\n}\n","/**\n * @fileoverview\n *   Check if a property is an event handler.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {isEventHandler} from 'hast-util-is-event-handler'\n *\n *   isEventHandler('oncut') //=> true\n *   isEventHandler('onpushsubscriptionchange') //=> true\n *   isEventHandler('ones') //=> false\n *   isEventHandler('class') //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isEventHandler(prop)`\n *\n *   Check if `prop` is a `string` starting with `'on'` and its `length` is 5 or\n *   more.\n */\n\n/**\n * Check if a property is an event handler.\n *\n * @param {string} name\n * @returns {boolean}\n */\nexport function isEventHandler(name) {\n  return Boolean(\n    name &&\n      name.slice &&\n      name.slice(0, 2).toLowerCase() === 'on' &&\n      name.length >= 5\n  )\n}\n","/**\n * @fileoverview\n *   Check if an element is a JavaScript script.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {isJavaScript} from 'hast-util-is-javascript'\n *\n *   isJavaScript(h('script')) //=> true\n *   isJavaScript(h('script', {type: 'text/ecmascript'})) //=> true\n *   isJavaScript(h('script', {language: 'ecmascript'})) //=> true\n *   isJavaScript(h('script', {type: 'text/fooscript'})) //=> false\n *   isJavaScript(h('script', {language: 'fooscript'})) //=> false\n *   ```\n *\n *   ## API\n *\n *   ### `isJavaScript(node)`\n *\n *   Return `true` if `node` is a `<script>` element that has a valid JavaScript\n *   `type`, has no `type` and a valid JavaScript `language`, or has neither.\n */\n\nimport {hasProperty} from 'hast-util-has-property'\nimport {isElement} from 'hast-util-is-element'\n\nconst mime = new Set([\n  'application/ecmascript',\n  'application/javascript',\n  'application/x-ecmascript',\n  'application/x-javascript',\n  'text/ecmascript',\n  'text/javascript',\n  'text/javascript1.0',\n  'text/javascript1.1',\n  'text/javascript1.2',\n  'text/javascript1.3',\n  'text/javascript1.4',\n  'text/javascript1.5',\n  'text/jscript',\n  'text/livescript',\n  'text/x-ecmascript',\n  'text/x-javascript'\n])\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Check if an element is a JavaScript script.\n *\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isJavaScript(node) {\n  if (!isElement(node, 'script')) {\n    return false\n  }\n\n  const props = node.properties || {}\n\n  if (hasProperty(node, 'type')) {\n    return check(props.type)\n  }\n\n  return !hasProperty(node, 'language') || check(props.language, 'text/')\n}\n\n/**\n * Check one value.\n *\n * @param {unknown} d\n * @param {string} [prefix]\n * @returns {boolean}\n */\nfunction check(d, prefix) {\n  if (typeof d !== 'string') {\n    return false\n  }\n\n  const value = d.split(';', 1)[0].trim().toLowerCase()\n\n  return value === '' || mime.has((prefix || '') + value)\n}\n","/**\n * @typedef {import('./lib/types.js').Element} Element\n * @typedef {import('./lib/types.js').HastNode} HastNode\n * @typedef {import('./lib/types.js').Space} Space\n */\n\nimport {any} from './lib/any.js'\nimport {parse} from './lib/parse.js'\n\n/**\n * @param {string} selector\n * @param {HastNode} [node]\n * @param {Space} [space]\n * @returns {boolean}\n */\nexport function matches(selector, node, space) {\n  return Boolean(\n    any(parse(selector), node, {space, one: true, shallow: true})[0]\n  )\n}\n\n/**\n * @param {string} selector\n * @param {HastNode} [node]\n * @param {Space} [space]\n * @returns {Element|null}\n */\nexport function select(selector, node, space) {\n  return any(parse(selector), node, {space, one: true})[0] || null\n}\n\n/**\n * @param {string} selector\n * @param {HastNode} [node]\n * @param {Space} [space]\n * @returns {Array.<Element>}\n */\nexport function selectAll(selector, node, space) {\n  return any(parse(selector), node, {space})\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').SelectState} SelectState\n */\n\nimport {html, svg} from 'property-information'\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {nest} from './nest.js'\nimport {pseudo} from './pseudo.js'\nimport {test} from './test.js'\n\nconst type = zwitch('type', {\n  // @ts-expect-error: hush.\n  unknown: unknownType,\n  invalid: invalidType,\n  // @ts-expect-error: hush.\n  handlers: {selectors, ruleSet, rule}\n})\n\n/**\n * @param {Selectors|RuleSet|Rule} query\n * @param {HastNode|undefined} node\n * @param {SelectState} state\n * @returns {Array.<Element>}\n */\nexport function any(query, node, state) {\n  // @ts-expect-error zwitch types are off.\n  return query && node ? type(query, node, state) : []\n}\n\n/**\n * @param {Selectors} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array.<Element>}\n */\nfunction selectors(query, node, state) {\n  const collector = new Collector(state.one)\n  let index = -1\n\n  while (++index < query.selectors.length) {\n    collector.collectAll(ruleSet(query.selectors[index], node, state))\n  }\n\n  return collector.result\n}\n\n/**\n * @param {RuleSet} query\n * @param {HastNode} node\n * @param {SelectState} state\n * @returns {Array.<Element>}\n */\nfunction ruleSet(query, node, state) {\n  return rule(query.rule, node, state)\n}\n\n/**\n * @param {Rule} query\n * @param {HastNode} tree\n * @param {SelectState} state\n * @returns {Array.<Element>}\n */\nfunction rule(query, tree, state) {\n  const collector = new Collector(state.one)\n\n  if (state.shallow && query.rule) {\n    throw new Error('Expected selector without nesting')\n  }\n\n  nest(\n    query,\n    tree,\n    0,\n    null,\n    configure(query, {\n      schema: state.space === 'svg' ? svg : html,\n      language: undefined,\n      direction: 'ltr',\n      editableOrEditingHost: false,\n      // @ts-expect-error assume elements.\n      scopeElements: tree.type === 'root' ? tree.children : [tree],\n      iterator,\n      one: state.one,\n      shallow: state.shallow\n    })\n  )\n\n  return collector.result\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    const exit = enterState(state, node)\n\n    if (test(query, node, index, parent, state)) {\n      if (query.rule) {\n        nest(query.rule, node, index, parent, configure(query.rule, state))\n      } else {\n        // @ts-expect-error `test` also asserts `node is Element`\n        collector.collect(node)\n        state.found = true\n      }\n    }\n\n    exit()\n  }\n\n  /**\n   * @template {SelectState} S\n   * @param {Rule} query\n   * @param {S} state\n   * @returns {S}\n   */\n  function configure(query, state) {\n    const pseudos = query.pseudos || []\n    let index = -1\n\n    while (++index < pseudos.length) {\n      if (pseudo.needsIndex.includes(pseudos[index].name)) {\n        state.index = true\n        break\n      }\n    }\n\n    return state\n  }\n}\n\n// Shouldnt be called, all data is handled.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownType(query) {\n  throw new Error('Unknown type `' + query.type + '`')\n}\n\n// Shouldnt be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidType() {\n  throw new Error('Invalid type')\n}\n\nclass Collector {\n  /**\n   * @param {boolean|undefined} [one]\n   */\n  constructor(one) {\n    /** @type {Array.<Element>} */\n    this.result = []\n    /** @type {boolean|undefined} */\n    this.one = one\n    /** @type {boolean} */\n    this.found = false\n  }\n\n  /**\n   * Append nodes to array, filtering out duplicates.\n   *\n   * @param {Array.<Element>} elements\n   */\n  collectAll(elements) {\n    let index = -1\n\n    while (++index < elements.length) {\n      this.collect(elements[index])\n    }\n  }\n\n  /**\n   * Append one node.\n   *\n   * @param {Element} element\n   */\n  collect(element) {\n    if (this.one) {\n      // Shouldnt happen, safeguards performance problems.\n      /* c8 ignore next */\n      if (this.found) return\n      this.found = true\n    }\n\n    if (!this.result.includes(element)) this.result.push(element)\n  }\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RuleAttr} RuleAttr\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Schema} Schema\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').PropertyValue} PropertyValue\n */\n\nimport {stringify as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {find} from 'property-information'\nimport {stringify as spaces} from 'space-separated-tokens'\nimport {zwitch} from 'zwitch'\n\nconst handle = zwitch('operator', {\n  // @ts-expect-error: hush.\n  unknown: unknownOperator,\n  // @ts-expect-error: hush.\n  invalid: exists,\n  handlers: {\n    // @ts-expect-error: hush.\n    '=': exact,\n    // @ts-expect-error: hush.\n    '~=': spaceSeparatedList,\n    // @ts-expect-error: hush.\n    '|=': exactOrPrefix,\n    // @ts-expect-error: hush.\n    '^=': begins,\n    // @ts-expect-error: hush.\n    '$=': ends,\n    // @ts-expect-error: hush.\n    '*=': contains\n  }\n})\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {Schema} schema\n * @returns {boolean}\n */\nexport function attribute(query, element, schema) {\n  const attrs = query.attrs\n  let index = -1\n\n  while (++index < attrs.length) {\n    if (!handle(attrs[index], element, find(schema, attrs[index].name))) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * `[attr]`\n *\n * @param {RuleAttr} _\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exists(_, element, info) {\n  return hasProperty(element, info.property)\n}\n\n/**\n * `[attr=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exact(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      normalizeValue(element.properties[info.property], info) === query.value\n  )\n}\n\n/**\n * `[attr~=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction spaceSeparatedList(query, element, info) {\n  const value = element.properties && element.properties[info.property]\n\n  return (\n    // If this is a comma-separated list, and the query is contained in it, return\n    // true.\n    (!info.commaSeparated &&\n      value &&\n      typeof value === 'object' &&\n      query.value &&\n      value.includes(query.value)) ||\n    // For all other values (including comma-separated lists), return whether this\n    // is an exact match.\n    (hasProperty(element, info.property) &&\n      normalizeValue(value, info) === query.value)\n  )\n}\n\n/**\n * `[attr|=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction exactOrPrefix(query, element, info) {\n  const value = normalizeValue(\n    element.properties && element.properties[info.property],\n    info\n  )\n\n  return Boolean(\n    hasProperty(element, info.property) &&\n      query.value &&\n      (value === query.value ||\n        (value.slice(0, query.value.length) === query.value &&\n          value.charAt(query.value.length) === '-'))\n  )\n}\n\n/**\n * `[attr^=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction begins(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        0,\n        query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * `[attr$=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction ends(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).slice(\n        -query.value.length\n      ) === query.value\n  )\n}\n\n/**\n * `[attr*=value]`\n *\n * @param {RuleAttr} query\n * @param {Element} element\n * @param {Info} info\n * @returns {boolean}\n */\nfunction contains(query, element, info) {\n  return Boolean(\n    hasProperty(element, info.property) &&\n      element.properties &&\n      query.value &&\n      normalizeValue(element.properties[info.property], info).includes(\n        query.value\n      )\n  )\n}\n\n// Shouldnt be called, Parser throws an error instead.\n/**\n * @param {RuleAttr} query\n * @returns {boolean}\n */\n/* c8 ignore next 3 */\nfunction unknownOperator(query) {\n  throw new Error('Unknown operator `' + query.operator + '`')\n}\n\n/**\n * Stringify a hast value back to its HTML form.\n *\n * @param {PropertyValue} value\n * @param {Info} info\n * @returns {string}\n */\nfunction normalizeValue(value, info) {\n  if (typeof value === 'boolean') {\n    return info.attribute\n  }\n\n  if (Array.isArray(value)) {\n    return (info.commaSeparated ? commas : spaces)(value)\n  }\n\n  return String(value)\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Element} Element\n */\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @returns {boolean}\n */\nexport function className(query, element) {\n  /** @type {Array.<string>} */\n  // @ts-expect-error Assume array.\n  const value = element.properties.className || []\n  let index = -1\n\n  if (query.classNames) {\n    while (++index < query.classNames.length) {\n      if (!value.includes(query.classNames[index])) return false\n    }\n  }\n\n  return true\n}\n","/**\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').ElementChild} ElementChild\n * @typedef {import('./types.js').Direction} Direction\n * @typedef {import('unist-util-visit').Visitor<ElementChild>} Visitor\n */\n\nimport {direction} from 'direction'\nimport {isElement} from 'hast-util-is-element'\nimport {toString} from 'hast-util-to-string'\nimport {svg} from 'property-information'\nimport {visit, EXIT, SKIP} from 'unist-util-visit'\nimport {element} from './util.js'\n\n/**\n * @param {SelectState} state\n * @param {HastNode} node\n * @returns {() => void}\n */\n// eslint-disable-next-line complexity\nexport function enterState(state, node) {\n  const schema = state.schema\n  const language = state.language\n  const currentDirection = state.direction\n  const editableOrEditingHost = state.editableOrEditingHost\n  /** @type {Direction|undefined} */\n  let dirInferred\n  /** @type {boolean|undefined} */\n  let found\n\n  if (element(node) && node.properties) {\n    const lang = node.properties.xmlLang || node.properties.lang\n    const type = node.properties.type || 'text'\n    const dir = dirProperty(node)\n\n    if (lang !== undefined && lang !== null) {\n      state.language = String(lang)\n      found = true\n    }\n\n    if (schema && schema.space === 'html') {\n      if (node.properties.contentEditable === 'true') {\n        state.editableOrEditingHost = true\n        found = true\n      }\n\n      if (isElement(node, 'svg')) {\n        state.schema = svg\n        found = true\n      }\n\n      // See: <https://html.spec.whatwg.org/#the-directionality>.\n      // Explicit `[dir=rtl]`.\n      if (dir === 'rtl') {\n        dirInferred = dir\n      } else if (\n        // Explicit `[dir=ltr]`.\n        dir === 'ltr' ||\n        // HTML with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'html')) ||\n        // `input[type=tel]` with an invalid or no `[dir]`.\n        (dir !== 'auto' && isElement(node, 'input') && type === 'tel')\n      ) {\n        dirInferred = 'ltr'\n        // `[dir=auto]` or `bdi` with an invalid or no `[dir]`.\n      } else if (dir === 'auto' || isElement(node, 'bdi')) {\n        if (isElement(node, 'textarea')) {\n          // Check contents of `<textarea>`.\n          dirInferred = dirBidi(toString(node))\n        } else if (\n          isElement(node, 'input') &&\n          (type === 'email' ||\n            type === 'search' ||\n            type === 'tel' ||\n            type === 'text')\n        ) {\n          // Check value of `<input>`.\n          // @ts-expect-error something is `never` in types but this is needed.\n          dirInferred = node.properties.value\n            ? // @ts-expect-error Assume string\n              dirBidi(node.properties.value)\n            : 'ltr'\n        } else {\n          // Check text nodes in `node`.\n          visit(node, inferDirectionality)\n        }\n      }\n\n      if (dirInferred) {\n        state.direction = dirInferred\n        found = true\n      }\n    }\n    // Turn off editing mode in non-HTML spaces.\n    else if (state.editableOrEditingHost) {\n      state.editableOrEditingHost = false\n      found = true\n    }\n  }\n\n  return found ? reset : noop\n\n  function reset() {\n    state.schema = schema\n    state.language = language\n    state.direction = currentDirection\n    state.editableOrEditingHost = editableOrEditingHost\n  }\n\n  /** @type {Visitor} */\n  function inferDirectionality(child) {\n    if (child.type === 'text') {\n      dirInferred = dirBidi(child.value)\n      return dirInferred ? EXIT : null\n    }\n\n    if (\n      child !== node &&\n      (isElement(child, ['bdi', 'script', 'style', 'textare']) ||\n        dirProperty(child))\n    ) {\n      return SKIP\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {Direction|undefined}\n */\nfunction dirBidi(value) {\n  const result = direction(value)\n  return result === 'neutral' ? undefined : result\n}\n\n/**\n * @param {ElementChild} node\n * @returns {Direction|undefined}\n */\nfunction dirProperty(node) {\n  const value =\n    element(node) && node.properties && typeof node.properties.dir === 'string'\n      ? node.properties.dir.toLowerCase()\n      : undefined\n\n  return value === 'auto' || value === 'ltr' || value === 'rtl'\n    ? value\n    : undefined\n}\n\nfunction noop() {}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Element} Element\n */\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @returns {boolean}\n */\nexport function id(query, element) {\n  return Boolean(element.properties && element.properties.id === query.id)\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Element} Element\n */\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @returns {boolean}\n */\nexport function name(query, element) {\n  return query.tagName === '*' || query.tagName === element.tagName\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').SelectIterator} SelectIterator\n * @typedef {import('./types.js').Handler} Handler\n */\n\nimport {zwitch} from 'zwitch'\nimport {enterState} from './enter-state.js'\nimport {parent, element} from './util.js'\n\nconst own = {}.hasOwnProperty\n\nconst handle = zwitch('nestingOperator', {\n  // @ts-expect-error: hush.\n  unknown: unknownNesting,\n  // @ts-expect-error: hush.\n  invalid: topScan, // `undefined` is the top query selector.\n  handlers: {\n    // @ts-expect-error: hush.\n    null: descendant, // `null` is the descendant combinator.\n    // @ts-expect-error: hush.\n    '>': child,\n    // @ts-expect-error: hush.\n    '+': adjacentSibling,\n    // @ts-expect-error: hush.\n    '~': generalSibling\n  }\n})\n\n/** @type {Handler} */\nexport function nest(query, node, index, parent, state) {\n  handle(query, node, index, parent, state)\n}\n\n// Shouldnt be called, parser gives correct data.\n/* c8 ignore next 6 */\n/**\n * @param {{[x: string]: unknown, type: string}} query\n */\nfunction unknownNesting(query) {\n  throw new Error('Unexpected nesting `' + query.nestingOperator + '`')\n}\n\n/** @type {Handler} */\nfunction topScan(query, node, index, parent, state) {\n  // Shouldnt happen.\n  /* c8 ignore next 3 */\n  if (parent || index === null) {\n    throw new Error('topScan is supposed to be called from the root node')\n  }\n\n  // Shouldnt happen.\n  /* c8 ignore next 3 */\n  if (!state.iterator) {\n    throw new Error('Expected `iterator`')\n  }\n\n  state.iterator(query, node, index, parent, state)\n  if (!state.shallow) descendant(query, node, index, parent, state)\n}\n\n/** @type {Handler} */\nfunction descendant(query, node, index, parent, state) {\n  const previous = state.iterator\n\n  state.iterator = iterator\n  child(query, node, index, parent, state)\n\n  /** @type {SelectIterator} */\n  function iterator(query, node, index, parent, state) {\n    // Shouldnt happen.\n    /* c8 ignore next 3 */\n    if (!previous) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator = previous\n    previous(query, node, index, parent, state)\n    state.iterator = iterator\n\n    if (state.one && state.found) return\n\n    child(query, node, index, parent, state)\n  }\n}\n\n/** @type {Handler} */\nfunction child(query, node, _1, _2, state) {\n  if (!parent(node)) return\n  if (node.children.length === 0) return\n  indexedSearch(query, node, state)\n}\n\n/** @type {Handler} */\nfunction adjacentSibling(query, _, index, parent, state) {\n  // Shouldnt happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1, true)\n}\n\n/** @type {Handler} */\nfunction generalSibling(query, _, index, parent, state) {\n  // Shouldnt happen.\n  /* c8 ignore next */\n  if (!parent || index === null) return\n  indexedSearch(query, parent, state, index + 1)\n}\n\n/**\n * Handles `typeIndex` and `typeCount` properties for every walker.\n *\n * @param {Rule} query\n * @param {Parent} parent\n * @param {SelectState} state\n * @param {number} [from=0]\n * @param {boolean} [firstElementOnly=false]\n */\nfunction indexedSearch(query, parent, state, from, firstElementOnly) {\n  const handle = state.index ? delay : add\n  const children = parent.children\n  let elements = 0\n  let index = -1\n  /** @type {Object.<string, number>} */\n  const types = {}\n  /** @type {Array.<Function>} */\n  const delayed = []\n\n  // Start looking at `from`\n  if (from === undefined || from === null) from = 0\n\n  // Exit if there are no further nodes.\n  if (from >= children.length) return\n\n  // If we need to index for types, do so for all elements before `from`.\n  if (state.index) {\n    while (++index < from) {\n      const child = children[index]\n      if (element(child)) count(child.tagName)\n    }\n  }\n\n  index = from - 1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Only check elements.\n    // Check either all elements, or only check the first sibling\n    if (element(child)) {\n      handle(child, index)\n\n      // Stop if were looking for one node and its already found.\n      if (state.one && state.found) return\n      if (firstElementOnly) break\n    }\n  }\n\n  if (state.index) {\n    index = -1\n\n    while (++index < delayed.length) {\n      delayed[index]()\n      if (state.one && state.found) return\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function delay(node, childIndex) {\n    const elementsBefore = elements\n    const elementsByTypeBefore = own.call(types, node.tagName)\n      ? types[node.tagName]\n      : 0\n\n    count(node.tagName)\n\n    delayed.push(fn)\n\n    function fn() {\n      // Before counting further elements:\n      state.elementIndex = elementsBefore\n      state.typeIndex = elementsByTypeBefore\n\n      // After counting all elements.\n      state.elementCount = elements\n      state.typeCount = types[node.tagName]\n\n      add(node, childIndex)\n    }\n  }\n\n  /**\n   * @param {Element} node\n   * @param {number} childIndex\n   */\n  function add(node, childIndex) {\n    const exit = enterState(state, node)\n\n    // Shouldnt happen.\n    /* c8 ignore next 3 */\n    if (!state.iterator) {\n      throw new Error('Expected `iterator`')\n    }\n\n    state.iterator(query, node, childIndex, parent, state)\n    exit()\n  }\n\n  /**\n   * @param {string} name\n   */\n  function count(name) {\n    if (!own.call(types, name)) types[name] = 0\n    elements++\n    types[name]++\n  }\n}\n","/**\n * @typedef {import('./types.js').Selector} Selector\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').RuleSet} RuleSet\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth\n */\n\nimport {CssSelectorParser} from 'css-selector-parser'\nimport fauxEsmNthCheck from 'nth-check'\nimport {zwitch} from 'zwitch'\n\n/** @type {import('nth-check').default} */\n// @ts-expect-error\nconst nthCheck = fauxEsmNthCheck.default\n\nconst nth = new Set([\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type'\n])\n\nconst parser = new CssSelectorParser()\n\n// @ts-expect-error: hush.\nconst compile = zwitch('type', {handlers: {selectors, ruleSet, rule}})\n\nparser.registerAttrEqualityMods('~', '|', '^', '$', '*')\nparser.registerSelectorPseudos('any', 'matches', 'not', 'has')\nparser.registerNestingOperators('>', '+', '~')\n\n/**\n * @param {string} selector\n * @returns {Selector}\n */\nexport function parse(selector) {\n  if (typeof selector !== 'string') {\n    throw new TypeError('Expected `string` as selector, not `' + selector + '`')\n  }\n\n  // @ts-expect-error types are wrong.\n  return compile(parser.parse(selector))\n}\n\n/**\n * @param {Selectors} query\n * @returns {Selectors}\n */\nfunction selectors(query) {\n  let index = -1\n\n  while (++index < query.selectors.length) {\n    compile(query.selectors[index])\n  }\n\n  return query\n}\n\n/**\n * @param {RuleSet} query\n * @returns {Rule}\n */\nfunction ruleSet(query) {\n  return rule(query.rule)\n}\n\n/**\n * @param {Rule} query\n * @returns {Rule}\n */\nfunction rule(query) {\n  const pseudos = query.pseudos || []\n  let index = -1\n\n  while (++index < pseudos.length) {\n    const pseudo = pseudos[index]\n\n    if (nth.has(pseudo.name)) {\n      // @ts-expect-error Patch a non-primitive type.\n      pseudo.value = nthCheck(pseudo.value)\n      // @ts-expect-error Patch a non-primitive type.\n      pseudo.valueType = 'function'\n    }\n  }\n\n  compile(query.rule)\n\n  return query\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').RulePseudo} RulePseudo\n * @typedef {import('./types.js').RulePseudoNth} RulePseudoNth\n * @typedef {import('./types.js').RulePseudoSelector} RulePseudoSelector\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').Selector} Selector\n * @typedef {import('./types.js').Selectors} Selectors\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').ElementChild} ElementChild\n */\n\nimport {extendedFilter} from 'bcp-47-match'\nimport {parse as commas} from 'comma-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isElement} from 'hast-util-is-element'\nimport {whitespace} from 'hast-util-whitespace'\nimport {zwitch} from 'zwitch'\nimport {any} from './any.js'\n\nconst handle = zwitch('name', {\n  // @ts-expect-error: hush.\n  unknown: unknownPseudo,\n  invalid: invalidPseudo,\n  handlers: {\n    // @ts-expect-error: hush.\n    any: matches,\n    // @ts-expect-error: hush.\n    'any-link': anyLink,\n    // @ts-expect-error: hush.\n    blank,\n    // @ts-expect-error: hush.\n    checked,\n    // @ts-expect-error: hush.\n    dir,\n    // @ts-expect-error: hush.\n    disabled,\n    // @ts-expect-error: hush.\n    empty,\n    // @ts-expect-error: hush.\n    enabled,\n    // @ts-expect-error: hush.\n    'first-child': firstChild,\n    // @ts-expect-error: hush.\n    'first-of-type': firstOfType,\n    // @ts-expect-error: hush.\n    has,\n    // @ts-expect-error: hush.\n    lang,\n    // @ts-expect-error: hush.\n    'last-child': lastChild,\n    // @ts-expect-error: hush.\n    'last-of-type': lastOfType,\n    // @ts-expect-error: hush.\n    matches,\n    // @ts-expect-error: hush.\n    not,\n    // @ts-expect-error: hush.\n    'nth-child': nthChild,\n    // @ts-expect-error: hush.\n    'nth-last-child': nthLastChild,\n    // @ts-expect-error: hush.\n    'nth-of-type': nthOfType,\n    // @ts-expect-error: hush.\n    'nth-last-of-type': nthLastOfType,\n    // @ts-expect-error: hush.\n    'only-child': onlyChild,\n    // @ts-expect-error: hush.\n    'only-of-type': onlyOfType,\n    // @ts-expect-error: hush.\n    optional,\n    // @ts-expect-error: hush.\n    'read-only': readOnly,\n    // @ts-expect-error: hush.\n    'read-write': readWrite,\n    // @ts-expect-error: hush.\n    required,\n    // @ts-expect-error: hush.\n    root,\n    // @ts-expect-error: hush.\n    scope\n  }\n})\n\npseudo.needsIndex = [\n  'first-child',\n  'first-of-type',\n  'last-child',\n  'last-of-type',\n  'nth-child',\n  'nth-last-child',\n  'nth-of-type',\n  'nth-last-of-type',\n  'only-child',\n  'only-of-type'\n]\n\n/**\n * @param {Rule} query\n * @param {Element} element\n * @param {number|null} index\n * @param {Parent|null} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function pseudo(query, element, index, parent, state) {\n  const pseudos = query.pseudos\n  let offset = -1\n\n  while (++offset < pseudos.length) {\n    if (!handle(pseudos[offset], element, index, parent, state)) return false\n  }\n\n  return true\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number|null} _1\n * @param {Parent|null} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction matches(query, element, _1, _2, state) {\n  const shallow = state.shallow\n  const one = state.one\n\n  state.shallow = true\n  state.one = true\n\n  const result = any(query.value, element, state)[0] === element\n\n  state.shallow = shallow\n  state.one = one\n\n  return result\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number|null} index\n * @param {Parent|null} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction not(query, element, index, parent, state) {\n  return !matches(query, element, index, parent, state)\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction anyLink(_, element) {\n  return (\n    isElement(element, ['a', 'area', 'link']) && hasProperty(element, 'href')\n  )\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction checked(_, element) {\n  if (isElement(element, ['input', 'menuitem'])) {\n    return Boolean(\n      element.properties &&\n        (element.properties.type === 'checkbox' ||\n          element.properties.type === 'radio') &&\n        hasProperty(element, 'checked')\n    )\n  }\n\n  if (isElement(element, 'option')) {\n    return hasProperty(element, 'selected')\n  }\n\n  return false\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction dir(query, _1, _2, _3, state) {\n  return state.direction === query.value\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction disabled(_, element) {\n  return (\n    isElement(element, [\n      'button',\n      'input',\n      'select',\n      'textarea',\n      'optgroup',\n      'option',\n      'menuitem',\n      'fieldset'\n    ]) && hasProperty(element, 'disabled')\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction enabled(query, element) {\n  return !disabled(query, element)\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction required(_, element) {\n  return (\n    isElement(element, ['input', 'textarea', 'select']) &&\n    hasProperty(element, 'required')\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} element\n * @returns {boolean}\n */\nfunction optional(query, element) {\n  return !required(query, element)\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number|null} _1\n * @param {Parent|null} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readWrite(_, element, _1, _2, state) {\n  return isElement(element, ['input', 'textarea'])\n    ? !hasProperty(element, 'readOnly') && !hasProperty(element, 'disabled')\n    : Boolean(state.editableOrEditingHost)\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} element\n * @param {number|null} index\n * @param {Parent|null} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction readOnly(query, element, index, parent, state) {\n  return !readWrite(query, element, index, parent, state)\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number|null} _1\n * @param {Parent|null} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction root(_, element, _1, parent, state) {\n  return Boolean(\n    (!parent || parent.type === 'root') &&\n      state.schema &&\n      (state.schema.space === 'html' || state.schema.space === 'svg') &&\n      isElement(element, ['html', 'svg'])\n  )\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @param {number|null} _1\n * @param {Parent|null} _2\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction scope(_, element, _1, _2, state) {\n  return Boolean(\n    isElement(element) &&\n      state.scopeElements &&\n      state.scopeElements.includes(element)\n  )\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction empty(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return child.type === 'element' || child.type === 'text'\n  }\n}\n\n/**\n * @param {RulePseudo} _\n * @param {Element} element\n * @returns {boolean}\n */\nfunction blank(_, element) {\n  return !someChildren(element, check)\n\n  /**\n   * @param {ElementChild} child\n   * @returns {boolean}\n   */\n  function check(child) {\n    return (\n      child.type === 'element' || (child.type === 'text' && !whitespace(child))\n    )\n  }\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementIndex === 0\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lang(query, _1, _2, _3, state) {\n  return (\n    state.language !== '' &&\n    state.language !== undefined &&\n    state.language !== null &&\n    // @ts-expect-error never `selectors`.\n    extendedFilter(state.language, commas(query.value)).length > 0\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    state.elementCount && state.elementIndex === state.elementCount - 1\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.elementCount === 1\n}\n\n/**\n * @param {RulePseudoNth} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.elementIndex === 'number' && query.value(state.elementIndex)\n  )\n}\n\n/**\n * @param {RulePseudoNth} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastChild(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return Boolean(\n    typeof state.elementCount === 'number' &&\n      typeof state.elementIndex === 'number' &&\n      query.value(state.elementCount - state.elementIndex - 1)\n  )\n}\n\n/**\n * @param {RulePseudoNth} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return typeof state.typeIndex === 'number' && query.value(state.typeIndex)\n}\n\n/**\n * @param {RulePseudoNth} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction nthLastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeCount === 'number' &&\n    typeof state.typeIndex === 'number' &&\n    query.value(state.typeCount - 1 - state.typeIndex)\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction firstOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeIndex === 0\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction lastOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return (\n    typeof state.typeIndex === 'number' &&\n    typeof state.typeCount === 'number' &&\n    state.typeIndex === state.typeCount - 1\n  )\n}\n\n/**\n * @param {RulePseudo} query\n * @param {Element} _1\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction onlyOfType(query, _1, _2, _3, state) {\n  assertDeep(state, query)\n  return state.typeCount === 1\n}\n\n/**\n * @param {Element} element\n * @param {(child: ElementChild) => boolean} check\n * @returns {boolean}\n */\nfunction someChildren(element, check) {\n  const children = element.children\n  let index = -1\n\n  while (++index < children.length) {\n    if (check(children[index])) return true\n  }\n\n  return false\n}\n\n// Shouldnt be called, parser gives correct data.\n/* c8 ignore next 3 */\nfunction invalidPseudo() {\n  throw new Error('Invalid pseudo-selector')\n}\n\n/**\n * @param {RulePseudo} query\n */\nfunction unknownPseudo(query) {\n  if (query.name) {\n    throw new Error('Unknown pseudo-selector `' + query.name + '`')\n  }\n\n  throw new Error('Unexpected pseudo-element or empty pseudo-class')\n}\n\n/**\n * @param {SelectState} state\n * @param {RulePseudo|RulePseudoNth} query\n */\nfunction assertDeep(state, query) {\n  if (state.shallow) {\n    throw new Error('Cannot use `:' + query.name + '` without parent')\n  }\n}\n\n/**\n * @param {RulePseudoSelector} query\n * @param {Element} element\n * @param {number|null} _2\n * @param {Parent|null} _3\n * @param {SelectState} state\n * @returns {boolean}\n */\nfunction has(query, element, _2, _3, state) {\n  const shallow = state.shallow\n  const one = state.one\n  const scopeElements = state.scopeElements\n  const value = appendScope(query.value)\n\n  state.shallow = false\n  state.one = true\n  state.scopeElements = [element]\n\n  const result = any(value, element, state).length > 0\n\n  state.shallow = shallow\n  state.one = one\n  state.scopeElements = scopeElements\n\n  return result\n}\n\n/**\n * @param {Selector} value\n * @returns {Selectors}\n */\nfunction appendScope(value) {\n  /** @type {Selectors} */\n  const selector =\n    value.type === 'ruleSet' ? {type: 'selectors', selectors: [value]} : value\n  let index = -1\n\n  while (++index < selector.selectors.length) {\n    const rule = selector.selectors[index].rule\n    rule.nestingOperator = null\n\n    if (\n      !rule.pseudos ||\n      rule.pseudos.length !== 1 ||\n      rule.pseudos[0].name !== 'scope'\n    ) {\n      selector.selectors[index] = {\n        type: 'ruleSet',\n        // @ts-expect-error pseudos are fine w/ just a name!\n        rule: {type: 'rule', rule, pseudos: [{name: 'scope'}]}\n      }\n    }\n  }\n\n  return selector\n}\n","/**\n * @typedef {import('./types.js').Rule} Rule\n * @typedef {import('./types.js').HastNode} HastNode\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').SelectState} SelectState\n * @typedef {import('hast-util-is-element').AssertPredicate<Element>} IsElement\n */\n\nimport {attribute} from './attribute.js'\nimport {className} from './class-name.js'\nimport {id} from './id.js'\nimport {name} from './name.js'\nimport {pseudo} from './pseudo.js'\nimport {element} from './util.js'\n\n/**\n * @param {Rule} query\n * @param {HastNode} node\n * @param {number|null} index\n * @param {Parent|null} parent\n * @param {SelectState} state\n * @returns {boolean}\n */\nexport function test(query, node, index, parent, state) {\n  return Boolean(\n    element(node) &&\n      state.schema &&\n      (!query.tagName || name(query, node)) &&\n      (!query.classNames || className(query, node)) &&\n      (!query.id || id(query, node)) &&\n      (!query.attrs || attribute(query, node, state.schema)) &&\n      (!query.pseudos || pseudo(query, node, index, parent, state))\n  )\n}\n","/**\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Element} Element\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('hast-util-is-element').AssertPredicate<Element>} IsElement\n */\n\nimport {convertElement} from 'hast-util-is-element'\n\n/**\n * @param {Node} node\n * @returns {node is Parent}\n */\nexport function parent(node) {\n  // @ts-expect-error: hush.\n  return Array.isArray(node.children)\n}\n\n/** @type {IsElement} */\n// @ts-expect-error it works.\nexport const element = convertElement()\n","/**\n * @fileoverview\n *   Get the plain-text value of a hast node.\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {h} from 'hastscript'\n *   import {toString} from 'hast-util-to-string'\n *\n *   toString(h('p', 'Alpha'))\n *   //=> 'Alpha'\n *   toString(h('div', [h('b', 'Bold'), ' and ', h('i', 'italic'), '.']))\n *   //=> 'Bold and italic.'\n *   ```\n *\n *   ## API\n *\n *   ### `toString(node)`\n *\n *   Transform a node to a string.\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {Root|Root['children'][number]} Node\n */\n\n/**\n * Get the plain-text value of a hast node.\n *\n * @param {Node} node\n * @returns {string}\n */\nexport function toString(node) {\n  // The concatenation of data of all the Text node descendants of the context\n  // object, in tree order.\n  if ('children' in node) {\n    return all(node)\n  }\n\n  // Context objects data.\n  return 'value' in node ? node.value : ''\n}\n\n/**\n * @param {Node} node\n * @returns {string}\n */\nfunction one(node) {\n  if (node.type === 'text') {\n    return node.value\n  }\n\n  return 'children' in node ? all(node) : ''\n}\n\n/**\n * @param {Root|Element} node\n * @returns {string}\n */\nfunction all(node) {\n  let index = -1\n  /** @type {string[]} */\n  const result = []\n\n  while (++index < node.children.length) {\n    result[index] = one(node.children[index])\n  }\n\n  return result.join('')\n}\n","/**\n * @fileoverview\n *   Map of enumerated attributes in HTML\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {enumeratedAttributes} from 'html-enumerated-attributes'\n *\n *   enumeratedAttributes.loading\n *   //=> {selector: 'iframe, img', invalid: 'eager', missing: 'eager', states: ['eager', 'lazy']}\n *   ```\n *\n *   ## API\n *\n *   ### `enumeratedAttributes`\n *\n *   Map of enumerated attributes in HTML (`Record<string, Definition|Array.<Definition>>`).\n */\n\n/**\n * @typedef Definition\n * @property {string} [selector]\n * @property {string|null} [missing]\n * @property {string|null} [invalid]\n * @property {Array.<null|string|string[]>} states\n * @property {true} [allowUnknown]\n * @property {true} [caseSensitive]\n */\n\n/**\n * This map exposes a map of property names to one or more definitions.\n * Each definition defines how that attribute is enumerated.\n *\n * @type {Record<string, Definition|Definition[]>}\n */\nexport const enumeratedAttributes = {\n  autocomplete: {\n    selector: 'form',\n    missing: '',\n    invalid: '',\n    states: [['', 'on'], 'off']\n  },\n  behavior: {\n    selector: 'marquee',\n    missing: 'scroll',\n    states: ['alternate', 'scroll', 'slide']\n  },\n  charset: {\n    selector: 'meta, script',\n    // In HTML5, utf8 is implied.\n    // But we let it be here for older versions.\n    states: [\n      ['utf8', 'utf-8', 'unicode-1-1-utf-8'],\n      ['866', 'cp866', 'ibm866', 'csibm866'],\n      [\n        'l1',\n        'ascii',\n        'cp819',\n        'cp1252',\n        'ibm819',\n        'latin1',\n        'us-ascii',\n        'x-cp1252',\n        'iso88591',\n        'iso8859-1',\n        'iso_8859-1',\n        'iso-8859-1',\n        'iso-ir-100',\n        'csisolatin1',\n        'windows-1252',\n        'ansi_x3.4-1968',\n        'iso_8859-1:1987'\n      ],\n      [\n        'l2',\n        'csisolatin2',\n        'iso-8859-2',\n        'iso-ir-101',\n        'iso8859-2',\n        'iso88592',\n        'iso_8859-2',\n        'iso_8859-2:1987',\n        'latin2'\n      ],\n      [\n        'l3',\n        'csisolatin3',\n        'iso-8859-3',\n        'iso-ir-109',\n        'iso8859-3',\n        'iso88593',\n        'iso_8859-3',\n        'iso_8859-3:1988',\n        'latin3'\n      ],\n      [\n        'l4',\n        'csisolatin4',\n        'iso-8859-4',\n        'iso-ir-110',\n        'iso8859-4',\n        'iso88594',\n        'iso_8859-4',\n        'iso_8859-4:1988',\n        'latin4'\n      ],\n      [\n        'l5',\n        'latin5',\n        'cp1254',\n        'x-cp1254',\n        'iso88599',\n        'iso8859-9',\n        'iso-8859-9',\n        'iso_8859-9',\n        'iso-ir-148',\n        'csisolatin5',\n        'windows-1254',\n        'iso_8859-9:1989'\n      ],\n      [\n        'l6',\n        'latin6',\n        'iso885910',\n        'iso-ir-157',\n        'iso8859-10',\n        'csisolatin6',\n        'iso-8859-10'\n      ],\n      [\n        'l9',\n        'iso885915',\n        'iso8859-15',\n        'iso-8859-15',\n        'iso_8859-15',\n        'csisolatin9'\n      ],\n      ['cp1250', 'x-cp1250', 'windows-1250'],\n      ['cp1251', 'x-cp1251', 'windows-1251'],\n      ['cp1253', 'x-cp1253', 'windows-1253'],\n      ['cp1255', 'x-cp1255', 'windows-1255'],\n      ['cp1256', 'x-cp1256', 'windows-1256'],\n      ['cp1257', 'x-cp1257', 'windows-1257'],\n      ['cp1258', 'x-cp1258', 'windows-1258'],\n      [\n        'cyrillic',\n        'iso88595',\n        'iso8859-5',\n        'iso-8859-5',\n        'iso_8859-5',\n        'iso-ir-144',\n        'iso_8859-5:1988',\n        'csisolatincyrillic'\n      ],\n      [\n        'arabic',\n        'iso88596',\n        'ecma-114',\n        'asmo-708',\n        'iso8859-6',\n        'iso-ir-127',\n        'iso_8859-6',\n        'iso-8859-6',\n        'csiso88596e',\n        'csiso88596i',\n        'iso-8859-6-e',\n        'iso-8859-6-i',\n        'iso_8859-6:1987',\n        'csisolatinarabic'\n      ],\n      [\n        'greek',\n        'greek8',\n        'iso88597',\n        'ecma-118',\n        'elot_928',\n        'iso8859-7',\n        'iso-8859-7',\n        'iso_8859-7',\n        'iso-ir-126',\n        'sun_eu_greek',\n        'iso_8859-7:1987',\n        'csisolatingreek'\n      ],\n      [\n        'hebrew',\n        'visual',\n        'iso88598',\n        'iso8859-8',\n        'iso-8859-8',\n        'iso_8859-8',\n        'iso-ir-138',\n        'csiso88598e',\n        'iso-8859-8-e',\n        'iso_8859-8:1988',\n        'csisolatinhebrew'\n      ],\n      ['logical', 'csiso88598i', 'iso-8859-8-i'],\n      ['iso885913', 'iso8859-13', 'iso-8859-13'],\n      ['iso885914', 'iso8859-14', 'iso-8859-14'],\n      ['iso-8859-16'],\n      ['koi', 'koi8', 'koi8-r', 'koi8_r', 'cskoi8r'],\n      ['koi8-u', 'koi8-ru'],\n      ['mac', 'macintosh', 'csmacintosh', 'x-mac-roman'],\n      [\n        'dos-874',\n        'tis-620',\n        'iso885911',\n        'iso8859-11',\n        'iso-8859-11',\n        'windows-874'\n      ],\n      ['x-mac-cyrillic', 'x-mac-ukrainian'],\n      [\n        'gbk',\n        'x-gbk',\n        'gb2312',\n        'chinese',\n        'gb_2312',\n        'csgb2312',\n        'iso-ir-58',\n        'gb_2312-80',\n        'csiso58gb231280'\n      ],\n      ['gb18030'],\n      ['big5', 'csbig5', 'cn-big5', 'x-x-big5', 'big5-hkscs'],\n      ['euc-jp', 'x-euc-jp', 'cseucpkdfmtjapanese'],\n      ['csiso2022jp', 'iso-2022-jp'],\n      [\n        'ms932',\n        'sjis',\n        'x-sjis',\n        'ms_kanji',\n        'shift-jis',\n        'shift_jis',\n        'csshiftjis',\n        'windows-31j'\n      ],\n      [\n        'korean',\n        'euc-kr',\n        'cseuckr',\n        'ksc5601',\n        'ksc_5601',\n        'iso-ir-149',\n        'windows-949',\n        'csksc56011987',\n        'ks_c_5601-1987',\n        'ks_c_5601-1989'\n      ],\n      [\n        'hz-gb-2312',\n        'csiso2022kr',\n        'iso-2022-kr',\n        'iso-2022-cn',\n        'iso-2022-cn-ext'\n      ],\n      ['utf-16be'],\n      ['utf-16', 'utf-16le'],\n      ['x-user-defined']\n    ]\n  },\n  contenteditable: {\n    missing: null,\n    invalid: null,\n    states: [null, ['', 'true'], 'false']\n  },\n  crossorigin: {\n    selector: 'link, img, audio, video, script',\n    missing: null,\n    invalid: '',\n    states: [['', 'anonymous'], 'use-credentials']\n  },\n  decoding: {\n    selector: 'img',\n    missing: '',\n    invalid: '',\n    states: ['sync', 'async', ['', 'auto']]\n  },\n  dir: {\n    missing: '',\n    invalid: '',\n    states: ['', 'ltr', 'rtl', 'auto']\n  },\n  direction: {\n    selector: 'marquee',\n    missing: 'left',\n    states: ['left', 'right', 'up', 'down']\n  },\n  draggable: {\n    missing: null,\n    states: [null, 'true', 'false']\n  },\n  // When changing `encType`, please also change `formenctype`.\n  enctype: {\n    selector: 'form',\n    invalid: 'application/x-www-form-urlencoded',\n    missing: 'application/x-www-form-urlencoded',\n    states: [\n      'application/x-www-form-urlencoded',\n      'multipart/form-data',\n      'text/plain'\n    ]\n  },\n  // When changing `formenctype`, please also change `encType`.\n  formenctype: {\n    selector: 'button, input',\n    invalid: 'application/x-www-form-urlencoded',\n    // Note that `missing: null` here is intentionally different from `encType`.\n    missing: null,\n    states: [\n      'application/x-www-form-urlencoded',\n      'multipart/form-data',\n      'text/plain'\n    ]\n  },\n  // When changing `formmethod`, please also change `method`.\n  formmethod: {\n    selector: 'button, input',\n    invalid: 'get',\n    // Note that `missing: null` here is intentionally different from `formmethod`.\n    missing: null,\n    states: ['dialog', 'get', 'post']\n  },\n  // When changing `formtarget`, please also change `target`.\n  formtarget: {\n    selector: 'button, input',\n    // Note that `missing: null` here is intentionally different from `target`.\n    missing: null,\n    allowUnknown: true,\n    // Note that `formtarget` uses `_self` and `target` uses `['', '_self']`,\n    // which is intentional.\n    states: ['_blank', '_parent', '_self', '_top']\n  },\n  inputmode: {\n    // In fact only applies to `text`, `search`, and `password`.\n    selector: 'input',\n    invalid: '',\n    missing: '',\n    states: [\n      '',\n      'email',\n      'full-width-latin',\n      'kana',\n      'kana-name',\n      'katakana',\n      'latin',\n      'latin-name',\n      'latin-prose',\n      'numeric',\n      'tel',\n      'url',\n      'verbatim'\n    ]\n  },\n  keytype: {\n    selector: 'keygen',\n    missing: 'rsa',\n    states: ['', 'rsa']\n  },\n  kind: {\n    selector: 'track',\n    missing: 'subtitles',\n    invalid: 'metadata',\n    states: ['captions', 'chapters', 'descriptions', 'metadata', 'subtitles']\n  },\n  loading: {\n    selector: 'iframe, img',\n    invalid: 'eager',\n    missing: 'eager',\n    states: ['eager', 'lazy']\n  },\n  // When changing `method`, please also change `formmethod`.\n  method: {\n    selector: 'form',\n    invalid: 'get',\n    missing: 'get',\n    states: ['dialog', 'get', 'post']\n  },\n  preload: {\n    selector: 'audio, video',\n    // Note: https://html.spec.whatwg.org/#attr-media-preload\n    states: [['', 'auto'], 'metadata', 'none']\n  },\n  // Should also apply to `content` on `meta[name=referrer]`.\n  referrerpolicy: {\n    selector: 'a, area, iframe, img, link',\n    missing: '',\n    invalid: '',\n    states: [\n      '',\n      'no-referrer',\n      'no-referrer-when-downgrade',\n      'origin',\n      'origin-when-cross-origin',\n      'unsafe-url'\n    ]\n  },\n  scope: {\n    selector: 'th',\n    missing: '',\n    states: ['', 'col', 'colgroup', 'row', 'rowgroup']\n  },\n  shape: {\n    selector: 'area',\n    missing: 'rect',\n    states: [\n      // The latter are non-conforming.\n      ['rect', 'rectangle'],\n      ['poly', 'polygon'],\n      ['circle', 'circ'],\n      'default'\n    ]\n  },\n  spellcheck: {\n    missing: null,\n    invalid: null,\n    states: [null, ['', 'true'], 'false']\n  },\n  // When changing `target`, please also change `formtarget`.\n  target: {\n    selector: 'a, area, base, form',\n    missing: '',\n    allowUnknown: true,\n    states: ['_blank', '_parent', ['', '_self'], '_top']\n  },\n  translate: {\n    missing: null,\n    invalid: null,\n    states: [['', 'yes'], 'no']\n  },\n  type: [\n    {\n      selector: 'button',\n      missing: 'submit',\n      states: ['button', 'menu', 'reset', 'submit']\n    },\n    {\n      selector: 'input',\n      missing: 'text',\n      states: [\n        'button',\n        'checkbox',\n        'color',\n        'date',\n        'datetime-local',\n        'email',\n        'file',\n        'hidden',\n        'image',\n        'number',\n        'month',\n        'password',\n        'radio',\n        'range',\n        'reset',\n        'search',\n        'submit',\n        'tel',\n        'text',\n        'time',\n        'url',\n        'week'\n      ]\n    },\n    {\n      caseSensitive: true,\n      selector: 'li',\n      missing: '',\n      invalid: '',\n      states: ['1', 'a', 'A', 'i', 'I', 'circle', 'disc', 'square']\n    },\n    {\n      selector: 'menu',\n      missing: '',\n      states: ['', 'context', 'toolbar']\n    },\n    {\n      selector: 'menuitem',\n      missing: 'command',\n      states: ['checkbox', 'command', 'radio']\n    },\n    {\n      caseSensitive: true,\n      selector: 'ol',\n      missing: '1',\n      invalid: '1',\n      states: ['1', 'a', 'A', 'i', 'I']\n    },\n    {\n      selector: 'ul',\n      missing: '',\n      invalid: '',\n      states: ['circle', 'disc', 'square']\n    }\n  ],\n  wrap: {\n    selector: 'textarea',\n    missing: 'soft',\n    states: ['hard', 'soft']\n  }\n}\n","/**\n * @fileoverview\n *   Map of URL attributes in HTML\n * @longdescription\n *   ## Use\n *\n *   ```js\n *   import {urlAttributes} from 'html-url-attributes'\n *\n *   urlAttributes.formAction\n *   //=> ['button', 'input']\n *   urlAttributes.href\n *   //=> ['a', 'area', 'base', 'link']\n *   ```\n *\n *   ## API\n *\n *   ### `urlAttributes`\n *\n *   Map of URL attributes in HTML (`Record<string, string[]>`).\n */\n\n/**\n * @type {Record<string, string[]|null>}\n */\nexport const urlAttributes = {\n  action: ['form'],\n  cite: ['blockquote', 'del', 'ins', 'q'],\n  data: ['object'],\n  formAction: ['button', 'input'],\n  href: ['a', 'area', 'base', 'link'],\n  icon: ['menuitem'],\n  itemId: null,\n  manifest: ['html'],\n  ping: ['a', 'area'],\n  poster: ['video'],\n  src: [\n    'audio',\n    'embed',\n    'iframe',\n    'img',\n    'input',\n    'script',\n    'source',\n    'track',\n    'video'\n  ]\n}\n","/**\n * Check if the given character code, or the character code at the first\n * character, is alphabetical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphabetical.\n */\nexport function isAlphabetical(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return (\n    (code >= 97 && code <= 122) /* a-z */ ||\n    (code >= 65 && code <= 90) /* A-Z */\n  )\n}\n","import {isAlphabetical} from 'is-alphabetical'\nimport {isDecimal} from 'is-decimal'\n\n/**\n * Check if the given character code, or the character code at the first\n * character, is alphanumerical.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is alphanumerical.\n */\nexport function isAlphanumerical(character) {\n  return isAlphabetical(character) || isDecimal(character)\n}\n","/**\n * Check if the given character code, or the character code at the first\n * character, is decimal.\n *\n * @param {string|number} character\n * @returns {boolean} Whether `character` is a decimal\n */\nexport function isDecimal(character) {\n  const code =\n    typeof character === 'string' ? character.charCodeAt(0) : character\n\n  return code >= 48 && code <= 57 /* 0-9 */\n}\n","/**\n * @fileoverview\n *   Minify whitespace in attributes.\n * @example\n *   <a href=\"  http://example.com \"></a>\n */\n\n// Note: Dont include non-strings (such as `boolean`s) here, theyre already\n// handled in the generator.\n\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isElement} from 'hast-util-is-element'\nimport {isEventHandler} from 'hast-util-is-event-handler'\nimport {schema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n */\n\n/**\n * Minify whitespace in attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyAttributeWhitespace() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (\n          hasProperty(node, prop) &&\n          (isEventHandler(prop) ||\n            (own.call(schema, prop) && isElement(node, schema[prop])))\n        ) {\n          props[prop] = minify(props[prop])\n        }\n      }\n    })\n  }\n}\n\n/**\n * @param {null|undefined|string|number|boolean|Array<string|number>} value\n */\nfunction minify(value) {\n  return Array.isArray(value) ? all(value) : one(value)\n}\n\n/**\n * @param {Array<string|number>} value\n */\nfunction all(value) {\n  let index = -1\n  /** @type {Array<string|number>} */\n  const result = []\n\n  while (++index < value.length) {\n    // @ts-expect-error: input matches output.\n    result[index] = one(value[index])\n  }\n\n  return result\n}\n\n/**\n * @param {null|undefined|string|number|boolean} value\n */\nfunction one(value) {\n  return typeof value === 'string' ? String(value).trim() : value\n}\n","/**\n * @type {Record<string, string[]|null>}\n */\nexport const schema = {\n  accept: ['input'],\n  acceptCharset: ['form'],\n  accessKey: null,\n  action: ['form'],\n  cite: ['blockquote', 'del', 'ins', 'q'],\n  className: null,\n  cols: ['textarea'],\n  colSpan: ['td', 'th'],\n  data: ['object'],\n  dropzone: null,\n  formAction: ['button', 'input'],\n  height: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video'],\n  high: ['meter'],\n  href: ['a', 'area', 'base', 'link'],\n  htmlFor: ['output'],\n  icon: ['menuitem'],\n  itemId: null,\n  low: ['meter'],\n  manifest: ['html'],\n  max: ['meter', 'progress'],\n  maxLength: ['input', 'textarea'],\n  media: ['source'],\n  min: ['meter'],\n  minLength: ['input', 'textarea'],\n  optimum: ['meter'],\n  ping: ['a', 'area'],\n  poster: ['video'],\n  profile: ['head'],\n  rows: ['textarea'],\n  rowSpan: ['td', 'th'],\n  size: ['input', 'select'],\n  span: ['col', 'colgroup'],\n  src: [\n    'audio',\n    'embed',\n    'iframe',\n    'img',\n    'input',\n    'script',\n    'source',\n    'track',\n    'video'\n  ],\n  start: ['ol'],\n  step: ['input'],\n  style: null,\n  tabIndex: null,\n  useMap: ['img', 'object'],\n  value: ['li', 'meter', 'progress'],\n  width: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video']\n}\n","/**\n * @fileoverview\n *   Minify CSS style elements.\n * @example\n *   <style>\n *     * { color: #ff0000 }\n *   </style>\n */\n\nimport CleanCSS from 'clean-css'\nimport {visit} from 'unist-util-visit'\nimport {fromString} from 'hast-util-from-string'\nimport {toString} from 'hast-util-to-string'\nimport {isCssStyle} from 'hast-util-is-css-style'\n\nconst clean = new CleanCSS()\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * Minify CSS style elements.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyCssStyle() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (isCssStyle(node)) {\n        try {\n          const value = toString(node)\n          fromString(node, clean.minify(value).styles || value)\n          // Potential third party errors?\n          /* c8 ignore next */\n        } catch {}\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify enumerated attributes.\n *\n *   Sometimes attributes or their values can be dropped entirely, or a shorter\n *   value can be used.\n * @example\n *   <meta charset=\"utf-8\">\n *   <video preload=\"auto\">\n *     <track kind=\"subtitles\" src=\"abc.xyz\">\n *   </video>\n */\n\nimport {visit} from 'unist-util-visit'\nimport {html, find} from 'property-information'\nimport {matches} from 'hast-util-select'\nimport {hasProperty} from 'hast-util-has-property'\nimport {stringify} from 'space-separated-tokens'\nimport {enumeratedAttributes} from 'html-enumerated-attributes'\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('html-enumerated-attributes').Definition} Definition\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * Minify enumerated attributes.\n *\n * Sometimes attributes or their values can be dropped entirely, or a shorter\n * value can be used.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyEnumeratedAttribute() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop) && hasProperty(node, prop)) {\n          const attribute = find(html, prop).attribute\n\n          if (own.call(enumeratedAttributes, attribute)) {\n            let value = props[prop]\n\n            // Note: we dont really handle enumerated as lists, so instead\n            // we cast them to a string (assuming they are space-separated).\n            if (Array.isArray(value)) {\n              value = stringify(value)\n            }\n\n            if (typeof value === 'string') {\n              const definition = enumeratedAttributes[attribute]\n              const definitions = Array.isArray(definition)\n                ? definition\n                : [definition]\n              let index = -1\n\n              // eslint-disable-next-line max-depth\n              while (++index < definitions.length) {\n                const definition = definitions[index]\n\n                // eslint-disable-next-line max-depth\n                if (\n                  !definition.selector ||\n                  matches(definition.selector, node)\n                ) {\n                  props[prop] = minify(value, definition)\n                }\n              }\n            }\n          }\n        }\n      }\n    })\n  }\n}\n\n/**\n * @param {string} value\n * @param {Definition} info\n * @returns {string|null}\n */\nfunction minify(value, info) {\n  const insensitive = info.caseSensitive ? value : value.toLowerCase()\n  const states = info.states\n  let index = -1\n  let known = false\n  /** @type {string|null} */\n  let result = null\n  /** @type {string|string[]|null} */\n  let state = null\n\n  while (++index < states.length) {\n    state = states[index]\n\n    if (state === null) {\n      continue\n    }\n\n    if (typeof state === 'string') {\n      state = [state]\n    }\n\n    if (state.includes(insensitive)) {\n      known = true\n      break\n    }\n  }\n\n  // So, this is a valid enumerated attribute.\n  // Letss optimize it.\n  if (known && state) {\n    result = state[0]\n  } else if (typeof info.invalid === 'string') {\n    result = info.invalid\n  } else if (typeof info.missing === 'string' && !info.allowUnknown) {\n    result = info.missing\n  } else {\n    return value\n  }\n\n  // Should be a setting.\n  // Theres a missing value defined, so we can just as well remove the property\n  // all-together if theyre the same.\n  if (result === info.missing) {\n    result = null\n  } else if (result === info.invalid) {\n    // If the invalid state is longer that one character, we explicitly set a\n    // short keyword, namely a (never used as a keyword so always invalid).\n    // Otherwise, we keep the result (its often an empty string)\n    result = result.length > 1 ? 'a' : result\n  }\n\n  return result\n}\n","/**\n * @fileoverview\n *   Minify event handler attributes.\n * @example\n *   <h1 onclick=\"javascript:alert(false)\">Hello</h1>\n */\n\nimport Uglify from 'uglify-js'\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isEventHandler} from 'hast-util-is-event-handler'\n\nconst prefix = 'function a(){'\nconst suffix = '}a();'\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * Minify event handler attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyEventHandler() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let name\n\n      for (name in props) {\n        if (hasProperty(node, name) && isEventHandler(name)) {\n          props[name] = minify(props[name])\n        }\n      }\n    })\n  }\n}\n\n/**\n * @param {null|undefined|string|number|boolean|Array.<string|number>} value\n * @returns {null|undefined|string|number|boolean|Array.<string|number>}\n */\nfunction minify(value) {\n  let result = value\n\n  if (typeof result !== 'string') {\n    return result\n  }\n\n  try {\n    const output = Uglify.minify(prefix + result + suffix)\n    result = output.code.slice(prefix.length, -suffix.length)\n  } catch {}\n\n  return result.trim()\n}\n","/**\n * @fileoverview\n *   Minify `script` elements with a JavaScript body.\n * @example\n *   <script>\n *     var name = \"World\";\n *     console.log(\"Hello, \" + name + \"!\");\n *   </script>\n */\n\nimport Uglify from 'uglify-js'\nimport {visit} from 'unist-util-visit'\nimport {fromString} from 'hast-util-from-string'\nimport {toString} from 'hast-util-to-string'\nimport {isJavaScript} from 'hast-util-is-javascript'\nimport {hasProperty} from 'hast-util-has-property'\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * Minify `script` elements with a JavaScript body.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyJavaScriptScript() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (isJavaScript(node) && !hasProperty(node, 'src')) {\n        try {\n          let value = Uglify.minify(toString(node)).code\n\n          if (value.charAt(value.length - 1) === ';') {\n            value = value.slice(0, -1)\n          }\n\n          fromString(node, value)\n          // Potential third party errors?\n          /* c8 ignore next */\n        } catch {}\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify JavaScript URLs.\n * @example\n *   <img src=\"javascript:alert(true)\">\n */\n\nimport Uglify from 'uglify-js'\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isElement} from 'hast-util-is-element'\nimport {urlAttributes} from 'html-url-attributes'\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nconst own = {}.hasOwnProperty\n\n/* eslint-disable no-script-url */\nconst protocol = 'javascript:'\n/* eslint-enable no-script-url */\n\nconst prefix = 'function a(){'\nconst suffix = '}a();'\n\n/**\n * Minify JavaScript URLs.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyJavaScriptUrl() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (\n          hasProperty(node, prop) &&\n          own.call(urlAttributes, prop) &&\n          isElement(node, urlAttributes[prop])\n        ) {\n          const value = props[prop]\n          let result = value\n\n          if (\n            typeof result === 'string' &&\n            result.slice(0, protocol.length).toLowerCase() === protocol\n          ) {\n            result = result.slice(protocol.length)\n\n            try {\n              const output = Uglify.minify(prefix + result + suffix)\n              result = output.code.slice(prefix.length, -suffix.length)\n            } catch {}\n\n            result = protocol + result.trim()\n          }\n\n          props[prop] = result\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify `script` elements with a JSON body.\n * @example\n *   <script type=\"application/ld+json\">\n *   {\n *     \"@context\": {\n *       \"name\": \"http://xmlns.com/foaf/0.1/name\",\n *       \"@id\": \"http://me.example.com\",\n *       \"@type\": \"Person\",\n *       \"name\": \"John Smith\",\n *       \"homepage\": \"http://www.example.com/\"\n *     }\n *   }\n *   </script>\n */\n\nimport {visit} from 'unist-util-visit'\nimport {fromString} from 'hast-util-from-string'\nimport {toString} from 'hast-util-to-string'\nimport {isElement} from 'hast-util-is-element'\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\n/**\n * Minify `script` elements with a JSON body.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyJsonScript() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (\n        isElement(node, 'script') &&\n        node.properties &&\n        node.properties.type === 'application/ld+json'\n      ) {\n        try {\n          fromString(node, JSON.stringify(JSON.parse(toString(node))))\n        } catch {}\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify language attributes.\n * @example\n *   <span lang=\"en-US\">Color</span>\n *   <a href=\"https://nl.wikipedia.org/wiki/HyperText_Markup_Language\" hreflang=\"nld-NL\">HTML</a>\n *   <span xml:lang=\"pt-BR\">timo</span>\n *   <track src=\"colour.vtt\" srclang=\"en-GB\" label=\"English (UK)\">\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {bcp47Normalize} from 'bcp-47-normalize'\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst fields = ['hrefLang', 'lang', 'srcLang', 'xmlLang']\n\n/**\n * Minify language attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyLanguage() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties\n      let index = -1\n\n      while (++index < fields.length) {\n        const prop = fields[index]\n\n        if (\n          props &&\n          hasProperty(node, prop) &&\n          typeof props[prop] === 'string'\n        ) {\n          // BCP 47 tags are case-insensitive, but in this project we prefer\n          // lowercase which *should* help GZIP.\n          props[prop] = String(\n            bcp47Normalize(String(props[prop])) || props[prop]\n          ).toLowerCase()\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify media attributes.\n * @example\n *   <link rel=\"stylesheet\" media=\"only screen and (min-width: 320px)\" href=\"index.css\">\n *   <link rel=\"stylesheet\" media=\"all\" href=\"index.css\">\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport CleanCSS from 'clean-css'\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\n\nconst clean = new CleanCSS()\n\nconst prefix = '@media '\nconst suffix = '{i{color:red}}'\n\n/**\n * Minify media attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyMediaAttribute() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties\n\n      if (props && isElement(node, ['link', 'source', 'style'])) {\n        let value = props.media\n\n        if (typeof value === 'string') {\n          try {\n            const output = clean.minify(prefix + value + suffix)\n            value = output.styles.slice(prefix.length, -suffix.length)\n            // Potential third party errors?\n            /* c8 ignore next */\n          } catch {}\n\n          props.media = value === 'all' || !value ? null : value\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify theme color attributes.\n * @example\n *   <meta name=\"theme-color\" content=\"#0000ff\">\n *   <meta name=\"msapplication-TileColor\" content=\"#ff0000\">\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport CleanCSS from 'clean-css'\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst clean = new CleanCSS()\n\nconst prefix = '*{color:'\nconst suffix = '}'\n\n/**\n * Minify theme color attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyMetaColor() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      const name = props.name\n\n      if (\n        isElement(node, 'meta') &&\n        (name === 'msapplication-TileColor' || name === 'theme-color') &&\n        hasProperty(node, 'content')\n      ) {\n        let value = props.content\n\n        if (typeof value === 'string') {\n          try {\n            const output = clean.minify(prefix + value + suffix)\n            value = output.styles.slice(prefix.length, -suffix.length)\n            // Potential third party errors?\n            /* c8 ignore next */\n          } catch {}\n\n          props.content = value\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify `content` on `meta` elements.\n *\n *   Note: `meta[name=theme-color]` and `meta[name=msapplication-TileColor]`\n *   are handled by `rehype-minify-meta-color`.\n * @example\n *   <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=yes\">\n *   <meta name=\"keywords\" content=\"foo, bar baz, qux\">\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {parse, stringify} from 'comma-separated-tokens'\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst lists = new Set([\n  'viewport',\n  'keywords',\n  'robots',\n  'apple-itunes-app',\n  'apple-media-service-subscription'\n])\n\n/**\n * Minify `content` on `meta` elements.\n *\n * Note: `meta[name=theme-color]` and `meta[name=msapplication-TileColor]`\n * are handled by `rehype-minify-meta-color`.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyMetaContent() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      const name = String(props.name || '')\n      let value = props.content\n\n      if (\n        isElement(node, 'meta') &&\n        hasProperty(node, 'content') &&\n        typeof value === 'string'\n      ) {\n        if (name === 'viewport') {\n          value = value\n            .replace(/(\\d+\\.\\d+)/, (d) => String(Number(d)))\n            .replace(/user-scalable=\\s*yes/, '')\n          // Fall through.\n        }\n\n        if (lists.has(name)) {\n          value = stringify(parse(value), {padLeft: false})\n        }\n\n        props.content = value\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Minify style attributes.\n * @example\n *   <img style=\"display: block;\">\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport CleanCSS from 'clean-css'\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\n\nconst clean = new CleanCSS()\n\nconst prefix = '*{'\nconst suffix = '}'\n\n/**\n * Minify style attributes.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeMinifyStyleAttribute() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (node.properties && hasProperty(node, 'style')) {\n        let value = node.properties.style\n\n        if (typeof value === 'string') {\n          try {\n            const output = clean.minify(prefix + value + suffix).styles\n            value = output ? output.slice(prefix.length, -suffix.length) : value\n            // Potential third party errors?\n            /* c8 ignore next */\n          } catch {}\n\n          node.properties.style = value || null\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Normalize casing of attribute values.\n *\n *   This optimizes for repetition-based compression (such as GZip).\n * @example\n *   <form method=\"GET\"></form>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {hasProperty} from 'hast-util-has-property'\nimport {isElement} from 'hast-util-is-element'\nimport {schema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Normalize casing of attribute values.\n * This optimizes for repetition-based compression (such as GZip).\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeNormalizeAttributeValueCase() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (\n          hasProperty(node, prop) &&\n          own.call(schema, prop) &&\n          isElement(node, schema[prop])\n        ) {\n          props[prop] = minify(props[prop])\n        }\n      }\n    })\n  }\n}\n\n/**\n * @param {null|undefined|string|number|boolean|Array.<string|number>} value\n * @returns {null|undefined|string|number|boolean|Array.<string|number>}\n */\nfunction minify(value) {\n  return Array.isArray(value) ? all(value) : one(value)\n}\n\n/**\n * @param {Array.<string|number>} value\n * @returns {Array.<string|number>}\n */\nfunction all(value) {\n  let index = -1\n  /** @type {Array.<string|number>} */\n  const result = []\n\n  while (++index < value.length) {\n    // @ts-expect-error: input type matches output type.\n    result[index] = one(value[index])\n  }\n\n  return result\n}\n\n/**\n * @param {null|undefined|string|number|boolean} value\n * @returns {null|undefined|string|number|boolean}\n */\nfunction one(value) {\n  return typeof value === 'string' ? value.toLowerCase() : value\n}\n","/**\n * @type {Record<string, string[]|null>}\n */\nexport const schema = {\n  acceptCharset: ['form'],\n  autoComplete: ['form'],\n  charSet: ['meta', 'script'],\n  contentEditable: null,\n  crossOrigin: ['audio', 'img', 'link', 'script', 'video'],\n  dir: null,\n  draggable: null,\n  dropzone: null,\n  encType: ['form'],\n  formEncType: ['button', 'input'],\n  formMethod: ['button', 'input'],\n  inputMode: ['input', 'textarea'],\n  kind: ['track'],\n  method: ['form'],\n  preload: ['audio', 'video'],\n  referrerPolicy: ['a', 'area', 'iframe', 'img', 'link'],\n  sandbox: ['iframe'],\n  spellCheck: null,\n  scope: ['th'],\n  shape: ['area'],\n  sizes: ['link'],\n  step: ['input'],\n  translate: null,\n  type: [\n    'a',\n    'link',\n    'button',\n    'embed',\n    'object',\n    'script',\n    'source',\n    'style',\n    'input',\n    'menu',\n    'menuitem'\n  ],\n  wrap: ['textarea']\n}\n","import rehypeMinifyAttributeWhitespace from 'rehype-minify-attribute-whitespace'\nimport rehypeMinifyCssStyle from 'rehype-minify-css-style'\nimport rehypeRemoveMetaHttpEquiv from 'rehype-remove-meta-http-equiv'\nimport rehypeMinifyEnumeratedAttribute from 'rehype-minify-enumerated-attribute'\nimport rehypeMinifyEventHandler from 'rehype-minify-event-handler'\nimport rehypeMinifyJavaScriptScript from 'rehype-minify-javascript-script'\nimport rehypeMinifyJavaScriptUrl from 'rehype-minify-javascript-url'\nimport rehypeMinifyJsonScript from 'rehype-minify-json-script'\nimport rehypeMinifyLanguage from 'rehype-minify-language'\nimport rehypeMinifyMediaAttribute from 'rehype-minify-media-attribute'\nimport rehypeMinifyMetaColor from 'rehype-minify-meta-color'\nimport rehypeMinifyMetaContent from 'rehype-minify-meta-content'\nimport rehypeMinifyStyleAttribute from 'rehype-minify-style-attribute'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport rehypeNormalizeAttributeValueCase from 'rehype-normalize-attribute-value-case'\nimport rehypeRemoveComments from 'rehype-remove-comments'\nimport rehypeRemoveDuplicateAttributeValues from 'rehype-remove-duplicate-attribute-values'\nimport rehypeRemoveEmptyAttribute from 'rehype-remove-empty-attribute'\nimport rehypeRemoveExternalScriptContent from 'rehype-remove-external-script-content'\nimport rehypeRemoveScriptTypeJavaScript from 'rehype-remove-script-type-javascript'\nimport rehypeRemoveStyleTypeCss from 'rehype-remove-style-type-css'\nimport rehypeSortAttributeValues from 'rehype-sort-attribute-values'\nimport rehypeSortAttributes from 'rehype-sort-attributes'\n\nconst settings = {\n  entities: {\n    omitOptionalSemicolons: true,\n    useShortestReferences: true\n  },\n  quoteSmart: true,\n  preferUnquoted: true,\n  omitOptionalTags: true,\n  bogusComments: true,\n  collapseEmptyAttributes: true,\n  closeEmptyElements: true,\n  tightSelfClosing: true,\n  tightCommaSeparatedLists: true,\n  tightAttributes: true,\n  tightDoctype: true,\n  allowParseErrors: true\n}\n\nconst plugins = [\n  rehypeMinifyAttributeWhitespace,\n  rehypeMinifyCssStyle,\n  // Do `remove-meta-http-equiv` before `enumerated-attribute`, because the\n  // latter might minify things further.\n  rehypeRemoveMetaHttpEquiv,\n  rehypeMinifyEnumeratedAttribute,\n  rehypeMinifyEventHandler,\n  rehypeMinifyJavaScriptScript,\n  rehypeMinifyJavaScriptUrl,\n  rehypeMinifyJsonScript,\n  rehypeMinifyLanguage,\n  rehypeMinifyMediaAttribute,\n  rehypeMinifyMetaColor,\n  rehypeMinifyMetaContent,\n  rehypeMinifyStyleAttribute,\n  rehypeMinifyWhitespace,\n  rehypeNormalizeAttributeValueCase,\n  rehypeRemoveComments,\n  rehypeRemoveDuplicateAttributeValues,\n  rehypeRemoveEmptyAttribute,\n  rehypeRemoveExternalScriptContent,\n  rehypeRemoveScriptTypeJavaScript,\n  rehypeRemoveStyleTypeCss,\n  rehypeSortAttributeValues,\n  rehypeSortAttributes\n]\n\nconst rehypePresetMinify = {settings, plugins}\n\nexport default rehypePresetMinify\n","/**\n * @fileoverview\n *   Remove comments (except conditional comments).\n *\n *   When configured with `force: true` (default: `false`), conditional comments\n *   are also removed.\n * @example\n *   <!--Hello-->\n *   <!--[if IE 6]>OK<![endif]-->\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('unist').Node} Node\n * @typedef {Root|Root['children'][number]} HastNode\n *\n * @typedef Options\n *   Configuration.\n * @property {boolean} [removeConditional=false]\n *   Conditional comments are also removed when configured with `force: true`\n *   The default is to leave them.\n */\n\nimport {filter} from 'unist-util-filter'\nimport {isConditionalComment} from 'hast-util-is-conditional-comment'\n\n/**\n * Remove comments (except conditional comments).\n *\n * When configured with `force: true` (default: `false`), conditional comments\n * are also removed.\n *\n * @type {import('unified').Plugin<[Options?] | void[], Root>}\n */\nexport default function rehypeRemoveComments(options = {}) {\n  const force = options.removeConditional\n\n  return (tree) =>\n    // `undefined` is never returned because we dont remove nodes (but TS\n    // doesnt know it.)\n    /* c8 ignore next */\n    filter(tree, {cascade: false}, force ? hard : soft) || undefined\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction soft(node) {\n  const x = /** @type {HastNode} */ (node)\n  return hard(x) || isConditionalComment(x)\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nfunction hard(node) {\n  const x = /** @type {HastNode} */ (node)\n  return x.type !== 'comment'\n}\n","/**\n * @fileoverview\n *   Remove duplicates in attribute values with unique tokens.\n * @example\n *   <div class=\"foo foo\"></label>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\nimport {schema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Remove duplicates in attribute values with unique tokens.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveDuplicateAttributeValues() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop)) {\n          const value = props[prop]\n\n          if (\n            own.call(schema, prop) &&\n            isElement(node, schema[prop]) &&\n            Array.isArray(value)\n          ) {\n            props[prop] = [...new Set(value)]\n          }\n        }\n      }\n    })\n  }\n}\n","/** @type {Record<string, string[]|string|null>} */\nexport const schema = {\n  acceptCharset: 'form',\n  accessKey: null,\n  className: null,\n  dropzone: null,\n  htmlFor: 'output',\n  headers: ['td', 'th'],\n  itemProp: null,\n  itemRef: null,\n  itemType: null,\n  sandbox: 'iframe',\n  sizes: 'link'\n}\n","/**\n * @fileoverview\n *   Remove empty attributes, if possible.\n * @example\n *   <label for id=\"\"></label>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\nimport {isEventHandler} from 'hast-util-is-event-handler'\nimport {schema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Remove empty attributes, if possible.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveEmptyAttribute() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop)) {\n          const value = props[prop]\n\n          if (\n            (value === '' || (Array.isArray(value) && value.length === 0)) &&\n            (isEventHandler(prop) ||\n              (own.call(schema, prop) && isElement(node, schema[prop])))\n          ) {\n            props[prop] = null\n          }\n        }\n      }\n    })\n  }\n}\n","/** @type {Record<string, string|string[]|null>} */\nexport const schema = {\n  abbr: 'th',\n  accept: 'input',\n  acceptCharset: 'form',\n  accessKey: null,\n  action: 'form',\n  charSet: ['meta', 'script'],\n  className: null,\n  cols: 'textarea',\n  colSpan: ['td', 'th'],\n  coords: 'area',\n  dir: null,\n  dirname: ['input', 'textarea'],\n  dropzone: null,\n  headers: ['td', 'th'],\n  htmlFor: ['label', 'output'],\n  form: [\n    'button',\n    'fieldset',\n    'input',\n    'keygen',\n    'object',\n    'output',\n    'select',\n    'textarea'\n  ],\n  formAction: ['button', 'input'],\n  height: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video'],\n  high: 'meter',\n  href: 'link',\n  icon: 'menuitem',\n  id: null,\n  itemProp: null,\n  itemRef: null,\n  itemType: null,\n  list: 'input',\n  low: 'meter',\n  manifest: 'html',\n  max: ['meter', 'progress'],\n  maxLength: ['input', 'textarea'],\n  menu: 'button',\n  min: 'meter',\n  minLength: ['input', 'textarea'],\n  name: [\n    'button',\n    'fieldset',\n    'input',\n    'keygen',\n    'output',\n    'select',\n    'textarea',\n    'form',\n    'map',\n    'meta',\n    'param',\n    'slot'\n  ],\n  optimum: 'meter',\n  pattern: 'input',\n  ping: ['a', 'area'],\n  placeholder: ['input', 'textarea'],\n  poster: 'video',\n  rel: ['a', 'area', 'link'],\n  rows: 'textarea',\n  rowSpan: ['td', 'th'],\n  size: ['input', 'select'],\n  span: ['col', 'colgroup'],\n  src: [\n    'audio',\n    'embed',\n    'iframe',\n    'img',\n    'input',\n    'script',\n    'source',\n    'track',\n    'video'\n  ],\n  start: 'ol',\n  style: null,\n  tabIndex: null,\n  type: [\n    'a',\n    'link',\n    'button',\n    'embed',\n    'object',\n    'script',\n    'source',\n    'style',\n    'input',\n    'menu',\n    'menuitem',\n    'ol'\n  ],\n  useMap: ['img', 'object'],\n  value: ['button', 'input', 'li'],\n  width: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video']\n}\n","/**\n * @fileoverview\n *   Remove content of external JavaScript `script` elements.\n * @example\n *   <script src=\"index.js\">Hello!</script>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isJavaScript} from 'hast-util-is-javascript'\nimport {hasProperty} from 'hast-util-has-property'\n\n/**\n * Remove content of external JavaScript `script` elements.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveExternalScriptContent() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (isJavaScript(node) && hasProperty(node, 'src')) {\n        node.children = []\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Remove `meta[http-equiv=content-language]` and\n *   `meta[http-equiv=content-type]` elements for shorter output.\n *\n *   Note: The missing whitespace in the output is due to\n *   [inikulin/parse5#150](https://github.com/inikulin/parse5/issues/150).\n * @example\n *   {\"processor\": {\"fragment\": false}}\n *   <!doctype html>\n *   <html lang=\"en-GB\">\n *     <head>\n *       <meta charset=\"utf8\">\n *       <meta http-equiv=\"content-type\" content=\"text/html; charset=chinese\">\n *       <meta http-equiv=\"content-language\" content=\"en-US\">\n *     </head>\n *     <body></body>\n *   </html>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Parent} Parent\n */\n\nimport {visit} from 'unist-util-visit'\nimport {stringify} from 'space-separated-tokens'\nimport {hasProperty} from 'hast-util-has-property'\n\n/**\n * Remove `meta[http-equiv=content-language]` and\n * `meta[http-equiv=content-type]` elements for shorter output.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveMetaHttpEquiv() {\n  return (tree) => {\n    /** @type {Element|undefined} */\n    let html\n    /** @type {Element|undefined} */\n    let head\n    /** @type {Element|undefined} */\n    let charSet\n    /** @type {Element|undefined} */\n    let contentType\n    /** @type {Element|undefined} */\n    let contentLanguage\n    /** @type {Parent|null|undefined} */\n    let contentTypeParent\n    /** @type {Parent|null|undefined} */\n    let contentLanguageParent\n\n    visit(tree, 'element', (node, _, parent) => {\n      // Stop walking as we only need the `head`.\n      if (node.tagName === 'body') {\n        return false\n      }\n\n      if (node.tagName === 'html') {\n        html = node\n      } else if (node.tagName === 'head') {\n        head = node\n      } else if (node.tagName === 'meta' && node.properties) {\n        if (hasProperty(node, 'charSet')) {\n          charSet = node\n        } else if (\n          hasProperty(node, 'httpEquiv') &&\n          Array.isArray(node.properties.httpEquiv)\n        ) {\n          const value = stringify(node.properties.httpEquiv).toLowerCase()\n\n          if (value === 'content-language') {\n            contentLanguage = node\n            // @ts-expect-error: fine parent.\n            contentLanguageParent = parent\n          } else if (value === 'content-type') {\n            contentType = node\n            // @ts-expect-error: fine parent.\n            contentTypeParent = parent\n          }\n        }\n      }\n    })\n\n    // `meta` has precedence over `html[lang]`:\n    // <https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes:pragma-set-default-language>\n    if (\n      html &&\n      html.properties &&\n      contentLanguage &&\n      contentLanguage.properties &&\n      contentLanguageParent\n    ) {\n      html.properties.lang = contentLanguage.properties.content\n      contentLanguageParent.children.splice(\n        contentLanguageParent.children.indexOf(contentLanguage),\n        1\n      )\n    }\n\n    // `meta` has precedence over `meta[charset]`.\n    if (contentTypeParent && contentType && contentType.properties) {\n      const value = String(contentType.properties.content).replace(\n        /^.+charset=/i,\n        ''\n      )\n\n      if (charSet && charSet.properties) {\n        charSet.properties.charSet = value\n        contentTypeParent.children.splice(\n          contentTypeParent.children.indexOf(contentType),\n          1\n        )\n      } else if (head) {\n        head.children.unshift({\n          type: 'element',\n          tagName: 'meta',\n          properties: {charSet: value},\n          children: []\n        })\n\n        contentTypeParent.children.splice(\n          contentTypeParent.children.indexOf(contentType),\n          1\n        )\n      }\n    }\n  }\n}\n","/**\n * @fileoverview\n *   Remove `type` and `language` on JavaScript scripts.\n * @example\n *   <script type=\"text/javascript\"></script>\n *   <script language=\"javascript1.5\"></script>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isJavaScript} from 'hast-util-is-javascript'\n\n/**\n * Remove `type` and `language` on JavaScript scripts.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveScriptTypeJavaScript() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (isJavaScript(node) && node.properties) {\n        if ('type' in node.properties) {\n          node.properties.type = null\n        }\n\n        if ('language' in node.properties) {\n          node.properties.language = null\n        }\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Remove `type` on CSS `style` and `link`s.\n * @example\n *   <link rel=\"stylesheet alternate\" type=\"text/css\" href=\"index.css\">\n *   <style type=\"text/css\"></style>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isCssLink} from 'hast-util-is-css-link'\nimport {isCssStyle} from 'hast-util-is-css-style'\n\n/**\n * Remove `type` on CSS `style` and `link`s.\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeRemoveStyleTypeCss() {\n  return (tree) => {\n    visit(tree, 'element', (node) => {\n      if (\n        node.properties &&\n        'type' in node.properties &&\n        (isCssLink(node) || isCssStyle(node))\n      ) {\n        node.properties.type = null\n      }\n    })\n  }\n}\n","/**\n * @fileoverview\n *   Sort attribute values.\n *\n *   This optimizes for repetition-based compression (such as GZip).\n * @example\n *   <div class=\"qux quux foo bar\"></div>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n */\n\nimport {visit} from 'unist-util-visit'\nimport {isElement} from 'hast-util-is-element'\nimport {schema} from './schema.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Sort attribute values.\n *\n * This optimizes for repetition-based compression (such as GZip).\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeSortAttributeValues() {\n  return (tree) => {\n    /** @type {Record<string, {known: string[], counts: Record<string, number>}>} */\n    const counts = {}\n    /** @type {Array.<[Array.<string|number>, string]>} */\n    const queues = []\n\n    visit(tree, 'element', (node) => {\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop)) {\n          const value = props[prop]\n\n          if (\n            own.call(schema, prop) &&\n            isElement(node, schema[prop]) &&\n            Array.isArray(value)\n          ) {\n            add(prop, value)\n          }\n        }\n      }\n    })\n\n    flush()\n\n    /**\n     * @param {string} prop\n     * @param {Array.<string|number>} values\n     */\n    function add(prop, values) {\n      const cache = counts[prop] || (counts[prop] = {known: [], counts: {}})\n      let index = -1\n\n      while (++index < values.length) {\n        const value = safe(values[index])\n\n        if (value in cache.counts) {\n          cache.counts[value]++\n        } else {\n          cache.counts[value] = 1\n          cache.known.push(String(values[index]))\n        }\n      }\n\n      queues.push([values, prop])\n    }\n\n    function flush() {\n      /** @type {Record<string, Array.<string|number>>} */\n      const caches = {}\n      /** @type {string} */\n      let prop\n\n      for (prop in counts) {\n        if (own.call(counts, prop)) {\n          const values = counts[prop]\n          caches[prop] = values.known.sort(\n            (a, b) =>\n              values.counts[safe(b)] - values.counts[safe(a)] ||\n              compare(a, b, 0)\n          )\n        }\n      }\n\n      let index = -1\n\n      while (++index < queues.length) {\n        const queue = queues[index]\n        const cache = caches[queue[1]]\n        queue[0].sort((a, b) => cache.indexOf(a) - cache.indexOf(b))\n      }\n    }\n  }\n}\n\n/**\n * @param {string|number} value\n * @returns {string}\n */\nfunction safe(value) {\n  return '$' + value\n}\n\n/**\n * This would create an infinite loop if `a` and `b` could be equal, but the\n * list we operate on only has unique values.\n *\n * @param {string} a\n * @param {string} b\n * @param {number} index\n * @returns {number}\n */\nfunction compare(a, b, index) {\n  return (\n    (a.charCodeAt(index) || 0) - (b.charCodeAt(index) || 0) ||\n    compare(a, b, index + 1)\n  )\n}\n","/** @type {Record<string, string|string[]|null>} */\nexport const schema = {\n  accept: 'input',\n  className: null,\n  dropzone: null,\n  htmlFor: 'output',\n  headers: ['td', 'th'],\n  itemProp: null,\n  itemRef: null,\n  itemType: null,\n  ping: ['a', 'area'],\n  rel: ['a', 'area', 'link'],\n  sandbox: 'iframe',\n  sizes: 'link'\n}\n","/**\n * @fileoverview\n *   Reorder attributes based on how often they occur.\n *\n *   This optimizes for repetition-based compression (such as GZip).\n * @example\n *   <div id=\"foo\"><strong class=\"bar\" id=\"baz\">qux</strong></div>\n */\n\n/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast').Element} Element\n */\n\nimport {visit} from 'unist-util-visit'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Reorder attributes based on how often they occur.\n *\n * This optimizes for repetition-based compression (such as GZip).\n *\n * @type {import('unified').Plugin<[], Root>}\n */\nexport default function rehypeSortAttributes() {\n  return (tree) => {\n    /** @type {Record<string, {known: string[], counts: Record<string, number>}>} */\n    const counts = {}\n\n    visit(tree, 'element', (node) => {\n      const name = node.tagName\n      const cache = counts[name] || (counts[name] = {known: [], counts: {}})\n      const props = node.properties || {}\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop)) {\n          const value = safe(prop)\n\n          if (value in cache.counts) {\n            cache.counts[value]++\n          } else {\n            cache.counts[value] = 1\n            cache.known.push(prop)\n          }\n        }\n      }\n    })\n\n    const caches = optimize()\n\n    visit(tree, 'element', (node) => {\n      const cache = caches[node.tagName]\n      const props = node.properties || {}\n      /** @type {string[]} */\n      const keys = []\n      /** @type {Required<Element['properties']>} */\n      const result = {}\n      let index = -1\n      /** @type {string} */\n      let prop\n\n      for (prop in props) {\n        if (own.call(props, prop)) {\n          keys.push(prop)\n        }\n      }\n\n      keys.sort((a, b) => cache.indexOf(a) - cache.indexOf(b))\n\n      while (++index < keys.length) {\n        result[keys[index]] = props[keys[index]]\n      }\n\n      node.properties = result\n    })\n\n    function optimize() {\n      /** @type {Record<string, Array.<string>>} */\n      const caches = {}\n      /** @type {string} */\n      let name\n\n      for (name in counts) {\n        if (own.call(counts, name)) {\n          const values = counts[name]\n          caches[name] = values.known.sort(\n            (a, b) =>\n              values.counts[safe(b)] - values.counts[safe(a)] ||\n              compare(a, b, 0)\n          )\n        }\n      }\n\n      return caches\n    }\n  }\n}\n\n/**\n * @param {string} value\n * @returns {string}\n */\nfunction safe(value) {\n  return '$' + value\n}\n\n/**\n * This would create an infinite loop if `a` and `b` could be equal, but the\n * list we operate on only has unique values.\n *\n * @param {string} a\n * @param {string} b\n * @param {number} index\n * @returns {number}\n */\nfunction compare(a, b, index) {\n  return (\n    (a.charCodeAt(index) || 0) - (b.charCodeAt(index) || 0) ||\n    compare(a, b, index + 1)\n  )\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n */\n\n/**\n * Options for unist util filter\n *\n * @typedef {Object} FilterOptions\n * @property {boolean} [cascade=true] Whether to drop parent nodes if they had children, but all their children were filtered out.\n */\n\nimport {convert} from 'unist-util-is'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a new tree consisting of copies of all nodes that pass test.\n * The tree is walked in preorder (NLR), visiting the node itself, then its head, etc.\n *\n * @param tree Tree to filter.\n * @param options Configuration (optional).\n * @param test is-compatible test (such as a type).\n * @returns Given `tree` or `null` if it didnt pass `test`.\n */\nexport const filter =\n  /**\n   * @type {(\n   *  (<Tree extends Node, Check extends Test>(node: Tree, options: FilterOptions, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n   *  (<Tree extends Node, Check extends Test>(node: Tree, test: Check) => import('./complex-types').Matches<Tree, Check>) &\n   *  (<Tree extends Node>(node: Tree, options?: FilterOptions) => Tree)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {FilterOptions} options\n     * @param {Test} test\n     * @returns {Node|null}\n     */\n    function (tree, options, test) {\n      const is = convert(test || options)\n      const cascade =\n        options.cascade === undefined || options.cascade === null\n          ? true\n          : options.cascade\n\n      return preorder(tree)\n\n      /**\n       * @param {Node} node\n       * @param {number|undefined} [index]\n       * @param {Parent|undefined} [parent]\n       * @returns {Node|null}\n       */\n      function preorder(node, index, parent) {\n        /** @type {Array.<Node>} */\n        const children = []\n        /** @type {number} */\n        let childIndex\n        /** @type {Node} */\n        let result\n        /** @type {string} */\n        let key\n\n        if (!is(node, index, parent)) return null\n\n        // @ts-expect-error: Looks like a parent.\n        if (node.children) {\n          childIndex = -1\n\n          // @ts-expect-error Looks like a parent.\n          while (++childIndex < node.children.length) {\n            // @ts-expect-error Looks like a parent.\n            result = preorder(node.children[childIndex], childIndex, node)\n\n            if (result) {\n              children.push(result)\n            }\n          }\n\n          // @ts-expect-error Looks like a parent.\n          if (cascade && node.children.length > 0 && children.length === 0)\n            return null\n        }\n\n        // Create a shallow clone, using the new children.\n        /** @type {typeof node} */\n        // @ts-expect-error all the fields will be copied over.\n        const next = {}\n\n        for (key in node) {\n          if (own.call(node, key)) {\n            // @ts-expect-error: Looks like a record.\n            next[key] = key === 'children' ? children : node[key]\n          }\n        }\n\n        return next\n      }\n    }\n  )\n","/**\n * @param {string} d\n * @returns {string}\n */\nexport function color(d) {\n  return d\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('./complex-types').Action} Action\n * @typedef {import('./complex-types').Index} Index\n * @typedef {import('./complex-types').ActionTuple} ActionTuple\n * @typedef {import('./complex-types').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\n\nimport {convert} from 'unist-util-is'\nimport {color} from './color.js'\n\n/**\n * Continue traversing as normal\n */\nexport const CONTINUE = true\n/**\n * Do not traverse this nodes children\n */\nexport const SKIP = 'skip'\n/**\n * Stop traversing immediately\n */\nexport const EXIT = false\n\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test node, optional\n * @param visitor Function to run for each node\n * @param reverse Visit the tree in reverse order, defaults to false\n */\nexport const visitParents =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types').Visitor<Node>} visitor\n     * @param {boolean} [reverse]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        // @ts-expect-error no visitor given, so `visitor` is test.\n        visitor = test\n        test = null\n      }\n\n      const is = convert(test)\n      const step = reverse ? -1 : 1\n\n      factory(tree, null, [])()\n\n      /**\n       * @param {Node} node\n       * @param {number?} index\n       * @param {Array.<Parent>} parents\n       */\n      function factory(node, index, parents) {\n        /** @type {Object.<string, unknown>} */\n        // @ts-expect-error: hush\n        const value = typeof node === 'object' && node !== null ? node : {}\n        /** @type {string|undefined} */\n        let name\n\n        if (typeof value.type === 'string') {\n          name =\n            typeof value.tagName === 'string'\n              ? value.tagName\n              : typeof value.name === 'string'\n              ? value.name\n              : undefined\n\n          Object.defineProperty(visit, 'name', {\n            value:\n              'node (' +\n              color(value.type + (name ? '<' + name + '>' : '')) +\n              ')'\n          })\n        }\n\n        return visit\n\n        function visit() {\n          /** @type {ActionTuple} */\n          let result = []\n          /** @type {ActionTuple} */\n          let subresult\n          /** @type {number} */\n          let offset\n          /** @type {Array.<Parent>} */\n          let grandparents\n\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\n            result = toResult(visitor(node, parents))\n\n            if (result[0] === EXIT) {\n              return result\n            }\n          }\n\n          // @ts-expect-error looks like a parent.\n          if (node.children && result[0] !== SKIP) {\n            // @ts-expect-error looks like a parent.\n            offset = (reverse ? node.children.length : -1) + step\n            // @ts-expect-error looks like a parent.\n            grandparents = parents.concat(node)\n\n            // @ts-expect-error looks like a parent.\n            while (offset > -1 && offset < node.children.length) {\n              // @ts-expect-error looks like a parent.\n              subresult = factory(node.children[offset], offset, grandparents)()\n\n              if (subresult[0] === EXIT) {\n                return subresult\n              }\n\n              offset =\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\n            }\n          }\n\n          return result\n        }\n      }\n    }\n  )\n\n/**\n * @param {VisitorResult} value\n * @returns {ActionTuple}\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value\n  }\n\n  if (typeof value === 'number') {\n    return [CONTINUE, value]\n  }\n\n  return [value]\n}\n","/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n * @typedef {import('./complex-types').Visitor} Visitor\n */\n\nimport {visitParents, CONTINUE, SKIP, EXIT} from 'unist-util-visit-parents'\n\nexport {CONTINUE, SKIP, EXIT}\n\n/**\n * Visit children of tree which pass a test\n *\n * @param tree Abstract syntax tree to walk\n * @param test Test, optional\n * @param visitor Function to run for each node\n * @param reverse Fisit the tree in reverse, defaults to false\n */\nexport const visit =\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types').BuildVisitor<Tree>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * @param {Node} tree\n     * @param {Test} test\n     * @param {import('./complex-types').Visitor} visitor\n     * @param {boolean} [reverse]\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array.<Parent>} parents\n       */\n      function overload(node, parents) {\n        const parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n","var own = {}.hasOwnProperty\n\n/**\n * @callback Handler\n * @param {...unknown} value\n * @return {unknown}\n *\n * @typedef {Record<string, Handler>} Handlers\n *\n * @typedef {Object} Options\n * @property {Handler} [unknown]\n * @property {Handler} [invalid]\n * @property {Handlers} [handlers]\n */\n\n/**\n * Handle values based on a property.\n *\n * @param {string} key\n * @param {Options} [options]\n */\nexport function zwitch(key, options) {\n  var settings = options || {}\n\n  /**\n   * Handle one value.\n   * Based on the bound `key`, a respective handler will be called.\n   * If `value` is not an object, or doesnt have a `key` property, the special\n   * invalid handler will be called.\n   * If `value` has an unknown `key`, the special unknown handler will be\n   * called.\n   *\n   * All arguments, and the context object, are passed through to the handler,\n   * and its result is returned.\n   *\n   * @param {...unknown} [value]\n   * @this {unknown}\n   * @returns {unknown}\n   * @property {Handler} invalid\n   * @property {Handler} unknown\n   * @property {Handlers} handlers\n   */\n  function one(value) {\n    var fn = one.invalid\n    var handlers = one.handlers\n\n    if (value && own.call(value, key)) {\n      fn = own.call(handlers, value[key]) ? handlers[value[key]] : one.unknown\n    }\n\n    if (fn) {\n      return fn.apply(this, arguments)\n    }\n  }\n\n  one.handlers = settings.handlers || {}\n  one.invalid = settings.invalid\n  one.unknown = settings.unknown\n\n  return one\n}\n","__webpack_require__.h = () => (\"557fed90fab463cbb771\")"],"names":[],"sourceRoot":""}