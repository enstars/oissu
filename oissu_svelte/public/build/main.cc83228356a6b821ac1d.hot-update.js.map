{"version":3,"file":"main.cc83228356a6b821ac1d.hot-update.js","mappings":"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","sources":["webpack://svelte-app/./src/parse.js","webpack://svelte-app/./node_modules/hast-util-to-dom/lib/index.js","webpack://svelte-app/./node_modules/rehype-dom-stringify/index.js","webpack://svelte-app/./node_modules/rehype-dom-stringify/lib/index.js","webpack://svelte-app/webpack/runtime/getFullHash"],"sourcesContent":["import { unified } from \"unified\";\nimport rehypeDomParse from \"rehype-dom-parse\";\nimport rehypeDomStringify from \"rehype-dom-stringify\";\n\nexport default function parse(ast) {\n  let story = [];\n  // let currentUnit = {};\n  ast.forEach((unit) => {\n    const stringifiedChildren = unified()\n      .use(rehypeDomStringify, { fragment: true })\n      .stringify(unit);\n    console.log(unit);\n    // if(unit.)\n    switch (unit.tagName) {\n      case \"p\":\n        // if (unit.children) {\n        // }\n        // if(story[story.length-1].type === \"line\" && story[story.length-1].speaker)\n        break;\n      case \"blockquote\":\n        break;\n    }\n\n    unit.type = \"root\";\n\n    // console.debug(stringifiedChildren);\n    // story.push({\n    //     content: stringifiedChildren,\n    // });\n  });\n  return story;\n}\n","/**\n * @typedef {import('hast').Parent} HastParent\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').DocType} HastDoctype\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {HastParent['children'][number]} HastChild\n * @typedef {HastChild|HastRoot} HastNode\n *\n * @typedef Options\n * @property {boolean} [fragment=false] Whether a DOM fragment should be returned\n * @property {Document} [document] Document interface to use (default: `globalThis.document`)\n * @property {string} [namespace] `namespace` to use to create elements\n *\n * @typedef Context\n * @property {Document} doc\n * @property {boolean} [fragment=false]\n * @property {string} [namespace]\n * @property {string} [impliedNamespace]\n */\n\nimport {webNamespaces} from 'web-namespaces'\nimport {find, html, svg} from 'property-information'\n\n/* eslint-env browser */\n\n/**\n * @param {HastNode} node\n * @param {Context} [ctx]\n */\nfunction transform(node, ctx) {\n  switch (node.type) {\n    case 'root':\n      return root(node, ctx)\n    case 'text':\n      return text(node, ctx)\n    case 'element':\n      return element(node, ctx)\n    case 'doctype':\n      return doctype(node, ctx)\n    case 'comment':\n      return comment(node, ctx)\n    default:\n      return element(node, ctx)\n  }\n}\n\n/**\n * Create a document.\n *\n * @param {HastRoot} node\n * @param {Context} ctx\n * @returns {XMLDocument|DocumentFragment|HTMLHtmlElement}\n */\nfunction root(node, ctx) {\n  const {doc, fragment, namespace: ctxNamespace} = ctx\n  const {children = []} = node\n  const {length: childrenLength} = children\n\n  let namespace = ctxNamespace\n  let rootIsDocument = childrenLength === 0\n\n  for (let i = 0; i < childrenLength; i += 1) {\n    const child = children[i]\n\n    if (child.type === 'element' && child.tagName === 'html') {\n      const {properties = {}} = child\n\n      // If we have a root HTML node, we don’t need to render as a fragment.\n      rootIsDocument = true\n\n      // Take namespace of the first child.\n      if (typeof ctxNamespace === 'undefined') {\n        namespace = String(properties.xmlns || '') || webNamespaces.html\n      }\n    }\n  }\n\n  // The root node will be a Document, DocumentFragment, or HTMLElement.\n  /** @type {XMLDocument|DocumentFragment|HTMLHtmlElement} */\n  let result\n\n  if (rootIsDocument) {\n    result = doc.implementation.createDocument(namespace, '', null)\n  } else if (fragment) {\n    result = doc.createDocumentFragment()\n  } else {\n    result = doc.createElement('html')\n  }\n\n  return appendAll(result, children, {\n    ...ctx,\n    fragment,\n    namespace,\n    impliedNamespace: namespace\n  })\n}\n\n/**\n * Create a `doctype`.\n *\n * @param {HastDoctype} _\n * @param {Context} ctx\n * @returns {DocumentType}\n */\nfunction doctype(_, {doc}) {\n  return doc.implementation.createDocumentType('html', '', '')\n}\n\n/**\n * Create a `text`.\n *\n * @param {HastText} node\n * @param {Context} ctx\n * @returns {Text}\n */\nfunction text(node, {doc}) {\n  return doc.createTextNode(node.value)\n}\n\n/**\n * Create a `comment`.\n *\n * @param {HastComment} node\n * @param {Context} ctx\n * @returns {Comment}\n */\nfunction comment(node, {doc}) {\n  return doc.createComment(node.value)\n}\n\n/**\n * Create an `element`.\n *\n * @param {HastElement} node\n * @param {Context} ctx\n * @returns {Element}\n */\n// eslint-disable-next-line complexity\nfunction element(node, ctx) {\n  const {namespace, doc} = ctx\n  let impliedNamespace = ctx.impliedNamespace || namespace\n  const {\n    tagName = impliedNamespace === webNamespaces.svg ? 'g' : 'div',\n    properties = {},\n    children = []\n  } = node\n\n  if (\n    (impliedNamespace === null ||\n      impliedNamespace === undefined ||\n      impliedNamespace === webNamespaces.html) &&\n    tagName === 'svg'\n  ) {\n    impliedNamespace = webNamespaces.svg\n  }\n\n  const schema = impliedNamespace === webNamespaces.svg ? svg : html\n\n  const result =\n    impliedNamespace === null || impliedNamespace === undefined\n      ? doc.createElement(tagName)\n      : doc.createElementNS(impliedNamespace, tagName)\n\n  // Add HTML attributes.\n  const props = Object.keys(properties)\n  const {length} = props\n\n  for (let i = 0; i < length; i += 1) {\n    const key = props[i]\n\n    const {\n      attribute,\n      property,\n      // `mustUseAttribute`,\n      mustUseProperty,\n      boolean,\n      booleanish,\n      overloadedBoolean,\n      // `number`,\n      // `defined`,\n      commaSeparated\n      // `spaceSeparated`,\n      // `commaOrSpaceSeparated`,\n    } = find(schema, key)\n\n    let value = properties[key]\n\n    if (Array.isArray(value)) {\n      value = value.join(commaSeparated ? ', ' : ' ')\n    }\n\n    if (mustUseProperty) {\n      result[property] = value\n    }\n\n    if (boolean || (overloadedBoolean && typeof value === 'boolean')) {\n      if (value) {\n        result.setAttribute(attribute, '')\n      } else {\n        result.removeAttribute(attribute)\n      }\n    } else if (booleanish) {\n      result.setAttribute(attribute, String(value))\n    } else if (value === true) {\n      result.setAttribute(attribute, '')\n    } else if (value || value === 0 || value === '') {\n      result.setAttribute(attribute, String(value))\n    }\n  }\n\n  return appendAll(result, children, {...ctx, impliedNamespace})\n}\n\n/**\n * Add all children.\n *\n * @template {Node} N\n * @param {N} node\n * @param {Array.<HastChild>} children\n * @param {Context} ctx\n * @returns {N}\n */\nfunction appendAll(node, children, ctx) {\n  let index = -1\n\n  while (++index < children.length) {\n    // eslint-disable-next-line unicorn/prefer-dom-node-append\n    node.appendChild(transform(children[index], ctx))\n  }\n\n  return node\n}\n\n/**\n * Transform a hast tree to a DOM tree\n *\n * @param {HastNode} node\n * @param {Options} [options]\n * @returns {Node}\n */\nexport function toDom(node, options = {}) {\n  const {document: doc = document, ...rest} = options\n  return transform(node, {doc, ...rest})\n}\n","import rehypeDomStringify from './lib/index.js'\n\nexport default rehypeDomStringify\n","/**\n * @typedef {import('hast').Root} Root\n * @typedef {import('hast-util-to-dom').Options} Options\n */\n\nimport {toDom} from 'hast-util-to-dom'\nimport {webNamespaces} from 'web-namespaces'\n\nconst htmlXmlnsExpression = new RegExp(` xmlns=\"${webNamespaces.html}\"`, 'g')\n\n/** @type {import('unified').Plugin<[Options?] | void[], Root, string>} */\nexport default function stringify(options) {\n  const config = /** @type {Options} */ (this.data('settings'))\n  const settings = {...options, ...config}\n\n  if (settings.fragment === null || settings.fragment === undefined) {\n    settings.fragment = true\n  }\n\n  Object.assign(this, {Compiler: compiler})\n\n  /** @type {import('unified').CompilerFunction<Root, string>} */\n  function compiler(tree) {\n    const node = toDom(tree, settings)\n    const serialized = new XMLSerializer().serializeToString(node)\n\n    // XMLSerializer puts xmlns on root elements (typically the document\n    // element, but in case of a fragment all of the fragments children).\n    // We’re using the DOM, and we focus on HTML, so we can always remove HTML\n    // XMLNS attributes (HTML inside SVG does not need to have an XMLNS).\n    return serialized.replace(htmlXmlnsExpression, '')\n  }\n}\n","__webpack_require__.h = () => (\"9ed8371b4418ac08e4dc\")"],"names":[],"sourceRoot":""}